<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mach-omap2 › powerdomain.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>powerdomain.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * OMAP powerdomain control</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007-2008, 2011 Texas Instruments, Inc.</span>
<span class="cm"> * Copyright (C) 2007-2011 Nokia Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Paul Walmsley</span>
<span class="cm"> * Added OMAP4 specific support by Abhijit Pagare &lt;abhijitpagare@ti.com&gt;</span>
<span class="cm"> * State counting code by Tero Kristo &lt;tero.kristo@nokia.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>
<span class="cp">#undef DEBUG</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;trace/events/power.h&gt;</span>

<span class="cp">#include &quot;cm2xxx_3xxx.h&quot;</span>
<span class="cp">#include &quot;prcm44xx.h&quot;</span>
<span class="cp">#include &quot;cm44xx.h&quot;</span>
<span class="cp">#include &quot;prm2xxx_3xxx.h&quot;</span>
<span class="cp">#include &quot;prm44xx.h&quot;</span>

<span class="cp">#include &lt;asm/cpu.h&gt;</span>
<span class="cp">#include &lt;plat/cpu.h&gt;</span>
<span class="cp">#include &quot;powerdomain.h&quot;</span>
<span class="cp">#include &quot;clockdomain.h&quot;</span>
<span class="cp">#include &lt;plat/prcm.h&gt;</span>

<span class="cp">#include &quot;pm.h&quot;</span>

<span class="cp">#define PWRDM_TRACE_STATES_FLAG	(1&lt;&lt;31)</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">PWRDM_STATE_NOW</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">PWRDM_STATE_PREV</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* pwrdm_list contains all registered struct powerdomains */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">pwrdm_list</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pwrdm_ops</span> <span class="o">*</span><span class="n">arch_pwrdm</span><span class="p">;</span>

<span class="cm">/* Private functions */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="nf">_pwrdm_lookup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span> <span class="o">*</span><span class="n">temp_pwrdm</span><span class="p">;</span>

	<span class="n">pwrdm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">temp_pwrdm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pwrdm_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">temp_pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pwrdm</span> <span class="o">=</span> <span class="n">temp_pwrdm</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pwrdm</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _pwrdm_register - register a powerdomain</span>
<span class="cm"> * @pwrdm: struct powerdomain * to register</span>
<span class="cm"> *</span>
<span class="cm"> * Adds a powerdomain to the internal powerdomain list.  Returns</span>
<span class="cm"> * -EINVAL if given a null pointer, -EEXIST if a powerdomain is</span>
<span class="cm"> * already registered by the provided name, or 0 upon success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_pwrdm_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span> <span class="o">||</span> <span class="o">!</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_omap44xx</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
	    <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">prcm_partition</span> <span class="o">==</span> <span class="n">OMAP4430_INVALID_PRCM_PARTITION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;powerdomain: %s: missing OMAP4 PRCM partition ID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_pwrdm_lookup</span><span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>

	<span class="n">voltdm</span> <span class="o">=</span> <span class="n">voltdm_lookup</span><span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">voltdm</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">voltdm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;powerdomain: %s: voltagedomain %s does not exist</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">voltdm</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">voltdm</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">voltdm</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">voltdm_node</span><span class="p">);</span>
	<span class="n">voltdm_add_pwrdm</span><span class="p">(</span><span class="n">voltdm</span><span class="p">,</span> <span class="n">pwrdm</span><span class="p">);</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pwrdm_list</span><span class="p">);</span>

	<span class="cm">/* Initialize the powerdomain&#39;s state counter */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PWRDM_MAX_PWRSTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">state_counter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">ret_logic_off_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">ret_mem_off_counter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pwrdm_wait_transition</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>
	<span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">pwrdm_read_pwrst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>
	<span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">state_counter</span><span class="p">[</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;powerdomain: registered %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_update_logic_membank_counters</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">prev_logic_pwrst</span><span class="p">,</span> <span class="n">prev_mem_pwrst</span><span class="p">;</span>

	<span class="n">prev_logic_pwrst</span> <span class="o">=</span> <span class="n">pwrdm_read_prev_logic_pwrst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrsts_logic_ret</span> <span class="o">==</span> <span class="n">PWRSTS_OFF_RET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">prev_logic_pwrst</span> <span class="o">==</span> <span class="n">PWRDM_POWER_OFF</span><span class="p">))</span>
		<span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">ret_logic_off_counter</span><span class="o">++</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prev_mem_pwrst</span> <span class="o">=</span> <span class="n">pwrdm_read_prev_mem_pwrst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrsts_mem_ret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">PWRSTS_OFF_RET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">prev_mem_pwrst</span> <span class="o">==</span> <span class="n">PWRDM_POWER_OFF</span><span class="p">))</span>
			<span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">ret_mem_off_counter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_pwrdm_state_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">prev</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">trace_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">pwrdm_read_pwrst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PWRDM_STATE_NOW</span>:
		<span class="n">prev</span> <span class="o">=</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PWRDM_STATE_PREV</span>:
		<span class="n">prev</span> <span class="o">=</span> <span class="n">pwrdm_read_prev_pwrst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">)</span>
			<span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">state_counter</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">==</span> <span class="n">PWRDM_POWER_RET</span><span class="p">)</span>
			<span class="n">_update_logic_membank_counters</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the power domain did not hit the desired state,</span>
<span class="cm">		 * generate a trace event with both the desired and hit states</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trace_state</span> <span class="o">=</span> <span class="p">(</span><span class="n">PWRDM_TRACE_STATES_FLAG</span> <span class="o">|</span>
				       <span class="p">((</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">OMAP_POWERSTATE_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
				       <span class="p">((</span><span class="n">prev</span> <span class="o">&amp;</span> <span class="n">OMAP_POWERSTATE_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">));</span>
			<span class="n">trace_power_domain_target</span><span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">trace_state</span><span class="p">,</span>
						  <span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">)</span>
		<span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">state_counter</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

	<span class="n">pm_dbg_update_time</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>

	<span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_pwrdm_pre_transition_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pwrdm_clear_all_prev_pwrst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>
	<span class="n">_pwrdm_state_switch</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">PWRDM_STATE_NOW</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_pwrdm_post_transition_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_pwrdm_state_switch</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">PWRDM_STATE_PREV</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Public functions */</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_register_platform_funcs - register powerdomain implementation fns</span>
<span class="cm"> * @po: func pointers for arch specific implementations</span>
<span class="cm"> *</span>
<span class="cm"> * Register the list of function pointers used to implement the</span>
<span class="cm"> * powerdomain functions on different OMAP SoCs.  Should be called</span>
<span class="cm"> * before any other pwrdm_register*() function.  Returns -EINVAL if</span>
<span class="cm"> * @po is null, -EEXIST if platform functions have already been</span>
<span class="cm"> * registered, or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_register_platform_funcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwrdm_ops</span> <span class="o">*</span><span class="n">po</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">po</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>

	<span class="n">arch_pwrdm</span> <span class="o">=</span> <span class="n">po</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_register_pwrdms - register SoC powerdomains</span>
<span class="cm"> * @ps: pointer to an array of struct powerdomain to register</span>
<span class="cm"> *</span>
<span class="cm"> * Register the powerdomains available on a particular OMAP SoC.  Must</span>
<span class="cm"> * be called after pwrdm_register_platform_funcs().  May be called</span>
<span class="cm"> * multiple times.  Returns -EACCES if called before</span>
<span class="cm"> * pwrdm_register_platform_funcs(); -EINVAL if the argument @ps is</span>
<span class="cm"> * null; or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_register_pwrdms</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">**</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ps</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">ps</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
		<span class="n">_pwrdm_register</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_complete_init - set up the powerdomain layer</span>
<span class="cm"> *</span>
<span class="cm"> * Do whatever is necessary to initialize registered powerdomains and</span>
<span class="cm"> * powerdomain code.  Currently, this programs the next power state</span>
<span class="cm"> * for each powerdomain to ON.  This prevents powerdomains from</span>
<span class="cm"> * unexpectedly losing context or entering high wakeup latency modes</span>
<span class="cm"> * with non-power-management-enabled kernels.  Must be called after</span>
<span class="cm"> * pwrdm_register_pwrdms().  Returns -EACCES if called before</span>
<span class="cm"> * pwrdm_register_pwrdms(), or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_complete_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">temp_p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwrdm_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">temp_p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pwrdm_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="n">pwrdm_set_next_pwrst</span><span class="p">(</span><span class="n">temp_p</span><span class="p">,</span> <span class="n">PWRDM_POWER_ON</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_lookup - look up a powerdomain by name, return a pointer</span>
<span class="cm"> * @name: name of powerdomain</span>
<span class="cm"> *</span>
<span class="cm"> * Find a registered powerdomain by its name @name.  Returns a pointer</span>
<span class="cm"> * to the struct powerdomain if found, or NULL otherwise.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="nf">pwrdm_lookup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pwrdm</span> <span class="o">=</span> <span class="n">_pwrdm_lookup</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pwrdm</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_for_each - call function on each registered clockdomain</span>
<span class="cm"> * @fn: callback function *</span>
<span class="cm"> *</span>
<span class="cm"> * Call the supplied function @fn for each registered powerdomain.</span>
<span class="cm"> * The callback function @fn can return anything but 0 to bail out</span>
<span class="cm"> * early from the iterator.  Returns the last return value of the</span>
<span class="cm"> * callback function, which should be 0 for success or anything else</span>
<span class="cm"> * to indicate failure; or -EINVAL if the function pointer is null.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_for_each</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user</span><span class="p">),</span>
		   <span class="kt">void</span> <span class="o">*</span><span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">temp_pwrdm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">temp_pwrdm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pwrdm_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="n">temp_pwrdm</span><span class="p">,</span> <span class="n">user</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_add_clkdm - add a clockdomain to a powerdomain</span>
<span class="cm"> * @pwrdm: struct powerdomain * to add the clockdomain to</span>
<span class="cm"> * @clkdm: struct clockdomain * to associate with a powerdomain</span>
<span class="cm"> *</span>
<span class="cm"> * Associate the clockdomain @clkdm with a powerdomain @pwrdm.  This</span>
<span class="cm"> * enables the use of pwrdm_for_each_clkdm().  Returns -EINVAL if</span>
<span class="cm"> * presented with invalid pointers; -ENOMEM if memory could not be allocated;</span>
<span class="cm"> * or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_add_clkdm</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clockdomain</span> <span class="o">*</span><span class="n">clkdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span> <span class="o">||</span> <span class="o">!</span><span class="n">clkdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;powerdomain: associating clockdomain %s with powerdomain &quot;</span>
		 <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PWRDM_MAX_CLKDMS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_clkdms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_clkdms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">clkdm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">pac_exit</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">PWRDM_MAX_CLKDMS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;powerdomain: increase PWRDM_MAX_CLKDMS for &quot;</span>
			 <span class="s">&quot;pwrdm %s clkdm %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">pac_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_clkdms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">clkdm</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">pac_exit:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_del_clkdm - remove a clockdomain from a powerdomain</span>
<span class="cm"> * @pwrdm: struct powerdomain * to add the clockdomain to</span>
<span class="cm"> * @clkdm: struct clockdomain * to associate with a powerdomain</span>
<span class="cm"> *</span>
<span class="cm"> * Dissociate the clockdomain @clkdm from the powerdomain</span>
<span class="cm"> * @pwrdm. Returns -EINVAL if presented with invalid pointers; -ENOENT</span>
<span class="cm"> * if @clkdm was not associated with the powerdomain, or 0 upon</span>
<span class="cm"> * success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_del_clkdm</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clockdomain</span> <span class="o">*</span><span class="n">clkdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span> <span class="o">||</span> <span class="o">!</span><span class="n">clkdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;powerdomain: dissociating clockdomain %s from powerdomain &quot;</span>
		 <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PWRDM_MAX_CLKDMS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_clkdms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">clkdm</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">PWRDM_MAX_CLKDMS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;powerdomain: clkdm %s not associated with pwrdm &quot;</span>
			 <span class="s">&quot;%s ?!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">pdc_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_clkdms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">pdc_exit:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_for_each_clkdm - call function on each clkdm in a pwrdm</span>
<span class="cm"> * @pwrdm: struct powerdomain * to iterate over</span>
<span class="cm"> * @fn: callback function *</span>
<span class="cm"> *</span>
<span class="cm"> * Call the supplied function @fn for each clockdomain in the powerdomain</span>
<span class="cm"> * @pwrdm.  The callback function can return anything but 0 to bail</span>
<span class="cm"> * out early from the iterator.  Returns -EINVAL if presented with</span>
<span class="cm"> * invalid pointers; or passes along the last return value of the</span>
<span class="cm"> * callback function, which should be 0 for success or anything else</span>
<span class="cm"> * to indicate failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_for_each_clkdm</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">clockdomain</span> <span class="o">*</span><span class="n">clkdm</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PWRDM_MAX_CLKDMS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ret</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_clkdms</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_get_voltdm - return a ptr to the voltdm that this pwrdm resides in</span>
<span class="cm"> * @pwrdm: struct powerdomain *</span>
<span class="cm"> *</span>
<span class="cm"> * Return a pointer to the struct voltageomain that the specified powerdomain</span>
<span class="cm"> * @pwrdm exists in.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="nf">pwrdm_get_voltdm</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">voltdm</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_get_mem_bank_count - get number of memory banks in this powerdomain</span>
<span class="cm"> * @pwrdm: struct powerdomain *</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of controllable memory banks in powerdomain @pwrdm,</span>
<span class="cm"> * starting with 1.  Returns -EINVAL if the powerdomain pointer is null.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_get_mem_bank_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">banks</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_set_next_pwrst - set next powerdomain power state</span>
<span class="cm"> * @pwrdm: struct powerdomain * to set</span>
<span class="cm"> * @pwrst: one of the PWRDM_POWER_* macros</span>
<span class="cm"> *</span>
<span class="cm"> * Set the powerdomain @pwrdm&#39;s next power state to @pwrst.  The powerdomain</span>
<span class="cm"> * may not enter this state immediately if the preconditions for this state</span>
<span class="cm"> * have not been satisfied.  Returns -EINVAL if the powerdomain pointer is</span>
<span class="cm"> * null or if the power state is invalid for the powerdomin, or returns 0</span>
<span class="cm"> * upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_set_next_pwrst</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pwrst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrsts</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pwrst</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;powerdomain: setting next powerstate for %s to %0x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pwrst</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_set_next_pwrst</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Trace the pwrdm desired target state */</span>
		<span class="n">trace_power_domain_target</span><span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pwrst</span><span class="p">,</span>
					  <span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="cm">/* Program the pwrdm desired target state */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_set_next_pwrst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">pwrst</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_read_next_pwrst - get next powerdomain power state</span>
<span class="cm"> * @pwrdm: struct powerdomain * to get power state</span>
<span class="cm"> *</span>
<span class="cm"> * Return the powerdomain @pwrdm&#39;s next power state.  Returns -EINVAL</span>
<span class="cm"> * if the powerdomain pointer is null or returns the next power state</span>
<span class="cm"> * upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_read_next_pwrst</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_next_pwrst</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_next_pwrst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_read_pwrst - get current powerdomain power state</span>
<span class="cm"> * @pwrdm: struct powerdomain * to get power state</span>
<span class="cm"> *</span>
<span class="cm"> * Return the powerdomain @pwrdm&#39;s current power state.	Returns -EINVAL</span>
<span class="cm"> * if the powerdomain pointer is null or returns the current power state</span>
<span class="cm"> * upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_read_pwrst</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_pwrst</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_pwrst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_read_prev_pwrst - get previous powerdomain power state</span>
<span class="cm"> * @pwrdm: struct powerdomain * to get previous power state</span>
<span class="cm"> *</span>
<span class="cm"> * Return the powerdomain @pwrdm&#39;s previous power state.  Returns -EINVAL</span>
<span class="cm"> * if the powerdomain pointer is null or returns the previous power state</span>
<span class="cm"> * upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_read_prev_pwrst</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_prev_pwrst</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_prev_pwrst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_set_logic_retst - set powerdomain logic power state upon retention</span>
<span class="cm"> * @pwrdm: struct powerdomain * to set</span>
<span class="cm"> * @pwrst: one of the PWRDM_POWER_* macros</span>
<span class="cm"> *</span>
<span class="cm"> * Set the next power state @pwrst that the logic portion of the</span>
<span class="cm"> * powerdomain @pwrdm will enter when the powerdomain enters retention.</span>
<span class="cm"> * This will be either RETENTION or OFF, if supported.  Returns</span>
<span class="cm"> * -EINVAL if the powerdomain pointer is null or the target power</span>
<span class="cm"> * state is not not supported, or returns 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_set_logic_retst</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pwrst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrsts_logic_ret</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pwrst</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;powerdomain: setting next logic powerstate for %s to %0x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pwrst</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_set_logic_retst</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_set_logic_retst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">pwrst</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_set_mem_onst - set memory power state while powerdomain ON</span>
<span class="cm"> * @pwrdm: struct powerdomain * to set</span>
<span class="cm"> * @bank: memory bank number to set (0-3)</span>
<span class="cm"> * @pwrst: one of the PWRDM_POWER_* macros</span>
<span class="cm"> *</span>
<span class="cm"> * Set the next power state @pwrst that memory bank @bank of the</span>
<span class="cm"> * powerdomain @pwrdm will enter when the powerdomain enters the ON</span>
<span class="cm"> * state.  @bank will be a number from 0 to 3, and represents different</span>
<span class="cm"> * types of memory, depending on the powerdomain.  Returns -EINVAL if</span>
<span class="cm"> * the powerdomain pointer is null or the target power state is not</span>
<span class="cm"> * not supported for this memory bank, -EEXIST if the target memory</span>
<span class="cm"> * bank does not exist or is not controllable, or returns 0 upon</span>
<span class="cm"> * success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_set_mem_onst</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bank</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pwrst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">banks</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">bank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrsts_mem_on</span><span class="p">[</span><span class="n">bank</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pwrst</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;powerdomain: setting next memory powerstate for domain %s &quot;</span>
		 <span class="s">&quot;bank %0x while pwrdm-ON to %0x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bank</span><span class="p">,</span> <span class="n">pwrst</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_set_mem_onst</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_set_mem_onst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">bank</span><span class="p">,</span> <span class="n">pwrst</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_set_mem_retst - set memory power state while powerdomain in RET</span>
<span class="cm"> * @pwrdm: struct powerdomain * to set</span>
<span class="cm"> * @bank: memory bank number to set (0-3)</span>
<span class="cm"> * @pwrst: one of the PWRDM_POWER_* macros</span>
<span class="cm"> *</span>
<span class="cm"> * Set the next power state @pwrst that memory bank @bank of the</span>
<span class="cm"> * powerdomain @pwrdm will enter when the powerdomain enters the</span>
<span class="cm"> * RETENTION state.  Bank will be a number from 0 to 3, and represents</span>
<span class="cm"> * different types of memory, depending on the powerdomain.  @pwrst</span>
<span class="cm"> * will be either RETENTION or OFF, if supported.  Returns -EINVAL if</span>
<span class="cm"> * the powerdomain pointer is null or the target power state is not</span>
<span class="cm"> * not supported for this memory bank, -EEXIST if the target memory</span>
<span class="cm"> * bank does not exist or is not controllable, or returns 0 upon</span>
<span class="cm"> * success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_set_mem_retst</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bank</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pwrst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">banks</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">bank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrsts_mem_ret</span><span class="p">[</span><span class="n">bank</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pwrst</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;powerdomain: setting next memory powerstate for domain %s &quot;</span>
		 <span class="s">&quot;bank %0x while pwrdm-RET to %0x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bank</span><span class="p">,</span> <span class="n">pwrst</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_set_mem_retst</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_set_mem_retst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">bank</span><span class="p">,</span> <span class="n">pwrst</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_read_logic_pwrst - get current powerdomain logic retention power state</span>
<span class="cm"> * @pwrdm: struct powerdomain * to get current logic retention power state</span>
<span class="cm"> *</span>
<span class="cm"> * Return the power state that the logic portion of powerdomain @pwrdm</span>
<span class="cm"> * will enter when the powerdomain enters retention.  Returns -EINVAL</span>
<span class="cm"> * if the powerdomain pointer is null or returns the logic retention</span>
<span class="cm"> * power state upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_read_logic_pwrst</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_logic_pwrst</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_logic_pwrst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_read_prev_logic_pwrst - get previous powerdomain logic power state</span>
<span class="cm"> * @pwrdm: struct powerdomain * to get previous logic power state</span>
<span class="cm"> *</span>
<span class="cm"> * Return the powerdomain @pwrdm&#39;s previous logic power state.  Returns</span>
<span class="cm"> * -EINVAL if the powerdomain pointer is null or returns the previous</span>
<span class="cm"> * logic power state upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_read_prev_logic_pwrst</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_prev_logic_pwrst</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_prev_logic_pwrst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_read_logic_retst - get next powerdomain logic power state</span>
<span class="cm"> * @pwrdm: struct powerdomain * to get next logic power state</span>
<span class="cm"> *</span>
<span class="cm"> * Return the powerdomain pwrdm&#39;s logic power state.  Returns -EINVAL</span>
<span class="cm"> * if the powerdomain pointer is null or returns the next logic</span>
<span class="cm"> * power state upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_read_logic_retst</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_logic_retst</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_logic_retst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_read_mem_pwrst - get current memory bank power state</span>
<span class="cm"> * @pwrdm: struct powerdomain * to get current memory bank power state</span>
<span class="cm"> * @bank: memory bank number (0-3)</span>
<span class="cm"> *</span>
<span class="cm"> * Return the powerdomain @pwrdm&#39;s current memory power state for bank</span>
<span class="cm"> * @bank.  Returns -EINVAL if the powerdomain pointer is null, -EEXIST if</span>
<span class="cm"> * the target memory bank does not exist or is not controllable, or</span>
<span class="cm"> * returns the current memory power state upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_read_mem_pwrst</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bank</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">banks</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">bank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PWRDM_HAS_MPU_QUIRK</span><span class="p">)</span>
		<span class="n">bank</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_mem_pwrst</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_mem_pwrst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">bank</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_read_prev_mem_pwrst - get previous memory bank power state</span>
<span class="cm"> * @pwrdm: struct powerdomain * to get previous memory bank power state</span>
<span class="cm"> * @bank: memory bank number (0-3)</span>
<span class="cm"> *</span>
<span class="cm"> * Return the powerdomain @pwrdm&#39;s previous memory power state for</span>
<span class="cm"> * bank @bank.  Returns -EINVAL if the powerdomain pointer is null,</span>
<span class="cm"> * -EEXIST if the target memory bank does not exist or is not</span>
<span class="cm"> * controllable, or returns the previous memory power state upon</span>
<span class="cm"> * success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_read_prev_mem_pwrst</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bank</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">banks</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">bank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PWRDM_HAS_MPU_QUIRK</span><span class="p">)</span>
		<span class="n">bank</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_prev_mem_pwrst</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_prev_mem_pwrst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">bank</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_read_mem_retst - get next memory bank power state</span>
<span class="cm"> * @pwrdm: struct powerdomain * to get mext memory bank power state</span>
<span class="cm"> * @bank: memory bank number (0-3)</span>
<span class="cm"> *</span>
<span class="cm"> * Return the powerdomain pwrdm&#39;s next memory power state for bank</span>
<span class="cm"> * x.  Returns -EINVAL if the powerdomain pointer is null, -EEXIST if</span>
<span class="cm"> * the target memory bank does not exist or is not controllable, or</span>
<span class="cm"> * returns the next memory power state upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_read_mem_retst</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bank</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">banks</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">bank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_mem_retst</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_read_mem_retst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">bank</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_clear_all_prev_pwrst - clear previous powerstate register for a pwrdm</span>
<span class="cm"> * @pwrdm: struct powerdomain * to clear</span>
<span class="cm"> *</span>
<span class="cm"> * Clear the powerdomain&#39;s previous power state register @pwrdm.</span>
<span class="cm"> * Clears the entire register, including logic and memory bank</span>
<span class="cm"> * previous power states.  Returns -EINVAL if the powerdomain pointer</span>
<span class="cm"> * is null, or returns 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_clear_all_prev_pwrst</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX should get the powerdomain&#39;s current state here;</span>
<span class="cm">	 * warn &amp; fail if it is not ON.</span>
<span class="cm">	 */</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;powerdomain: clearing previous power state reg for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_clear_all_prev_pwrst</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_clear_all_prev_pwrst</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_enable_hdwr_sar - enable automatic hardware SAR for a pwrdm</span>
<span class="cm"> * @pwrdm: struct powerdomain *</span>
<span class="cm"> *</span>
<span class="cm"> * Enable automatic context save-and-restore upon power state change</span>
<span class="cm"> * for some devices in the powerdomain @pwrdm.  Warning: this only</span>
<span class="cm"> * affects a subset of devices in a powerdomain; check the TRM</span>
<span class="cm"> * closely.  Returns -EINVAL if the powerdomain pointer is null or if</span>
<span class="cm"> * the powerdomain does not support automatic save-and-restore, or</span>
<span class="cm"> * returns 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_enable_hdwr_sar</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PWRDM_HAS_HDWR_SAR</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;powerdomain: %s: setting SAVEANDRESTORE bit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_enable_hdwr_sar</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_enable_hdwr_sar</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_disable_hdwr_sar - disable automatic hardware SAR for a pwrdm</span>
<span class="cm"> * @pwrdm: struct powerdomain *</span>
<span class="cm"> *</span>
<span class="cm"> * Disable automatic context save-and-restore upon power state change</span>
<span class="cm"> * for some devices in the powerdomain @pwrdm.  Warning: this only</span>
<span class="cm"> * affects a subset of devices in a powerdomain; check the TRM</span>
<span class="cm"> * closely.  Returns -EINVAL if the powerdomain pointer is null or if</span>
<span class="cm"> * the powerdomain does not support automatic save-and-restore, or</span>
<span class="cm"> * returns 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_disable_hdwr_sar</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PWRDM_HAS_HDWR_SAR</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;powerdomain: %s: clearing SAVEANDRESTORE bit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_disable_hdwr_sar</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_disable_hdwr_sar</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_has_hdwr_sar - test whether powerdomain supports hardware SAR</span>
<span class="cm"> * @pwrdm: struct powerdomain *</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if powerdomain @pwrdm supports hardware save-and-restore</span>
<span class="cm"> * for some devices, or 0 if it does not.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">pwrdm_has_hdwr_sar</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PWRDM_HAS_HDWR_SAR</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_set_lowpwrstchange - Request a low power state change</span>
<span class="cm"> * @pwrdm: struct powerdomain *</span>
<span class="cm"> *</span>
<span class="cm"> * Allows a powerdomain to transtion to a lower power sleep state</span>
<span class="cm"> * from an existing sleep state without waking up the powerdomain.</span>
<span class="cm"> * Returns -EINVAL if the powerdomain pointer is null or if the</span>
<span class="cm"> * powerdomain does not support LOWPOWERSTATECHANGE, or returns 0</span>
<span class="cm"> * upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_set_lowpwrstchange</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PWRDM_HAS_LOWPOWERSTATECHANGE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;powerdomain: %s: setting LOWPOWERSTATECHANGE bit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_set_lowpwrstchange</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_set_lowpwrstchange</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_wait_transition - wait for powerdomain power transition to finish</span>
<span class="cm"> * @pwrdm: struct powerdomain * to wait for</span>
<span class="cm"> *</span>
<span class="cm"> * If the powerdomain @pwrdm is in the process of a state transition,</span>
<span class="cm"> * spin until it completes the power transition, or until an iteration</span>
<span class="cm"> * bailout value is reached. Returns -EINVAL if the powerdomain</span>
<span class="cm"> * pointer is null, -EAGAIN if the bailout value was reached, or</span>
<span class="cm"> * returns 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_wait_transition</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_pwrdm</span> <span class="o">&amp;&amp;</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_wait_transition</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_pwrdm</span><span class="o">-&gt;</span><span class="n">pwrdm_wait_transition</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pwrdm_state_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pwrdm_wait_transition</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">_pwrdm_state_switch</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">PWRDM_STATE_NOW</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pwrdm_pre_transition</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pwrdm_for_each</span><span class="p">(</span><span class="n">_pwrdm_pre_transition_cb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pwrdm_post_transition</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pwrdm_for_each</span><span class="p">(</span><span class="n">_pwrdm_post_transition_cb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_get_context_loss_count - get powerdomain&#39;s context loss count</span>
<span class="cm"> * @pwrdm: struct powerdomain * to wait for</span>
<span class="cm"> *</span>
<span class="cm"> * Context loss count is the sum of powerdomain off-mode counter, the</span>
<span class="cm"> * logic off counter and the per-bank memory off counter.  Returns negative</span>
<span class="cm"> * (and WARNs) upon error, otherwise, returns the context loss count.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pwrdm_get_context_loss_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;powerdomain: %s: pwrdm is null</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">state_counter</span><span class="p">[</span><span class="n">PWRDM_POWER_OFF</span><span class="p">];</span>
	<span class="n">count</span> <span class="o">+=</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">ret_logic_off_counter</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">ret_mem_off_counter</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Context loss count has to be a non-negative value. Clear the sign</span>
<span class="cm">	 * bit to get a value range from 0 to INT_MAX.</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">&amp;=</span> <span class="n">INT_MAX</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;powerdomain: %s: context loss count = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pwrdm_can_ever_lose_context - can this powerdomain ever lose context?</span>
<span class="cm"> * @pwrdm: struct powerdomain *</span>
<span class="cm"> *</span>
<span class="cm"> * Given a struct powerdomain * @pwrdm, returns 1 if the powerdomain</span>
<span class="cm"> * can lose either memory or logic context or if @pwrdm is invalid, or</span>
<span class="cm"> * returns 0 otherwise.  This function is not concerned with how the</span>
<span class="cm"> * powerdomain registers are programmed (i.e., to go off or not); it&#39;s</span>
<span class="cm"> * concerned with whether it&#39;s ever possible for this powerdomain to</span>
<span class="cm"> * go off while some other part of the chip is active.  This function</span>
<span class="cm"> * assumes that every powerdomain can go to either ON or INACTIVE.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">pwrdm_can_ever_lose_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;powerdomain: %s: invalid powerdomain pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrsts</span> <span class="o">&amp;</span> <span class="n">PWRSTS_OFF</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrsts</span> <span class="o">&amp;</span> <span class="n">PWRSTS_RET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrsts_logic_ret</span> <span class="o">&amp;</span> <span class="n">PWRSTS_OFF</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrsts_mem_ret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">PWRSTS_OFF</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">pwrsts_mem_on</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">PWRSTS_OFF</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
