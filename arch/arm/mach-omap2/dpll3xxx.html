<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mach-omap2 › dpll3xxx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>dpll3xxx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * OMAP3/4 - specific DPLL control functions</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009-2010 Texas Instruments, Inc.</span>
<span class="cm"> * Copyright (C) 2009-2010 Nokia Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Paul Walmsley</span>
<span class="cm"> * Testing and integration fixes by Jouni Högander</span>
<span class="cm"> *</span>
<span class="cm"> * 36xx support added by Vishwanath BS, Richard Woodruff, and Nishanth</span>
<span class="cm"> * Menon</span>
<span class="cm"> *</span>
<span class="cm"> * Parts of this code are based on code written by</span>
<span class="cm"> * Richard Woodruff, Tony Lindgren, Tuukka Tikkanen, Karthik Dasu</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/clkdev.h&gt;</span>

<span class="cp">#include &lt;plat/cpu.h&gt;</span>
<span class="cp">#include &lt;plat/clock.h&gt;</span>

<span class="cp">#include &quot;clock.h&quot;</span>
<span class="cp">#include &quot;cm2xxx_3xxx.h&quot;</span>
<span class="cp">#include &quot;cm-regbits-34xx.h&quot;</span>

<span class="cm">/* CM_AUTOIDLE_PLL*.AUTO_* bit values */</span>
<span class="cp">#define DPLL_AUTOIDLE_DISABLE			0x0</span>
<span class="cp">#define DPLL_AUTOIDLE_LOW_POWER_STOP		0x1</span>

<span class="cp">#define MAX_DPLL_WAIT_TRIES		1000000</span>

<span class="cm">/* Private functions */</span>

<span class="cm">/* _omap3_dpll_write_clken - write clken_bits arg to a DPLL&#39;s enable bits */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_omap3_dpll_write_clken</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="n">u8</span> <span class="n">clken_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dpll_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">dd</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">control_reg</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">enable_mask</span><span class="p">;</span>
	<span class="n">v</span> <span class="o">|=</span> <span class="n">clken_bits</span> <span class="o">&lt;&lt;</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">enable_mask</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">control_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* _omap3_wait_dpll_status: wait for a DPLL to enter a specific state */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_omap3_wait_dpll_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="n">u8</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dpll_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dd</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">&lt;&lt;=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">idlest_mask</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(((</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">idlest_reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">idlest_mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">state</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_DPLL_WAIT_TRIES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MAX_DPLL_WAIT_TRIES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;clock: %s failed transition to &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;locked&quot;</span> <span class="o">:</span> <span class="s">&quot;bypassed&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: %s transition to &#39;%s&#39; in %d loops</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;locked&quot;</span> <span class="o">:</span> <span class="s">&quot;bypassed&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* From 3430 TRM ES2 4.7.6.2 */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">_omap3_dpll_compute_freqsel</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="n">u8</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fint</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fint</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="o">-&gt;</span><span class="n">clk_ref</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">/</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: fint is %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fint</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fint</span> <span class="o">&gt;=</span> <span class="mi">750000</span> <span class="o">&amp;&amp;</span> <span class="n">fint</span> <span class="o">&lt;=</span> <span class="mi">1000000</span><span class="p">)</span>
		<span class="n">f</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fint</span> <span class="o">&gt;</span> <span class="mi">1000000</span> <span class="o">&amp;&amp;</span> <span class="n">fint</span> <span class="o">&lt;=</span> <span class="mi">1250000</span><span class="p">)</span>
		<span class="n">f</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fint</span> <span class="o">&gt;</span> <span class="mi">1250000</span> <span class="o">&amp;&amp;</span> <span class="n">fint</span> <span class="o">&lt;=</span> <span class="mi">1500000</span><span class="p">)</span>
		<span class="n">f</span> <span class="o">=</span> <span class="mh">0x5</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fint</span> <span class="o">&gt;</span> <span class="mi">1500000</span> <span class="o">&amp;&amp;</span> <span class="n">fint</span> <span class="o">&lt;=</span> <span class="mi">1750000</span><span class="p">)</span>
		<span class="n">f</span> <span class="o">=</span> <span class="mh">0x6</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fint</span> <span class="o">&gt;</span> <span class="mi">1750000</span> <span class="o">&amp;&amp;</span> <span class="n">fint</span> <span class="o">&lt;=</span> <span class="mi">2100000</span><span class="p">)</span>
		<span class="n">f</span> <span class="o">=</span> <span class="mh">0x7</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fint</span> <span class="o">&gt;</span> <span class="mi">7500000</span> <span class="o">&amp;&amp;</span> <span class="n">fint</span> <span class="o">&lt;=</span> <span class="mi">10000000</span><span class="p">)</span>
		<span class="n">f</span> <span class="o">=</span> <span class="mh">0xB</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fint</span> <span class="o">&gt;</span> <span class="mi">10000000</span> <span class="o">&amp;&amp;</span> <span class="n">fint</span> <span class="o">&lt;=</span> <span class="mi">12500000</span><span class="p">)</span>
		<span class="n">f</span> <span class="o">=</span> <span class="mh">0xC</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fint</span> <span class="o">&gt;</span> <span class="mi">12500000</span> <span class="o">&amp;&amp;</span> <span class="n">fint</span> <span class="o">&lt;=</span> <span class="mi">15000000</span><span class="p">)</span>
		<span class="n">f</span> <span class="o">=</span> <span class="mh">0xD</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fint</span> <span class="o">&gt;</span> <span class="mi">15000000</span> <span class="o">&amp;&amp;</span> <span class="n">fint</span> <span class="o">&lt;=</span> <span class="mi">17500000</span><span class="p">)</span>
		<span class="n">f</span> <span class="o">=</span> <span class="mh">0xE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fint</span> <span class="o">&gt;</span> <span class="mi">17500000</span> <span class="o">&amp;&amp;</span> <span class="n">fint</span> <span class="o">&lt;=</span> <span class="mi">21000000</span><span class="p">)</span>
		<span class="n">f</span> <span class="o">=</span> <span class="mh">0xF</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: unknown freqsel setting for %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * _omap3_noncore_dpll_lock - instruct a DPLL to lock and wait for readiness</span>
<span class="cm"> * @clk: pointer to a DPLL struct clk</span>
<span class="cm"> *</span>
<span class="cm"> * Instructs a non-CORE DPLL to lock.  Waits for the DPLL to report</span>
<span class="cm"> * readiness before returning.  Will save and restore the DPLL&#39;s</span>
<span class="cm"> * autoidle state across the enable, per the CDP code.  If the DPLL</span>
<span class="cm"> * locked successfully, return 0; if the DPLL did not lock in the time</span>
<span class="cm"> * allotted, or DPLL3 was passed in, return -EINVAL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_omap3_noncore_dpll_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ai</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: locking DPLL %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">ai</span> <span class="o">=</span> <span class="n">omap3_dpll_autoidle_read</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ai</span><span class="p">)</span>
		<span class="n">omap3_dpll_deny_idle</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">_omap3_dpll_write_clken</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">DPLL_LOCKED</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">_omap3_wait_dpll_status</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ai</span><span class="p">)</span>
		<span class="n">omap3_dpll_allow_idle</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * _omap3_noncore_dpll_bypass - instruct a DPLL to bypass and wait for readiness</span>
<span class="cm"> * @clk: pointer to a DPLL struct clk</span>
<span class="cm"> *</span>
<span class="cm"> * Instructs a non-CORE DPLL to enter low-power bypass mode.  In</span>
<span class="cm"> * bypass mode, the DPLL&#39;s rate is set equal to its parent clock&#39;s</span>
<span class="cm"> * rate.  Waits for the DPLL to report readiness before returning.</span>
<span class="cm"> * Will save and restore the DPLL&#39;s autoidle state across the enable,</span>
<span class="cm"> * per the CDP code.  If the DPLL entered bypass mode successfully,</span>
<span class="cm"> * return 0; if the DPLL did not enter bypass in the time allotted, or</span>
<span class="cm"> * DPLL3 was passed in, or the DPLL does not support low-power bypass,</span>
<span class="cm"> * return -EINVAL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_omap3_noncore_dpll_bypass</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ai</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">DPLL_LOW_POWER_BYPASS</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: configuring DPLL %s for low-power bypass</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">ai</span> <span class="o">=</span> <span class="n">omap3_dpll_autoidle_read</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">_omap3_dpll_write_clken</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">DPLL_LOW_POWER_BYPASS</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">_omap3_wait_dpll_status</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ai</span><span class="p">)</span>
		<span class="n">omap3_dpll_allow_idle</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * _omap3_noncore_dpll_stop - instruct a DPLL to stop</span>
<span class="cm"> * @clk: pointer to a DPLL struct clk</span>
<span class="cm"> *</span>
<span class="cm"> * Instructs a non-CORE DPLL to enter low-power stop. Will save and</span>
<span class="cm"> * restore the DPLL&#39;s autoidle state across the stop, per the CDP</span>
<span class="cm"> * code.  If DPLL3 was passed in, or the DPLL does not support</span>
<span class="cm"> * low-power stop, return -EINVAL; otherwise, return 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_omap3_noncore_dpll_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ai</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">DPLL_LOW_POWER_STOP</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: stopping DPLL %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">ai</span> <span class="o">=</span> <span class="n">omap3_dpll_autoidle_read</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">_omap3_dpll_write_clken</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">DPLL_LOW_POWER_STOP</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ai</span><span class="p">)</span>
		<span class="n">omap3_dpll_allow_idle</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _lookup_dco - Lookup DCO used by j-type DPLL</span>
<span class="cm"> * @clk: pointer to a DPLL struct clk</span>
<span class="cm"> * @dco: digital control oscillator selector</span>
<span class="cm"> * @m: DPLL multiplier to set</span>
<span class="cm"> * @n: DPLL divider to set</span>
<span class="cm"> *</span>
<span class="cm"> * See 36xx TRM section 3.5.3.3.3.2 &quot;Type B DPLL (Low-Jitter)&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * XXX This code is not needed for 3430/AM35xx; can it be optimized</span>
<span class="cm"> * out in non-multi-OMAP builds for those chips?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_lookup_dco</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">dco</span><span class="p">,</span> <span class="n">u16</span> <span class="n">m</span><span class="p">,</span> <span class="n">u8</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fint</span><span class="p">,</span> <span class="n">clkinp</span><span class="p">;</span> <span class="cm">/* watch out for overflow */</span>

	<span class="n">clkinp</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>
	<span class="n">fint</span> <span class="o">=</span> <span class="p">(</span><span class="n">clkinp</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fint</span> <span class="o">&lt;</span> <span class="mi">1000000000</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dco</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">dco</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _lookup_sddiv - Calculate sigma delta divider for j-type DPLL</span>
<span class="cm"> * @clk: pointer to a DPLL struct clk</span>
<span class="cm"> * @sd_div: target sigma-delta divider</span>
<span class="cm"> * @m: DPLL multiplier to set</span>
<span class="cm"> * @n: DPLL divider to set</span>
<span class="cm"> *</span>
<span class="cm"> * See 36xx TRM section 3.5.3.3.3.2 &quot;Type B DPLL (Low-Jitter)&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * XXX This code is not needed for 3430/AM35xx; can it be optimized</span>
<span class="cm"> * out in non-multi-OMAP builds for those chips?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_lookup_sddiv</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">sd_div</span><span class="p">,</span> <span class="n">u16</span> <span class="n">m</span><span class="p">,</span> <span class="n">u8</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clkinp</span><span class="p">,</span> <span class="n">sd</span><span class="p">;</span> <span class="cm">/* watch out for overflow */</span>
	<span class="kt">int</span> <span class="n">mod1</span><span class="p">,</span> <span class="n">mod2</span><span class="p">;</span>

	<span class="n">clkinp</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * target sigma-delta to near 250MHz</span>
<span class="cm">	 * sd = ceil[(m/(n+1)) * (clkinp_MHz / 250)]</span>
<span class="cm">	 */</span>
	<span class="n">clkinp</span> <span class="o">/=</span> <span class="mi">100000</span><span class="p">;</span> <span class="cm">/* shift from MHz to 10*Hz for 38.4 and 19.2 */</span>
	<span class="n">mod1</span> <span class="o">=</span> <span class="p">(</span><span class="n">clkinp</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">250</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">sd</span> <span class="o">=</span> <span class="p">(</span><span class="n">clkinp</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">250</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">mod2</span> <span class="o">=</span> <span class="n">sd</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">sd</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mod1</span> <span class="o">||</span> <span class="n">mod2</span><span class="p">)</span>
		<span class="n">sd</span><span class="o">++</span><span class="p">;</span>
	<span class="o">*</span><span class="n">sd_div</span> <span class="o">=</span> <span class="n">sd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * _omap3_noncore_dpll_program - set non-core DPLL M,N values directly</span>
<span class="cm"> * @clk: struct clk * of DPLL to set</span>
<span class="cm"> * @m: DPLL multiplier to set</span>
<span class="cm"> * @n: DPLL divider to set</span>
<span class="cm"> * @freqsel: FREQSEL value to set</span>
<span class="cm"> *</span>
<span class="cm"> * Program the DPLL with the supplied M, N values, and wait for the DPLL to</span>
<span class="cm"> * lock..  Returns -EINVAL upon error, or 0 upon success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap3_noncore_dpll_program</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="n">u16</span> <span class="n">m</span><span class="p">,</span> <span class="n">u8</span> <span class="n">n</span><span class="p">,</span> <span class="n">u16</span> <span class="n">freqsel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dpll_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dco</span><span class="p">,</span> <span class="n">sd_div</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="cm">/* 3430 ES2 TRM: 4.7.6.9 DPLL Programming Sequence */</span>
	<span class="n">_omap3_noncore_dpll_bypass</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set jitter correction. No jitter correction for OMAP4 and 3630</span>
<span class="cm">	 * since freqsel field is no longer present</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_is_omap44xx</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_is_omap3630</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">control_reg</span><span class="p">);</span>
		<span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">freqsel_mask</span><span class="p">;</span>
		<span class="n">v</span> <span class="o">|=</span> <span class="n">freqsel</span> <span class="o">&lt;&lt;</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">freqsel_mask</span><span class="p">);</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">control_reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set DPLL multiplier, divider */</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mult_div1_reg</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mult_mask</span> <span class="o">|</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">div1_mask</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">|=</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mult_mask</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">|=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">div1_mask</span><span class="p">);</span>

	<span class="cm">/* Configure dco and sd_div for dplls that have these fields */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dco_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_lookup_dco</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dco</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dco_mask</span><span class="p">);</span>
		<span class="n">v</span> <span class="o">|=</span> <span class="n">dco</span> <span class="o">&lt;&lt;</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dco_mask</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">sddiv_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_lookup_sddiv</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd_div</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">sddiv_mask</span><span class="p">);</span>
		<span class="n">v</span> <span class="o">|=</span> <span class="n">sd_div</span> <span class="o">&lt;&lt;</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">sddiv_mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">mult_div1_reg</span><span class="p">);</span>

	<span class="cm">/* We let the clock framework set the other output dividers later */</span>

	<span class="cm">/* REVISIT: Set ramp-up delay? */</span>

	<span class="n">_omap3_noncore_dpll_lock</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Public functions */</span>

<span class="cm">/**</span>
<span class="cm"> * omap3_dpll_recalc - recalculate DPLL rate</span>
<span class="cm"> * @clk: DPLL struct clk</span>
<span class="cm"> *</span>
<span class="cm"> * Recalculate and propagate the DPLL rate.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">omap3_dpll_recalc</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">omap2_get_dpll_rate</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Non-CORE DPLL (e.g., DPLLs that do not control SDRC) clock functions */</span>

<span class="cm">/**</span>
<span class="cm"> * omap3_noncore_dpll_enable - instruct a DPLL to enter bypass or lock mode</span>
<span class="cm"> * @clk: pointer to a DPLL struct clk</span>
<span class="cm"> *</span>
<span class="cm"> * Instructs a non-CORE DPLL to enable, e.g., to enter bypass or lock.</span>
<span class="cm"> * The choice of modes depends on the DPLL&#39;s programmed rate: if it is</span>
<span class="cm"> * the same as the DPLL&#39;s parent clock, it will enter bypass;</span>
<span class="cm"> * otherwise, it will enter lock.  This code will wait for the DPLL to</span>
<span class="cm"> * indicate readiness before returning, unless the DPLL takes too long</span>
<span class="cm"> * to enter the target state.  Intended to be used as the struct clk&#39;s</span>
<span class="cm"> * enable function.  If DPLL3 was passed in, or the DPLL does not</span>
<span class="cm"> * support low-power stop, or if the DPLL took too long to enter</span>
<span class="cm"> * bypass or lock, return -EINVAL; otherwise, return 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap3_noncore_dpll_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dpll_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>

	<span class="n">dd</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">==</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">clk_bypass</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">clk_bypass</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">_omap3_noncore_dpll_bypass</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">clk_ref</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">_omap3_noncore_dpll_lock</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *FIXME: this is dubious - if clk-&gt;rate has changed, what about</span>
<span class="cm">	 * propagating?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">recalc</span><span class="p">)</span> <span class="o">?</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">recalc</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">omap2_get_dpll_rate</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap3_noncore_dpll_disable - instruct a DPLL to enter low-power stop</span>
<span class="cm"> * @clk: pointer to a DPLL struct clk</span>
<span class="cm"> *</span>
<span class="cm"> * Instructs a non-CORE DPLL to enter low-power stop.  This function is</span>
<span class="cm"> * intended for use in struct clkops.  No return value.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">omap3_noncore_dpll_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_omap3_noncore_dpll_stop</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Non-CORE DPLL rate set code */</span>

<span class="cm">/**</span>
<span class="cm"> * omap3_noncore_dpll_set_rate - set non-core DPLL rate</span>
<span class="cm"> * @clk: struct clk * of DPLL to set</span>
<span class="cm"> * @rate: rounded target rate</span>
<span class="cm"> *</span>
<span class="cm"> * Set the DPLL CLKOUT to the target rate.  If the DPLL can enter</span>
<span class="cm"> * low-power bypass, and the target rate is the bypass source clock</span>
<span class="cm"> * rate, then configure the DPLL for bypass.  Otherwise, round the</span>
<span class="cm"> * target rate if it hasn&#39;t been done already, then program and lock</span>
<span class="cm"> * the DPLL.  Returns -EINVAL upon error, or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap3_noncore_dpll_set_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">new_parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hw_rate</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">freqsel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dpll_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span> <span class="o">||</span> <span class="o">!</span><span class="n">rate</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dd</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">hw_rate</span> <span class="o">=</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">recalc</span><span class="p">)</span> <span class="o">?</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">recalc</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span> <span class="o">:</span> <span class="n">omap2_get_dpll_rate</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rate</span> <span class="o">==</span> <span class="n">hw_rate</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure both the bypass and ref clocks are enabled prior to</span>
<span class="cm">	 * doing anything; we need the bypass clock running to reprogram</span>
<span class="cm">	 * the DPLL.</span>
<span class="cm">	 */</span>
	<span class="n">omap2_clk_enable</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">clk_bypass</span><span class="p">);</span>
	<span class="n">omap2_clk_enable</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">clk_ref</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">clk_bypass</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">==</span> <span class="n">rate</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">DPLL_LOW_POWER_BYPASS</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: %s: set rate: entering bypass.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">_omap3_noncore_dpll_bypass</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">new_parent</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">clk_bypass</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">last_rounded_rate</span> <span class="o">!=</span> <span class="n">rate</span><span class="p">)</span>
			<span class="n">rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">round_rate</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">last_rounded_rate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* No freqsel on OMAP4 and OMAP3630 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_is_omap44xx</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_is_omap3630</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">freqsel</span> <span class="o">=</span> <span class="n">_omap3_dpll_compute_freqsel</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span>
						<span class="n">dd</span><span class="o">-&gt;</span><span class="n">last_rounded_n</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">freqsel</span><span class="p">)</span>
				<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: %s: set rate: locking rate to %lu.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">omap3_noncore_dpll_program</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">last_rounded_m</span><span class="p">,</span>
						 <span class="n">dd</span><span class="o">-&gt;</span><span class="n">last_rounded_n</span><span class="p">,</span> <span class="n">freqsel</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">new_parent</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">clk_ref</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Switch the parent clock in the hierarchy, and make sure</span>
<span class="cm">		 * that the new parent&#39;s usecount is correct.  Note: we</span>
<span class="cm">		 * enable the new parent before disabling the old to avoid</span>
<span class="cm">		 * any unnecessary hardware disable-&gt;enable transitions.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">usecount</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">omap2_clk_enable</span><span class="p">(</span><span class="n">new_parent</span><span class="p">);</span>
			<span class="n">omap2_clk_disable</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">clk_reparent</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">new_parent</span><span class="p">);</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="n">rate</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">omap2_clk_disable</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">clk_ref</span><span class="p">);</span>
	<span class="n">omap2_clk_disable</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">clk_bypass</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* DPLL autoidle read/set code */</span>

<span class="cm">/**</span>
<span class="cm"> * omap3_dpll_autoidle_read - read a DPLL&#39;s autoidle bits</span>
<span class="cm"> * @clk: struct clk * of the DPLL to read</span>
<span class="cm"> *</span>
<span class="cm"> * Return the DPLL&#39;s autoidle bits, shifted down to bit 0.  Returns</span>
<span class="cm"> * -EINVAL if passed a null pointer or if the struct clk does not</span>
<span class="cm"> * appear to refer to a DPLL.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">omap3_dpll_autoidle_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dpll_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span> <span class="o">||</span> <span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dd</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">autoidle_reg</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">autoidle_reg</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">&amp;=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">autoidle_mask</span><span class="p">;</span>
	<span class="n">v</span> <span class="o">&gt;&gt;=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">autoidle_mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap3_dpll_allow_idle - enable DPLL autoidle bits</span>
<span class="cm"> * @clk: struct clk * of the DPLL to operate on</span>
<span class="cm"> *</span>
<span class="cm"> * Enable DPLL automatic idle control.  This automatic idle mode</span>
<span class="cm"> * switching takes effect only when the DPLL is locked, at least on</span>
<span class="cm"> * OMAP3430.  The DPLL will enter low-power stop when its downstream</span>
<span class="cm"> * clocks are gated.  No return value.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">omap3_dpll_allow_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dpll_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span> <span class="o">||</span> <span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dd</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">autoidle_reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: DPLL %s: autoidle not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * REVISIT: CORE DPLL can optionally enter low-power bypass</span>
<span class="cm">	 * by writing 0x5 instead of 0x1.  Add some mechanism to</span>
<span class="cm">	 * optionally enter this mode.</span>
<span class="cm">	 */</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">autoidle_reg</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">autoidle_mask</span><span class="p">;</span>
	<span class="n">v</span> <span class="o">|=</span> <span class="n">DPLL_AUTOIDLE_LOW_POWER_STOP</span> <span class="o">&lt;&lt;</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">autoidle_mask</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">autoidle_reg</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap3_dpll_deny_idle - prevent DPLL from automatically idling</span>
<span class="cm"> * @clk: struct clk * of the DPLL to operate on</span>
<span class="cm"> *</span>
<span class="cm"> * Disable DPLL automatic idle control.  No return value.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">omap3_dpll_deny_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dpll_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span> <span class="o">||</span> <span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dd</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">autoidle_reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: DPLL %s: autoidle not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">autoidle_reg</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">autoidle_mask</span><span class="p">;</span>
	<span class="n">v</span> <span class="o">|=</span> <span class="n">DPLL_AUTOIDLE_DISABLE</span> <span class="o">&lt;&lt;</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">autoidle_mask</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">autoidle_reg</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/* Clock control for DPLL outputs */</span>

<span class="cm">/**</span>
<span class="cm"> * omap3_clkoutx2_recalc - recalculate DPLL X2 output virtual clock rate</span>
<span class="cm"> * @clk: DPLL output struct clk</span>
<span class="cm"> *</span>
<span class="cm"> * Using parent clock DPLL data, look up DPLL state.  If locked, set our</span>
<span class="cm"> * rate to the dpll_clk * 2; otherwise, just use dpll_clk.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">omap3_clkoutx2_recalc</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dpll_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">pclk</span><span class="p">;</span>

	<span class="cm">/* Walk up the parents of clk, looking for a DPLL */</span>
	<span class="n">pclk</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pclk</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pclk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="p">)</span>
		<span class="n">pclk</span> <span class="o">=</span> <span class="n">pclk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="cm">/* clk does not have a DPLL as a parent? */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pclk</span><span class="p">);</span>

	<span class="n">dd</span> <span class="o">=</span> <span class="n">pclk</span><span class="o">-&gt;</span><span class="n">dpll_data</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">enable_mask</span><span class="p">);</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">control_reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">enable_mask</span><span class="p">;</span>
	<span class="n">v</span> <span class="o">&gt;&gt;=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">enable_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">!=</span> <span class="n">OMAP3XXX_EN_DPLL_LOCKED</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DPLL_J_TYPE</span><span class="p">))</span>
		<span class="n">rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rate</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
