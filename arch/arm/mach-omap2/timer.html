<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mach-omap2 › timer.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>timer.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/arch/arm/mach-omap2/timer.c</span>
<span class="cm"> *</span>
<span class="cm"> * OMAP2 GP timer support.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009 Nokia Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Update to use new clocksource/clockevent layers</span>
<span class="cm"> * Author: Kevin Hilman, MontaVista Software, Inc. &lt;source@mvista.com&gt;</span>
<span class="cm"> * Copyright (C) 2007 MontaVista Software, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Original driver:</span>
<span class="cm"> * Copyright (C) 2005 Nokia Corporation</span>
<span class="cm"> * Author: Paul Mundt &lt;paul.mundt@nokia.com&gt;</span>
<span class="cm"> *         Juha Yrjölä &lt;juha.yrjola@nokia.com&gt;</span>
<span class="cm"> * OMAP Dual-mode timer framework support by Timo Teras</span>
<span class="cm"> *</span>
<span class="cm"> * Some parts based off of TI&#39;s 24xx code:</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004-2009 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Roughly modelled after the OMAP1 MPU timer code.</span>
<span class="cm"> * Added OMAP4 support - Santosh Shilimkar &lt;santosh.shilimkar@ti.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License. See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/clocksource.h&gt;</span>
<span class="cp">#include &lt;linux/clockchips.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/mach/time.h&gt;</span>
<span class="cp">#include &lt;plat/dmtimer.h&gt;</span>
<span class="cp">#include &lt;asm/smp_twd.h&gt;</span>
<span class="cp">#include &lt;asm/sched_clock.h&gt;</span>
<span class="cp">#include &quot;common.h&quot;</span>
<span class="cp">#include &lt;plat/omap_hwmod.h&gt;</span>
<span class="cp">#include &lt;plat/omap_device.h&gt;</span>
<span class="cp">#include &lt;plat/omap-pm.h&gt;</span>

<span class="cp">#include &quot;powerdomain.h&quot;</span>

<span class="cm">/* Parent clocks, eventually these will come from the clock framework */</span>

<span class="cp">#define OMAP2_MPU_SOURCE	&quot;sys_ck&quot;</span>
<span class="cp">#define OMAP3_MPU_SOURCE	OMAP2_MPU_SOURCE</span>
<span class="cp">#define OMAP4_MPU_SOURCE	&quot;sys_clkin_ck&quot;</span>
<span class="cp">#define OMAP2_32K_SOURCE	&quot;func_32k_ck&quot;</span>
<span class="cp">#define OMAP3_32K_SOURCE	&quot;omap_32k_fck&quot;</span>
<span class="cp">#define OMAP4_32K_SOURCE	&quot;sys_32k_ck&quot;</span>

<span class="cp">#ifdef CONFIG_OMAP_32K_TIMER</span>
<span class="cp">#define OMAP2_CLKEV_SOURCE	OMAP2_32K_SOURCE</span>
<span class="cp">#define OMAP3_CLKEV_SOURCE	OMAP3_32K_SOURCE</span>
<span class="cp">#define OMAP4_CLKEV_SOURCE	OMAP4_32K_SOURCE</span>
<span class="cp">#define OMAP3_SECURE_TIMER	12</span>
<span class="cp">#else</span>
<span class="cp">#define OMAP2_CLKEV_SOURCE	OMAP2_MPU_SOURCE</span>
<span class="cp">#define OMAP3_CLKEV_SOURCE	OMAP3_MPU_SOURCE</span>
<span class="cp">#define OMAP4_CLKEV_SOURCE	OMAP4_MPU_SOURCE</span>
<span class="cp">#define OMAP3_SECURE_TIMER	1</span>
<span class="cp">#endif</span>

<span class="cm">/* MAX_GPTIMER_ID: number of GPTIMERs on the chip */</span>
<span class="cp">#define MAX_GPTIMER_ID		12</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">sys_timer_reserved</span><span class="p">;</span>

<span class="cm">/* Clockevent code */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">omap_dm_timer</span> <span class="n">clkev</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="n">clockevent_gpt</span><span class="p">;</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">omap2_gp_timer_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">evt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">clockevent_gpt</span><span class="p">;</span>

	<span class="n">__omap_dm_timer_write_status</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clkev</span><span class="p">,</span> <span class="n">OMAP_TIMER_INT_OVERFLOW</span><span class="p">);</span>

	<span class="n">evt</span><span class="o">-&gt;</span><span class="n">event_handler</span><span class="p">(</span><span class="n">evt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">omap2_gp_timer_irq</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;gp_timer&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">IRQF_DISABLED</span> <span class="o">|</span> <span class="n">IRQF_TIMER</span> <span class="o">|</span> <span class="n">IRQF_IRQPOLL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">handler</span>	<span class="o">=</span> <span class="n">omap2_gp_timer_interrupt</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap2_gp_timer_set_next_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cycles</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__omap_dm_timer_load_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clkev</span><span class="p">,</span> <span class="n">OMAP_TIMER_CTRL_ST</span><span class="p">,</span>
						<span class="mh">0xffffffff</span> <span class="o">-</span> <span class="n">cycles</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap2_gp_timer_set_mode</span><span class="p">(</span><span class="k">enum</span> <span class="n">clock_event_mode</span> <span class="n">mode</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">period</span><span class="p">;</span>

	<span class="n">__omap_dm_timer_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clkev</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">clkev</span><span class="p">.</span><span class="n">rate</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CLOCK_EVT_MODE_PERIODIC</span>:
		<span class="n">period</span> <span class="o">=</span> <span class="n">clkev</span><span class="p">.</span><span class="n">rate</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="n">period</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Looks like we need to first set the load value separately */</span>
		<span class="n">__omap_dm_timer_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clkev</span><span class="p">,</span> <span class="n">OMAP_TIMER_LOAD_REG</span><span class="p">,</span>
					<span class="mh">0xffffffff</span> <span class="o">-</span> <span class="n">period</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">__omap_dm_timer_load_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clkev</span><span class="p">,</span>
					<span class="n">OMAP_TIMER_CTRL_AR</span> <span class="o">|</span> <span class="n">OMAP_TIMER_CTRL_ST</span><span class="p">,</span>
						<span class="mh">0xffffffff</span> <span class="o">-</span> <span class="n">period</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CLOCK_EVT_MODE_ONESHOT</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CLOCK_EVT_MODE_UNUSED</span>:
	<span class="k">case</span> <span class="n">CLOCK_EVT_MODE_SHUTDOWN</span>:
	<span class="k">case</span> <span class="n">CLOCK_EVT_MODE_RESUME</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="n">clockevent_gpt</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;gp_timer&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">features</span>       <span class="o">=</span> <span class="n">CLOCK_EVT_FEAT_PERIODIC</span> <span class="o">|</span> <span class="n">CLOCK_EVT_FEAT_ONESHOT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shift</span>		<span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_next_event</span>	<span class="o">=</span> <span class="n">omap2_gp_timer_set_next_event</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_mode</span>	<span class="o">=</span> <span class="n">omap2_gp_timer_set_mode</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">omap_dm_timer_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_dm_timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">gptimer_id</span><span class="p">,</span>
						<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fck_source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="cm">/* 10 = sizeof(&quot;gptXX_Xck0&quot;) */</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="n">irq_rsrc</span><span class="p">,</span> <span class="n">mem_rsrc</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;timer%d&quot;</span><span class="p">,</span> <span class="n">gptimer_id</span><span class="p">);</span>
	<span class="n">omap_hwmod_setup_one</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="n">oh</span> <span class="o">=</span> <span class="n">omap_hwmod_lookup</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">omap_hwmod_get_resource_byname</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">IORESOURCE_IRQ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_rsrc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq_rsrc</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">omap_hwmod_get_resource_byname</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mem_rsrc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">phys_base</span> <span class="o">=</span> <span class="n">mem_rsrc</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">mem_rsrc</span><span class="p">.</span><span class="n">end</span> <span class="o">-</span> <span class="n">mem_rsrc</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>

	<span class="cm">/* Static mapping, never released */</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">phys_base</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">io_base</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="cm">/* After the dmtimer is using hwmod these clocks won&#39;t be needed */</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;gpt%d_fck&quot;</span><span class="p">,</span> <span class="n">gptimer_id</span><span class="p">);</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">fclk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">fclk</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">omap_hwmod_enable</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>

	<span class="n">sys_timer_reserved</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">gptimer_id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gptimer_id</span> <span class="o">!=</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>

		<span class="n">src</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">fck_source</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">src</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">__omap_dm_timer_set_source</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">fclk</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
				<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: timer%i cannot set source</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">,</span> <span class="n">gptimer_id</span><span class="p">);</span>
			<span class="n">clk_put</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">__omap_dm_timer_init_regs</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">__omap_dm_timer_reset</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">posted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="n">clk_get_rate</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">fclk</span><span class="p">);</span>

	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">omap2_gp_clockevent_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">gptimer_id</span><span class="p">,</span>
						<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fck_source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">omap_dm_timer_init_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clkev</span><span class="p">,</span> <span class="n">gptimer_id</span><span class="p">,</span> <span class="n">fck_source</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>

	<span class="n">omap2_gp_timer_irq</span><span class="p">.</span><span class="n">dev_id</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clkev</span><span class="p">;</span>
	<span class="n">setup_irq</span><span class="p">(</span><span class="n">clkev</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">omap2_gp_timer_irq</span><span class="p">);</span>

	<span class="n">__omap_dm_timer_int_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clkev</span><span class="p">,</span> <span class="n">OMAP_TIMER_INT_OVERFLOW</span><span class="p">);</span>

	<span class="n">clockevent_gpt</span><span class="p">.</span><span class="n">mult</span> <span class="o">=</span> <span class="n">div_sc</span><span class="p">(</span><span class="n">clkev</span><span class="p">.</span><span class="n">rate</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span><span class="p">,</span>
				     <span class="n">clockevent_gpt</span><span class="p">.</span><span class="n">shift</span><span class="p">);</span>
	<span class="n">clockevent_gpt</span><span class="p">.</span><span class="n">max_delta_ns</span> <span class="o">=</span>
		<span class="n">clockevent_delta2ns</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clockevent_gpt</span><span class="p">);</span>
	<span class="n">clockevent_gpt</span><span class="p">.</span><span class="n">min_delta_ns</span> <span class="o">=</span>
		<span class="n">clockevent_delta2ns</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clockevent_gpt</span><span class="p">);</span>
		<span class="cm">/* Timer internal resynch latency. */</span>

	<span class="n">clockevent_gpt</span><span class="p">.</span><span class="n">cpumask</span> <span class="o">=</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">clockevents_register_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clockevent_gpt</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;OMAP clockevent source: GPTIMER%d at %lu Hz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">gptimer_id</span><span class="p">,</span> <span class="n">clkev</span><span class="p">.</span><span class="n">rate</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Clocksource code */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">omap_dm_timer</span> <span class="n">clksrc</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">use_gptimer_clksrc</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * clocksource</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">cycle_t</span> <span class="nf">clocksource_read_cycles</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">cycle_t</span><span class="p">)</span><span class="n">__omap_dm_timer_read_counter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clksrc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">clocksource</span> <span class="n">clocksource_gpt</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;gp_timer&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rating</span>		<span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">clocksource_read_cycles</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mask</span>		<span class="o">=</span> <span class="n">CLOCKSOURCE_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">CLOCK_SOURCE_IS_CONTINUOUS</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">notrace</span> <span class="nf">dmtimer_read_sched_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clksrc</span><span class="p">.</span><span class="n">reserved</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__omap_dm_timer_read_counter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clksrc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Setup free-running counter for clocksource */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">omap2_sync32k_clocksource_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">vbase</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oh_name</span> <span class="o">=</span> <span class="s">&quot;counter_32k&quot;</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First check hwmod data is available for sync32k counter</span>
<span class="cm">	 */</span>
	<span class="n">oh</span> <span class="o">=</span> <span class="n">omap_hwmod_lookup</span><span class="p">(</span><span class="n">oh_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span> <span class="o">||</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slaves_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">omap_hwmod_setup_one</span><span class="p">(</span><span class="n">oh_name</span><span class="p">);</span>

	<span class="n">vbase</span> <span class="o">=</span> <span class="n">omap_hwmod_get_mpu_rt_va</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vbase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: failed to get counter_32k resource</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">omap_hwmod_enable</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: failed to enable counter_32k module (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">omap_init_clocksource_32k</span><span class="p">(</span><span class="n">vbase</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: failed to initialize counter_32k as a clocksource (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">omap_hwmod_idle</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">omap2_gptimer_clocksource_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">gptimer_id</span><span class="p">,</span>
						<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fck_source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">omap_dm_timer_init_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clksrc</span><span class="p">,</span> <span class="n">gptimer_id</span><span class="p">,</span> <span class="n">fck_source</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>

	<span class="n">__omap_dm_timer_load_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clksrc</span><span class="p">,</span>
			<span class="n">OMAP_TIMER_CTRL_ST</span> <span class="o">|</span> <span class="n">OMAP_TIMER_CTRL_AR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">setup_sched_clock</span><span class="p">(</span><span class="n">dmtimer_read_sched_clock</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">clksrc</span><span class="p">.</span><span class="n">rate</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clocksource_register_hz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_gpt</span><span class="p">,</span> <span class="n">clksrc</span><span class="p">.</span><span class="n">rate</span><span class="p">))</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Could not register clocksource %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">clocksource_gpt</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;OMAP clocksource: GPTIMER%d at %lu Hz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">gptimer_id</span><span class="p">,</span> <span class="n">clksrc</span><span class="p">.</span><span class="n">rate</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">omap2_clocksource_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">gptimer_id</span><span class="p">,</span>
						<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fck_source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * First give preference to kernel parameter configuration</span>
<span class="cm">	 * by user (clocksource=&quot;gp_timer&quot;).</span>
<span class="cm">	 *</span>
<span class="cm">	 * In case of missing kernel parameter for clocksource,</span>
<span class="cm">	 * first check for availability for 32k-sync timer, in case</span>
<span class="cm">	 * of failure in finding 32k_counter module or registering</span>
<span class="cm">	 * it as clocksource, execution will fallback to gp-timer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_gptimer_clksrc</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
		<span class="n">omap2_gptimer_clocksource_init</span><span class="p">(</span><span class="n">gptimer_id</span><span class="p">,</span> <span class="n">fck_source</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">omap2_sync32k_clocksource_init</span><span class="p">())</span>
		<span class="cm">/* Fall back to gp-timer code */</span>
		<span class="n">omap2_gptimer_clocksource_init</span><span class="p">(</span><span class="n">gptimer_id</span><span class="p">,</span> <span class="n">fck_source</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define OMAP_SYS_TIMER_INIT(name, clkev_nr, clkev_src,			\</span>
<span class="cp">				clksrc_nr, clksrc_src)			\</span>
<span class="cp">static void __init omap##name##_timer_init(void)			\</span>
<span class="cp">{									\</span>
<span class="cp">	omap2_gp_clockevent_init((clkev_nr), clkev_src);		\</span>
<span class="cp">	omap2_clocksource_init((clksrc_nr), clksrc_src);		\</span>
<span class="cp">}</span>

<span class="cp">#define OMAP_SYS_TIMER(name)						\</span>
<span class="cp">struct sys_timer omap##name##_timer = {					\</span>
<span class="cp">	.init	= omap##name##_timer_init,				\</span>
<span class="cp">};</span>

<span class="cp">#ifdef CONFIG_ARCH_OMAP2</span>
<span class="n">OMAP_SYS_TIMER_INIT</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">OMAP2_CLKEV_SOURCE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">OMAP2_MPU_SOURCE</span><span class="p">)</span>
<span class="n">OMAP_SYS_TIMER</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ARCH_OMAP3</span>
<span class="n">OMAP_SYS_TIMER_INIT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">OMAP3_CLKEV_SOURCE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">OMAP3_MPU_SOURCE</span><span class="p">)</span>
<span class="n">OMAP_SYS_TIMER</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">OMAP_SYS_TIMER_INIT</span><span class="p">(</span><span class="mi">3</span><span class="n">_secure</span><span class="p">,</span> <span class="n">OMAP3_SECURE_TIMER</span><span class="p">,</span> <span class="n">OMAP3_CLKEV_SOURCE</span><span class="p">,</span>
			<span class="mi">2</span><span class="p">,</span> <span class="n">OMAP3_MPU_SOURCE</span><span class="p">)</span>
<span class="n">OMAP_SYS_TIMER</span><span class="p">(</span><span class="mi">3</span><span class="n">_secure</span><span class="p">)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ARCH_OMAP4</span>
<span class="cp">#ifdef CONFIG_LOCAL_TIMERS</span>
<span class="k">static</span> <span class="n">DEFINE_TWD_LOCAL_TIMER</span><span class="p">(</span><span class="n">twd_local_timer</span><span class="p">,</span>
			      <span class="n">OMAP44XX_LOCAL_TWD_BASE</span><span class="p">,</span>
			      <span class="n">OMAP44XX_IRQ_LOCALTIMER</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">omap4_timer_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">omap2_gp_clockevent_init</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">OMAP4_CLKEV_SOURCE</span><span class="p">);</span>
	<span class="n">omap2_clocksource_init</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">OMAP4_MPU_SOURCE</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_LOCAL_TIMERS</span>
	<span class="cm">/* Local timers are not supprted on OMAP4430 ES1.0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">omap_rev</span><span class="p">()</span> <span class="o">!=</span> <span class="n">OMAP4430_REV_ES1_0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">twd_local_timer_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">twd_local_timer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;twd_local_timer_register failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">OMAP_SYS_TIMER</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_dm_timer_set_src - change the timer input clock source</span>
<span class="cm"> * @pdev:	timer platform device pointer</span>
<span class="cm"> * @source:	array index of parent clock source</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">omap2_dm_timer_set_src</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmtimer_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">fclk</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">parent_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">fclk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fck&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">fclk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: %d: clk_get() FAILED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">OMAP_TIMER_SRC_SYS_CLK</span>:
		<span class="n">parent_name</span> <span class="o">=</span> <span class="s">&quot;sys_ck&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">OMAP_TIMER_SRC_32_KHZ</span>:
		<span class="n">parent_name</span> <span class="o">=</span> <span class="s">&quot;32k_ck&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">OMAP_TIMER_SRC_EXT_CLK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">timer_ip_version</span> <span class="o">==</span> <span class="n">OMAP_TIMER_IP_VERSION_1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parent_name</span> <span class="o">=</span> <span class="s">&quot;alt_ck&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: %d: invalid clk src.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">fclk</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">parent_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: %d: clk_get() %s FAILED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">parent_name</span><span class="p">);</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">fclk</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk_set_parent</span><span class="p">(</span><span class="n">fclk</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: clk_set_parent() to %s FAILED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">parent_name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">clk_put</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">fclk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_timer_init - build and register timer device with an</span>
<span class="cm"> * associated timer hwmod</span>
<span class="cm"> * @oh:	timer hwmod pointer to be used to build timer device</span>
<span class="cm"> * @user:	parameter that can be passed from calling hwmod API</span>
<span class="cm"> *</span>
<span class="cm"> * Called by omap_hwmod_for_each_by_class to register each of the timer</span>
<span class="cm"> * devices present in the system. The number of timer devices is known</span>
<span class="cm"> * by parsing through the hwmod database for a given class name. At the</span>
<span class="cm"> * end of function call memory is allocated for timer device and it is</span>
<span class="cm"> * registered to the framework ready to be proved by the driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">omap_timer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;omap_timer&quot;</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmtimer_platform_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_timer_capability_dev_attr</span> <span class="o">*</span><span class="n">timer_dev_attr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* on secure device, do not register secure timer */</span>
	<span class="n">timer_dev_attr</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">dev_attr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">omap_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">OMAP2_DEVICE_TYPE_GP</span> <span class="o">&amp;&amp;</span> <span class="n">timer_dev_attr</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer_dev_attr</span><span class="o">-&gt;</span><span class="n">timer_capability</span> <span class="o">==</span> <span class="n">OMAP_TIMER_SECURE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pdata</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: No memory for [%s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Extract the IDs from name field in hwmod database</span>
<span class="cm">	 * and use the same for constructing ids&#39; for the</span>
<span class="cm">	 * timer devices. In a way, we are avoiding usage of</span>
<span class="cm">	 * static variable witin the function to do the same.</span>
<span class="cm">	 * CAUTION: We have to be careful and make sure the</span>
<span class="cm">	 * name in hwmod database does not change in which case</span>
<span class="cm">	 * we might either make corresponding change here or</span>
<span class="cm">	 * switch back static variable mechanism.</span>
<span class="cm">	 */</span>
	<span class="n">sscanf</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;timer%2d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>

	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">set_timer_src</span> <span class="o">=</span> <span class="n">omap2_dm_timer_set_src</span><span class="p">;</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">timer_ip_version</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">;</span>

	<span class="cm">/* Mark clocksource and clockevent timers as reserved */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sys_timer_reserved</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pwrdm</span> <span class="o">=</span> <span class="n">omap_hwmod_get_pwrdm</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">loses_context</span> <span class="o">=</span> <span class="n">pwrdm_can_ever_lose_context</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">get_context_loss_count</span> <span class="o">=</span> <span class="n">omap_pm_get_dev_context_loss_count</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">pdev</span> <span class="o">=</span> <span class="n">omap_device_build</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">oh</span><span class="p">,</span> <span class="n">pdata</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="p">),</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Can&#39;t build omap_device for %s: %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pdata</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_dm_timer_init - top level regular device initialization</span>
<span class="cm"> *</span>
<span class="cm"> * Uses dedicated hwmod api to parse through hwmod database for</span>
<span class="cm"> * given class name and then build and register the timer device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">omap2_dm_timer_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">omap_hwmod_for_each_by_class</span><span class="p">(</span><span class="s">&quot;timer&quot;</span><span class="p">,</span> <span class="n">omap_timer_init</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: device registration failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">arch_initcall</span><span class="p">(</span><span class="n">omap2_dm_timer_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_override_clocksource - clocksource override with user configuration</span>
<span class="cm"> *</span>
<span class="cm"> * Allows user to override default clocksource, using kernel parameter</span>
<span class="cm"> *   clocksource=&quot;gp_timer&quot;	(For all OMAP2PLUS architectures)</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, here we are using same standard kernel parameter &quot;clocksource=&quot;,</span>
<span class="cm"> * and not introducing any OMAP specific interface.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">omap2_override_clocksource</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * For OMAP architecture, we only have two options</span>
<span class="cm">	 *    - sync_32k (default)</span>
<span class="cm">	 *    - gp_timer (sys_clk based)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;gp_timer&quot;</span><span class="p">))</span>
		<span class="n">use_gptimer_clksrc</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;clocksource&quot;</span><span class="p">,</span> <span class="n">omap2_override_clocksource</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
