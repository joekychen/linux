<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mach-omap2 › omap-mpuss-lowpower.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>omap-mpuss-lowpower.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * OMAP MPUSS low power code</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2011 Texas Instruments, Inc.</span>
<span class="cm"> *	Santosh Shilimkar &lt;santosh.shilimkar@ti.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * OMAP4430 MPUSS mainly consists of dual Cortex-A9 with per-CPU</span>
<span class="cm"> * Local timer and Watchdog, GIC, SCU, PL310 L2 cache controller,</span>
<span class="cm"> * CPU0 and CPU1 LPRM modules.</span>
<span class="cm"> * CPU0, CPU1 and MPUSS each have there own power domain and</span>
<span class="cm"> * hence multiple low power combinations of MPUSS are possible.</span>
<span class="cm"> *</span>
<span class="cm"> * The CPU0 and CPU1 can&#39;t support Closed switch Retention (CSWR)</span>
<span class="cm"> * because the mode is not supported by hw constraints of dormant</span>
<span class="cm"> * mode. While waking up from the dormant mode, a reset  signal</span>
<span class="cm"> * to the Cortex-A9 processor must be asserted by the external</span>
<span class="cm"> * power controller.</span>
<span class="cm"> *</span>
<span class="cm"> * With architectural inputs and hardware recommendations, only</span>
<span class="cm"> * below modes are supported from power gain vs latency point of view.</span>
<span class="cm"> *</span>
<span class="cm"> *	CPU0		CPU1		MPUSS</span>
<span class="cm"> *	----------------------------------------------</span>
<span class="cm"> *	ON		ON		ON</span>
<span class="cm"> *	ON(Inactive)	OFF		ON(Inactive)</span>
<span class="cm"> *	OFF		OFF		CSWR</span>
<span class="cm"> *	OFF		OFF		OSWR</span>
<span class="cm"> *	OFF		OFF		OFF(Device OFF *TBD)</span>
<span class="cm"> *	----------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * Note: CPU0 is the master core and it is the last CPU to go down</span>
<span class="cm"> * and first to wake-up when MPUSS low power states are excercised</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>

<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/smp_scu.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/suspend.h&gt;</span>
<span class="cp">#include &lt;asm/hardware/cache-l2x0.h&gt;</span>

<span class="cp">#include &lt;plat/omap44xx.h&gt;</span>

<span class="cp">#include &quot;common.h&quot;</span>
<span class="cp">#include &quot;omap4-sar-layout.h&quot;</span>
<span class="cp">#include &quot;pm.h&quot;</span>
<span class="cp">#include &quot;prcm_mpu44xx.h&quot;</span>
<span class="cp">#include &quot;prminst44xx.h&quot;</span>
<span class="cp">#include &quot;prcm44xx.h&quot;</span>
<span class="cp">#include &quot;prm44xx.h&quot;</span>
<span class="cp">#include &quot;prm-regbits-44xx.h&quot;</span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="k">struct</span> <span class="n">omap4_cpu_pm_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">scu_sar_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">wkup_sar_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">l2x0_sar_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap4_cpu_pm_info</span><span class="p">,</span> <span class="n">omap4_pm_info</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">mpuss_pd</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">sar_base</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Program the wakeup routine address for the CPU0 and CPU1</span>
<span class="cm"> * used for OFF or DORMANT wakeup.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_cpu_wakeup_addr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap4_cpu_pm_info</span> <span class="o">*</span><span class="n">pm_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">omap4_pm_info</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">wkup_sar_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the CPUx powerdomain&#39;s previous power state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_cpu_next_pwrst</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">power_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap4_cpu_pm_info</span> <span class="o">*</span><span class="n">pm_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">omap4_pm_info</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>

	<span class="n">pwrdm_set_next_pwrst</span><span class="p">(</span><span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">power_state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read CPU&#39;s previous power state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">read_cpu_prev_pwrst</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap4_cpu_pm_info</span> <span class="o">*</span><span class="n">pm_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">omap4_pm_info</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pwrdm_read_prev_pwrst</span><span class="p">(</span><span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear the CPUx powerdomain&#39;s previous power state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_cpu_prev_pwrst</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap4_cpu_pm_info</span> <span class="o">*</span><span class="n">pm_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">omap4_pm_info</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>

	<span class="n">pwrdm_clear_all_prev_pwrst</span><span class="p">(</span><span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Store the SCU power status value to scratchpad memory</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scu_pwrst_prepare</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap4_cpu_pm_info</span> <span class="o">*</span><span class="n">pm_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">omap4_pm_info</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">scu_pwr_st</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cpu_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PWRDM_POWER_RET</span>:
		<span class="n">scu_pwr_st</span> <span class="o">=</span> <span class="n">SCU_PM_DORMANT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PWRDM_POWER_OFF</span>:
		<span class="n">scu_pwr_st</span> <span class="o">=</span> <span class="n">SCU_PM_POWEROFF</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PWRDM_POWER_ON</span>:
	<span class="k">case</span> <span class="n">PWRDM_POWER_INACTIVE</span>:
	<span class="nl">default:</span>
		<span class="n">scu_pwr_st</span> <span class="o">=</span> <span class="n">SCU_PM_NORMAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">scu_pwr_st</span><span class="p">,</span> <span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">scu_sar_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Helper functions for MPUSS OSWR */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mpuss_clear_prev_logic_pwrst</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">omap4_prminst_read_inst_reg</span><span class="p">(</span><span class="n">OMAP4430_PRM_PARTITION</span><span class="p">,</span>
		<span class="n">OMAP4430_PRM_MPU_INST</span><span class="p">,</span> <span class="n">OMAP4_RM_MPU_MPU_CONTEXT_OFFSET</span><span class="p">);</span>
	<span class="n">omap4_prminst_write_inst_reg</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">OMAP4430_PRM_PARTITION</span><span class="p">,</span>
		<span class="n">OMAP4430_PRM_MPU_INST</span><span class="p">,</span> <span class="n">OMAP4_RM_MPU_MPU_CONTEXT_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpu_clear_prev_logic_pwrst</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">omap4_prcm_mpu_read_inst_reg</span><span class="p">(</span><span class="n">OMAP4430_PRCM_MPU_CPU1_INST</span><span class="p">,</span>
					<span class="n">OMAP4_RM_CPU1_CPU1_CONTEXT_OFFSET</span><span class="p">);</span>
		<span class="n">omap4_prcm_mpu_write_inst_reg</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">OMAP4430_PRCM_MPU_CPU1_INST</span><span class="p">,</span>
					<span class="n">OMAP4_RM_CPU1_CPU1_CONTEXT_OFFSET</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">omap4_prcm_mpu_read_inst_reg</span><span class="p">(</span><span class="n">OMAP4430_PRCM_MPU_CPU0_INST</span><span class="p">,</span>
					<span class="n">OMAP4_RM_CPU0_CPU0_CONTEXT_OFFSET</span><span class="p">);</span>
		<span class="n">omap4_prcm_mpu_write_inst_reg</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">OMAP4430_PRCM_MPU_CPU0_INST</span><span class="p">,</span>
					<span class="n">OMAP4_RM_CPU0_CPU0_CONTEXT_OFFSET</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap4_mpuss_read_prev_context_state:</span>
<span class="cm"> * Function returns the MPUSS previous context state</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">omap4_mpuss_read_prev_context_state</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">omap4_prminst_read_inst_reg</span><span class="p">(</span><span class="n">OMAP4430_PRM_PARTITION</span><span class="p">,</span>
		<span class="n">OMAP4430_PRM_MPU_INST</span><span class="p">,</span> <span class="n">OMAP4_RM_MPU_MPU_CONTEXT_OFFSET</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="n">OMAP4430_LOSTCONTEXT_DFF_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">reg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Store the CPU cluster state for L2X0 low power operations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">l2x0_pwrst_prepare</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">save_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap4_cpu_pm_info</span> <span class="o">*</span><span class="n">pm_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">omap4_pm_info</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">save_state</span><span class="p">,</span> <span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">l2x0_sar_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Save the L2X0 AUXCTRL and POR value to SAR memory. Its used to</span>
<span class="cm"> * in every restore MPUSS OFF path.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_CACHE_L2X0</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">save_l2x0_context</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">l2x0_base</span> <span class="o">=</span> <span class="n">omap4_get_l2cache_base</span><span class="p">();</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">l2x0_base</span> <span class="o">+</span> <span class="n">L2X0_AUX_CTRL</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">sar_base</span> <span class="o">+</span> <span class="n">L2X0_AUXCTRL_OFFSET</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">l2x0_base</span> <span class="o">+</span> <span class="n">L2X0_PREFETCH_CTRL</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">sar_base</span> <span class="o">+</span> <span class="n">L2X0_PREFETCH_CTRL_OFFSET</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">save_l2x0_context</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * omap4_enter_lowpower: OMAP4 MPUSS Low Power Entry Function</span>
<span class="cm"> * The purpose of this function is to manage low power programming</span>
<span class="cm"> * of OMAP4 MPUSS subsystem</span>
<span class="cm"> * @cpu : CPU ID</span>
<span class="cm"> * @power_state: Low power state.</span>
<span class="cm"> *</span>
<span class="cm"> * MPUSS states for the context save:</span>
<span class="cm"> * save_state =</span>
<span class="cm"> *	0 - Nothing lost and no need to save: MPUSS INACTIVE</span>
<span class="cm"> *	1 - CPUx L1 and logic lost: MPUSS CSWR</span>
<span class="cm"> *	2 - CPUx L1 and logic lost + GIC lost: MPUSS OSWR</span>
<span class="cm"> *	3 - CPUx L1 and logic lost + GIC + L2 lost: DEVICE OFF</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap4_enter_lowpower</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">power_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">save_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wakeup_cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">omap_rev</span><span class="p">()</span> <span class="o">==</span> <span class="n">OMAP4430_REV_ES1_0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">power_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PWRDM_POWER_ON</span>:
	<span class="k">case</span> <span class="n">PWRDM_POWER_INACTIVE</span>:
		<span class="n">save_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PWRDM_POWER_OFF</span>:
		<span class="n">save_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PWRDM_POWER_RET</span>:
	<span class="nl">default:</span>
		<span class="cm">/*</span>
<span class="cm">		 * CPUx CSWR is invalid hardware state. Also CPUx OSWR</span>
<span class="cm">		 * doesn&#39;t make much scense, since logic is lost and $L1</span>
<span class="cm">		 * needs to be cleaned because of coherency. This makes</span>
<span class="cm">		 * CPUx OSWR equivalent to CPUX OFF and hence not supported</span>
<span class="cm">		 */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pwrdm_pre_transition</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check MPUSS next state and save interrupt controller if needed.</span>
<span class="cm">	 * In MPUSS OSWR or device OFF, interrupt controller  contest is lost.</span>
<span class="cm">	 */</span>
	<span class="n">mpuss_clear_prev_logic_pwrst</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pwrdm_read_next_pwrst</span><span class="p">(</span><span class="n">mpuss_pd</span><span class="p">)</span> <span class="o">==</span> <span class="n">PWRDM_POWER_RET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">pwrdm_read_logic_retst</span><span class="p">(</span><span class="n">mpuss_pd</span><span class="p">)</span> <span class="o">==</span> <span class="n">PWRDM_POWER_OFF</span><span class="p">))</span>
		<span class="n">save_state</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">cpu_clear_prev_logic_pwrst</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">set_cpu_next_pwrst</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">power_state</span><span class="p">);</span>
	<span class="n">set_cpu_wakeup_addr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">omap4_cpu_resume</span><span class="p">));</span>
	<span class="n">scu_pwrst_prepare</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">power_state</span><span class="p">);</span>
	<span class="n">l2x0_pwrst_prepare</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">save_state</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call low level function  with targeted low power state.</span>
<span class="cm">	 */</span>
	<span class="n">cpu_suspend</span><span class="p">(</span><span class="n">save_state</span><span class="p">,</span> <span class="n">omap4_finish_suspend</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restore the CPUx power state to ON otherwise CPUx</span>
<span class="cm">	 * power domain can transitions to programmed low power</span>
<span class="cm">	 * state while doing WFI outside the low powe code. On</span>
<span class="cm">	 * secure devices, CPUx does WFI which can result in</span>
<span class="cm">	 * domain transition</span>
<span class="cm">	 */</span>
	<span class="n">wakeup_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">set_cpu_next_pwrst</span><span class="p">(</span><span class="n">wakeup_cpu</span><span class="p">,</span> <span class="n">PWRDM_POWER_ON</span><span class="p">);</span>

	<span class="n">pwrdm_post_transition</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap4_hotplug_cpu: OMAP4 CPU hotplug entry</span>
<span class="cm"> * @cpu : CPU ID</span>
<span class="cm"> * @power_state: CPU low power state.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">omap4_hotplug_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">power_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">omap_rev</span><span class="p">()</span> <span class="o">==</span> <span class="n">OMAP4430_REV_ES1_0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">power_state</span> <span class="o">==</span> <span class="n">PWRDM_POWER_OFF</span><span class="p">)</span>
		<span class="n">cpu_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">clear_cpu_prev_pwrst</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">set_cpu_next_pwrst</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">power_state</span><span class="p">);</span>
	<span class="n">set_cpu_wakeup_addr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">omap_secondary_startup</span><span class="p">));</span>
	<span class="n">scu_pwrst_prepare</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">power_state</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * CPU never retuns back if targetted power state is OFF mode.</span>
<span class="cm">	 * CPU ONLINE follows normal CPU ONLINE ptah via</span>
<span class="cm">	 * omap_secondary_startup().</span>
<span class="cm">	 */</span>
	<span class="n">omap4_finish_suspend</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">);</span>

	<span class="n">set_cpu_next_pwrst</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">PWRDM_POWER_ON</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Initialise OMAP4 MPUSS</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">omap4_mpuss_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap4_cpu_pm_info</span> <span class="o">*</span><span class="n">pm_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">omap_rev</span><span class="p">()</span> <span class="o">==</span> <span class="n">OMAP4430_REV_ES1_0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Power Management not supported on OMAP4430 ES1.0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sar_base</span> <span class="o">=</span> <span class="n">omap4_get_sar_ram_base</span><span class="p">();</span>

	<span class="cm">/* Initilaise per CPU PM information */</span>
	<span class="n">pm_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">omap4_pm_info</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
	<span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">scu_sar_addr</span> <span class="o">=</span> <span class="n">sar_base</span> <span class="o">+</span> <span class="n">SCU_OFFSET0</span><span class="p">;</span>
	<span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">wkup_sar_addr</span> <span class="o">=</span> <span class="n">sar_base</span> <span class="o">+</span> <span class="n">CPU0_WAKEUP_NS_PA_ADDR_OFFSET</span><span class="p">;</span>
	<span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">l2x0_sar_addr</span> <span class="o">=</span> <span class="n">sar_base</span> <span class="o">+</span> <span class="n">L2X0_SAVE_OFFSET0</span><span class="p">;</span>
	<span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">pwrdm</span> <span class="o">=</span> <span class="n">pwrdm_lookup</span><span class="p">(</span><span class="s">&quot;cpu0_pwrdm&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Lookup failed for CPU0 pwrdm</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear CPU previous power domain state */</span>
	<span class="n">pwrdm_clear_all_prev_pwrst</span><span class="p">(</span><span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">);</span>
	<span class="n">cpu_clear_prev_logic_pwrst</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Initialise CPU0 power domain state to ON */</span>
	<span class="n">pwrdm_set_next_pwrst</span><span class="p">(</span><span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">PWRDM_POWER_ON</span><span class="p">);</span>

	<span class="n">pm_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">omap4_pm_info</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>
	<span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">scu_sar_addr</span> <span class="o">=</span> <span class="n">sar_base</span> <span class="o">+</span> <span class="n">SCU_OFFSET1</span><span class="p">;</span>
	<span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">wkup_sar_addr</span> <span class="o">=</span> <span class="n">sar_base</span> <span class="o">+</span> <span class="n">CPU1_WAKEUP_NS_PA_ADDR_OFFSET</span><span class="p">;</span>
	<span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">l2x0_sar_addr</span> <span class="o">=</span> <span class="n">sar_base</span> <span class="o">+</span> <span class="n">L2X0_SAVE_OFFSET1</span><span class="p">;</span>
	<span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">pwrdm</span> <span class="o">=</span> <span class="n">pwrdm_lookup</span><span class="p">(</span><span class="s">&quot;cpu1_pwrdm&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Lookup failed for CPU1 pwrdm</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear CPU previous power domain state */</span>
	<span class="n">pwrdm_clear_all_prev_pwrst</span><span class="p">(</span><span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">);</span>
	<span class="n">cpu_clear_prev_logic_pwrst</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Initialise CPU1 power domain state to ON */</span>
	<span class="n">pwrdm_set_next_pwrst</span><span class="p">(</span><span class="n">pm_info</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">,</span> <span class="n">PWRDM_POWER_ON</span><span class="p">);</span>

	<span class="n">mpuss_pd</span> <span class="o">=</span> <span class="n">pwrdm_lookup</span><span class="p">(</span><span class="s">&quot;mpu_pwrdm&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mpuss_pd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to lookup MPUSS power domain</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pwrdm_clear_all_prev_pwrst</span><span class="p">(</span><span class="n">mpuss_pd</span><span class="p">);</span>
	<span class="n">mpuss_clear_prev_logic_pwrst</span><span class="p">();</span>

	<span class="cm">/* Save device type on scratchpad for low level code to use */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">omap_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">OMAP2_DEVICE_TYPE_GP</span><span class="p">)</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sar_base</span> <span class="o">+</span> <span class="n">OMAP_TYPE_OFFSET</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sar_base</span> <span class="o">+</span> <span class="n">OMAP_TYPE_OFFSET</span><span class="p">);</span>

	<span class="n">save_l2x0_context</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
