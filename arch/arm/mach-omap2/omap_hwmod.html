<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mach-omap2 › omap_hwmod.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>omap_hwmod.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * omap_hwmod implementation for OMAP2/3/4</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009-2011 Nokia Corporation</span>
<span class="cm"> * Copyright (C) 2011-2012 Texas Instruments, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Paul Walmsley, Benoît Cousson, Kevin Hilman</span>
<span class="cm"> *</span>
<span class="cm"> * Created in collaboration with (alphabetical order): Thara Gopinath,</span>
<span class="cm"> * Tony Lindgren, Rajendra Nayak, Vikram Pandita, Sakari Poussa, Anand</span>
<span class="cm"> * Sawant, Santosh Shilimkar, Richard Woodruff</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * Introduction</span>
<span class="cm"> * ------------</span>
<span class="cm"> * One way to view an OMAP SoC is as a collection of largely unrelated</span>
<span class="cm"> * IP blocks connected by interconnects.  The IP blocks include</span>
<span class="cm"> * devices such as ARM processors, audio serial interfaces, UARTs,</span>
<span class="cm"> * etc.  Some of these devices, like the DSP, are created by TI;</span>
<span class="cm"> * others, like the SGX, largely originate from external vendors.  In</span>
<span class="cm"> * TI&#39;s documentation, on-chip devices are referred to as &quot;OMAP</span>
<span class="cm"> * modules.&quot;  Some of these IP blocks are identical across several</span>
<span class="cm"> * OMAP versions.  Others are revised frequently.</span>
<span class="cm"> *</span>
<span class="cm"> * These OMAP modules are tied together by various interconnects.</span>
<span class="cm"> * Most of the address and data flow between modules is via OCP-based</span>
<span class="cm"> * interconnects such as the L3 and L4 buses; but there are other</span>
<span class="cm"> * interconnects that distribute the hardware clock tree, handle idle</span>
<span class="cm"> * and reset signaling, supply power, and connect the modules to</span>
<span class="cm"> * various pads or balls on the OMAP package.</span>
<span class="cm"> *</span>
<span class="cm"> * OMAP hwmod provides a consistent way to describe the on-chip</span>
<span class="cm"> * hardware blocks and their integration into the rest of the chip.</span>
<span class="cm"> * This description can be automatically generated from the TI</span>
<span class="cm"> * hardware database.  OMAP hwmod provides a standard, consistent API</span>
<span class="cm"> * to reset, enable, idle, and disable these hardware blocks.  And</span>
<span class="cm"> * hwmod provides a way for other core code, such as the Linux device</span>
<span class="cm"> * code or the OMAP power management and address space mapping code,</span>
<span class="cm"> * to query the hardware database.</span>
<span class="cm"> *</span>
<span class="cm"> * Using hwmod</span>
<span class="cm"> * -----------</span>
<span class="cm"> * Drivers won&#39;t call hwmod functions directly.  That is done by the</span>
<span class="cm"> * omap_device code, and in rare occasions, by custom integration code</span>
<span class="cm"> * in arch/arm/ *omap*.  The omap_device code includes functions to</span>
<span class="cm"> * build a struct platform_device using omap_hwmod data, and that is</span>
<span class="cm"> * currently how hwmod data is communicated to drivers and to the</span>
<span class="cm"> * Linux driver model.  Most drivers will call omap_hwmod functions only</span>
<span class="cm"> * indirectly, via pm_runtime*() functions.</span>
<span class="cm"> *</span>
<span class="cm"> * From a layering perspective, here is where the OMAP hwmod code</span>
<span class="cm"> * fits into the kernel software stack:</span>
<span class="cm"> *</span>
<span class="cm"> *            +-------------------------------+</span>
<span class="cm"> *            |      Device driver code       |</span>
<span class="cm"> *            |      (e.g., drivers/)         |</span>
<span class="cm"> *            +-------------------------------+</span>
<span class="cm"> *            |      Linux driver model       |</span>
<span class="cm"> *            |     (platform_device /        |</span>
<span class="cm"> *            |  platform_driver data/code)   |</span>
<span class="cm"> *            +-------------------------------+</span>
<span class="cm"> *            | OMAP core-driver integration  |</span>
<span class="cm"> *            |(arch/arm/mach-omap2/devices.c)|</span>
<span class="cm"> *            +-------------------------------+</span>
<span class="cm"> *            |      omap_device code         |</span>
<span class="cm"> *            | (../plat-omap/omap_device.c)  |</span>
<span class="cm"> *            +-------------------------------+</span>
<span class="cm"> *   ----&gt;    |    omap_hwmod code/data       |    &lt;-----</span>
<span class="cm"> *            | (../mach-omap2/omap_hwmod*)   |</span>
<span class="cm"> *            +-------------------------------+</span>
<span class="cm"> *            | OMAP clock/PRCM/register fns  |</span>
<span class="cm"> *            | (__raw_{read,write}l, clk*)   |</span>
<span class="cm"> *            +-------------------------------+</span>
<span class="cm"> *</span>
<span class="cm"> * Device drivers should not contain any OMAP-specific code or data in</span>
<span class="cm"> * them.  They should only contain code to operate the IP block that</span>
<span class="cm"> * the driver is responsible for.  This is because these IP blocks can</span>
<span class="cm"> * also appear in other SoCs, either from TI (such as DaVinci) or from</span>
<span class="cm"> * other manufacturers; and drivers should be reusable across other</span>
<span class="cm"> * platforms.</span>
<span class="cm"> *</span>
<span class="cm"> * The OMAP hwmod code also will attempt to reset and idle all on-chip</span>
<span class="cm"> * devices upon boot.  The goal here is for the kernel to be</span>
<span class="cm"> * completely self-reliant and independent from bootloaders.  This is</span>
<span class="cm"> * to ensure a repeatable configuration, both to ensure consistent</span>
<span class="cm"> * runtime behavior, and to make it easier for others to reproduce</span>
<span class="cm"> * bugs.</span>
<span class="cm"> *</span>
<span class="cm"> * OMAP module activity states</span>
<span class="cm"> * ---------------------------</span>
<span class="cm"> * The hwmod code considers modules to be in one of several activity</span>
<span class="cm"> * states.  IP blocks start out in an UNKNOWN state, then once they</span>
<span class="cm"> * are registered via the hwmod code, proceed to the REGISTERED state.</span>
<span class="cm"> * Once their clock names are resolved to clock pointers, the module</span>
<span class="cm"> * enters the CLKS_INITED state; and finally, once the module has been</span>
<span class="cm"> * reset and the integration registers programmed, the INITIALIZED state</span>
<span class="cm"> * is entered.  The hwmod code will then place the module into either</span>
<span class="cm"> * the IDLE state to save power, or in the case of a critical system</span>
<span class="cm"> * module, the ENABLED state.</span>
<span class="cm"> *</span>
<span class="cm"> * OMAP core integration code can then call omap_hwmod*() functions</span>
<span class="cm"> * directly to move the module between the IDLE, ENABLED, and DISABLED</span>
<span class="cm"> * states, as needed.  This is done during both the PM idle loop, and</span>
<span class="cm"> * in the OMAP core integration code&#39;s implementation of the PM runtime</span>
<span class="cm"> * functions.</span>
<span class="cm"> *</span>
<span class="cm"> * References</span>
<span class="cm"> * ----------</span>
<span class="cm"> * This is a partial list.</span>
<span class="cm"> * - OMAP2420 Multimedia Processor Silicon Revision 2.1.1, 2.2 (SWPU064)</span>
<span class="cm"> * - OMAP2430 Multimedia Device POP Silicon Revision 2.1 (SWPU090)</span>
<span class="cm"> * - OMAP34xx Multimedia Device Silicon Revision 3.1 (SWPU108)</span>
<span class="cm"> * - OMAP4430 Multimedia Device Silicon Revision 1.0 (SWPU140)</span>
<span class="cm"> * - Open Core Protocol Specification 2.2</span>
<span class="cm"> *</span>
<span class="cm"> * To do:</span>
<span class="cm"> * - handle IO mapping</span>
<span class="cm"> * - bus throughput &amp; module latency measurement code</span>
<span class="cm"> *</span>
<span class="cm"> * XXX add tests at the beginning of each function to ensure the hwmod is</span>
<span class="cm"> * in the appropriate state</span>
<span class="cm"> * XXX error return values should be checked to ensure that they are</span>
<span class="cm"> * appropriate</span>
<span class="cm"> */</span>
<span class="cp">#undef DEBUG</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>

<span class="cp">#include &quot;common.h&quot;</span>
<span class="cp">#include &lt;plat/cpu.h&gt;</span>
<span class="cp">#include &quot;clockdomain.h&quot;</span>
<span class="cp">#include &quot;powerdomain.h&quot;</span>
<span class="cp">#include &lt;plat/clock.h&gt;</span>
<span class="cp">#include &lt;plat/omap_hwmod.h&gt;</span>
<span class="cp">#include &lt;plat/prcm.h&gt;</span>

<span class="cp">#include &quot;cm2xxx_3xxx.h&quot;</span>
<span class="cp">#include &quot;cminst44xx.h&quot;</span>
<span class="cp">#include &quot;prm2xxx_3xxx.h&quot;</span>
<span class="cp">#include &quot;prm44xx.h&quot;</span>
<span class="cp">#include &quot;prminst44xx.h&quot;</span>
<span class="cp">#include &quot;mux.h&quot;</span>

<span class="cm">/* Maximum microseconds to wait for OMAP module to softreset */</span>
<span class="cp">#define MAX_MODULE_SOFTRESET_WAIT	10000</span>

<span class="cm">/* Name of the OMAP hwmod for the MPU */</span>
<span class="cp">#define MPU_INITIATOR_NAME		&quot;mpu&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Number of struct omap_hwmod_link records per struct</span>
<span class="cm"> * omap_hwmod_ocp_if record (master-&gt;slave and slave-&gt;master)</span>
<span class="cm"> */</span>
<span class="cp">#define LINKS_PER_OCP_IF		2</span>

<span class="cm">/* omap_hwmod_list contains all registered struct omap_hwmods */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">omap_hwmod_list</span><span class="p">);</span>

<span class="cm">/* mpu_oh: used to add/remove MPU initiator from sleepdep list */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">mpu_oh</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * linkspace: ptr to a buffer that struct omap_hwmod_link records are</span>
<span class="cm"> * allocated from - used to reduce the number of small memory</span>
<span class="cm"> * allocations, which has a significant impact on performance</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">omap_hwmod_link</span> <span class="o">*</span><span class="n">linkspace</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * free_ls, max_ls: array indexes into linkspace; representing the</span>
<span class="cm"> * next free struct omap_hwmod_link index, and the maximum number of</span>
<span class="cm"> * struct omap_hwmod_link records allocated (respectively)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">free_ls</span><span class="p">,</span> <span class="n">max_ls</span><span class="p">,</span> <span class="n">ls_supp</span><span class="p">;</span>

<span class="cm">/* Private functions */</span>

<span class="cm">/**</span>
<span class="cm"> * _fetch_next_ocp_if - return the next OCP interface in a list</span>
<span class="cm"> * @p: ptr to a ptr to the list_head inside the ocp_if to return</span>
<span class="cm"> * @i: pointer to the index of the element pointed to by @p in the list</span>
<span class="cm"> *</span>
<span class="cm"> * Return a pointer to the struct omap_hwmod_ocp_if record</span>
<span class="cm"> * containing the struct list_head pointed to by @p, and increment</span>
<span class="cm"> * @p such that a future call to this routine will return the next</span>
<span class="cm"> * record.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="nf">_fetch_next_ocp_if</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span>
						    <span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="n">oi</span><span class="p">;</span>

	<span class="n">oi</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap_hwmod_link</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ocp_if</span><span class="p">;</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">oi</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _update_sysc_cache - return the module OCP_SYSCONFIG register, keep copy</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Load the current value of the hwmod OCP_SYSCONFIG register into the</span>
<span class="cm"> * struct omap_hwmod for later use.  Returns -EINVAL if the hwmod has no</span>
<span class="cm"> * OCP_SYSCONFIG register or 0 upon success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_update_sysc_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_hwmod: %s: cannot read OCP_SYSCONFIG: not defined on hwmod&#39;s class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* XXX ensure module interface clock is up */</span>

	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_sysc_cache</span> <span class="o">=</span> <span class="n">omap_hwmod_read</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_offs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span> <span class="o">&amp;</span> <span class="n">SYSC_NO_CACHE</span><span class="p">))</span>
		<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_int_flags</span> <span class="o">|=</span> <span class="n">_HWMOD_SYSCONFIG_LOADED</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _write_sysconfig - write a value to the module&#39;s OCP_SYSCONFIG register</span>
<span class="cm"> * @v: OCP_SYSCONFIG value to write</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Write @v into the module class&#39; OCP_SYSCONFIG register, if it has</span>
<span class="cm"> * one.  No return value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_write_sysconfig</span><span class="p">(</span><span class="n">u32</span> <span class="n">v</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_hwmod: %s: cannot write OCP_SYSCONFIG: not defined on hwmod&#39;s class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* XXX ensure module interface clock is up */</span>

	<span class="cm">/* Module might have lost context, always update cache and register */</span>
	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_sysc_cache</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">omap_hwmod_write</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">oh</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_offs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _set_master_standbymode: set the OCP_SYSCONFIG MIDLEMODE field in @v</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @standbymode: MIDLEMODE field bits</span>
<span class="cm"> * @v: pointer to register contents to modify</span>
<span class="cm"> *</span>
<span class="cm"> * Update the master standby mode bits in @v to be @standbymode for</span>
<span class="cm"> * the @oh hwmod.  Does not write to the hardware.  Returns -EINVAL</span>
<span class="cm"> * upon error or 0 upon success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_set_master_standbymode</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u8</span> <span class="n">standbymode</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mstandby_mask</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mstandby_shift</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_MIDLEMODE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_fields</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_hwmod: %s: offset struct for sysconfig not provided in class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mstandby_shift</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_fields</span><span class="o">-&gt;</span><span class="n">midle_shift</span><span class="p">;</span>
	<span class="n">mstandby_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="n">mstandby_shift</span><span class="p">);</span>

	<span class="o">*</span><span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mstandby_mask</span><span class="p">;</span>
	<span class="o">*</span><span class="n">v</span> <span class="o">|=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">standbymode</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">mstandby_shift</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _set_slave_idlemode: set the OCP_SYSCONFIG SIDLEMODE field in @v</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @idlemode: SIDLEMODE field bits</span>
<span class="cm"> * @v: pointer to register contents to modify</span>
<span class="cm"> *</span>
<span class="cm"> * Update the slave idle mode bits in @v to be @idlemode for the @oh</span>
<span class="cm"> * hwmod.  Does not write to the hardware.  Returns -EINVAL upon error</span>
<span class="cm"> * or 0 upon success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_set_slave_idlemode</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u8</span> <span class="n">idlemode</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sidle_mask</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sidle_shift</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_SIDLEMODE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_fields</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_hwmod: %s: offset struct for sysconfig not provided in class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sidle_shift</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_fields</span><span class="o">-&gt;</span><span class="n">sidle_shift</span><span class="p">;</span>
	<span class="n">sidle_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="n">sidle_shift</span><span class="p">);</span>

	<span class="o">*</span><span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">sidle_mask</span><span class="p">;</span>
	<span class="o">*</span><span class="n">v</span> <span class="o">|=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">idlemode</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">sidle_shift</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _set_clockactivity: set OCP_SYSCONFIG.CLOCKACTIVITY bits in @v</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @clockact: CLOCKACTIVITY field bits</span>
<span class="cm"> * @v: pointer to register contents to modify</span>
<span class="cm"> *</span>
<span class="cm"> * Update the clockactivity mode bits in @v to be @clockact for the</span>
<span class="cm"> * @oh hwmod.  Used for additional powersaving on some modules.  Does</span>
<span class="cm"> * not write to the hardware.  Returns -EINVAL upon error or 0 upon</span>
<span class="cm"> * success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_set_clockactivity</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u8</span> <span class="n">clockact</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">clkact_mask</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">clkact_shift</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_CLOCKACTIVITY</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_fields</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_hwmod: %s: offset struct for sysconfig not provided in class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">clkact_shift</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_fields</span><span class="o">-&gt;</span><span class="n">clkact_shift</span><span class="p">;</span>
	<span class="n">clkact_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="n">clkact_shift</span><span class="p">);</span>

	<span class="o">*</span><span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">clkact_mask</span><span class="p">;</span>
	<span class="o">*</span><span class="n">v</span> <span class="o">|=</span> <span class="n">clockact</span> <span class="o">&lt;&lt;</span> <span class="n">clkact_shift</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _set_softreset: set OCP_SYSCONFIG.CLOCKACTIVITY bits in @v</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @v: pointer to register contents to modify</span>
<span class="cm"> *</span>
<span class="cm"> * Set the SOFTRESET bit in @v for hwmod @oh.  Returns -EINVAL upon</span>
<span class="cm"> * error or 0 upon success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_set_softreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">softrst_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_SOFTRESET</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_fields</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_hwmod: %s: offset struct for sysconfig not provided in class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">softrst_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_fields</span><span class="o">-&gt;</span><span class="n">srst_shift</span><span class="p">);</span>

	<span class="o">*</span><span class="n">v</span> <span class="o">|=</span> <span class="n">softrst_mask</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _set_module_autoidle: set the OCP_SYSCONFIG AUTOIDLE field in @v</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @autoidle: desired AUTOIDLE bitfield value (0 or 1)</span>
<span class="cm"> * @v: pointer to register contents to modify</span>
<span class="cm"> *</span>
<span class="cm"> * Update the module autoidle bit in @v to be @autoidle for the @oh</span>
<span class="cm"> * hwmod.  The autoidle bit controls whether the module can gate</span>
<span class="cm"> * internal clocks automatically when it isn&#39;t doing anything; the</span>
<span class="cm"> * exact function of this bit varies on a per-module basis.  This</span>
<span class="cm"> * function does not write to the hardware.  Returns -EINVAL upon</span>
<span class="cm"> * error or 0 upon success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_set_module_autoidle</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u8</span> <span class="n">autoidle</span><span class="p">,</span>
				<span class="n">u32</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">autoidle_mask</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">autoidle_shift</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_AUTOIDLE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_fields</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_hwmod: %s: offset struct for sysconfig not provided in class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">autoidle_shift</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_fields</span><span class="o">-&gt;</span><span class="n">autoidle_shift</span><span class="p">;</span>
	<span class="n">autoidle_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">autoidle_shift</span><span class="p">);</span>

	<span class="o">*</span><span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">autoidle_mask</span><span class="p">;</span>
	<span class="o">*</span><span class="n">v</span> <span class="o">|=</span> <span class="n">autoidle</span> <span class="o">&lt;&lt;</span> <span class="n">autoidle_shift</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _set_idle_ioring_wakeup - enable/disable IO pad wakeup on hwmod idle for mux</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @set_wake: bool value indicating to set (true) or clear (false) wakeup enable</span>
<span class="cm"> *</span>
<span class="cm"> * Set or clear the I/O pad wakeup flag in the mux entries for the</span>
<span class="cm"> * hwmod @oh.  This function changes the @oh-&gt;mux-&gt;pads_dynamic array</span>
<span class="cm"> * in memory.  If the hwmod is currently idled, and the new idle</span>
<span class="cm"> * values don&#39;t match the previous ones, this function will also</span>
<span class="cm"> * update the SCM PADCTRL registers.  Otherwise, if the hwmod is not</span>
<span class="cm"> * currently idled, this function won&#39;t touch the hardware: the new</span>
<span class="cm"> * mux settings are written to the SCM PADCTRL registers when the</span>
<span class="cm"> * hwmod is idled.  No return value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_set_idle_ioring_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">bool</span> <span class="n">set_wake</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_device_pad</span> <span class="o">*</span><span class="n">pad</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">change</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">prev_idle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span> <span class="o">||</span> <span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">nr_pads_dynamic</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pad</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">pads_dynamic</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pad</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_DEVICE_PAD_WAKEUP</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">prev_idle</span> <span class="o">=</span> <span class="n">pad</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">set_wake</span><span class="p">)</span>
			<span class="n">pad</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">|=</span> <span class="n">OMAP_WAKEUP_EN</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pad</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">OMAP_WAKEUP_EN</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prev_idle</span> <span class="o">!=</span> <span class="n">pad</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">)</span>
			<span class="n">change</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">change</span> <span class="o">&amp;&amp;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">==</span> <span class="n">_HWMOD_STATE_IDLE</span><span class="p">)</span>
		<span class="n">omap_hwmod_mux</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="p">,</span> <span class="n">_HWMOD_STATE_IDLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _enable_wakeup: set OCP_SYSCONFIG.ENAWAKEUP bit in the hardware</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Allow the hardware module @oh to send wakeups.  Returns -EINVAL</span>
<span class="cm"> * upon error or 0 upon success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_enable_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">((</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_ENAWAKEUP</span><span class="p">)</span> <span class="o">||</span>
	      <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">idlemodes</span> <span class="o">&amp;</span> <span class="n">SIDLE_SMART_WKUP</span><span class="p">)</span> <span class="o">||</span>
	      <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">idlemodes</span> <span class="o">&amp;</span> <span class="n">MSTANDBY_SMART_WKUP</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_fields</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_hwmod: %s: offset struct for sysconfig not provided in class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_ENAWAKEUP</span><span class="p">)</span>
		<span class="o">*</span><span class="n">v</span> <span class="o">|=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_fields</span><span class="o">-&gt;</span><span class="n">enwkup_shift</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">idlemodes</span> <span class="o">&amp;</span> <span class="n">SIDLE_SMART_WKUP</span><span class="p">)</span>
		<span class="n">_set_slave_idlemode</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">HWMOD_IDLEMODE_SMART_WKUP</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">idlemodes</span> <span class="o">&amp;</span> <span class="n">MSTANDBY_SMART_WKUP</span><span class="p">)</span>
		<span class="n">_set_master_standbymode</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">HWMOD_IDLEMODE_SMART_WKUP</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

	<span class="cm">/* XXX test pwrdm_get_wken for this hwmod&#39;s subsystem */</span>

	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_int_flags</span> <span class="o">|=</span> <span class="n">_HWMOD_WAKEUP_ENABLED</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _disable_wakeup: clear OCP_SYSCONFIG.ENAWAKEUP bit in the hardware</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Prevent the hardware module @oh to send wakeups.  Returns -EINVAL</span>
<span class="cm"> * upon error or 0 upon success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_disable_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">((</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_ENAWAKEUP</span><span class="p">)</span> <span class="o">||</span>
	      <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">idlemodes</span> <span class="o">&amp;</span> <span class="n">SIDLE_SMART_WKUP</span><span class="p">)</span> <span class="o">||</span>
	      <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">idlemodes</span> <span class="o">&amp;</span> <span class="n">MSTANDBY_SMART_WKUP</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_fields</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_hwmod: %s: offset struct for sysconfig not provided in class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_ENAWAKEUP</span><span class="p">)</span>
		<span class="o">*</span><span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_fields</span><span class="o">-&gt;</span><span class="n">enwkup_shift</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">idlemodes</span> <span class="o">&amp;</span> <span class="n">SIDLE_SMART_WKUP</span><span class="p">)</span>
		<span class="n">_set_slave_idlemode</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">HWMOD_IDLEMODE_SMART</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">idlemodes</span> <span class="o">&amp;</span> <span class="n">MSTANDBY_SMART_WKUP</span><span class="p">)</span>
		<span class="n">_set_master_standbymode</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">HWMOD_IDLEMODE_SMART</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

	<span class="cm">/* XXX test pwrdm_get_wken for this hwmod&#39;s subsystem */</span>

	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_int_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_HWMOD_WAKEUP_ENABLED</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _add_initiator_dep: prevent @oh from smart-idling while @init_oh is active</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Prevent the hardware module @oh from entering idle while the</span>
<span class="cm"> * hardare module initiator @init_oh is active.  Useful when a module</span>
<span class="cm"> * will be accessed by a particular initiator (e.g., if a module will</span>
<span class="cm"> * be accessed by the IVA, there should be a sleepdep between the IVA</span>
<span class="cm"> * initiator and the module).  Only applies to modules in smart-idle</span>
<span class="cm"> * mode.  If the clockdomain is marked as not needing autodeps, return</span>
<span class="cm"> * 0 without doing anything.  Otherwise, returns -EINVAL upon error or</span>
<span class="cm"> * passes along clkdm_add_sleepdep() value upon success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_add_initiator_dep</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">init_oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="o">-&gt;</span><span class="n">clkdm</span> <span class="o">&amp;&amp;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLKDM_NO_AUTODEPS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">clkdm_add_sleepdep</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">,</span> <span class="n">init_oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _del_initiator_dep: allow @oh to smart-idle even if @init_oh is active</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Allow the hardware module @oh to enter idle while the hardare</span>
<span class="cm"> * module initiator @init_oh is active.  Useful when a module will not</span>
<span class="cm"> * be accessed by a particular initiator (e.g., if a module will not</span>
<span class="cm"> * be accessed by the IVA, there should be no sleepdep between the IVA</span>
<span class="cm"> * initiator and the module).  Only applies to modules in smart-idle</span>
<span class="cm"> * mode.  If the clockdomain is marked as not needing autodeps, return</span>
<span class="cm"> * 0 without doing anything.  Returns -EINVAL upon error or passes</span>
<span class="cm"> * along clkdm_del_sleepdep() value upon success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_del_initiator_dep</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">init_oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="o">-&gt;</span><span class="n">clkdm</span> <span class="o">&amp;&amp;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLKDM_NO_AUTODEPS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">clkdm_del_sleepdep</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">,</span> <span class="n">init_oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _init_main_clk - get a struct clk * for the the hwmod&#39;s main functional clk</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Called from _init_clocks().  Populates the @oh _clk (main</span>
<span class="cm"> * functional clock pointer) if a main_clk is present.  Returns 0 on</span>
<span class="cm"> * success or -EINVAL on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_init_main_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">main_clk</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span> <span class="o">=</span> <span class="n">omap_clk_get_by_name</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">main_clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: cannot clk_get main_clk %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">main_clk</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: missing clockdomain for %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">oh</span><span class="o">-&gt;</span><span class="n">main_clk</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _init_interface_clks - get a struct clk * for the the hwmod&#39;s interface clks</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Called from _init_clocks().  Populates the @oh OCP slave interface</span>
<span class="cm"> * clock pointers.  Returns 0 on success or -EINVAL on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_init_interface_clks</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="n">os</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slave_ports</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slaves_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">os</span> <span class="o">=</span> <span class="n">_fetch_next_ocp_if</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">c</span> <span class="o">=</span> <span class="n">omap_clk_get_by_name</span><span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: cannot clk_get interface_clk %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">os</span><span class="o">-&gt;</span><span class="n">_clk</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _init_opt_clk - get a struct clk * for the the hwmod&#39;s optional clocks</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Called from _init_clocks().  Populates the @oh omap_hwmod_opt_clk</span>
<span class="cm"> * clock pointers.  Returns 0 on success or -EINVAL on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_init_opt_clks</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_opt_clk</span> <span class="o">*</span><span class="n">oc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">opt_clks_cnt</span><span class="p">,</span> <span class="n">oc</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">opt_clks</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">,</span> <span class="n">oc</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">omap_clk_get_by_name</span><span class="p">(</span><span class="n">oc</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: cannot clk_get opt_clk %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">oc</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">oc</span><span class="o">-&gt;</span><span class="n">_clk</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _enable_clocks - enable hwmod main clock and interface clocks</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Enables all clocks necessary for register reads and writes to succeed</span>
<span class="cm"> * on the hwmod @oh.  Returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_enable_clocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="n">os</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: enabling clocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">)</span>
		<span class="n">clk_enable</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slave_ports</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slaves_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">os</span> <span class="o">=</span> <span class="n">_fetch_next_ocp_if</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">_clk</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OCPIF_SWSUP_IDLE</span><span class="p">))</span>
			<span class="n">clk_enable</span><span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* The opt clocks are controlled by the device driver. */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _disable_clocks - disable hwmod main clock and interface clocks</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Disables the hwmod @oh main functional and interface clocks.  Returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_disable_clocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="n">os</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: disabling clocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">)</span>
		<span class="n">clk_disable</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slave_ports</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slaves_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">os</span> <span class="o">=</span> <span class="n">_fetch_next_ocp_if</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">_clk</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OCPIF_SWSUP_IDLE</span><span class="p">))</span>
			<span class="n">clk_disable</span><span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* The opt clocks are controlled by the device driver. */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_enable_optional_clocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_opt_clk</span> <span class="o">*</span><span class="n">oc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: enabling optional clocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">opt_clks_cnt</span><span class="p">,</span> <span class="n">oc</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">opt_clks</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">,</span> <span class="n">oc</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oc</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: enable %s:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oc</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">,</span>
				 <span class="n">oc</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">clk_enable</span><span class="p">(</span><span class="n">oc</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">);</span>
		<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_disable_optional_clocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_opt_clk</span> <span class="o">*</span><span class="n">oc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: disabling optional clocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">opt_clks_cnt</span><span class="p">,</span> <span class="n">oc</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">opt_clks</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">,</span> <span class="n">oc</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oc</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: disable %s:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oc</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">,</span>
				 <span class="n">oc</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">clk_disable</span><span class="p">(</span><span class="n">oc</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">);</span>
		<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _enable_module - enable CLKCTRL modulemode on OMAP4</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Enables the PRCM module mode related to the hwmod @oh.</span>
<span class="cm"> * No return value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_enable_module</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The module mode does not exist prior OMAP4 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_omap24xx</span><span class="p">()</span> <span class="o">||</span> <span class="n">cpu_is_omap34xx</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span> <span class="o">||</span> <span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap4</span><span class="p">.</span><span class="n">modulemode</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: _enable_module: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap4</span><span class="p">.</span><span class="n">modulemode</span><span class="p">);</span>

	<span class="n">omap4_cminst_module_enable</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap4</span><span class="p">.</span><span class="n">modulemode</span><span class="p">,</span>
				   <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">prcm_partition</span><span class="p">,</span>
				   <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">cm_inst</span><span class="p">,</span>
				   <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">clkdm_offs</span><span class="p">,</span>
				   <span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap4</span><span class="p">.</span><span class="n">clkctrl_offs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _omap4_wait_target_disable - wait for a module to be disabled on OMAP4</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Wait for a module @oh to enter slave idle.  Returns 0 if the module</span>
<span class="cm"> * does not have an IDLEST bit or if the module successfully enters</span>
<span class="cm"> * slave idle; otherwise, pass along the return value of the</span>
<span class="cm"> * appropriate *_cm*_wait_module_idle() function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_omap4_wait_target_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_is_omap44xx</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_int_flags</span> <span class="o">&amp;</span> <span class="n">_HWMOD_NO_MPU_PORT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_NO_IDLEST</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">omap4_cminst_wait_module_idle</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">prcm_partition</span><span class="p">,</span>
					     <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">cm_inst</span><span class="p">,</span>
					     <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">clkdm_offs</span><span class="p">,</span>
					     <span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap4</span><span class="p">.</span><span class="n">clkctrl_offs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _count_mpu_irqs - count the number of MPU IRQ lines associated with @oh</span>
<span class="cm"> * @oh: struct omap_hwmod *oh</span>
<span class="cm"> *</span>
<span class="cm"> * Count and return the number of MPU IRQs associated with the hwmod</span>
<span class="cm"> * @oh.  Used to allocate struct resource data.  Returns 0 if @oh is</span>
<span class="cm"> * NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_count_mpu_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_irq_info</span> <span class="o">*</span><span class="n">ohii</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span> <span class="o">||</span> <span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mpu_irqs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ohii</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mpu_irqs</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ohii</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _count_sdma_reqs - count the number of SDMA request lines associated with @oh</span>
<span class="cm"> * @oh: struct omap_hwmod *oh</span>
<span class="cm"> *</span>
<span class="cm"> * Count and return the number of SDMA request lines associated with</span>
<span class="cm"> * the hwmod @oh.  Used to allocate struct resource data.  Returns 0</span>
<span class="cm"> * if @oh is NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_count_sdma_reqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_dma_info</span> <span class="o">*</span><span class="n">ohdi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span> <span class="o">||</span> <span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">sdma_reqs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ohdi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">sdma_reqs</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ohdi</span><span class="o">-&gt;</span><span class="n">dma_req</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _count_ocp_if_addr_spaces - count the number of address space entries for @oh</span>
<span class="cm"> * @oh: struct omap_hwmod *oh</span>
<span class="cm"> *</span>
<span class="cm"> * Count and return the number of address space ranges associated with</span>
<span class="cm"> * the hwmod @oh.  Used to allocate struct resource data.  Returns 0</span>
<span class="cm"> * if @oh is NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_count_ocp_if_addr_spaces</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="n">os</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_addr_space</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">os</span> <span class="o">||</span> <span class="o">!</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">mem</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">pa_start</span> <span class="o">!=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">pa_end</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _get_mpu_irq_by_name - fetch MPU interrupt line number by name</span>
<span class="cm"> * @oh: struct omap_hwmod * to operate on</span>
<span class="cm"> * @name: pointer to the name of the MPU interrupt number to fetch (optional)</span>
<span class="cm"> * @irq: pointer to an unsigned int to store the MPU IRQ number to</span>
<span class="cm"> *</span>
<span class="cm"> * Retrieve a MPU hardware IRQ line number named by @name associated</span>
<span class="cm"> * with the IP block pointed to by @oh.  The IRQ number will be filled</span>
<span class="cm"> * into the address pointed to by @dma.  When @name is non-null, the</span>
<span class="cm"> * IRQ line number associated with the named entry will be returned.</span>
<span class="cm"> * If @name is null, the first matching entry will be returned.  Data</span>
<span class="cm"> * order is not meaningful in hwmod data, so callers are strongly</span>
<span class="cm"> * encouraged to use a non-null @name whenever possible to avoid</span>
<span class="cm"> * unpredictable effects if hwmod data is later added that causes data</span>
<span class="cm"> * ordering to change.  Returns 0 upon success or a negative error</span>
<span class="cm"> * code upon error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_get_mpu_irq_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mpu_irqs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mpu_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">irq</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">mpu_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">mpu_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="o">*</span><span class="n">irq</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">mpu_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">irq</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _get_sdma_req_by_name - fetch SDMA request line ID by name</span>
<span class="cm"> * @oh: struct omap_hwmod * to operate on</span>
<span class="cm"> * @name: pointer to the name of the SDMA request line to fetch (optional)</span>
<span class="cm"> * @dma: pointer to an unsigned int to store the request line ID to</span>
<span class="cm"> *</span>
<span class="cm"> * Retrieve an SDMA request line ID named by @name on the IP block</span>
<span class="cm"> * pointed to by @oh.  The ID will be filled into the address pointed</span>
<span class="cm"> * to by @dma.  When @name is non-null, the request line ID associated</span>
<span class="cm"> * with the named entry will be returned.  If @name is null, the first</span>
<span class="cm"> * matching entry will be returned.  Data order is not meaningful in</span>
<span class="cm"> * hwmod data, so callers are strongly encouraged to use a non-null</span>
<span class="cm"> * @name whenever possible to avoid unpredictable effects if hwmod</span>
<span class="cm"> * data is later added that causes data ordering to change.  Returns 0</span>
<span class="cm"> * upon success or a negative error code upon error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_get_sdma_req_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">sdma_reqs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">sdma_reqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma_req</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">sdma_reqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">sdma_reqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="o">*</span><span class="n">dma</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">sdma_reqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma_req</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _get_addr_space_by_name - fetch address space start &amp; end by name</span>
<span class="cm"> * @oh: struct omap_hwmod * to operate on</span>
<span class="cm"> * @name: pointer to the name of the address space to fetch (optional)</span>
<span class="cm"> * @pa_start: pointer to a u32 to store the starting address to</span>
<span class="cm"> * @pa_end: pointer to a u32 to store the ending address to</span>
<span class="cm"> *</span>
<span class="cm"> * Retrieve address space start and end addresses for the IP block</span>
<span class="cm"> * pointed to by @oh.  The data will be filled into the addresses</span>
<span class="cm"> * pointed to by @pa_start and @pa_end.  When @name is non-null, the</span>
<span class="cm"> * address space data associated with the named entry will be</span>
<span class="cm"> * returned.  If @name is null, the first matching entry will be</span>
<span class="cm"> * returned.  Data order is not meaningful in hwmod data, so callers</span>
<span class="cm"> * are strongly encouraged to use a non-null @name whenever possible</span>
<span class="cm"> * to avoid unpredictable effects if hwmod data is later added that</span>
<span class="cm"> * causes data ordering to change.  Returns 0 upon success or a</span>
<span class="cm"> * negative error code upon error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_get_addr_space_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="o">*</span><span class="n">pa_start</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pa_end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="n">os</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slave_ports</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slaves_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">os</span> <span class="o">=</span> <span class="n">_fetch_next_ocp_if</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

		<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">pa_start</span> <span class="o">!=</span> <span class="n">os</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">pa_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">os</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">name</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">j</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="o">*</span><span class="n">pa_start</span> <span class="o">=</span> <span class="n">os</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">pa_start</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pa_end</span> <span class="o">=</span> <span class="n">os</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">pa_end</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _save_mpu_port_index - find and save the index to @oh&#39;s MPU port</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Determines the array index of the OCP slave port that the MPU uses</span>
<span class="cm"> * to address the device, and saves it into the struct omap_hwmod.</span>
<span class="cm"> * Intended to be called during hwmod registration only. No return</span>
<span class="cm"> * value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">_save_mpu_port_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="n">os</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_int_flags</span> <span class="o">|=</span> <span class="n">_HWMOD_NO_MPU_PORT</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slave_ports</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slaves_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">os</span> <span class="o">=</span> <span class="n">_fetch_next_ocp_if</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">&amp;</span> <span class="n">OCP_USER_MPU</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_mpu_port</span> <span class="o">=</span> <span class="n">os</span><span class="p">;</span>
			<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_int_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_HWMOD_NO_MPU_PORT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _find_mpu_rt_port - return omap_hwmod_ocp_if accessible by the MPU</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Given a pointer to a struct omap_hwmod record @oh, return a pointer</span>
<span class="cm"> * to the struct omap_hwmod_ocp_if record that is used by the MPU to</span>
<span class="cm"> * communicate with the IP block.  This interface need not be directly</span>
<span class="cm"> * connected to the MPU (and almost certainly is not), but is directly</span>
<span class="cm"> * connected to the IP block represented by @oh.  Returns a pointer</span>
<span class="cm"> * to the struct omap_hwmod_ocp_if * upon success, or returns NULL upon</span>
<span class="cm"> * error or if there does not appear to be a path from the MPU to this</span>
<span class="cm"> * IP block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="nf">_find_mpu_rt_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span> <span class="o">||</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_int_flags</span> <span class="o">&amp;</span> <span class="n">_HWMOD_NO_MPU_PORT</span> <span class="o">||</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slaves_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_mpu_port</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * _find_mpu_rt_addr_space - return MPU register target address space for @oh</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the struct omap_hwmod_addr_space record representing</span>
<span class="cm"> * the register target MPU address space; or returns NULL upon error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">omap_hwmod_addr_space</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">_find_mpu_rt_addr_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="n">os</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_addr_space</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">os</span> <span class="o">=</span> <span class="n">_find_mpu_rt_port</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">os</span> <span class="o">||</span> <span class="o">!</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">mem</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ADDR_TYPE_RT</span><span class="p">)</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span> <span class="o">&amp;&amp;</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">pa_start</span> <span class="o">!=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">pa_end</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="o">?</span> <span class="n">mem</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _enable_sysc - try to bring a module out of idle via OCP_SYSCONFIG</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * If module is marked as SWSUP_SIDLE, force the module out of slave</span>
<span class="cm"> * idle; otherwise, configure it for smart-idle.  If module is marked</span>
<span class="cm"> * as SWSUP_MSUSPEND, force the module out of master standby;</span>
<span class="cm"> * otherwise, configure it for smart-standby.  No return value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_enable_sysc</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">idlemode</span><span class="p">,</span> <span class="n">sf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_sysc_cache</span><span class="p">;</span>
	<span class="n">sf</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sf</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_SIDLEMODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idlemode</span> <span class="o">=</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_SWSUP_SIDLE</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">HWMOD_IDLEMODE_NO</span> <span class="o">:</span> <span class="n">HWMOD_IDLEMODE_SMART</span><span class="p">;</span>
		<span class="n">_set_slave_idlemode</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">idlemode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sf</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_MIDLEMODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_SWSUP_MSTANDBY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">idlemode</span> <span class="o">=</span> <span class="n">HWMOD_IDLEMODE_NO</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sf</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_ENAWAKEUP</span><span class="p">)</span>
				<span class="n">_enable_wakeup</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">idlemodes</span> <span class="o">&amp;</span> <span class="n">MSTANDBY_SMART_WKUP</span><span class="p">)</span>
				<span class="n">idlemode</span> <span class="o">=</span> <span class="n">HWMOD_IDLEMODE_SMART_WKUP</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">idlemode</span> <span class="o">=</span> <span class="n">HWMOD_IDLEMODE_SMART</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">_set_master_standbymode</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">idlemode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX The clock framework should handle this, by</span>
<span class="cm">	 * calling into this code.  But this must wait until the</span>
<span class="cm">	 * clock structures are tagged with omap_hwmod entries</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_SET_DEFAULT_CLOCKACT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">sf</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_CLOCKACTIVITY</span><span class="p">))</span>
		<span class="n">_set_clockactivity</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">clockact</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>

	<span class="cm">/* If slave is in SMARTIDLE, also enable wakeup */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sf</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_SIDLEMODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_SWSUP_SIDLE</span><span class="p">))</span>
		<span class="n">_enable_wakeup</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>

	<span class="n">_write_sysconfig</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">oh</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the autoidle bit only after setting the smartidle bit</span>
<span class="cm">	 * Setting this will not have any impact on the other modules.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sf</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_AUTOIDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idlemode</span> <span class="o">=</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_NO_OCP_AUTOIDLE</span><span class="p">)</span> <span class="o">?</span>
			<span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">_set_module_autoidle</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">idlemode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
		<span class="n">_write_sysconfig</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">oh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _idle_sysc - try to put a module into idle via OCP_SYSCONFIG</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * If module is marked as SWSUP_SIDLE, force the module into slave</span>
<span class="cm"> * idle; otherwise, configure it for smart-idle.  If module is marked</span>
<span class="cm"> * as SWSUP_MSUSPEND, force the module into master standby; otherwise,</span>
<span class="cm"> * configure it for smart-standby.  No return value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_idle_sysc</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">idlemode</span><span class="p">,</span> <span class="n">sf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_sysc_cache</span><span class="p">;</span>
	<span class="n">sf</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sf</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_SIDLEMODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idlemode</span> <span class="o">=</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_SWSUP_SIDLE</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">HWMOD_IDLEMODE_FORCE</span> <span class="o">:</span> <span class="n">HWMOD_IDLEMODE_SMART</span><span class="p">;</span>
		<span class="n">_set_slave_idlemode</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">idlemode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sf</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_MIDLEMODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_SWSUP_MSTANDBY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">idlemode</span> <span class="o">=</span> <span class="n">HWMOD_IDLEMODE_FORCE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sf</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_ENAWAKEUP</span><span class="p">)</span>
				<span class="n">_enable_wakeup</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">idlemodes</span> <span class="o">&amp;</span> <span class="n">MSTANDBY_SMART_WKUP</span><span class="p">)</span>
				<span class="n">idlemode</span> <span class="o">=</span> <span class="n">HWMOD_IDLEMODE_SMART_WKUP</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">idlemode</span> <span class="o">=</span> <span class="n">HWMOD_IDLEMODE_SMART</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">_set_master_standbymode</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">idlemode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If slave is in SMARTIDLE, also enable wakeup */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sf</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_SIDLEMODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_SWSUP_SIDLE</span><span class="p">))</span>
		<span class="n">_enable_wakeup</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>

	<span class="n">_write_sysconfig</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">oh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _shutdown_sysc - force a module into idle via OCP_SYSCONFIG</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Force the module into slave idle and master suspend. No return</span>
<span class="cm"> * value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_shutdown_sysc</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_sysc_cache</span><span class="p">;</span>
	<span class="n">sf</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sf</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_SIDLEMODE</span><span class="p">)</span>
		<span class="n">_set_slave_idlemode</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">HWMOD_IDLEMODE_FORCE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sf</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_MIDLEMODE</span><span class="p">)</span>
		<span class="n">_set_master_standbymode</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">HWMOD_IDLEMODE_FORCE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sf</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_AUTOIDLE</span><span class="p">)</span>
		<span class="n">_set_module_autoidle</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>

	<span class="n">_write_sysconfig</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">oh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _lookup - find an omap_hwmod by name</span>
<span class="cm"> * @name: find an omap_hwmod by name</span>
<span class="cm"> *</span>
<span class="cm"> * Return a pointer to an omap_hwmod by name, or NULL if not found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="nf">_lookup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="o">*</span><span class="n">temp_oh</span><span class="p">;</span>

	<span class="n">oh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">temp_oh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">omap_hwmod_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">temp_oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">oh</span> <span class="o">=</span> <span class="n">temp_oh</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">oh</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * _init_clkdm - look up a clockdomain name, store pointer in omap_hwmod</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Convert a clockdomain name stored in a struct omap_hwmod into a</span>
<span class="cm"> * clockdomain pointer, and save it into the struct omap_hwmod.</span>
<span class="cm"> * return -EINVAL if clkdm_name does not exist or if the lookup failed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_init_clkdm</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_omap24xx</span><span class="p">()</span> <span class="o">||</span> <span class="n">cpu_is_omap34xx</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: no clkdm_name</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span> <span class="o">=</span> <span class="n">clkdm_lookup</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: could not associate to clkdm %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: associated to clkdm %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm_name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _init_clocks - clk_get() all clocks associated with this hwmod. Retrieve as</span>
<span class="cm"> * well the clockdomain.</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @data: not used; pass NULL</span>
<span class="cm"> *</span>
<span class="cm"> * Called by omap_hwmod_setup_*() (after omap2_clk_init()).</span>
<span class="cm"> * Resolves all clock names embedded in the hwmod.  Returns 0 on</span>
<span class="cm"> * success, or a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_init_clocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_REGISTERED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: looking up clocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">|=</span> <span class="n">_init_main_clk</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">|=</span> <span class="n">_init_interface_clks</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">|=</span> <span class="n">_init_opt_clks</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">|=</span> <span class="n">_init_clkdm</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">=</span> <span class="n">_HWMOD_STATE_CLKS_INITED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: cannot _init_clocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _wait_target_ready - wait for a module to leave slave idle</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Wait for a module @oh to leave slave idle.  Returns 0 if the module</span>
<span class="cm"> * does not have an IDLEST bit or if the module successfully leaves</span>
<span class="cm"> * slave idle; otherwise, pass along the return value of the</span>
<span class="cm"> * appropriate *_cm*_wait_module_ready() function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_wait_target_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="n">os</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_NO_IDLEST</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">os</span> <span class="o">=</span> <span class="n">_find_mpu_rt_port</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">os</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* XXX check module SIDLEMODE */</span>

	<span class="cm">/* XXX check clock enable states */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_omap24xx</span><span class="p">()</span> <span class="o">||</span> <span class="n">cpu_is_omap34xx</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">omap2_cm_wait_module_ready</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap2</span><span class="p">.</span><span class="n">module_offs</span><span class="p">,</span>
						 <span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap2</span><span class="p">.</span><span class="n">idlest_reg_id</span><span class="p">,</span>
						 <span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap2</span><span class="p">.</span><span class="n">idlest_idle_bit</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_omap44xx</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">omap4_cminst_wait_module_ready</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">prcm_partition</span><span class="p">,</span>
						     <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">cm_inst</span><span class="p">,</span>
						     <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">clkdm_offs</span><span class="p">,</span>
						     <span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap4</span><span class="p">.</span><span class="n">clkctrl_offs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _lookup_hardreset - fill register bit info for this hwmod/reset line</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @name: name of the reset line in the context of this hwmod</span>
<span class="cm"> * @ohri: struct omap_hwmod_rst_info * that this function will fill in</span>
<span class="cm"> *</span>
<span class="cm"> * Return the bit position of the reset line that match the</span>
<span class="cm"> * input name. Return -ENOENT if not found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">_lookup_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">omap_hwmod_rst_info</span> <span class="o">*</span><span class="n">ohri</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">rst_lines_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rst_line</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">rst_lines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">rst_line</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ohri</span><span class="o">-&gt;</span><span class="n">rst_shift</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">rst_lines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rst_shift</span><span class="p">;</span>
			<span class="n">ohri</span><span class="o">-&gt;</span><span class="n">st_shift</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">rst_lines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_shift</span><span class="p">;</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: %s: %s: rst %d st %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rst_line</span><span class="p">,</span> <span class="n">ohri</span><span class="o">-&gt;</span><span class="n">rst_shift</span><span class="p">,</span>
				 <span class="n">ohri</span><span class="o">-&gt;</span><span class="n">st_shift</span><span class="p">);</span>

			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _assert_hardreset - assert the HW reset line of submodules</span>
<span class="cm"> * contained in the hwmod module.</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @name: name of the reset line to lookup and assert</span>
<span class="cm"> *</span>
<span class="cm"> * Some IP like dsp, ipu or iva contain processor that require</span>
<span class="cm"> * an HW reset line to be assert / deassert in order to enable fully</span>
<span class="cm"> * the IP.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_assert_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_rst_info</span> <span class="n">ohri</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">_lookup_hardreset</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohri</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_omap24xx</span><span class="p">()</span> <span class="o">||</span> <span class="n">cpu_is_omap34xx</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">omap2_prm_assert_hardreset</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap2</span><span class="p">.</span><span class="n">module_offs</span><span class="p">,</span>
						  <span class="n">ohri</span><span class="p">.</span><span class="n">rst_shift</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_omap44xx</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">omap4_prminst_assert_hardreset</span><span class="p">(</span><span class="n">ohri</span><span class="p">.</span><span class="n">rst_shift</span><span class="p">,</span>
				  <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">.</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">prcm_partition</span><span class="p">,</span>
				  <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">.</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">prcm_offs</span><span class="p">,</span>
				  <span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap4</span><span class="p">.</span><span class="n">rstctrl_offs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _deassert_hardreset - deassert the HW reset line of submodules contained</span>
<span class="cm"> * in the hwmod module.</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @name: name of the reset line to look up and deassert</span>
<span class="cm"> *</span>
<span class="cm"> * Some IP like dsp, ipu or iva contain processor that require</span>
<span class="cm"> * an HW reset line to be assert / deassert in order to enable fully</span>
<span class="cm"> * the IP.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_deassert_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_rst_info</span> <span class="n">ohri</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">_lookup_hardreset</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohri</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_omap24xx</span><span class="p">()</span> <span class="o">||</span> <span class="n">cpu_is_omap34xx</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">omap2_prm_deassert_hardreset</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap2</span><span class="p">.</span><span class="n">module_offs</span><span class="p">,</span>
						   <span class="n">ohri</span><span class="p">.</span><span class="n">rst_shift</span><span class="p">,</span>
						   <span class="n">ohri</span><span class="p">.</span><span class="n">st_shift</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_omap44xx</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ohri</span><span class="p">.</span><span class="n">st_shift</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: %s: hwmod data error: OMAP4 does not support st_shift</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">omap4_prminst_deassert_hardreset</span><span class="p">(</span><span class="n">ohri</span><span class="p">.</span><span class="n">rst_shift</span><span class="p">,</span>
				  <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">.</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">prcm_partition</span><span class="p">,</span>
				  <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">.</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">prcm_offs</span><span class="p">,</span>
				  <span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap4</span><span class="p">.</span><span class="n">rstctrl_offs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: failed to hardreset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _read_hardreset - read the HW reset line state of submodules</span>
<span class="cm"> * contained in the hwmod module</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @name: name of the reset line to look up and read</span>
<span class="cm"> *</span>
<span class="cm"> * Return the state of the reset line.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_read_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_rst_info</span> <span class="n">ohri</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">_lookup_hardreset</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ohri</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_omap24xx</span><span class="p">()</span> <span class="o">||</span> <span class="n">cpu_is_omap34xx</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">omap2_prm_is_hardreset_asserted</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap2</span><span class="p">.</span><span class="n">module_offs</span><span class="p">,</span>
						       <span class="n">ohri</span><span class="p">.</span><span class="n">st_shift</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_omap44xx</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">omap4_prminst_is_hardreset_asserted</span><span class="p">(</span><span class="n">ohri</span><span class="p">.</span><span class="n">rst_shift</span><span class="p">,</span>
				  <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">.</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">prcm_partition</span><span class="p">,</span>
				  <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">.</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">prcm_offs</span><span class="p">,</span>
				  <span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap4</span><span class="p">.</span><span class="n">rstctrl_offs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _are_any_hardreset_lines_asserted - return true if part of @oh is hard-reset</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * If any hardreset line associated with @oh is asserted, then return true.</span>
<span class="cm"> * Otherwise, if @oh has no hardreset lines associated with it, or if</span>
<span class="cm"> * no hardreset lines associated with @oh are asserted, then return false.</span>
<span class="cm"> * This function is used to avoid executing some parts of the IP block</span>
<span class="cm"> * enable/disable sequence if a hardreset line is set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">_are_any_hardreset_lines_asserted</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">rst_lines_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">rst_lines_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">_read_hardreset</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">rst_lines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _omap4_disable_module - enable CLKCTRL modulemode on OMAP4</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Disable the PRCM module mode related to the hwmod @oh.</span>
<span class="cm"> * Return EINVAL if the modulemode is not supported and 0 in case of success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_omap4_disable_module</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">v</span><span class="p">;</span>

	<span class="cm">/* The module mode does not exist prior OMAP4 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_is_omap44xx</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span> <span class="o">||</span> <span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap4</span><span class="p">.</span><span class="n">modulemode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">omap4_cminst_module_disable</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">prcm_partition</span><span class="p">,</span>
				    <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">cm_inst</span><span class="p">,</span>
				    <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">clkdm_offs</span><span class="p">,</span>
				    <span class="n">oh</span><span class="o">-&gt;</span><span class="n">prcm</span><span class="p">.</span><span class="n">omap4</span><span class="p">.</span><span class="n">clkctrl_offs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_are_any_hardreset_lines_asserted</span><span class="p">(</span><span class="n">oh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">_omap4_wait_target_disable</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: _wait_target_disable failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _ocp_softreset - reset an omap_hwmod via the OCP_SYSCONFIG bit</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Resets an omap_hwmod @oh via the OCP_SYSCONFIG bit.  hwmod must be</span>
<span class="cm"> * enabled for this to work.  Returns -ENOENT if the hwmod cannot be</span>
<span class="cm"> * reset this way, -EINVAL if the hwmod is in the wrong state,</span>
<span class="cm"> * -ETIMEDOUT if the module did not reset in time, or 0 upon success.</span>
<span class="cm"> *</span>
<span class="cm"> * In OMAP3 a specific SYSSTATUS register is used to get the reset status.</span>
<span class="cm"> * Starting in OMAP4, some IPs do not have SYSSTATUS registers and instead</span>
<span class="cm"> * use the SYSCONFIG softreset bit to provide the status.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that some IP like McBSP do have reset control but don&#39;t have</span>
<span class="cm"> * reset status.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_ocp_softreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">,</span> <span class="n">softrst_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_SOFTRESET</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="cm">/* clocks must be on for this operation */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: reset can only be entered from &quot;</span>
			   <span class="s">&quot;enabled state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* For some modules, all optionnal clocks need to be enabled as well */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_CONTROL_OPT_CLKS_IN_RESET</span><span class="p">)</span>
		<span class="n">_enable_optional_clocks</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: resetting via OCP SOFTRESET</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_sysc_cache</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">_set_softreset</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">dis_opt_clks</span><span class="p">;</span>
	<span class="n">_write_sysconfig</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">oh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">srst_udelay</span><span class="p">)</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">srst_udelay</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span> <span class="o">&amp;</span> <span class="n">SYSS_HAS_RESET_STATUS</span><span class="p">)</span>
		<span class="n">omap_test_timeout</span><span class="p">((</span><span class="n">omap_hwmod_read</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span>
						    <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">syss_offs</span><span class="p">)</span>
				   <span class="o">&amp;</span> <span class="n">SYSS_RESETDONE_MASK</span><span class="p">),</span>
				  <span class="n">MAX_MODULE_SOFTRESET_WAIT</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_RESET_STATUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">softrst_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_fields</span><span class="o">-&gt;</span><span class="n">srst_shift</span><span class="p">);</span>
		<span class="n">omap_test_timeout</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">omap_hwmod_read</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span>
						     <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_offs</span><span class="p">)</span>
				   <span class="o">&amp;</span> <span class="n">softrst_mask</span><span class="p">),</span>
				  <span class="n">MAX_MODULE_SOFTRESET_WAIT</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">MAX_MODULE_SOFTRESET_WAIT</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: softreset failed (waited %d usec)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">MAX_MODULE_SOFTRESET_WAIT</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: softreset in %d usec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX add _HWMOD_STATE_WEDGED for modules that don&#39;t come back from</span>
<span class="cm">	 * _wait_target_ready() or _reset()</span>
<span class="cm">	 */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">MAX_MODULE_SOFTRESET_WAIT</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">ETIMEDOUT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">dis_opt_clks:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_CONTROL_OPT_CLKS_IN_RESET</span><span class="p">)</span>
		<span class="n">_disable_optional_clocks</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _reset - reset an omap_hwmod</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Resets an omap_hwmod @oh.  If the module has a custom reset</span>
<span class="cm"> * function pointer defined, then call it to reset the IP block, and</span>
<span class="cm"> * pass along its return value to the caller.  Otherwise, if the IP</span>
<span class="cm"> * block has an OCP_SYSCONFIG register with a SOFTRESET bitfield</span>
<span class="cm"> * associated with it, call a function to reset the IP block via that</span>
<span class="cm"> * method, and pass along the return value to the caller.  Finally, if</span>
<span class="cm"> * the IP block has some hardreset lines associated with it, assert</span>
<span class="cm"> * all of those, but do _not_ deassert them. (This is because driver</span>
<span class="cm"> * authors have expressed an apparent requirement to control the</span>
<span class="cm"> * deassertion of the hardreset lines themselves.)</span>
<span class="cm"> *</span>
<span class="cm"> * The default software reset mechanism for most OMAP IP blocks is</span>
<span class="cm"> * triggered via the OCP_SYSCONFIG.SOFTRESET bit.  However, some</span>
<span class="cm"> * hwmods cannot be reset via this method.  Some are not targets and</span>
<span class="cm"> * therefore have no OCP header registers to access.  Others (like the</span>
<span class="cm"> * IVA) have idiosyncratic reset sequences.  So for these relatively</span>
<span class="cm"> * rare cases, custom reset code can be supplied in the struct</span>
<span class="cm"> * omap_hwmod_class .reset function pointer.  Passes along the return</span>
<span class="cm"> * value from either _ocp_softreset() or the custom reset function -</span>
<span class="cm"> * these must return -EINVAL if the hwmod cannot be reset this way or</span>
<span class="cm"> * if the hwmod is in the wrong state, -ETIMEDOUT if the module did</span>
<span class="cm"> * not reset in time, or 0 upon success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">rst_lines_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">rst_lines_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">_assert_hardreset</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">rst_lines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">_ocp_softreset</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
				<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * OCP_SYSCONFIG bits need to be reprogrammed after a</span>
<span class="cm">	 * softreset.  The _enable() function should be split to avoid</span>
<span class="cm">	 * the rewrite of the OCP_SYSCONFIG register.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_update_sysc_cache</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
		<span class="n">_enable_sysc</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _enable - enable an omap_hwmod</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Enables an omap_hwmod @oh such that the MPU can access the hwmod&#39;s</span>
<span class="cm"> * register target.  Returns -EINVAL if the hwmod is in the wrong</span>
<span class="cm"> * state or passes along the return value of _wait_target_ready().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hwsup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: enabling</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * hwmods with HWMOD_INIT_NO_IDLE flag set are left in enabled</span>
<span class="cm">	 * state at init.  Now that someone is really trying to enable</span>
<span class="cm">	 * them, just ensure that the hwmod mux is set.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_int_flags</span> <span class="o">&amp;</span> <span class="n">_HWMOD_SKIP_ENABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the caller has mux data populated, do the mux&#39;ing</span>
<span class="cm">		 * which wouldn&#39;t have been done as part of the _enable()</span>
<span class="cm">		 * done during setup.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="p">)</span>
			<span class="n">omap_hwmod_mux</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="p">,</span> <span class="n">_HWMOD_STATE_ENABLED</span><span class="p">);</span>

		<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_int_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_HWMOD_SKIP_ENABLE</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_INITIALIZED</span> <span class="o">&amp;&amp;</span>
	    <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_IDLE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_DISABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_hwmod: %s: enabled state can only be entered from initialized, idle, or disabled state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If an IP block contains HW reset lines and any of them are</span>
<span class="cm">	 * asserted, we let integration code associated with that</span>
<span class="cm">	 * block handle the enable.  We&#39;ve received very little</span>
<span class="cm">	 * information on what those driver authors need, and until</span>
<span class="cm">	 * detailed information is provided and the driver code is</span>
<span class="cm">	 * posted to the public lists, this is probably the best we</span>
<span class="cm">	 * can do.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_are_any_hardreset_lines_asserted</span><span class="p">(</span><span class="n">oh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Mux pins for device runtime if populated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">||</span>
			<span class="p">((</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">==</span> <span class="n">_HWMOD_STATE_IDLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			 <span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">pads_dynamic</span><span class="p">)))</span>
		<span class="n">omap_hwmod_mux</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="p">,</span> <span class="n">_HWMOD_STATE_ENABLED</span><span class="p">);</span>

	<span class="n">_add_initiator_dep</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">mpu_oh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * A clockdomain must be in SW_SUP before enabling</span>
<span class="cm">		 * completely the module. The clockdomain can be set</span>
<span class="cm">		 * in HW_AUTO only when the module become ready.</span>
<span class="cm">		 */</span>
		<span class="n">hwsup</span> <span class="o">=</span> <span class="n">clkdm_in_hwsup</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">clkdm_hwmod_enable</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">,</span> <span class="n">oh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_hwmod: %s: could not enable clockdomain %s: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">_enable_clocks</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="n">_enable_module</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">_wait_target_ready</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set the clockdomain to HW_AUTO only if the target is ready,</span>
<span class="cm">		 * assuming that the previous state was HW_AUTO</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span> <span class="o">&amp;&amp;</span> <span class="n">hwsup</span><span class="p">)</span>
			<span class="n">clkdm_allow_idle</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">);</span>

		<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">=</span> <span class="n">_HWMOD_STATE_ENABLED</span><span class="p">;</span>

		<span class="cm">/* Access the sysconfig only if the target is ready */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_int_flags</span> <span class="o">&amp;</span> <span class="n">_HWMOD_SYSCONFIG_LOADED</span><span class="p">))</span>
				<span class="n">_update_sysc_cache</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
			<span class="n">_enable_sysc</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">_disable_clocks</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: _wait_target_ready: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">)</span>
			<span class="n">clkdm_hwmod_disable</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">,</span> <span class="n">oh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _idle - idle an omap_hwmod</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Idles an omap_hwmod @oh.  This should be called once the hwmod has</span>
<span class="cm"> * no further work.  Returns -EINVAL if the hwmod is in the wrong</span>
<span class="cm"> * state or returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: idling</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_hwmod: %s: idle state can only be entered from enabled state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_are_any_hardreset_lines_asserted</span><span class="p">(</span><span class="n">oh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="p">)</span>
		<span class="n">_idle_sysc</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="n">_del_initiator_dep</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">mpu_oh</span><span class="p">);</span>

	<span class="n">_omap4_disable_module</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The module must be in idle mode before disabling any parents</span>
<span class="cm">	 * clocks. Otherwise, the parent clock might be disabled before</span>
<span class="cm">	 * the module transition is done, and thus will prevent the</span>
<span class="cm">	 * transition to complete properly.</span>
<span class="cm">	 */</span>
	<span class="n">_disable_clocks</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">)</span>
		<span class="n">clkdm_hwmod_disable</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">,</span> <span class="n">oh</span><span class="p">);</span>

	<span class="cm">/* Mux pins for device idle if populated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span> <span class="o">&amp;&amp;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">pads_dynamic</span><span class="p">)</span>
		<span class="n">omap_hwmod_mux</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="p">,</span> <span class="n">_HWMOD_STATE_IDLE</span><span class="p">);</span>

	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">=</span> <span class="n">_HWMOD_STATE_IDLE</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_set_ocp_autoidle - set the hwmod&#39;s OCP autoidle bit</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @autoidle: desired AUTOIDLE bitfield value (0 or 1)</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the IP block&#39;s OCP autoidle bit in hardware, and updates our</span>
<span class="cm"> * local copy. Intended to be used by drivers that require</span>
<span class="cm"> * direct manipulation of the AUTOIDLE bits.</span>
<span class="cm"> * Returns -EINVAL if @oh is null or is not in the ENABLED state, or passes</span>
<span class="cm"> * along the return value from _set_module_autoidle().</span>
<span class="cm"> *</span>
<span class="cm"> * Any users of this function should be scrutinized carefully.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_set_ocp_autoidle</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u8</span> <span class="n">autoidle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span> <span class="o">||</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_ENABLED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_sysc_cache</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">_set_module_autoidle</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">autoidle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">_write_sysconfig</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">oh</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _shutdown - shutdown an omap_hwmod</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Shut down an omap_hwmod @oh.  This should be called when the driver</span>
<span class="cm"> * used for the hwmod is removed or unloaded or if the driver is not</span>
<span class="cm"> * used by the system.  Returns -EINVAL if the hwmod is in the wrong</span>
<span class="cm"> * state or returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">prev_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_IDLE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_hwmod: %s: disabled state can only be entered from idle, or enabled state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_are_any_hardreset_lines_asserted</span><span class="p">(</span><span class="n">oh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: disabling</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">pre_shutdown</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prev_state</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">==</span> <span class="n">_HWMOD_STATE_IDLE</span><span class="p">)</span>
			<span class="n">_enable</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">pre_shutdown</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prev_state</span> <span class="o">==</span> <span class="n">_HWMOD_STATE_IDLE</span><span class="p">)</span>
				<span class="n">_idle</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">==</span> <span class="n">_HWMOD_STATE_IDLE</span><span class="p">)</span>
			<span class="n">_enable</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
		<span class="n">_shutdown_sysc</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* clocks and deps are already disabled in idle */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">==</span> <span class="n">_HWMOD_STATE_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_del_initiator_dep</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">mpu_oh</span><span class="p">);</span>
		<span class="cm">/* XXX what about the other system initiators here? dma, dsp */</span>
		<span class="n">_omap4_disable_module</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
		<span class="n">_disable_clocks</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">)</span>
			<span class="n">clkdm_hwmod_disable</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">,</span> <span class="n">oh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* XXX Should this code also force-disable the optional clocks? */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">rst_lines_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">_assert_hardreset</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">rst_lines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* Mux pins to safe mode or use populated off mode values */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="p">)</span>
		<span class="n">omap_hwmod_mux</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="p">,</span> <span class="n">_HWMOD_STATE_DISABLED</span><span class="p">);</span>

	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">=</span> <span class="n">_HWMOD_STATE_DISABLED</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _init_mpu_rt_base - populate the virtual address for a hwmod</span>
<span class="cm"> * @oh: struct omap_hwmod * to locate the virtual address</span>
<span class="cm"> *</span>
<span class="cm"> * Cache the virtual address used by the MPU to access this IP block&#39;s</span>
<span class="cm"> * registers.  This address is needed early so the OCP registers that</span>
<span class="cm"> * are part of the device&#39;s address space can be ioremapped properly.</span>
<span class="cm"> * No return value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">_init_mpu_rt_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_addr_space</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">va_start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">_save_mpu_port_index</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_int_flags</span> <span class="o">&amp;</span> <span class="n">_HWMOD_NO_MPU_PORT</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mem</span> <span class="o">=</span> <span class="n">_find_mpu_rt_addr_space</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: no MPU register target found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">va_start</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">pa_start</span><span class="p">,</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">pa_end</span> <span class="o">-</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">pa_start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">va_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: Could not ioremap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: MPU register target at va %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">va_start</span><span class="p">);</span>

	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_mpu_rt_va</span> <span class="o">=</span> <span class="n">va_start</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _init - initialize internal data for the hwmod @oh</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @n: (unused)</span>
<span class="cm"> *</span>
<span class="cm"> * Look up the clocks and the address space used by the MPU to access</span>
<span class="cm"> * registers belonging to the hwmod @oh.  @oh must already be</span>
<span class="cm"> * registered at this point.  This is the first of two phases for</span>
<span class="cm"> * hwmod initialization.  Code called here does not touch any hardware</span>
<span class="cm"> * registers, it simply prepares internal data structures.  Returns 0</span>
<span class="cm"> * upon success or if the hwmod isn&#39;t registered, or -EINVAL upon</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_REGISTERED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">_init_mpu_rt_base</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">_init_clocks</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_hwmod: %s: couldn&#39;t init clocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">=</span> <span class="n">_HWMOD_STATE_INITIALIZED</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _setup_iclk_autoidle - configure an IP block&#39;s interface clocks</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Set up the module&#39;s interface clocks.  XXX This function is still mostly</span>
<span class="cm"> * a stub; implementing this properly requires iclk autoidle usecounting in</span>
<span class="cm"> * the clock code.   No return value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">_setup_iclk_autoidle</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="n">os</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_INITIALIZED</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slave_ports</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slaves_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">os</span> <span class="o">=</span> <span class="n">_fetch_next_ocp_if</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OCPIF_SWSUP_IDLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* XXX omap_iclk_deny_idle(c); */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* XXX omap_iclk_allow_idle(c); */</span>
			<span class="n">clk_enable</span><span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _setup_reset - reset an IP block during the setup process</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Reset the IP block corresponding to the hwmod @oh during the setup</span>
<span class="cm"> * process.  The IP block is first enabled so it can be successfully</span>
<span class="cm"> * reset.  Returns 0 upon success or a negative error code upon</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">_setup_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_INITIALIZED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">rst_lines_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">_enable</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: cannot be enabled for reset (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_INIT_NO_RESET</span><span class="p">))</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">_reset</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _setup_postsetup - transition to the appropriate state after _setup</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Place an IP block represented by @oh into a &quot;post-setup&quot; state --</span>
<span class="cm"> * either IDLE, ENABLED, or DISABLED.  (&quot;post-setup&quot; simply means that</span>
<span class="cm"> * this function is called at the end of _setup().)  The postsetup</span>
<span class="cm"> * state for an IP block can be changed by calling</span>
<span class="cm"> * omap_hwmod_enter_postsetup_state() early in the boot process,</span>
<span class="cm"> * before one of the omap_hwmod_setup*() functions are called for the</span>
<span class="cm"> * IP block.</span>
<span class="cm"> *</span>
<span class="cm"> * The IP block stays in this state until a PM runtime-based driver is</span>
<span class="cm"> * loaded for that IP block.  A post-setup state of IDLE is</span>
<span class="cm"> * appropriate for almost all IP blocks with runtime PM-enabled</span>
<span class="cm"> * drivers, since those drivers are able to enable the IP block.  A</span>
<span class="cm"> * post-setup state of ENABLED is appropriate for kernels with PM</span>
<span class="cm"> * runtime disabled.  The DISABLED state is appropriate for unusual IP</span>
<span class="cm"> * blocks such as the MPU WDTIMER on kernels without WDTIMER drivers</span>
<span class="cm"> * included, since the WDTIMER starts running on reset and will reset</span>
<span class="cm"> * the MPU if left active.</span>
<span class="cm"> *</span>
<span class="cm"> * This post-setup mechanism is deprecated.  Once all of the OMAP</span>
<span class="cm"> * drivers have been converted to use PM runtime, and all of the IP</span>
<span class="cm"> * block data and interconnect data is available to the hwmod code, it</span>
<span class="cm"> * should be possible to replace this mechanism with a &quot;lazy reset&quot;</span>
<span class="cm"> * arrangement.  In a &quot;lazy reset&quot; setup, each IP block is enabled</span>
<span class="cm"> * when the driver first probes, then all remaining IP blocks without</span>
<span class="cm"> * drivers are either shut down or enabled after the drivers have</span>
<span class="cm"> * loaded.  However, this cannot take place until the above</span>
<span class="cm"> * preconditions have been met, since otherwise the late reset code</span>
<span class="cm"> * has no way of knowing which IP blocks are in use by drivers, and</span>
<span class="cm"> * which ones are unused.</span>
<span class="cm"> *</span>
<span class="cm"> * No return value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">_setup_postsetup</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">postsetup_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">rst_lines_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">postsetup_state</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_postsetup_state</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">postsetup_state</span> <span class="o">==</span> <span class="n">_HWMOD_STATE_UNKNOWN</span><span class="p">)</span>
		<span class="n">postsetup_state</span> <span class="o">=</span> <span class="n">_HWMOD_STATE_ENABLED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX HWMOD_INIT_NO_IDLE does not belong in hwmod data -</span>
<span class="cm">	 * it should be set by the core code as a runtime flag during startup</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_INIT_NO_IDLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">postsetup_state</span> <span class="o">==</span> <span class="n">_HWMOD_STATE_IDLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_int_flags</span> <span class="o">|=</span> <span class="n">_HWMOD_SKIP_ENABLE</span><span class="p">;</span>
		<span class="n">postsetup_state</span> <span class="o">=</span> <span class="n">_HWMOD_STATE_ENABLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">postsetup_state</span> <span class="o">==</span> <span class="n">_HWMOD_STATE_IDLE</span><span class="p">)</span>
		<span class="n">_idle</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">postsetup_state</span> <span class="o">==</span> <span class="n">_HWMOD_STATE_DISABLED</span><span class="p">)</span>
		<span class="n">_shutdown</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">postsetup_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_ENABLED</span><span class="p">)</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;hwmod: %s: unknown postsetup state %d! defaulting to enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">postsetup_state</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _setup - prepare IP block hardware for use</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @n: (unused, pass NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the IP block represented by @oh.  This may include</span>
<span class="cm"> * enabling the IP block, resetting it, and placing it into a</span>
<span class="cm"> * post-setup state, depending on the type of IP block and applicable</span>
<span class="cm"> * flags.  IP blocks are reset to prevent any previous configuration</span>
<span class="cm"> * by the bootloader or previous operating system from interfering</span>
<span class="cm"> * with power management or other parts of the system.  The reset can</span>
<span class="cm"> * be avoided; see omap_hwmod_no_setup_reset().  This is the second of</span>
<span class="cm"> * two phases for hwmod initialization.  Code called here generally</span>
<span class="cm"> * affects the IP block hardware, or system integration hardware</span>
<span class="cm"> * associated with the IP block.  Returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_INITIALIZED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">_setup_iclk_autoidle</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_setup_reset</span><span class="p">(</span><span class="n">oh</span><span class="p">))</span>
		<span class="n">_setup_postsetup</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _register - register a struct omap_hwmod</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Registers the omap_hwmod @oh.  Returns -EEXIST if an omap_hwmod</span>
<span class="cm"> * already has been registered by the same name; -EINVAL if the</span>
<span class="cm"> * omap_hwmod is in the wrong state, if @oh is NULL, if the</span>
<span class="cm"> * omap_hwmod&#39;s class field is NULL; if the omap_hwmod is missing a</span>
<span class="cm"> * name, or if the omap_hwmod&#39;s class is missing a name; or 0 upon</span>
<span class="cm"> * success.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX The data should be copied into bootmem, so the original data</span>
<span class="cm"> * should be marked __initdata and freed after init.  This would allow</span>
<span class="cm"> * unneeded omap_hwmods to be freed on multi-OMAP configurations.  Note</span>
<span class="cm"> * that the copy process would be relatively complex due to the large number</span>
<span class="cm"> * of substructures.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span> <span class="o">||</span> <span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">||</span> <span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">||</span> <span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_UNKNOWN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: registering</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_lookup</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">omap_hwmod_list</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">master_ports</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">slave_ports</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">);</span>

	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">=</span> <span class="n">_HWMOD_STATE_REGISTERED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX Rather than doing a strcmp(), this should test a flag</span>
<span class="cm">	 * set in the hwmod data, inserted by the autogenerator code.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">MPU_INITIATOR_NAME</span><span class="p">))</span>
		<span class="n">mpu_oh</span> <span class="o">=</span> <span class="n">oh</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _alloc_links - return allocated memory for hwmod links</span>
<span class="cm"> * @ml: pointer to a struct omap_hwmod_link * for the master link</span>
<span class="cm"> * @sl: pointer to a struct omap_hwmod_link * for the slave link</span>
<span class="cm"> *</span>
<span class="cm"> * Return pointers to two struct omap_hwmod_link records, via the</span>
<span class="cm"> * addresses pointed to by @ml and @sl.  Will first attempt to return</span>
<span class="cm"> * memory allocated as part of a large initial block, but if that has</span>
<span class="cm"> * been exhausted, will allocate memory itself.  Since ideally this</span>
<span class="cm"> * second allocation path will never occur, the number of these</span>
<span class="cm"> * &#39;supplemental&#39; allocations will be logged when debugging is</span>
<span class="cm"> * enabled.  Returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">_alloc_links</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod_link</span> <span class="o">**</span><span class="n">ml</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">omap_hwmod_link</span> <span class="o">**</span><span class="n">sl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">free_ls</span> <span class="o">+</span> <span class="n">LINKS_PER_OCP_IF</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_ls</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ml</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">linkspace</span><span class="p">[</span><span class="n">free_ls</span><span class="o">++</span><span class="p">];</span>
		<span class="o">*</span><span class="n">sl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">linkspace</span><span class="p">[</span><span class="n">free_ls</span><span class="o">++</span><span class="p">];</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod_link</span><span class="p">)</span> <span class="o">*</span> <span class="n">LINKS_PER_OCP_IF</span><span class="p">;</span>

	<span class="o">*</span><span class="n">sl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ml</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">*</span><span class="n">ml</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>

	<span class="o">*</span><span class="n">sl</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">ml</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod_link</span><span class="p">);</span>

	<span class="n">ls_supp</span><span class="o">++</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: supplemental link allocations needed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">ls_supp</span> <span class="o">*</span> <span class="n">LINKS_PER_OCP_IF</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * _add_link - add an interconnect between two IP blocks</span>
<span class="cm"> * @oi: pointer to a struct omap_hwmod_ocp_if record</span>
<span class="cm"> *</span>
<span class="cm"> * Add struct omap_hwmod_link records connecting the master IP block</span>
<span class="cm"> * specified in @oi-&gt;master to @oi, and connecting the slave IP block</span>
<span class="cm"> * specified in @oi-&gt;slave to @oi.  This code is assumed to run before</span>
<span class="cm"> * preemption or SMP has been enabled, thus avoiding the need for</span>
<span class="cm"> * locking in this code.  Changes to this assumption will require</span>
<span class="cm"> * additional locking.  Returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">_add_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="n">oi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_link</span> <span class="o">*</span><span class="n">ml</span><span class="p">,</span> <span class="o">*</span><span class="n">sl</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s -&gt; %s: adding link</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		 <span class="n">oi</span><span class="o">-&gt;</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">_alloc_links</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ml</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sl</span><span class="p">);</span>

	<span class="n">ml</span><span class="o">-&gt;</span><span class="n">ocp_if</span> <span class="o">=</span> <span class="n">oi</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ml</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ml</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">master_ports</span><span class="p">);</span>
	<span class="n">oi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">masters_cnt</span><span class="o">++</span><span class="p">;</span>

	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">ocp_if</span> <span class="o">=</span> <span class="n">oi</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oi</span><span class="o">-&gt;</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">slave_ports</span><span class="p">);</span>
	<span class="n">oi</span><span class="o">-&gt;</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">slaves_cnt</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _register_link - register a struct omap_hwmod_ocp_if</span>
<span class="cm"> * @oi: struct omap_hwmod_ocp_if *</span>
<span class="cm"> *</span>
<span class="cm"> * Registers the omap_hwmod_ocp_if record @oi.  Returns -EEXIST if it</span>
<span class="cm"> * has already been registered; -EINVAL if @oi is NULL or if the</span>
<span class="cm"> * record pointed to by @oi is missing required fields; or 0 upon</span>
<span class="cm"> * success.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX The data should be copied into bootmem, so the original data</span>
<span class="cm"> * should be marked __initdata and freed after init.  This would allow</span>
<span class="cm"> * unneeded omap_hwmods to be freed on multi-OMAP configurations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">_register_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="n">oi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oi</span> <span class="o">||</span> <span class="o">!</span><span class="n">oi</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">||</span> <span class="o">!</span><span class="n">oi</span><span class="o">-&gt;</span><span class="n">slave</span> <span class="o">||</span> <span class="o">!</span><span class="n">oi</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oi</span><span class="o">-&gt;</span><span class="n">_int_flags</span> <span class="o">&amp;</span> <span class="n">_OCPIF_INT_FLAGS_REGISTERED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: registering link from %s to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">oi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">oi</span><span class="o">-&gt;</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register the connected hwmods, if they haven&#39;t been</span>
<span class="cm">	 * registered already</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_REGISTERED</span><span class="p">)</span>
		<span class="n">_register</span><span class="p">(</span><span class="n">oi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oi</span><span class="o">-&gt;</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_REGISTERED</span><span class="p">)</span>
		<span class="n">_register</span><span class="p">(</span><span class="n">oi</span><span class="o">-&gt;</span><span class="n">slave</span><span class="p">);</span>

	<span class="n">_add_link</span><span class="p">(</span><span class="n">oi</span><span class="p">);</span>

	<span class="n">oi</span><span class="o">-&gt;</span><span class="n">_int_flags</span> <span class="o">|=</span> <span class="n">_OCPIF_INT_FLAGS_REGISTERED</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _alloc_linkspace - allocate large block of hwmod links</span>
<span class="cm"> * @ois: pointer to an array of struct omap_hwmod_ocp_if records to count</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate a large block of struct omap_hwmod_link records.  This</span>
<span class="cm"> * improves boot time significantly by avoiding the need to allocate</span>
<span class="cm"> * individual records one by one.  If the number of records to</span>
<span class="cm"> * allocate in the block hasn&#39;t been manually specified, this function</span>
<span class="cm"> * will count the number of struct omap_hwmod_ocp_if records in @ois</span>
<span class="cm"> * and use that to determine the allocation size.  For SoC families</span>
<span class="cm"> * that require multiple list registrations, such as OMAP3xxx, this</span>
<span class="cm"> * estimation process isn&#39;t optimal, so manual estimation is advised</span>
<span class="cm"> * in those cases.  Returns -EEXIST if the allocation has already occurred</span>
<span class="cm"> * or 0 upon success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">_alloc_linkspace</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">**</span><span class="n">ois</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">linkspace</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;linkspace already allocated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_ls</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ois</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">])</span>
			<span class="n">max_ls</span> <span class="o">+=</span> <span class="n">LINKS_PER_OCP_IF</span><span class="p">;</span>

	<span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod_link</span><span class="p">)</span> <span class="o">*</span> <span class="n">max_ls</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: allocating %d byte linkspace (%d links)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">__func__</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">max_ls</span><span class="p">);</span>

	<span class="n">linkspace</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">linkspace</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Public functions */</span>

<span class="n">u32</span> <span class="nf">omap_hwmod_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg_offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_16BIT_REG</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__raw_readw</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_mpu_rt_va</span> <span class="o">+</span> <span class="n">reg_offs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_mpu_rt_va</span> <span class="o">+</span> <span class="n">reg_offs</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">omap_hwmod_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">v</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg_offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HWMOD_16BIT_REG</span><span class="p">)</span>
		<span class="n">__raw_writew</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_mpu_rt_va</span> <span class="o">+</span> <span class="n">reg_offs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_mpu_rt_va</span> <span class="o">+</span> <span class="n">reg_offs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_softreset - reset a module via SYSCONFIG.SOFTRESET bit</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * This is a public function exposed to drivers. Some drivers may need to do</span>
<span class="cm"> * some settings before and after resetting the device.  Those drivers after</span>
<span class="cm"> * doing the necessary settings could use this function to start a reset by</span>
<span class="cm"> * setting the SYSCONFIG.SOFTRESET bit.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_softreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_sysc_cache</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_sysc_cache</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">_set_softreset</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">_write_sysconfig</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">oh</span><span class="p">);</span>

<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_set_slave_idlemode - set the hwmod&#39;s OCP slave idlemode</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @idlemode: SIDLEMODE field bits (shifted to bit 0)</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the IP block&#39;s OCP slave idlemode in hardware, and updates our</span>
<span class="cm"> * local copy.  Intended to be used by drivers that have some erratum</span>
<span class="cm"> * that requires direct manipulation of the SIDLEMODE bits.  Returns</span>
<span class="cm"> * -EINVAL if @oh is null, or passes along the return value from</span>
<span class="cm"> * _set_slave_idlemode().</span>
<span class="cm"> *</span>
<span class="cm"> * XXX Does this function have any current users?  If not, we should</span>
<span class="cm"> * remove it; it is better to let the rest of the hwmod code handle this.</span>
<span class="cm"> * Any users of this function should be scrutinized carefully.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_set_slave_idlemode</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u8</span> <span class="n">idlemode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_sysc_cache</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">_set_slave_idlemode</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">idlemode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">_write_sysconfig</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">oh</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_lookup - look up a registered omap_hwmod by name</span>
<span class="cm"> * @name: name of the omap_hwmod to look up</span>
<span class="cm"> *</span>
<span class="cm"> * Given a @name of an omap_hwmod, return a pointer to the registered</span>
<span class="cm"> * struct omap_hwmod *, or NULL upon error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="nf">omap_hwmod_lookup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">oh</span> <span class="o">=</span> <span class="n">_lookup</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">oh</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_for_each - call function for each registered omap_hwmod</span>
<span class="cm"> * @fn: pointer to a callback function</span>
<span class="cm"> * @data: void * data to pass to callback function</span>
<span class="cm"> *</span>
<span class="cm"> * Call @fn for each registered omap_hwmod, passing @data to each</span>
<span class="cm"> * function.  @fn must return 0 for success or any other value for</span>
<span class="cm"> * failure.  If @fn returns non-zero, the iteration across omap_hwmods</span>
<span class="cm"> * will stop and the non-zero return value will be passed to the</span>
<span class="cm"> * caller of omap_hwmod_for_each().  @fn is called with</span>
<span class="cm"> * omap_hwmod_for_each() held.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_for_each</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">temp_oh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">temp_oh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">omap_hwmod_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="n">temp_oh</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_register_links - register an array of hwmod links</span>
<span class="cm"> * @ois: pointer to an array of omap_hwmod_ocp_if to register</span>
<span class="cm"> *</span>
<span class="cm"> * Intended to be called early in boot before the clock framework is</span>
<span class="cm"> * initialized.  If @ois is not null, will register all omap_hwmods</span>
<span class="cm"> * listed in @ois that are valid for this chip.  Returns 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">omap_hwmod_register_links</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">**</span><span class="n">ois</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ois</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">linkspace</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">_alloc_linkspace</span><span class="p">(</span><span class="n">ois</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;omap_hwmod: could not allocate link space</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">_register_link</span><span class="p">(</span><span class="n">ois</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">WARN</span><span class="p">(</span><span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">,</span>
		     <span class="s">&quot;omap_hwmod: _register_link(%s -&gt; %s) returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">ois</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ois</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ois</span><span class="p">[</span><span class="o">++</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _ensure_mpu_hwmod_is_setup - ensure the MPU SS hwmod is init&#39;ed and set up</span>
<span class="cm"> * @oh: pointer to the hwmod currently being set up (usually not the MPU)</span>
<span class="cm"> *</span>
<span class="cm"> * If the hwmod data corresponding to the MPU subsystem IP block</span>
<span class="cm"> * hasn&#39;t been initialized and set up yet, do so now.  This must be</span>
<span class="cm"> * done first since sleep dependencies may be added from other hwmods</span>
<span class="cm"> * to the MPU.  Intended to be called only by omap_hwmod_setup*().  No</span>
<span class="cm"> * return value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">_ensure_mpu_hwmod_is_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mpu_oh</span> <span class="o">||</span> <span class="n">mpu_oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">==</span> <span class="n">_HWMOD_STATE_UNKNOWN</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: MPU initiator hwmod %s not yet registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">MPU_INITIATOR_NAME</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mpu_oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">==</span> <span class="n">_HWMOD_STATE_REGISTERED</span> <span class="o">&amp;&amp;</span> <span class="n">oh</span> <span class="o">!=</span> <span class="n">mpu_oh</span><span class="p">)</span>
		<span class="n">omap_hwmod_setup_one</span><span class="p">(</span><span class="n">MPU_INITIATOR_NAME</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_setup_one - set up a single hwmod</span>
<span class="cm"> * @oh_name: const char * name of the already-registered hwmod to set up</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize and set up a single hwmod.  Intended to be used for a</span>
<span class="cm"> * small number of early devices, such as the timer IP blocks used for</span>
<span class="cm"> * the scheduler clock.  Must be called after omap2_clk_init().</span>
<span class="cm"> * Resolves the struct clk names to struct clk pointers for each</span>
<span class="cm"> * registered omap_hwmod.  Also calls _setup() on each hwmod.  Returns</span>
<span class="cm"> * -EINVAL upon error or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">omap_hwmod_setup_one</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oh_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh_name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">oh</span> <span class="o">=</span> <span class="n">_lookup</span><span class="p">(</span><span class="n">oh_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_hwmod: %s: hwmod not yet registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oh_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_ensure_mpu_hwmod_is_setup</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>

	<span class="n">_init</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">_setup</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_setup_all - set up all registered IP blocks</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize and set up all IP blocks registered with the hwmod code.</span>
<span class="cm"> * Must be called after omap2_clk_init().  Resolves the struct clk</span>
<span class="cm"> * names to struct clk pointers for each registered omap_hwmod.  Also</span>
<span class="cm"> * calls _setup() on each hwmod.  Returns 0 upon success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">omap_hwmod_setup_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_ensure_mpu_hwmod_is_setup</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

	<span class="n">omap_hwmod_for_each</span><span class="p">(</span><span class="n">_init</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">omap_hwmod_for_each</span><span class="p">(</span><span class="n">_setup</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">core_initcall</span><span class="p">(</span><span class="n">omap_hwmod_setup_all</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_enable - enable an omap_hwmod</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Enable an omap_hwmod @oh.  Intended to be called by omap_device_enable().</span>
<span class="cm"> * Returns -EINVAL on error or passes along the return value from _enable().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">_enable</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_idle - idle an omap_hwmod</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Idle an omap_hwmod @oh.  Intended to be called by omap_device_idle().</span>
<span class="cm"> * Returns -EINVAL on error or passes along the return value from _idle().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">_idle</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_shutdown - shutdown an omap_hwmod</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Shutdown an omap_hwmod @oh.  Intended to be called by</span>
<span class="cm"> * omap_device_shutdown().  Returns -EINVAL on error or passes along</span>
<span class="cm"> * the return value from _shutdown().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">_shutdown</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_enable_clocks - enable main_clk, all interface clocks</span>
<span class="cm"> * @oh: struct omap_hwmod *oh</span>
<span class="cm"> *</span>
<span class="cm"> * Intended to be called by the omap_device code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_enable_clocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">_enable_clocks</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_disable_clocks - disable main_clk, all interface clocks</span>
<span class="cm"> * @oh: struct omap_hwmod *oh</span>
<span class="cm"> *</span>
<span class="cm"> * Intended to be called by the omap_device code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_disable_clocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">_disable_clocks</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_ocp_barrier - wait for posted writes against the hwmod to complete</span>
<span class="cm"> * @oh: struct omap_hwmod *oh</span>
<span class="cm"> *</span>
<span class="cm"> * Intended to be called by drivers and core code when all posted</span>
<span class="cm"> * writes to a device must complete before continuing further</span>
<span class="cm"> * execution (for example, after clearing some device IRQSTATUS</span>
<span class="cm"> * register bits)</span>
<span class="cm"> *</span>
<span class="cm"> * XXX what about targets with multiple OCP threads?</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">omap_hwmod_ocp_barrier</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span> <span class="o">||</span> <span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;omap_device: %s: OCP barrier impossible due to device configuration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Forces posted writes to complete on the OCP thread handling</span>
<span class="cm">	 * register writes</span>
<span class="cm">	 */</span>
	<span class="n">omap_hwmod_read</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_offs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_reset - reset the hwmod</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Under some conditions, a driver may wish to reset the entire device.</span>
<span class="cm"> * Called from omap_device code.  Returns -EINVAL on error or passes along</span>
<span class="cm"> * the return value from _reset().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">_reset</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * IP block data retrieval functions</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_count_resources - count number of struct resources needed by hwmod</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @res: pointer to the first element of an array of struct resource to fill</span>
<span class="cm"> *</span>
<span class="cm"> * Count the number of struct resource array elements necessary to</span>
<span class="cm"> * contain omap_hwmod @oh resources.  Intended to be called by code</span>
<span class="cm"> * that registers omap_devices.  Intended to be used to determine the</span>
<span class="cm"> * size of a dynamically-allocated struct resource array, before</span>
<span class="cm"> * calling omap_hwmod_fill_resources().  Returns the number of struct</span>
<span class="cm"> * resource array elements needed.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX This code is not optimized.  It could attempt to merge adjacent</span>
<span class="cm"> * resource IDs.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_count_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="n">os</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">_count_mpu_irqs</span><span class="p">(</span><span class="n">oh</span><span class="p">)</span> <span class="o">+</span> <span class="n">_count_sdma_reqs</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slave_ports</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slaves_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">os</span> <span class="o">=</span> <span class="n">_fetch_next_ocp_if</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">_count_ocp_if_addr_spaces</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_fill_resources - fill struct resource array with hwmod data</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @res: pointer to the first element of an array of struct resource to fill</span>
<span class="cm"> *</span>
<span class="cm"> * Fill the struct resource array @res with resource data from the</span>
<span class="cm"> * omap_hwmod @oh.  Intended to be called by code that registers</span>
<span class="cm"> * omap_devices.  See also omap_hwmod_count_resources().  Returns the</span>
<span class="cm"> * number of array elements filled.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_fill_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="n">os</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mpu_irqs_cnt</span><span class="p">,</span> <span class="n">sdma_reqs_cnt</span><span class="p">,</span> <span class="n">addr_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* For each IRQ, DMA, memory area, fill in array.*/</span>

	<span class="n">mpu_irqs_cnt</span> <span class="o">=</span> <span class="n">_count_mpu_irqs</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mpu_irqs_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="n">res</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mpu_irqs</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="p">(</span><span class="n">res</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mpu_irqs</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
		<span class="p">(</span><span class="n">res</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mpu_irqs</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
		<span class="p">(</span><span class="n">res</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_IRQ</span><span class="p">;</span>
		<span class="n">r</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sdma_reqs_cnt</span> <span class="o">=</span> <span class="n">_count_sdma_reqs</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sdma_reqs_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="n">res</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">sdma_reqs</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="p">(</span><span class="n">res</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">sdma_reqs</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dma_req</span><span class="p">;</span>
		<span class="p">(</span><span class="n">res</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">sdma_reqs</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dma_req</span><span class="p">;</span>
		<span class="p">(</span><span class="n">res</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_DMA</span><span class="p">;</span>
		<span class="n">r</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slave_ports</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">slaves_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">os</span> <span class="o">=</span> <span class="n">_fetch_next_ocp_if</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="n">addr_cnt</span> <span class="o">=</span> <span class="n">_count_ocp_if_addr_spaces</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">addr_cnt</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">(</span><span class="n">res</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
			<span class="p">(</span><span class="n">res</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pa_start</span><span class="p">;</span>
			<span class="p">(</span><span class="n">res</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">os</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pa_end</span><span class="p">;</span>
			<span class="p">(</span><span class="n">res</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">;</span>
			<span class="n">r</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_get_resource_byname - fetch IP block integration data by name</span>
<span class="cm"> * @oh: struct omap_hwmod * to operate on</span>
<span class="cm"> * @type: one of the IORESOURCE_* constants from include/linux/ioport.h</span>
<span class="cm"> * @name: pointer to the name of the data to fetch (optional)</span>
<span class="cm"> * @rsrc: pointer to a struct resource, allocated by the caller</span>
<span class="cm"> *</span>
<span class="cm"> * Retrieve MPU IRQ, SDMA request line, or address space start/end</span>
<span class="cm"> * data for the IP block pointed to by @oh.  The data will be filled</span>
<span class="cm"> * into a struct resource record pointed to by @rsrc.  The struct</span>
<span class="cm"> * resource must be allocated by the caller.  When @name is non-null,</span>
<span class="cm"> * the data associated with the matching entry in the IRQ/SDMA/address</span>
<span class="cm"> * space hwmod data arrays will be returned.  If @name is null, the</span>
<span class="cm"> * first array entry will be returned.  Data order is not meaningful</span>
<span class="cm"> * in hwmod data, so callers are strongly encouraged to use a non-null</span>
<span class="cm"> * @name whenever possible to avoid unpredictable effects if hwmod</span>
<span class="cm"> * data is later added that causes data ordering to change.  This</span>
<span class="cm"> * function is only intended for use by OMAP core code.  Device</span>
<span class="cm"> * drivers should not call this function - the appropriate bus-related</span>
<span class="cm"> * data accessor functions should be used instead.  Returns 0 upon</span>
<span class="cm"> * success or a negative error code upon error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_get_resource_byname</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">rsrc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">dma</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pa_start</span><span class="p">,</span> <span class="n">pa_end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span> <span class="o">||</span> <span class="o">!</span><span class="n">rsrc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">IORESOURCE_IRQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">_get_mpu_irq_by_name</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

		<span class="n">rsrc</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
		<span class="n">rsrc</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">IORESOURCE_DMA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">_get_sdma_req_by_name</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

		<span class="n">rsrc</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
		<span class="n">rsrc</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">IORESOURCE_MEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">_get_addr_space_by_name</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pa_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pa_end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

		<span class="n">rsrc</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">pa_start</span><span class="p">;</span>
		<span class="n">rsrc</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">pa_end</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rsrc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">rsrc</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_get_pwrdm - return pointer to this module&#39;s main powerdomain</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Return the powerdomain pointer associated with the OMAP module</span>
<span class="cm"> * @oh&#39;s main clock.  If @oh does not have a main clk, return the</span>
<span class="cm"> * powerdomain associated with the interface clock associated with the</span>
<span class="cm"> * module&#39;s MPU port. (XXX Perhaps this should use the SDMA port</span>
<span class="cm"> * instead?)  Returns NULL on error, or a struct powerdomain * on</span>
<span class="cm"> * success.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="nf">omap_hwmod_get_pwrdm</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">*</span><span class="n">oi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">oi</span> <span class="o">=</span> <span class="n">_find_mpu_rt_port</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oi</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">oi</span><span class="o">-&gt;</span><span class="n">_clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_get_mpu_rt_va - return the module&#39;s base address (for the MPU)</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the virtual address corresponding to the beginning of the</span>
<span class="cm"> * module&#39;s register target, in the address range that is intended to</span>
<span class="cm"> * be used by the MPU.  Returns the virtual address upon success or NULL</span>
<span class="cm"> * upon error.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">omap_hwmod_get_mpu_rt_va</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_int_flags</span> <span class="o">&amp;</span> <span class="n">_HWMOD_NO_MPU_PORT</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">==</span> <span class="n">_HWMOD_STATE_UNKNOWN</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_mpu_rt_va</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_add_initiator_dep - add sleepdep from @init_oh to @oh</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @init_oh: struct omap_hwmod * (initiator)</span>
<span class="cm"> *</span>
<span class="cm"> * Add a sleep dependency between the initiator @init_oh and @oh.</span>
<span class="cm"> * Intended to be called by DSP/Bridge code via platform_data for the</span>
<span class="cm"> * DSP case; and by the DMA code in the sDMA case.  DMA code, *Bridge</span>
<span class="cm"> * code needs to add/del initiator dependencies dynamically</span>
<span class="cm"> * before/after accessing a device.  Returns the return value from</span>
<span class="cm"> * _add_initiator_dep().</span>
<span class="cm"> *</span>
<span class="cm"> * XXX Keep a usecount in the clockdomain code</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_add_initiator_dep</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">init_oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_add_initiator_dep</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">init_oh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * XXX what about functions for drivers to save/restore ocp_sysconfig</span>
<span class="cm"> * for context save/restore operations?</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_del_initiator_dep - remove sleepdep from @init_oh to @oh</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @init_oh: struct omap_hwmod * (initiator)</span>
<span class="cm"> *</span>
<span class="cm"> * Remove a sleep dependency between the initiator @init_oh and @oh.</span>
<span class="cm"> * Intended to be called by DSP/Bridge code via platform_data for the</span>
<span class="cm"> * DSP case; and by the DMA code in the sDMA case.  DMA code, *Bridge</span>
<span class="cm"> * code needs to add/del initiator dependencies dynamically</span>
<span class="cm"> * before/after accessing a device.  Returns the return value from</span>
<span class="cm"> * _del_initiator_dep().</span>
<span class="cm"> *</span>
<span class="cm"> * XXX Keep a usecount in the clockdomain code</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_del_initiator_dep</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">init_oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_del_initiator_dep</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">init_oh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_enable_wakeup - allow device to wake up the system</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the module OCP socket ENAWAKEUP bit to allow the module to</span>
<span class="cm"> * send wakeups to the PRCM, and enable I/O ring wakeup events for</span>
<span class="cm"> * this IP block if it has dynamic mux entries.  Eventually this</span>
<span class="cm"> * should set PRCM wakeup registers to cause the PRCM to receive</span>
<span class="cm"> * wakeup events from the module.  Does not set any wakeup routing</span>
<span class="cm"> * registers beyond this point - if the module is to wake up any other</span>
<span class="cm"> * module or subsystem, that must be set separately.  Called by</span>
<span class="cm"> * omap_device code.  Returns -EINVAL on error or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_enable_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_ENAWAKEUP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_sysc_cache</span><span class="p">;</span>
		<span class="n">_enable_wakeup</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
		<span class="n">_write_sysconfig</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">oh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">_set_idle_ioring_wakeup</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_disable_wakeup - prevent device from waking the system</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Clears the module OCP socket ENAWAKEUP bit to prevent the module</span>
<span class="cm"> * from sending wakeups to the PRCM, and disable I/O ring wakeup</span>
<span class="cm"> * events for this IP block if it has dynamic mux entries.  Eventually</span>
<span class="cm"> * this should clear PRCM wakeup registers to cause the PRCM to ignore</span>
<span class="cm"> * wakeup events from the module.  Does not set any wakeup routing</span>
<span class="cm"> * registers beyond this point - if the module is to wake up any other</span>
<span class="cm"> * module or subsystem, that must be set separately.  Called by</span>
<span class="cm"> * omap_device code.  Returns -EINVAL on error or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_disable_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">sysc_flags</span> <span class="o">&amp;</span> <span class="n">SYSC_HAS_ENAWAKEUP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">_sysc_cache</span><span class="p">;</span>
		<span class="n">_disable_wakeup</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
		<span class="n">_write_sysconfig</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">oh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">_set_idle_ioring_wakeup</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_assert_hardreset - assert the HW reset line of submodules</span>
<span class="cm"> * contained in the hwmod module.</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @name: name of the reset line to lookup and assert</span>
<span class="cm"> *</span>
<span class="cm"> * Some IP like dsp, ipu or iva contain processor that require</span>
<span class="cm"> * an HW reset line to be assert / deassert in order to enable fully</span>
<span class="cm"> * the IP.  Returns -EINVAL if @oh is null or if the operation is not</span>
<span class="cm"> * yet supported on this OMAP; otherwise, passes along the return value</span>
<span class="cm"> * from _assert_hardreset().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_assert_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">_assert_hardreset</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_deassert_hardreset - deassert the HW reset line of submodules</span>
<span class="cm"> * contained in the hwmod module.</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @name: name of the reset line to look up and deassert</span>
<span class="cm"> *</span>
<span class="cm"> * Some IP like dsp, ipu or iva contain processor that require</span>
<span class="cm"> * an HW reset line to be assert / deassert in order to enable fully</span>
<span class="cm"> * the IP.  Returns -EINVAL if @oh is null or if the operation is not</span>
<span class="cm"> * yet supported on this OMAP; otherwise, passes along the return value</span>
<span class="cm"> * from _deassert_hardreset().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_deassert_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">_deassert_hardreset</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_read_hardreset - read the HW reset line state of submodules</span>
<span class="cm"> * contained in the hwmod module</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @name: name of the reset line to look up and read</span>
<span class="cm"> *</span>
<span class="cm"> * Return the current state of the hwmod @oh&#39;s reset line named @name:</span>
<span class="cm"> * returns -EINVAL upon parameter error or if this operation</span>
<span class="cm"> * is unsupported on the current OMAP; otherwise, passes along the return</span>
<span class="cm"> * value from _read_hardreset().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_read_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">_read_hardreset</span><span class="p">(</span><span class="n">oh</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_for_each_by_class - call @fn for each hwmod of class @classname</span>
<span class="cm"> * @classname: struct omap_hwmod_class name to search for</span>
<span class="cm"> * @fn: callback function pointer to call for each hwmod in class @classname</span>
<span class="cm"> * @user: arbitrary context data to pass to the callback function</span>
<span class="cm"> *</span>
<span class="cm"> * For each omap_hwmod of class @classname, call @fn.</span>
<span class="cm"> * If the callback function returns something other than</span>
<span class="cm"> * zero, the iterator is terminated, and the callback function&#39;s return</span>
<span class="cm"> * value is passed back to the caller.  Returns 0 upon success, -EINVAL</span>
<span class="cm"> * if @classname or @fn are NULL, or passes back the error code from @fn.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_for_each_by_class</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">classname</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="o">*</span><span class="n">user</span><span class="p">),</span>
				 <span class="kt">void</span> <span class="o">*</span><span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">temp_oh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">classname</span> <span class="o">||</span> <span class="o">!</span><span class="n">fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: looking for modules of class %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">__func__</span><span class="p">,</span> <span class="n">classname</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">temp_oh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">omap_hwmod_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">temp_oh</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">classname</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: %s: calling callback fn</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">__func__</span><span class="p">,</span> <span class="n">temp_oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="n">temp_oh</span><span class="p">,</span> <span class="n">user</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: iterator terminated early: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_set_postsetup_state - set the post-_setup() state for this hwmod</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> * @state: state that _setup() should leave the hwmod in</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the hwmod state that @oh will enter at the end of _setup()</span>
<span class="cm"> * (called by omap_hwmod_setup_*()).  See also the documentation</span>
<span class="cm"> * for _setup_postsetup(), above.  Returns 0 upon success or</span>
<span class="cm"> * -EINVAL if there is a problem with the arguments or if the hwmod is</span>
<span class="cm"> * in the wrong state.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_set_postsetup_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u8</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_DISABLED</span> <span class="o">&amp;&amp;</span>
	    <span class="n">state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_ENABLED</span> <span class="o">&amp;&amp;</span>
	    <span class="n">state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_IDLE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_REGISTERED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">ohsps_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">_postsetup_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">ohsps_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_get_context_loss_count - get lost context count</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Query the powerdomain of of @oh to get the context loss</span>
<span class="cm"> * count for this device.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the context loss count of the powerdomain assocated with @oh</span>
<span class="cm"> * upon success, or zero if no powerdomain exists for @oh.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_get_context_loss_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pwrdm</span> <span class="o">=</span> <span class="n">omap_hwmod_get_pwrdm</span><span class="p">(</span><span class="n">oh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pwrdm_get_context_loss_count</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_no_setup_reset - prevent a hwmod from being reset upon setup</span>
<span class="cm"> * @oh: struct omap_hwmod *</span>
<span class="cm"> *</span>
<span class="cm"> * Prevent the hwmod @oh from being reset during the setup process.</span>
<span class="cm"> * Intended for use by board-*.c files on boards with devices that</span>
<span class="cm"> * cannot tolerate being reset.  Must be called before the hwmod has</span>
<span class="cm"> * been set up.  Returns 0 upon success or negative error code upon</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_no_setup_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">_HWMOD_STATE_REGISTERED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;omap_hwmod: %s: cannot prevent setup reset; in wrong state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">HWMOD_INIT_NO_RESET</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_hwmod_pad_route_irq - route an I/O pad wakeup to a particular MPU IRQ</span>
<span class="cm"> * @oh: struct omap_hwmod * containing hwmod mux entries</span>
<span class="cm"> * @pad_idx: array index in oh-&gt;mux of the hwmod mux entry to route wakeup</span>
<span class="cm"> * @irq_idx: the hwmod mpu_irqs array index of the IRQ to trigger on wakeup</span>
<span class="cm"> *</span>
<span class="cm"> * When an I/O pad wakeup arrives for the dynamic or wakeup hwmod mux</span>
<span class="cm"> * entry number @pad_idx for the hwmod @oh, trigger the interrupt</span>
<span class="cm"> * service routine for the hwmod&#39;s mpu_irqs array index @irq_idx.  If</span>
<span class="cm"> * this function is not called for a given pad_idx, then the ISR</span>
<span class="cm"> * associated with @oh&#39;s first MPU IRQ will be triggered when an I/O</span>
<span class="cm"> * pad wakeup occurs on that pad.  Note that @pad_idx is the index of</span>
<span class="cm"> * the _dynamic or wakeup_ entry: if there are other entries not</span>
<span class="cm"> * marked with OMAP_DEVICE_PAD_WAKEUP or OMAP_DEVICE_PAD_REMUX, these</span>
<span class="cm"> * entries are NOT COUNTED in the dynamic pad index.  This function</span>
<span class="cm"> * must be called separately for each pad that requires its interrupt</span>
<span class="cm"> * to be re-routed this way.  Returns -EINVAL if there is an argument</span>
<span class="cm"> * problem or if @oh does not have hwmod mux entries or MPU IRQs;</span>
<span class="cm"> * returns -ENOMEM if memory cannot be allocated; or 0 upon success.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX This function interface is fragile.  Rather than using array</span>
<span class="cm"> * indexes, which are subject to unpredictable change, it should be</span>
<span class="cm"> * using hwmod IRQ names, and some other stable key for the hwmod mux</span>
<span class="cm"> * pad records.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_hwmod_pad_route_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad_idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_irqs</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span> <span class="o">||</span> <span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span> <span class="o">||</span> <span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mpu_irqs</span> <span class="o">||</span> <span class="n">pad_idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">pad_idx</span> <span class="o">&gt;=</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">nr_pads_dynamic</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Check the number of available mpu_irqs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">nr_irqs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">mpu_irqs</span><span class="p">[</span><span class="n">nr_irqs</span><span class="p">].</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nr_irqs</span><span class="o">++</span><span class="p">)</span>
		<span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_idx</span> <span class="o">&gt;=</span> <span class="n">nr_irqs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">irqs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* XXX What frees this? */</span>
		<span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">irqs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">nr_pads_dynamic</span><span class="p">,</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">irqs</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span><span class="o">-&gt;</span><span class="n">irqs</span><span class="p">[</span><span class="n">pad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">irq_idx</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
