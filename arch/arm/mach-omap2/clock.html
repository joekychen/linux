<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mach-omap2 › clock.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>clock.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/arch/arm/mach-omap2/clock.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2005-2008 Texas Instruments, Inc.</span>
<span class="cm"> *  Copyright (C) 2004-2010 Nokia Corporation</span>
<span class="cm"> *</span>
<span class="cm"> *  Contacts:</span>
<span class="cm"> *  Richard Woodruff &lt;r-woodruff2@ti.com&gt;</span>
<span class="cm"> *  Paul Walmsley</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>
<span class="cp">#undef DEBUG</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;trace/events/power.h&gt;</span>

<span class="cp">#include &lt;asm/cpu.h&gt;</span>
<span class="cp">#include &lt;plat/clock.h&gt;</span>
<span class="cp">#include &quot;clockdomain.h&quot;</span>
<span class="cp">#include &lt;plat/cpu.h&gt;</span>
<span class="cp">#include &lt;plat/prcm.h&gt;</span>

<span class="cp">#include &quot;clock.h&quot;</span>
<span class="cp">#include &quot;cm2xxx_3xxx.h&quot;</span>
<span class="cp">#include &quot;cm-regbits-24xx.h&quot;</span>
<span class="cp">#include &quot;cm-regbits-34xx.h&quot;</span>

<span class="n">u16</span> <span class="n">cpu_mask</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * clkdm_control: if true, then when a clock is enabled in the</span>
<span class="cm"> * hardware, its clockdomain will first be enabled; and when a clock</span>
<span class="cm"> * is disabled in the hardware, its clockdomain will be disabled</span>
<span class="cm"> * afterwards.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">clkdm_control</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * OMAP2+ specific clock functions</span>
<span class="cm"> */</span>

<span class="cm">/* Private functions */</span>

<span class="cm">/**</span>
<span class="cm"> * _omap2_module_wait_ready - wait for an OMAP module to leave IDLE</span>
<span class="cm"> * @clk: struct clk * belonging to the module</span>
<span class="cm"> *</span>
<span class="cm"> * If the necessary clocks for the OMAP hardware IP block that</span>
<span class="cm"> * corresponds to clock @clk are enabled, then wait for the module to</span>
<span class="cm"> * indicate readiness (i.e., to leave IDLE).  This code does not</span>
<span class="cm"> * belong in the clock code and will be moved in the medium term to</span>
<span class="cm"> * module-dependent code.  No return value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_omap2_module_wait_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">companion_reg</span><span class="p">,</span> <span class="o">*</span><span class="n">idlest_reg</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">other_bit</span><span class="p">,</span> <span class="n">idlest_bit</span><span class="p">,</span> <span class="n">idlest_val</span><span class="p">;</span>

	<span class="cm">/* Not all modules have multiple clocks that their IDLEST depends on */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">find_companion</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">find_companion</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">companion_reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">other_bit</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">companion_reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">other_bit</span><span class="p">)))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">find_idlest</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idlest_reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idlest_bit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idlest_val</span><span class="p">);</span>

	<span class="n">omap2_cm_wait_idlest</span><span class="p">(</span><span class="n">idlest_reg</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">idlest_bit</span><span class="p">),</span> <span class="n">idlest_val</span><span class="p">,</span>
			     <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Public functions */</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_init_clk_clkdm - look up a clockdomain name, store pointer in clk</span>
<span class="cm"> * @clk: OMAP clock struct ptr to use</span>
<span class="cm"> *</span>
<span class="cm"> * Convert a clockdomain name stored in a struct clk &#39;clk&#39; into a</span>
<span class="cm"> * clockdomain pointer, and save it into the struct clk.  Intended to be</span>
<span class="cm"> * called during clk_register().  No return value.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">omap2_init_clk_clkdm</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clockdomain</span> <span class="o">*</span><span class="n">clkdm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clkdm_name</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">clkdm</span> <span class="o">=</span> <span class="n">clkdm_lookup</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clkdm_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clkdm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: associated clk %s to clkdm %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">clkdm_name</span><span class="p">);</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">clkdm</span> <span class="o">=</span> <span class="n">clkdm</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: could not associate clk %s to &quot;</span>
			 <span class="s">&quot;clkdm %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">clkdm_name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_clk_disable_clkdm_control - disable clkdm control on clk enable/disable</span>
<span class="cm"> *</span>
<span class="cm"> * Prevent the OMAP clock code from calling into the clockdomain code</span>
<span class="cm"> * when a hardware clock in that clockdomain is enabled or disabled.</span>
<span class="cm"> * Intended to be called at init time from omap*_clk_init().  No</span>
<span class="cm"> * return value.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">omap2_clk_disable_clkdm_control</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clkdm_control</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_clk_dflt_find_companion - find companion clock to @clk</span>
<span class="cm"> * @clk: struct clk * to find the companion clock of</span>
<span class="cm"> * @other_reg: void __iomem ** to return the companion clock CM_*CLKEN va in</span>
<span class="cm"> * @other_bit: u8 ** to return the companion clock bit shift in</span>
<span class="cm"> *</span>
<span class="cm"> * Note: We don&#39;t need special code here for INVERT_ENABLE for the</span>
<span class="cm"> * time being since INVERT_ENABLE only applies to clocks enabled by</span>
<span class="cm"> * CM_CLKEN_PLL</span>
<span class="cm"> *</span>
<span class="cm"> * Convert CM_ICLKEN* &lt;-&gt; CM_FCLKEN*.  This conversion assumes it&#39;s</span>
<span class="cm"> * just a matter of XORing the bits.</span>
<span class="cm"> *</span>
<span class="cm"> * Some clocks don&#39;t have companion clocks.  For example, modules with</span>
<span class="cm"> * only an interface clock (such as MAILBOXES) don&#39;t have a companion</span>
<span class="cm"> * clock.  Right now, this code relies on the hardware exporting a bit</span>
<span class="cm"> * in the correct companion register that indicates that the</span>
<span class="cm"> * nonexistent &#39;companion clock&#39; is active.  Future patches will</span>
<span class="cm"> * associate this type of code with per-module data structures to</span>
<span class="cm"> * avoid this issue, and remove the casts.  No return value.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">omap2_clk_dflt_find_companion</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">**</span><span class="n">other_reg</span><span class="p">,</span>
				   <span class="n">u8</span> <span class="o">*</span><span class="n">other_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">r</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Convert CM_ICLKEN* &lt;-&gt; CM_FCLKEN*.  This conversion assumes</span>
<span class="cm">	 * it&#39;s just a matter of XORing the bits.</span>
<span class="cm">	 */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="p">((</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_reg</span> <span class="o">^</span> <span class="p">(</span><span class="n">CM_FCLKEN</span> <span class="o">^</span> <span class="n">CM_ICLKEN</span><span class="p">));</span>

	<span class="o">*</span><span class="n">other_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">;</span>
	<span class="o">*</span><span class="n">other_bit</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_bit</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_clk_dflt_find_idlest - find CM_IDLEST reg va, bit shift for @clk</span>
<span class="cm"> * @clk: struct clk * to find IDLEST info for</span>
<span class="cm"> * @idlest_reg: void __iomem ** to return the CM_IDLEST va in</span>
<span class="cm"> * @idlest_bit: u8 * to return the CM_IDLEST bit shift in</span>
<span class="cm"> * @idlest_val: u8 * to return the idle status indicator</span>
<span class="cm"> *</span>
<span class="cm"> * Return the CM_IDLEST register address and bit shift corresponding</span>
<span class="cm"> * to the module that &quot;owns&quot; this clock.  This default code assumes</span>
<span class="cm"> * that the CM_IDLEST bit shift is the CM_*CLKEN bit shift, and that</span>
<span class="cm"> * the IDLEST register address ID corresponds to the CM_*CLKEN</span>
<span class="cm"> * register address ID (e.g., that CM_FCLKEN2 corresponds to</span>
<span class="cm"> * CM_IDLEST2).  This is not true for all modules.  No return value.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">omap2_clk_dflt_find_idlest</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">**</span><span class="n">idlest_reg</span><span class="p">,</span>
				<span class="n">u8</span> <span class="o">*</span><span class="n">idlest_bit</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">idlest_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="p">(((</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_reg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xf0</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x20</span><span class="p">);</span>
	<span class="o">*</span><span class="n">idlest_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">;</span>
	<span class="o">*</span><span class="n">idlest_bit</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_bit</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 24xx uses 0 to indicate not ready, and 1 to indicate ready.</span>
<span class="cm">	 * 34xx reverses this, just to keep us on our toes</span>
<span class="cm">	 * AM35xx uses both, depending on the module.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_omap24xx</span><span class="p">())</span>
		<span class="o">*</span><span class="n">idlest_val</span> <span class="o">=</span> <span class="n">OMAP24XX_CM_IDLEST_VAL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_omap34xx</span><span class="p">())</span>
		<span class="o">*</span><span class="n">idlest_val</span> <span class="o">=</span> <span class="n">OMAP34XX_CM_IDLEST_VAL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">omap2_dflt_clk_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_reg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;clock.c: Enable for %s without enable code</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* REVISIT: -EINVAL */</span>
	<span class="p">}</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">INVERT_ENABLE</span><span class="p">)</span>
		<span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_bit</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">v</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_bit</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_reg</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_reg</span><span class="p">);</span> <span class="cm">/* OCP barrier */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">find_idlest</span><span class="p">)</span>
		<span class="n">_omap2_module_wait_ready</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">omap2_dflt_clk_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * &#39;Independent&#39; here refers to a clock which is not</span>
<span class="cm">		 * controlled by its parent.</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;clock: clk_disable called on independent &quot;</span>
		       <span class="s">&quot;clock %s which has no enable_reg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">INVERT_ENABLE</span><span class="p">)</span>
		<span class="n">v</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_bit</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_bit</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_reg</span><span class="p">);</span>
	<span class="cm">/* No OCP barrier needed here since it is a disable operation */</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">clkops</span> <span class="n">clkops_omap2_dflt_wait</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">enable</span>		<span class="o">=</span> <span class="n">omap2_dflt_clk_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable</span>	<span class="o">=</span> <span class="n">omap2_dflt_clk_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">find_companion</span>	<span class="o">=</span> <span class="n">omap2_clk_dflt_find_companion</span><span class="p">,</span>
	<span class="p">.</span><span class="n">find_idlest</span>	<span class="o">=</span> <span class="n">omap2_clk_dflt_find_idlest</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">clkops</span> <span class="n">clkops_omap2_dflt</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">enable</span>		<span class="o">=</span> <span class="n">omap2_dflt_clk_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable</span>	<span class="o">=</span> <span class="n">omap2_dflt_clk_disable</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_clk_disable - disable a clock, if the system is not using it</span>
<span class="cm"> * @clk: struct clk * to disable</span>
<span class="cm"> *</span>
<span class="cm"> * Decrements the usecount on struct clk @clk.  If there are no users</span>
<span class="cm"> * left, call the clkops-specific clock disable function to disable it</span>
<span class="cm"> * in hardware.  If the clock is part of a clockdomain (which they all</span>
<span class="cm"> * should be), request that the clockdomain be disabled.  (It too has</span>
<span class="cm"> * a usecount, and so will not be disabled in the hardware until it no</span>
<span class="cm"> * longer has any users.)  If the clock has a parent clock (most of</span>
<span class="cm"> * them do), then call ourselves, recursing on the parent clock.  This</span>
<span class="cm"> * can cause an entire branch of the clock tree to be powered off by</span>
<span class="cm"> * simply disabling one clock.  Intended to be called with the clockfw_lock</span>
<span class="cm"> * spinlock held.  No return value.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">omap2_clk_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">usecount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;clock: %s: omap2_clk_disable() called, but usecount &quot;</span>
		     <span class="s">&quot;already 0?&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: %s: decrementing usecount</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">usecount</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">usecount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: %s: disabling in hardware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">&amp;&amp;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">disable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_clock_disable</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">disable</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clkdm_control</span> <span class="o">&amp;&amp;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">)</span>
		<span class="n">clkdm_clk_disable</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">,</span> <span class="n">clk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">omap2_clk_disable</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_clk_enable - request that the system enable a clock</span>
<span class="cm"> * @clk: struct clk * to enable</span>
<span class="cm"> *</span>
<span class="cm"> * Increments the usecount on struct clk @clk.  If there were no users</span>
<span class="cm"> * previously, then recurse up the clock tree, enabling all of the</span>
<span class="cm"> * clock&#39;s parents and all of the parent clockdomains, and finally,</span>
<span class="cm"> * enabling @clk&#39;s clockdomain, and @clk itself.  Intended to be</span>
<span class="cm"> * called with the clockfw_lock spinlock held.  Returns 0 upon success</span>
<span class="cm"> * or a negative error code upon failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap2_clk_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: %s: incrementing usecount</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">usecount</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">usecount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: %s: enabling in hardware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">omap2_clk_enable</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;clock: %s: could not enable parent %s: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">oce_err1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clkdm_control</span> <span class="o">&amp;&amp;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">clkdm_clk_enable</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">,</span> <span class="n">clk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;clock: %s: could not enable clockdomain %s: &quot;</span>
			     <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">oce_err2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">&amp;&amp;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_clock_enable</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;clock: %s: could not enable: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">oce_err3</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">oce_err3:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clkdm_control</span> <span class="o">&amp;&amp;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">)</span>
		<span class="n">clkdm_clk_disable</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="p">,</span> <span class="n">clk</span><span class="p">);</span>
<span class="nl">oce_err2:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">omap2_clk_disable</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
<span class="nl">oce_err1:</span>
	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">usecount</span><span class="o">--</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Given a clock and a rate apply a clock specific rounding function */</span>
<span class="kt">long</span> <span class="nf">omap2_clk_round_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">round_rate</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">round_rate</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set the clock rate for a clock source */</span>
<span class="kt">int</span> <span class="nf">omap2_clk_set_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: set_rate for clock %s to rate %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>

	<span class="cm">/* dpll_ck, core_ck, virt_prcm_set; plus all clksel clocks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">set_rate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_clock_set_rate</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">set_rate</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">omap2_clk_set_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">new_parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">new_parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">omap2_clksel_set_parent</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">new_parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* OMAP3/4 non-CORE DPLL clkops */</span>

<span class="cp">#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_ARCH_OMAP4)</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">clkops</span> <span class="n">clkops_omap3_noncore_dpll_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">enable</span>		<span class="o">=</span> <span class="n">omap3_noncore_dpll_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable</span>	<span class="o">=</span> <span class="n">omap3_noncore_dpll_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">allow_idle</span>	<span class="o">=</span> <span class="n">omap3_dpll_allow_idle</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deny_idle</span>	<span class="o">=</span> <span class="n">omap3_dpll_deny_idle</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">clkops</span> <span class="n">clkops_omap3_core_dpll_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">allow_idle</span>	<span class="o">=</span> <span class="n">omap3_dpll_allow_idle</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deny_idle</span>	<span class="o">=</span> <span class="n">omap3_dpll_deny_idle</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * OMAP2+ clock reset and init functions</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_OMAP_RESET_CLOCKS</span>
<span class="kt">void</span> <span class="nf">omap2_clk_disable_unused</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">regval32</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">INVERT_ENABLE</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_bit</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">regval32</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">regval32</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">enable_bit</span><span class="p">))</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Disabling unused clock </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_omap34xx</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">omap2_clk_enable</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
		<span class="n">omap2_clk_disable</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">disable</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clkdm</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">pwrdm_state_switch</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clkdm</span><span class="o">-&gt;</span><span class="n">pwrdm</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_clk_switch_mpurate_at_boot - switch ARM MPU rate by boot-time argument</span>
<span class="cm"> * @mpurate_ck_name: clk name of the clock to change rate</span>
<span class="cm"> *</span>
<span class="cm"> * Change the ARM MPU clock rate to the rate specified on the command</span>
<span class="cm"> * line, if one was specified.  @mpurate_ck_name should be</span>
<span class="cm"> * &quot;virt_prcm_set&quot; on OMAP2xxx and &quot;dpll1_ck&quot; on OMAP34xx/OMAP36xx.</span>
<span class="cm"> * XXX Does not handle voltage scaling - on OMAP2xxx this is currently</span>
<span class="cm"> * handled by the virt_prcm_set clock, but this should be handled by</span>
<span class="cm"> * the OPP layer.  XXX This is intended to be handled by the OPP layer</span>
<span class="cm"> * code in the near future and should be removed from the clock code.</span>
<span class="cm"> * Returns -EINVAL if &#39;mpurate&#39; is zero or if clk_set_rate() rejects</span>
<span class="cm"> * the rate, -ENOENT if the struct clk referred to by @mpurate_ck_name</span>
<span class="cm"> * cannot be found, or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">omap2_clk_switch_mpurate_at_boot</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mpurate_ck_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">mpurate_ck</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mpurate</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mpurate_ck</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mpurate_ck_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mpurate_ck</span><span class="p">),</span> <span class="s">&quot;Failed to get %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mpurate_ck_name</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">clk_set_rate</span><span class="p">(</span><span class="n">mpurate_ck</span><span class="p">,</span> <span class="n">mpurate</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;clock: %s: unable to set MPU rate to %d: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">mpurate_ck</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mpurate</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">mpurate_ck</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">calibrate_delay</span><span class="p">();</span>
	<span class="n">recalculate_root_clocks</span><span class="p">();</span>

	<span class="n">clk_put</span><span class="p">(</span><span class="n">mpurate_ck</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_clk_print_new_rates - print summary of current clock tree rates</span>
<span class="cm"> * @hfclkin_ck_name: clk name for the off-chip HF oscillator</span>
<span class="cm"> * @core_ck_name: clk name for the on-chip CORE_CLK</span>
<span class="cm"> * @mpu_ck_name: clk name for the ARM MPU clock</span>
<span class="cm"> *</span>
<span class="cm"> * Prints a short message to the console with the HFCLKIN oscillator</span>
<span class="cm"> * rate, the rate of the CORE clock, and the rate of the ARM MPU clock.</span>
<span class="cm"> * Called by the boot-time MPU rate switching code.   XXX This is intended</span>
<span class="cm"> * to be handled by the OPP layer code in the near future and should be</span>
<span class="cm"> * removed from the clock code.  No return value.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">omap2_clk_print_new_rates</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hfclkin_ck_name</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">core_ck_name</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mpu_ck_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">hfclkin_ck</span><span class="p">,</span> <span class="o">*</span><span class="n">core_ck</span><span class="p">,</span> <span class="o">*</span><span class="n">mpu_ck</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hfclkin_rate</span><span class="p">;</span>

	<span class="n">mpu_ck</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mpu_ck_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mpu_ck</span><span class="p">),</span> <span class="s">&quot;clock: failed to get %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mpu_ck_name</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">core_ck</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">core_ck_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">core_ck</span><span class="p">),</span> <span class="s">&quot;clock: failed to get %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">core_ck_name</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">hfclkin_ck</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">hfclkin_ck_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hfclkin_ck</span><span class="p">),</span> <span class="s">&quot;Failed to get %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hfclkin_ck_name</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">hfclkin_rate</span> <span class="o">=</span> <span class="n">clk_get_rate</span><span class="p">(</span><span class="n">hfclkin_ck</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Switched to new clocking rate (Crystal/Core/MPU): &quot;</span>
		<span class="s">&quot;%ld.%01ld/%ld/%ld MHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">hfclkin_rate</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">),</span>
		<span class="p">((</span><span class="n">hfclkin_rate</span> <span class="o">/</span> <span class="mi">100000</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">),</span>
		<span class="p">(</span><span class="n">clk_get_rate</span><span class="p">(</span><span class="n">core_ck</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">),</span>
		<span class="p">(</span><span class="n">clk_get_rate</span><span class="p">(</span><span class="n">mpu_ck</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Common data */</span>

<span class="k">struct</span> <span class="n">clk_functions</span> <span class="n">omap2_clk_functions</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">clk_enable</span>		<span class="o">=</span> <span class="n">omap2_clk_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clk_disable</span>		<span class="o">=</span> <span class="n">omap2_clk_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clk_round_rate</span>		<span class="o">=</span> <span class="n">omap2_clk_round_rate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clk_set_rate</span>		<span class="o">=</span> <span class="n">omap2_clk_set_rate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clk_set_parent</span>		<span class="o">=</span> <span class="n">omap2_clk_set_parent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clk_disable_unused</span>	<span class="o">=</span> <span class="n">omap2_clk_disable_unused</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
