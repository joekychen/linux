<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mach-omap2 › clkt_clksel.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>clkt_clksel.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * clkt_clksel.c - OMAP2/3/4 clksel clock functions</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2008 Texas Instruments, Inc.</span>
<span class="cm"> * Copyright (C) 2004-2010 Nokia Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Contacts:</span>
<span class="cm"> * Richard Woodruff &lt;r-woodruff2@ti.com&gt;</span>
<span class="cm"> * Paul Walmsley</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * clksel clocks are clocks that do not have a fixed parent, or that</span>
<span class="cm"> * can divide their parent&#39;s rate, or possibly both at the same time, based</span>
<span class="cm"> * on the contents of a hardware register bitfield.</span>
<span class="cm"> *</span>
<span class="cm"> * All of the various mux and divider settings can be encoded into</span>
<span class="cm"> * struct clksel* data structures, and then these can be autogenerated</span>
<span class="cm"> * from some hardware database for each new chip generation.  This</span>
<span class="cm"> * should avoid the need to write, review, and validate a lot of new</span>
<span class="cm"> * clock code for each new chip, since it can be exported from the SoC</span>
<span class="cm"> * design flow.  This is now done on OMAP4.</span>
<span class="cm"> *</span>
<span class="cm"> * The fusion of mux and divider clocks is a software creation.  In</span>
<span class="cm"> * hardware reality, the multiplexer (parent selection) and the</span>
<span class="cm"> * divider exist separately.  XXX At some point these clksel clocks</span>
<span class="cm"> * should be split into &quot;divider&quot; clocks and &quot;mux&quot; clocks to better</span>
<span class="cm"> * match the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * (The name &quot;clksel&quot; comes from the name of the corresponding</span>
<span class="cm"> * register field in the OMAP2/3 family of SoCs.)</span>
<span class="cm"> *</span>
<span class="cm"> * XXX Currently these clocks are only used in the OMAP2/3/4 code, but</span>
<span class="cm"> * many of the OMAP1 clocks should be convertible to use this</span>
<span class="cm"> * mechanism.</span>
<span class="cm"> */</span>
<span class="cp">#undef DEBUG</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>

<span class="cp">#include &lt;plat/clock.h&gt;</span>

<span class="cp">#include &quot;clock.h&quot;</span>

<span class="cm">/* Private functions */</span>

<span class="cm">/**</span>
<span class="cm"> * _get_clksel_by_parent() - return clksel struct for a given clk &amp; parent</span>
<span class="cm"> * @clk: OMAP struct clk ptr to inspect</span>
<span class="cm"> * @src_clk: OMAP struct clk ptr of the parent clk to search for</span>
<span class="cm"> *</span>
<span class="cm"> * Scan the struct clksel array associated with the clock to find</span>
<span class="cm"> * the element associated with the supplied parent clock address.</span>
<span class="cm"> * Returns a pointer to the struct clksel on success or NULL on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">clksel</span> <span class="o">*</span><span class="nf">_get_clksel_by_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">src_clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">clksel</span> <span class="o">*</span><span class="n">clks</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">clks</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel</span><span class="p">;</span> <span class="n">clks</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span> <span class="n">clks</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clks</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">src_clk</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span> <span class="cm">/* Found the requested parent */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clks</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This indicates a data problem */</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;clock: Could not find parent clock %s in clksel array &quot;</span>
		     <span class="s">&quot;of clock %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">src_clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">clks</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _get_div_and_fieldval() - find the new clksel divisor and field value to use</span>
<span class="cm"> * @src_clk: planned new parent struct clk *</span>
<span class="cm"> * @clk: struct clk * that is being reparented</span>
<span class="cm"> * @field_val: pointer to a u32 to contain the register data for the divisor</span>
<span class="cm"> *</span>
<span class="cm"> * Given an intended new parent struct clk * @src_clk, and the struct</span>
<span class="cm"> * clk * @clk to the clock that is being reparented, find the</span>
<span class="cm"> * appropriate rate divisor for the new clock (returned as the return</span>
<span class="cm"> * value), and the corresponding register bitfield data to program to</span>
<span class="cm"> * reach that divisor (returned in the u32 pointed to by @field_val).</span>
<span class="cm"> * Returns 0 on error, or returns the newly-selected divisor upon</span>
<span class="cm"> * success (in this latter case, the corresponding register bitfield</span>
<span class="cm"> * value is passed back in the variable pointed to by @field_val)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">_get_div_and_fieldval</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">src_clk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span>
				<span class="n">u32</span> <span class="o">*</span><span class="n">field_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">clksel</span> <span class="o">*</span><span class="n">clks</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">clksel_rate</span> <span class="o">*</span><span class="n">clkr</span><span class="p">,</span> <span class="o">*</span><span class="n">max_clkr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_div</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">clks</span> <span class="o">=</span> <span class="n">_get_clksel_by_parent</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">src_clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clks</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the highest divisor (e.g., the one resulting in the</span>
<span class="cm">	 * lowest rate) to use as the default.  This should avoid</span>
<span class="cm">	 * clock rates that are too high for the device.  XXX A better</span>
<span class="cm">	 * solution here would be to try to determine if there is a</span>
<span class="cm">	 * divisor matching the original clock rate before the parent</span>
<span class="cm">	 * switch, and if it cannot be found, to fall back to the</span>
<span class="cm">	 * highest divisor.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">clkr</span> <span class="o">=</span> <span class="n">clks</span><span class="o">-&gt;</span><span class="n">rates</span><span class="p">;</span> <span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span><span class="p">;</span> <span class="n">clkr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">clkr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">cpu_mask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span> <span class="o">&gt;</span> <span class="n">max_div</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">max_div</span> <span class="o">=</span> <span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span><span class="p">;</span>
			<span class="n">max_clkr</span> <span class="o">=</span> <span class="n">clkr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_div</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This indicates an error in the clksel data */</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;clock: Could not find divisor for clock %s parent %s&quot;</span>
		     <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">src_clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">field_val</span> <span class="o">=</span> <span class="n">max_clkr</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">max_div</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _write_clksel_reg() - program a clock&#39;s clksel register in hardware</span>
<span class="cm"> * @clk: struct clk * to program</span>
<span class="cm"> * @v: clksel bitfield value to program (with LSB at bit 0)</span>
<span class="cm"> *</span>
<span class="cm"> * Shift the clksel register bitfield value @v to its appropriate</span>
<span class="cm"> * location in the clksel register and write it in.  This function</span>
<span class="cm"> * will ensure that the write to the clksel_reg reaches its</span>
<span class="cm"> * destination before returning -- important since PRM and CM register</span>
<span class="cm"> * accesses can be quite slow compared to ARM cycles -- but does not</span>
<span class="cm"> * take into account any time the hardware might take to switch the</span>
<span class="cm"> * clock source.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_write_clksel_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_reg</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_mask</span><span class="p">;</span>
	<span class="n">v</span> <span class="o">|=</span> <span class="n">field_val</span> <span class="o">&lt;&lt;</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_mask</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_reg</span><span class="p">);</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_reg</span><span class="p">);</span> <span class="cm">/* OCP barrier */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _clksel_to_divisor() - turn clksel field value into integer divider</span>
<span class="cm"> * @clk: OMAP struct clk to use</span>
<span class="cm"> * @field_val: register field value to find</span>
<span class="cm"> *</span>
<span class="cm"> * Given a struct clk of a rate-selectable clksel clock, and a register field</span>
<span class="cm"> * value to search for, find the corresponding clock divisor.  The register</span>
<span class="cm"> * field value should be pre-masked and shifted down so the LSB is at bit 0</span>
<span class="cm"> * before calling.  Returns 0 on error or returns the actual integer divisor</span>
<span class="cm"> * upon success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">_clksel_to_divisor</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">clksel</span> <span class="o">*</span><span class="n">clks</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">clksel_rate</span> <span class="o">*</span><span class="n">clkr</span><span class="p">;</span>

	<span class="n">clks</span> <span class="o">=</span> <span class="n">_get_clksel_by_parent</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clks</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">clkr</span> <span class="o">=</span> <span class="n">clks</span><span class="o">-&gt;</span><span class="n">rates</span><span class="p">;</span> <span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span><span class="p">;</span> <span class="n">clkr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">clkr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">cpu_mask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">clkr</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">field_val</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This indicates a data error */</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;clock: Could not find fieldval %d for clock %s parent &quot;</span>
		     <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field_val</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _divisor_to_clksel() - turn clksel integer divisor into a field value</span>
<span class="cm"> * @clk: OMAP struct clk to use</span>
<span class="cm"> * @div: integer divisor to search for</span>
<span class="cm"> *</span>
<span class="cm"> * Given a struct clk of a rate-selectable clksel clock, and a clock</span>
<span class="cm"> * divisor, find the corresponding register field value.  Returns the</span>
<span class="cm"> * register field value _before_ left-shifting (i.e., LSB is at bit</span>
<span class="cm"> * 0); or returns 0xFFFFFFFF (~0) upon error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">_divisor_to_clksel</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">div</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">clksel</span> <span class="o">*</span><span class="n">clks</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">clksel_rate</span> <span class="o">*</span><span class="n">clkr</span><span class="p">;</span>

	<span class="cm">/* should never happen */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">div</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">clks</span> <span class="o">=</span> <span class="n">_get_clksel_by_parent</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clks</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">clkr</span> <span class="o">=</span> <span class="n">clks</span><span class="o">-&gt;</span><span class="n">rates</span><span class="p">;</span> <span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span><span class="p">;</span> <span class="n">clkr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">clkr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">cpu_mask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span> <span class="o">==</span> <span class="n">div</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;clock: Could not find divisor %d for clock %s parent &quot;</span>
		       <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">div</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">clkr</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _read_divisor() - get current divisor applied to parent clock (from hdwr)</span>
<span class="cm"> * @clk: OMAP struct clk to use.</span>
<span class="cm"> *</span>
<span class="cm"> * Read the current divisor register value for @clk that is programmed</span>
<span class="cm"> * into the hardware, convert it into the actual divisor value, and</span>
<span class="cm"> * return it; or return 0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">_read_divisor</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel</span> <span class="o">||</span> <span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_reg</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">&amp;=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_mask</span><span class="p">;</span>
	<span class="n">v</span> <span class="o">&gt;&gt;=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">_clksel_to_divisor</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Public functions */</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_clksel_round_rate_div() - find divisor for the given clock and rate</span>
<span class="cm"> * @clk: OMAP struct clk to use</span>
<span class="cm"> * @target_rate: desired clock rate</span>
<span class="cm"> * @new_div: ptr to where we should store the divisor</span>
<span class="cm"> *</span>
<span class="cm"> * Finds &#39;best&#39; divider value in an array based on the source and target</span>
<span class="cm"> * rates.  The divider array must be sorted with smallest divider first.</span>
<span class="cm"> * This function is also used by the DPLL3 M2 divider code.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the rounded clock rate or returns 0xffffffff on error.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">omap2_clksel_round_rate_div</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">target_rate</span><span class="p">,</span>
				<span class="n">u32</span> <span class="o">*</span><span class="n">new_div</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">test_rate</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">clksel</span> <span class="o">*</span><span class="n">clks</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">clksel_rate</span> <span class="o">*</span><span class="n">clkr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_div</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel</span> <span class="o">||</span> <span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: clksel_round_rate_div: %s target_rate %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">target_rate</span><span class="p">);</span>

	<span class="o">*</span><span class="n">new_div</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">clks</span> <span class="o">=</span> <span class="n">_get_clksel_by_parent</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clks</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">clkr</span> <span class="o">=</span> <span class="n">clks</span><span class="o">-&gt;</span><span class="n">rates</span><span class="p">;</span> <span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span><span class="p">;</span> <span class="n">clkr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">clkr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">cpu_mask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Sanity check */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span> <span class="o">&lt;=</span> <span class="n">last_div</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;clock: clksel_rate table not sorted &quot;</span>
			       <span class="s">&quot;for clock %s&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="n">last_div</span> <span class="o">=</span> <span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span><span class="p">;</span>

		<span class="n">test_rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">/</span> <span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_rate</span> <span class="o">&lt;=</span> <span class="n">target_rate</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span> <span class="cm">/* found it */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;clock: Could not find divisor for target &quot;</span>
		       <span class="s">&quot;rate %ld for clock %s parent %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">target_rate</span><span class="p">,</span>
		       <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">new_div</span> <span class="o">=</span> <span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: new_div = %d, new_rate = %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">new_div</span><span class="p">,</span>
		 <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">/</span> <span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">/</span> <span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clocktype interface functions to the OMAP clock code</span>
<span class="cm"> * (i.e., those used in struct clk field function pointers, etc.)</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_init_clksel_parent() - set a clksel clk&#39;s parent field from the hdwr</span>
<span class="cm"> * @clk: OMAP clock struct ptr to use</span>
<span class="cm"> *</span>
<span class="cm"> * Given a pointer @clk to a source-selectable struct clk, read the</span>
<span class="cm"> * hardware register and determine what its parent is currently set</span>
<span class="cm"> * to.  Update @clk&#39;s .parent field with the appropriate clk ptr.  No</span>
<span class="cm"> * return value.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">omap2_init_clksel_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">clksel</span> <span class="o">*</span><span class="n">clks</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">clksel_rate</span> <span class="o">*</span><span class="n">clkr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">r</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel</span> <span class="o">||</span> <span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_mask</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_mask</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">&gt;&gt;=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_mask</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">clks</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel</span><span class="p">;</span> <span class="n">clks</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">found</span><span class="p">;</span> <span class="n">clks</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">clkr</span> <span class="o">=</span> <span class="n">clks</span><span class="o">-&gt;</span><span class="n">rates</span><span class="p">;</span> <span class="n">clkr</span><span class="o">-&gt;</span><span class="n">div</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">found</span><span class="p">;</span> <span class="n">clkr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">clkr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">cpu_mask</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">clkr</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">clks</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: inited %s parent &quot;</span>
						 <span class="s">&quot;to %s (was %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						 <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">clks</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
						 <span class="p">((</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="o">?</span>
						  <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;NULL&quot;</span><span class="p">));</span>
					<span class="n">clk_reparent</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">clks</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
				<span class="p">};</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* This indicates a data error */</span>
	<span class="n">WARN</span><span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">,</span> <span class="s">&quot;clock: %s: init parent: could not find regval %0x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_clksel_recalc() - function ptr to pass via struct clk .recalc field</span>
<span class="cm"> * @clk: struct clk *</span>
<span class="cm"> *</span>
<span class="cm"> * This function is intended to be called only by the clock framework.</span>
<span class="cm"> * Each clksel clock should have its struct clk .recalc field set to this</span>
<span class="cm"> * function.  Returns the clock&#39;s current rate, based on its parent&#39;s rate</span>
<span class="cm"> * and its current divisor setting in the hardware.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">omap2_clksel_recalc</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">div</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">div</span> <span class="o">=</span> <span class="n">_read_divisor</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">div</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>

	<span class="n">rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">/</span> <span class="n">div</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: %s: recalc&#39;d rate is %ld (div %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		 <span class="n">rate</span><span class="p">,</span> <span class="n">div</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rate</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_clksel_round_rate() - find rounded rate for the given clock and rate</span>
<span class="cm"> * @clk: OMAP struct clk to use</span>
<span class="cm"> * @target_rate: desired clock rate</span>
<span class="cm"> *</span>
<span class="cm"> * This function is intended to be called only by the clock framework.</span>
<span class="cm"> * Finds best target rate based on the source clock and possible dividers.</span>
<span class="cm"> * rates. The divider array must be sorted with smallest divider first.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the rounded clock rate or returns 0xffffffff on error.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">omap2_clksel_round_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">target_rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">new_div</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">omap2_clksel_round_rate_div</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">target_rate</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_div</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_clksel_set_rate() - program clock rate in hardware</span>
<span class="cm"> * @clk: struct clk * to program rate</span>
<span class="cm"> * @rate: target rate to program</span>
<span class="cm"> *</span>
<span class="cm"> * This function is intended to be called only by the clock framework.</span>
<span class="cm"> * Program @clk&#39;s rate to @rate in the hardware.  The clock can be</span>
<span class="cm"> * either enabled or disabled when this happens, although if the clock</span>
<span class="cm"> * is enabled, some downstream devices may glitch or behave</span>
<span class="cm"> * unpredictably when the clock rate is changed - this depends on the</span>
<span class="cm"> * hardware. This function does not currently check the usecount of</span>
<span class="cm"> * the clock, so if multiple drivers are using the clock, and the rate</span>
<span class="cm"> * is changed, they will all be affected without any notification.</span>
<span class="cm"> * Returns -EINVAL upon error, or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap2_clksel_set_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">field_val</span><span class="p">,</span> <span class="n">validrate</span><span class="p">,</span> <span class="n">new_div</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel</span> <span class="o">||</span> <span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">validrate</span> <span class="o">=</span> <span class="n">omap2_clksel_round_rate_div</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_div</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">validrate</span> <span class="o">!=</span> <span class="n">rate</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">field_val</span> <span class="o">=</span> <span class="n">_divisor_to_clksel</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">new_div</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">field_val</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">_write_clksel_reg</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">field_val</span><span class="p">);</span>

	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">/</span> <span class="n">new_div</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: %s: set rate to %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clksel parent setting function - not passed in struct clk function</span>
<span class="cm"> * pointer - instead, the OMAP clock code currently assumes that any</span>
<span class="cm"> * parent-setting clock is a clksel clock, and calls</span>
<span class="cm"> * omap2_clksel_set_parent() by default</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * omap2_clksel_set_parent() - change a clock&#39;s parent clock</span>
<span class="cm"> * @clk: struct clk * of the child clock</span>
<span class="cm"> * @new_parent: struct clk * of the new parent clock</span>
<span class="cm"> *</span>
<span class="cm"> * This function is intended to be called only by the clock framework.</span>
<span class="cm"> * Change the parent clock of clock @clk to @new_parent.  This is</span>
<span class="cm"> * intended to be used while @clk is disabled.  This function does not</span>
<span class="cm"> * currently check the usecount of the clock, so if multiple drivers</span>
<span class="cm"> * are using the clock, and the parent is changed, they will all be</span>
<span class="cm"> * affected without any notification.  Returns -EINVAL upon error, or</span>
<span class="cm"> * 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap2_clksel_set_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">new_parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">field_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">parent_div</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel</span> <span class="o">||</span> <span class="o">!</span><span class="n">clk</span><span class="o">-&gt;</span><span class="n">clksel_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">parent_div</span> <span class="o">=</span> <span class="n">_get_div_and_fieldval</span><span class="p">(</span><span class="n">new_parent</span><span class="p">,</span> <span class="n">clk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">field_val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent_div</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">_write_clksel_reg</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">field_val</span><span class="p">);</span>

	<span class="n">clk_reparent</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">new_parent</span><span class="p">);</span>

	<span class="cm">/* CLKSEL clocks follow their parents&#39; rates, divided by a divisor */</span>
	<span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="n">new_parent</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent_div</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">/=</span> <span class="n">parent_div</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;clock: %s: set parent to %s (new rate %ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">clk</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">clk</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
