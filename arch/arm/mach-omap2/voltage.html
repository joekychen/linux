<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mach-omap2 › voltage.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>voltage.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * OMAP3/OMAP4 Voltage Management Routines</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Thara Gopinath	&lt;thara@ti.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007 Texas Instruments, Inc.</span>
<span class="cm"> * Rajendra Nayak &lt;rnayak@ti.com&gt;</span>
<span class="cm"> * Lesly A M &lt;x0080970@ti.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008, 2011 Nokia Corporation</span>
<span class="cm"> * Kalle Jokiniemi</span>
<span class="cm"> * Paul Walmsley</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2010 Texas Instruments, Inc.</span>
<span class="cm"> * Thara Gopinath &lt;thara@ti.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>

<span class="cp">#include &quot;common.h&quot;</span>

<span class="cp">#include &quot;prm-regbits-34xx.h&quot;</span>
<span class="cp">#include &quot;prm-regbits-44xx.h&quot;</span>
<span class="cp">#include &quot;prm44xx.h&quot;</span>
<span class="cp">#include &quot;prcm44xx.h&quot;</span>
<span class="cp">#include &quot;prminst44xx.h&quot;</span>
<span class="cp">#include &quot;control.h&quot;</span>

<span class="cp">#include &quot;voltage.h&quot;</span>
<span class="cp">#include &quot;powerdomain.h&quot;</span>

<span class="cp">#include &quot;vc.h&quot;</span>
<span class="cp">#include &quot;vp.h&quot;</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">voltdm_list</span><span class="p">);</span>

<span class="cm">/* Public functions */</span>
<span class="cm">/**</span>
<span class="cm"> * voltdm_get_voltage() - Gets the current non-auto-compensated voltage</span>
<span class="cm"> * @voltdm:	pointer to the voltdm for which current voltage info is needed</span>
<span class="cm"> *</span>
<span class="cm"> * API to get the current non-auto-compensated voltage for a voltage domain.</span>
<span class="cm"> * Returns 0 in case of error else returns the current voltage.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">voltdm_get_voltage</span><span class="p">(</span><span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">voltdm</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">voltdm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: VDD specified does not exist!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">nominal_volt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * voltdm_scale() - API to scale voltage of a particular voltage domain.</span>
<span class="cm"> * @voltdm: pointer to the voltage domain which is to be scaled.</span>
<span class="cm"> * @target_volt: The target voltage of the voltage domain</span>
<span class="cm"> *</span>
<span class="cm"> * This API should be called by the kernel to do the voltage scaling</span>
<span class="cm"> * for a particular voltage domain during DVFS.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">voltdm_scale</span><span class="p">(</span><span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">target_volt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">volt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">voltdm</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">voltdm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: VDD specified does not exist!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">scale</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: No voltage scale API registered for vdd_%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Adjust voltage to the exact voltage from the OPP table */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">volt_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">volt_nominal</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">volt_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">volt_nominal</span> <span class="o">&gt;=</span> <span class="n">target_volt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">volt</span> <span class="o">=</span> <span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">volt_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">volt_nominal</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">volt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: not scaling. OPP voltage for %lu, not found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">target_volt</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">scale</span><span class="p">(</span><span class="n">voltdm</span><span class="p">,</span> <span class="n">volt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">nominal_volt</span> <span class="o">=</span> <span class="n">volt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * voltdm_reset() - Resets the voltage of a particular voltage domain</span>
<span class="cm"> *		    to that of the current OPP.</span>
<span class="cm"> * @voltdm: pointer to the voltage domain whose voltage is to be reset.</span>
<span class="cm"> *</span>
<span class="cm"> * This API finds out the correct voltage the voltage domain is supposed</span>
<span class="cm"> * to be at and resets the voltage to that level. Should be used especially</span>
<span class="cm"> * while disabling any voltage compensation modules.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">voltdm_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">target_volt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">voltdm</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">voltdm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: VDD specified does not exist!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">target_volt</span> <span class="o">=</span> <span class="n">voltdm_get_voltage</span><span class="p">(</span><span class="n">voltdm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">target_volt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: unable to find current voltage for vdd_%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">voltdm_scale</span><span class="p">(</span><span class="n">voltdm</span><span class="p">,</span> <span class="n">target_volt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_voltage_get_volttable() - API to get the voltage table associated with a</span>
<span class="cm"> *				particular voltage domain.</span>
<span class="cm"> * @voltdm:	pointer to the VDD for which the voltage table is required</span>
<span class="cm"> * @volt_data:	the voltage table for the particular vdd which is to be</span>
<span class="cm"> *		populated by this API</span>
<span class="cm"> *</span>
<span class="cm"> * This API populates the voltage table associated with a VDD into the</span>
<span class="cm"> * passed parameter pointer. Returns the count of distinct voltages</span>
<span class="cm"> * supported by this vdd.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">omap_voltage_get_volttable</span><span class="p">(</span><span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">omap_volt_data</span> <span class="o">**</span><span class="n">volt_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">voltdm</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">voltdm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: VDD specified does not exist!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">volt_data</span> <span class="o">=</span> <span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">volt_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_voltage_get_voltdata() - API to get the voltage table entry for a</span>
<span class="cm"> *				particular voltage</span>
<span class="cm"> * @voltdm:	pointer to the VDD whose voltage table has to be searched</span>
<span class="cm"> * @volt:	the voltage to be searched in the voltage table</span>
<span class="cm"> *</span>
<span class="cm"> * This API searches through the voltage table for the required voltage</span>
<span class="cm"> * domain and tries to find a matching entry for the passed voltage volt.</span>
<span class="cm"> * If a matching entry is found volt_data is populated with that entry.</span>
<span class="cm"> * This API searches only through the non-compensated voltages int the</span>
<span class="cm"> * voltage table.</span>
<span class="cm"> * Returns pointer to the voltage table entry corresponding to volt on</span>
<span class="cm"> * success. Returns -ENODATA if no voltage table exisits for the passed voltage</span>
<span class="cm"> * domain or if there is no matching entry.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_volt_data</span> <span class="o">*</span><span class="nf">omap_voltage_get_voltdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">volt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">voltdm</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">voltdm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: VDD specified does not exist!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">volt_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: voltage table does not exist for vdd_%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODATA</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">volt_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">volt_nominal</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">volt_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">volt_nominal</span> <span class="o">==</span> <span class="n">volt</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">volt_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;%s: Unable to match the current voltage with the voltage&quot;</span>
		<span class="s">&quot;table for vdd_%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODATA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_voltage_register_pmic() - API to register PMIC specific data</span>
<span class="cm"> * @voltdm:	pointer to the VDD for which the PMIC specific data is</span>
<span class="cm"> *		to be registered</span>
<span class="cm"> * @pmic:	the structure containing pmic info</span>
<span class="cm"> *</span>
<span class="cm"> * This API is to be called by the SOC/PMIC file to specify the</span>
<span class="cm"> * pmic specific info as present in omap_voltdm_pmic structure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_voltage_register_pmic</span><span class="p">(</span><span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">omap_voltdm_pmic</span> <span class="o">*</span><span class="n">pmic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">voltdm</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">voltdm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: VDD specified does not exist!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">pmic</span> <span class="o">=</span> <span class="n">pmic</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_change_voltscale_method() - API to change the voltage scaling method.</span>
<span class="cm"> * @voltdm:	pointer to the VDD whose voltage scaling method</span>
<span class="cm"> *		has to be changed.</span>
<span class="cm"> * @voltscale_method:	the method to be used for voltage scaling.</span>
<span class="cm"> *</span>
<span class="cm"> * This API can be used by the board files to change the method of voltage</span>
<span class="cm"> * scaling between vpforceupdate and vcbypass. The parameter values are</span>
<span class="cm"> * defined in voltage.h</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">omap_change_voltscale_method</span><span class="p">(</span><span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">voltscale_method</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">voltdm</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">voltdm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: VDD specified does not exist!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">voltscale_method</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VOLTSCALE_VPFORCEUPDATE</span>:
		<span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">scale</span> <span class="o">=</span> <span class="n">omap_vp_forceupdate_scale</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VOLTSCALE_VCBYPASS</span>:
		<span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">scale</span> <span class="o">=</span> <span class="n">omap_vc_bypass_scale</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Trying to change the method of voltage scaling&quot;</span>
			<span class="s">&quot;to an unsupported one!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_voltage_late_init() - Init the various voltage parameters</span>
<span class="cm"> *</span>
<span class="cm"> * This API is to be called in the later stages of the</span>
<span class="cm"> * system boot to init the voltage controller and</span>
<span class="cm"> * voltage processors.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">omap_voltage_late_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">voltdm_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Voltage driver support not added</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">voltdm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voltdm_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">sys_ck</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">scalable</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">sys_ck</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">sys_clk</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sys_ck</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Could not get sys clk.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">sys_clk</span><span class="p">.</span><span class="n">rate</span> <span class="o">=</span> <span class="n">clk_get_rate</span><span class="p">(</span><span class="n">sys_ck</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">sys_clk</span><span class="p">.</span><span class="n">rate</span><span class="p">);</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">sys_ck</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">vc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">scale</span> <span class="o">=</span> <span class="n">omap_vc_bypass_scale</span><span class="p">;</span>
			<span class="n">omap_vc_init_channel</span><span class="p">(</span><span class="n">voltdm</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">vp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">scale</span> <span class="o">=</span> <span class="n">omap_vp_forceupdate_scale</span><span class="p">;</span>
			<span class="n">omap_vp_init</span><span class="p">(</span><span class="n">voltdm</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="nf">_voltdm_lookup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span><span class="p">,</span> <span class="o">*</span><span class="n">temp_voltdm</span><span class="p">;</span>

	<span class="n">voltdm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">temp_voltdm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voltdm_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">temp_voltdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">voltdm</span> <span class="o">=</span> <span class="n">temp_voltdm</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">voltdm</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * voltdm_add_pwrdm - add a powerdomain to a voltagedomain</span>
<span class="cm"> * @voltdm: struct voltagedomain * to add the powerdomain to</span>
<span class="cm"> * @pwrdm: struct powerdomain * to associate with a voltagedomain</span>
<span class="cm"> *</span>
<span class="cm"> * Associate the powerdomain @pwrdm with a voltagedomain @voltdm.  This</span>
<span class="cm"> * enables the use of voltdm_for_each_pwrdm().  Returns -EINVAL if</span>
<span class="cm"> * presented with invalid pointers; -ENOMEM if memory could not be allocated;</span>
<span class="cm"> * or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">voltdm_add_pwrdm</span><span class="p">(</span><span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">voltdm</span> <span class="o">||</span> <span class="o">!</span><span class="n">pwrdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;voltagedomain: associating powerdomain %s with voltagedomain &quot;</span>
		 <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwrdm</span><span class="o">-&gt;</span><span class="n">voltdm_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">pwrdm_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * voltdm_for_each_pwrdm - call function for each pwrdm in a voltdm</span>
<span class="cm"> * @voltdm: struct voltagedomain * to iterate over</span>
<span class="cm"> * @fn: callback function *</span>
<span class="cm"> *</span>
<span class="cm"> * Call the supplied function @fn for each powerdomain in the</span>
<span class="cm"> * voltagedomain @voltdm.  Returns -EINVAL if presented with invalid</span>
<span class="cm"> * pointers; or passes along the last return value of the callback</span>
<span class="cm"> * function, which should be 0 for success or anything else to</span>
<span class="cm"> * indicate failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">voltdm_for_each_pwrdm</span><span class="p">(</span><span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">pwrdm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pwrdm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">pwrdm_list</span><span class="p">,</span> <span class="n">voltdm_node</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="n">voltdm</span><span class="p">,</span> <span class="n">pwrdm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * voltdm_for_each - call function on each registered voltagedomain</span>
<span class="cm"> * @fn: callback function *</span>
<span class="cm"> *</span>
<span class="cm"> * Call the supplied function @fn for each registered voltagedomain.</span>
<span class="cm"> * The callback function @fn can return anything but 0 to bail out</span>
<span class="cm"> * early from the iterator.  Returns the last return value of the</span>
<span class="cm"> * callback function, which should be 0 for success or anything else</span>
<span class="cm"> * to indicate failure; or -EINVAL if the function pointer is null.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">voltdm_for_each</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user</span><span class="p">),</span>
		    <span class="kt">void</span> <span class="o">*</span><span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">temp_voltdm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fn</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">temp_voltdm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voltdm_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="n">temp_voltdm</span><span class="p">,</span> <span class="n">user</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_voltdm_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">voltdm</span> <span class="o">||</span> <span class="o">!</span><span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">pwrdm_list</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voltdm_list</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;voltagedomain: registered %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">voltdm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * voltdm_lookup - look up a voltagedomain by name, return a pointer</span>
<span class="cm"> * @name: name of voltagedomain</span>
<span class="cm"> *</span>
<span class="cm"> * Find a registered voltagedomain by its name @name.  Returns a pointer</span>
<span class="cm"> * to the struct voltagedomain if found, or NULL otherwise.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="nf">voltdm_lookup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">*</span><span class="n">voltdm</span> <span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">voltdm</span> <span class="o">=</span> <span class="n">_voltdm_lookup</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">voltdm</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * voltdm_init - set up the voltagedomain layer</span>
<span class="cm"> * @voltdm_list: array of struct voltagedomain pointers to register</span>
<span class="cm"> *</span>
<span class="cm"> * Loop through the array of voltagedomains @voltdm_list, registering all</span>
<span class="cm"> * that are available on the current CPU. If voltdm_list is supplied</span>
<span class="cm"> * and not null, all of the referenced voltagedomains will be</span>
<span class="cm"> * registered.  No return value.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">voltdm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">**</span><span class="n">voltdms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">voltagedomain</span> <span class="o">**</span><span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">voltdms</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">voltdms</span><span class="p">;</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span>
			<span class="n">_voltdm_register</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
