<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mach-omap2 › serial.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>serial.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * arch/arm/mach-omap2/serial.c</span>
<span class="cm"> *</span>
<span class="cm"> * OMAP2 serial support.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2008 Nokia Corporation</span>
<span class="cm"> * Author: Paul Mundt &lt;paul.mundt@nokia.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Major rework for PM support by Kevin Hilman</span>
<span class="cm"> *</span>
<span class="cm"> * Based off of arch/arm/mach-omap/omap1/serial.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009 Texas Instruments</span>
<span class="cm"> * Added OMAP4 support - Santosh Shilimkar &lt;santosh.shilimkar@ti.com</span>
<span class="cm"> *</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License. See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>

<span class="cp">#include &lt;plat/omap-serial.h&gt;</span>
<span class="cp">#include &quot;common.h&quot;</span>
<span class="cp">#include &lt;plat/board.h&gt;</span>
<span class="cp">#include &lt;plat/dma.h&gt;</span>
<span class="cp">#include &lt;plat/omap_hwmod.h&gt;</span>
<span class="cp">#include &lt;plat/omap_device.h&gt;</span>
<span class="cp">#include &lt;plat/omap-pm.h&gt;</span>

<span class="cp">#include &quot;prm2xxx_3xxx.h&quot;</span>
<span class="cp">#include &quot;pm.h&quot;</span>
<span class="cp">#include &quot;cm2xxx_3xxx.h&quot;</span>
<span class="cp">#include &quot;prm-regbits-34xx.h&quot;</span>
<span class="cp">#include &quot;control.h&quot;</span>
<span class="cp">#include &quot;mux.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE: By default the serial auto_suspend timeout is disabled as it causes</span>
<span class="cm"> * lost characters over the serial ports. This means that the UART clocks will</span>
<span class="cm"> * stay on until power/autosuspend_delay is set for the uart from sysfs.</span>
<span class="cm"> * This also causes that any deeper omap sleep states are blocked.</span>
<span class="cm"> */</span>
<span class="cp">#define DEFAULT_AUTOSUSPEND_DELAY	-1</span>

<span class="cp">#define MAX_UART_HWMOD_NAME_LEN		16</span>

<span class="k">struct</span> <span class="n">omap_uart_state</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_device_pad</span> <span class="n">default_omap_uart_pads</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">uart_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">num_uarts</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">console_uart_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">no_console_suspend</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">uart_debug</span><span class="p">;</span>

<span class="cp">#define DEFAULT_RXDMA_POLLRATE		1	</span><span class="cm">/* RX DMA polling rate (us) */</span><span class="cp"></span>
<span class="cp">#define DEFAULT_RXDMA_BUFSIZE		4096	</span><span class="cm">/* RX DMA buffer size */</span><span class="cp"></span>
<span class="cp">#define DEFAULT_RXDMA_TIMEOUT		(3 * HZ)</span><span class="cm">/* RX DMA timeout (jiffies) */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">omap_uart_port_info</span> <span class="n">omap_serial_default_info</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">dma_enabled</span>	<span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dma_rx_buf_size</span> <span class="o">=</span> <span class="n">DEFAULT_RXDMA_BUFSIZE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dma_rx_poll_rate</span> <span class="o">=</span> <span class="n">DEFAULT_RXDMA_POLLRATE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dma_rx_timeout</span> <span class="o">=</span> <span class="n">DEFAULT_RXDMA_TIMEOUT</span><span class="p">,</span>
		<span class="p">.</span><span class="n">autosuspend_timeout</span> <span class="o">=</span> <span class="n">DEFAULT_AUTOSUSPEND_DELAY</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap_uart_enable_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span> <span class="o">=</span> <span class="n">to_omap_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">od</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">omap_hwmod_enable_wakeup</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">omap_hwmod_disable_wakeup</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Errata i291: [UART]:Cannot Acknowledge Idle Requests</span>
<span class="cm"> * in Smartidle Mode When Configured for DMA Operations.</span>
<span class="cm"> * WA: configure uart in force idle mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap_uart_set_noidle</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span> <span class="o">=</span> <span class="n">to_omap_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">omap_hwmod_set_slave_idlemode</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">HWMOD_IDLEMODE_NO</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap_uart_set_smartidle</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span> <span class="o">=</span> <span class="n">to_omap_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">idlemode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">sysc</span><span class="o">-&gt;</span><span class="n">idlemodes</span> <span class="o">&amp;</span> <span class="n">SIDLE_SMART_WKUP</span><span class="p">)</span>
		<span class="n">idlemode</span> <span class="o">=</span> <span class="n">HWMOD_IDLEMODE_SMART_WKUP</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">idlemode</span> <span class="o">=</span> <span class="n">HWMOD_IDLEMODE_SMART</span><span class="p">;</span>

	<span class="n">omap_hwmod_set_slave_idlemode</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idlemode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap_uart_enable_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap_uart_set_noidle</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap_uart_set_smartidle</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_OMAP_MUX</span>

<span class="cp">#define OMAP_UART_DEFAULT_PAD_NAME_LEN	28</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">rx_pad_name</span><span class="p">[</span><span class="n">OMAP_UART_DEFAULT_PAD_NAME_LEN</span><span class="p">],</span>
		<span class="n">tx_pad_name</span><span class="p">[</span><span class="n">OMAP_UART_DEFAULT_PAD_NAME_LEN</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span>  <span class="n">__init</span>
<span class="nf">omap_serial_fill_uart_tx_rx_pads</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_board_data</span> <span class="o">*</span><span class="n">bdata</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">omap_uart_state</span> <span class="o">*</span><span class="n">uart</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">default_omap_uart_pads</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="n">rx_pad_name</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">default_omap_uart_pads</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">OMAP_DEVICE_PAD_REMUX</span> <span class="o">|</span>
							<span class="n">OMAP_DEVICE_PAD_WAKEUP</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">default_omap_uart_pads</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">enable</span> <span class="o">=</span> <span class="n">OMAP_PIN_INPUT</span> <span class="o">|</span>
							<span class="n">OMAP_MUX_MODE0</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">default_omap_uart_pads</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">idle</span> <span class="o">=</span> <span class="n">OMAP_PIN_INPUT</span> <span class="o">|</span> <span class="n">OMAP_MUX_MODE0</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">default_omap_uart_pads</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="n">tx_pad_name</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">default_omap_uart_pads</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">enable</span> <span class="o">=</span> <span class="n">OMAP_PIN_OUTPUT</span> <span class="o">|</span>
							<span class="n">OMAP_MUX_MODE0</span><span class="p">;</span>
	<span class="n">bdata</span><span class="o">-&gt;</span><span class="n">pads</span> <span class="o">=</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">default_omap_uart_pads</span><span class="p">;</span>
	<span class="n">bdata</span><span class="o">-&gt;</span><span class="n">pads_cnt</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">default_omap_uart_pads</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>  <span class="n">__init</span> <span class="nf">omap_serial_check_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_board_data</span> <span class="o">*</span><span class="n">bdata</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">omap_uart_state</span> <span class="o">*</span><span class="n">uart</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_mux_partition</span> <span class="o">*</span><span class="n">tx_partition</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">rx_partition</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_mux</span> <span class="o">*</span><span class="n">rx_mux</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tx_mux</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">rx_fmt</span><span class="p">,</span> <span class="o">*</span><span class="n">tx_fmt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uart_nr</span> <span class="o">=</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx_fmt</span> <span class="o">=</span> <span class="s">&quot;uart%d_rx.uart%d_rx&quot;</span><span class="p">;</span>
		<span class="n">tx_fmt</span> <span class="o">=</span> <span class="s">&quot;uart%d_tx.uart%d_tx&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rx_fmt</span> <span class="o">=</span> <span class="s">&quot;uart%d_rx_irrx.uart%d_rx_irrx&quot;</span><span class="p">;</span>
		<span class="n">tx_fmt</span> <span class="o">=</span> <span class="s">&quot;uart%d_tx_irtx.uart%d_tx_irtx&quot;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">rx_pad_name</span><span class="p">,</span> <span class="n">OMAP_UART_DEFAULT_PAD_NAME_LEN</span><span class="p">,</span> <span class="n">rx_fmt</span><span class="p">,</span>
			<span class="n">uart_nr</span><span class="p">,</span> <span class="n">uart_nr</span><span class="p">);</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">tx_pad_name</span><span class="p">,</span> <span class="n">OMAP_UART_DEFAULT_PAD_NAME_LEN</span><span class="p">,</span> <span class="n">tx_fmt</span><span class="p">,</span>
			<span class="n">uart_nr</span><span class="p">,</span> <span class="n">uart_nr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">omap_mux_get_by_name</span><span class="p">(</span><span class="n">rx_pad_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_partition</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_mux</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="n">omap_mux_get_by_name</span>
				<span class="p">(</span><span class="n">tx_pad_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_partition</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_mux</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">tx_mode</span><span class="p">,</span> <span class="n">rx_mode</span><span class="p">;</span>

		<span class="n">tx_mode</span> <span class="o">=</span> <span class="n">omap_mux_read</span><span class="p">(</span><span class="n">tx_partition</span><span class="p">,</span> <span class="n">tx_mux</span><span class="o">-&gt;</span><span class="n">reg_offset</span><span class="p">);</span>
		<span class="n">rx_mode</span> <span class="o">=</span> <span class="n">omap_mux_read</span><span class="p">(</span><span class="n">rx_partition</span><span class="p">,</span> <span class="n">rx_mux</span><span class="o">-&gt;</span><span class="n">reg_offset</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check if uart is used in default tx/rx mode i.e. in mux mode0</span>
<span class="cm">		 * if yes then configure rx pin for wake up capability</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OMAP_MODE_UART</span><span class="p">(</span><span class="n">rx_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">OMAP_MODE_UART</span><span class="p">(</span><span class="n">tx_mode</span><span class="p">))</span>
			<span class="n">omap_serial_fill_uart_tx_rx_pads</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">uart</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">omap_serial_check_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_board_data</span> <span class="o">*</span><span class="n">bdata</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">omap_uart_state</span> <span class="o">*</span><span class="n">uart</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">cmdline_find_option</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">saved_command_line</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">strstr</span><span class="p">(</span><span class="n">saved_command_line</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">omap_serial_early_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">oh_name</span><span class="p">[</span><span class="n">MAX_UART_HWMOD_NAME_LEN</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">omap_uart_state</span> <span class="o">*</span><span class="n">uart</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">uart_name</span><span class="p">[</span><span class="n">MAX_UART_HWMOD_NAME_LEN</span><span class="p">];</span>

		<span class="n">snprintf</span><span class="p">(</span><span class="n">oh_name</span><span class="p">,</span> <span class="n">MAX_UART_HWMOD_NAME_LEN</span><span class="p">,</span>
			 <span class="s">&quot;uart%d&quot;</span><span class="p">,</span> <span class="n">num_uarts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">oh</span> <span class="o">=</span> <span class="n">omap_hwmod_lookup</span><span class="p">(</span><span class="n">oh_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">uart</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_uart_state</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">uart</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">oh</span> <span class="o">=</span> <span class="n">oh</span><span class="p">;</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="n">num_uarts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uart_list</span><span class="p">);</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">uart_name</span><span class="p">,</span> <span class="n">MAX_UART_HWMOD_NAME_LEN</span><span class="p">,</span>
				<span class="s">&quot;%s%d&quot;</span><span class="p">,</span> <span class="n">OMAP_SERIAL_NAME</span><span class="p">,</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmdline_find_option</span><span class="p">(</span><span class="n">uart_name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">console_uart_id</span> <span class="o">=</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">console_loglevel</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">uart_debug</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s used as console in debug mode&quot;</span>
						<span class="s">&quot; uart%d clocks will not be&quot;</span>
						<span class="s">&quot; gated&quot;</span><span class="p">,</span> <span class="n">uart_name</span><span class="p">,</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cmdline_find_option</span><span class="p">(</span><span class="s">&quot;no_console_suspend&quot;</span><span class="p">))</span>
				<span class="n">no_console_suspend</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * omap-uart can be used for earlyprintk logs</span>
<span class="cm">			 * So if omap-uart is used as console then prevent</span>
<span class="cm">			 * uart reset and idle to get logs from omap-uart</span>
<span class="cm">			 * until uart console driver is available to take</span>
<span class="cm">			 * care for console messages.</span>
<span class="cm">			 * Idling or resetting omap-uart while printing logs</span>
<span class="cm">			 * early boot logs can stall the boot-up.</span>
<span class="cm">			 */</span>
			<span class="n">oh</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">HWMOD_INIT_NO_IDLE</span> <span class="o">|</span> <span class="n">HWMOD_INIT_NO_RESET</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">core_initcall</span><span class="p">(</span><span class="n">omap_serial_early_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * omap_serial_init_port() - initialize single serial port</span>
<span class="cm"> * @bdata: port specific board data pointer</span>
<span class="cm"> * @info: platform specific data pointer</span>
<span class="cm"> *</span>
<span class="cm"> * This function initialies serial driver for given port only.</span>
<span class="cm"> * Platforms can call this function instead of omap_serial_init()</span>
<span class="cm"> * if they don&#39;t plan to use all available UARTs as serial ports.</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t mix calls to omap_serial_init_port() and omap_serial_init(),</span>
<span class="cm"> * use only one of the two.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">omap_serial_init_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_board_data</span> <span class="o">*</span><span class="n">bdata</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">omap_uart_port_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_uart_state</span> <span class="o">*</span><span class="n">uart</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pdata_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_uart_port_info</span> <span class="n">omap_up</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">bdata</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">num_uarts</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">uart</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uart_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">omap_serial_default_info</span><span class="p">;</span>

	<span class="n">oh</span> <span class="o">=</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">oh</span><span class="p">;</span>
	<span class="n">name</span> <span class="o">=</span> <span class="n">DRIVER_NAME</span><span class="p">;</span>

	<span class="n">omap_up</span><span class="p">.</span><span class="n">dma_enabled</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_enabled</span><span class="p">;</span>
	<span class="n">omap_up</span><span class="p">.</span><span class="n">uartclk</span> <span class="o">=</span> <span class="n">OMAP24XX_BASE_BAUD</span> <span class="o">*</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">omap_up</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UPF_BOOT_AUTOCONF</span><span class="p">;</span>
	<span class="n">omap_up</span><span class="p">.</span><span class="n">get_context_loss_count</span> <span class="o">=</span> <span class="n">omap_pm_get_dev_context_loss_count</span><span class="p">;</span>
	<span class="n">omap_up</span><span class="p">.</span><span class="n">set_forceidle</span> <span class="o">=</span> <span class="n">omap_uart_set_smartidle</span><span class="p">;</span>
	<span class="n">omap_up</span><span class="p">.</span><span class="n">set_noidle</span> <span class="o">=</span> <span class="n">omap_uart_set_noidle</span><span class="p">;</span>
	<span class="n">omap_up</span><span class="p">.</span><span class="n">enable_wakeup</span> <span class="o">=</span> <span class="n">omap_uart_enable_wakeup</span><span class="p">;</span>
	<span class="n">omap_up</span><span class="p">.</span><span class="n">dma_rx_buf_size</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_rx_buf_size</span><span class="p">;</span>
	<span class="n">omap_up</span><span class="p">.</span><span class="n">dma_rx_timeout</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_rx_timeout</span><span class="p">;</span>
	<span class="n">omap_up</span><span class="p">.</span><span class="n">dma_rx_poll_rate</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_rx_poll_rate</span><span class="p">;</span>
	<span class="n">omap_up</span><span class="p">.</span><span class="n">autosuspend_timeout</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">autosuspend_timeout</span><span class="p">;</span>

	<span class="n">pdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">omap_up</span><span class="p">;</span>
	<span class="n">pdata_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_uart_port_info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pdev</span> <span class="o">=</span> <span class="n">omap_device_build</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="n">oh</span><span class="p">,</span> <span class="n">pdata</span><span class="p">,</span> <span class="n">pdata_size</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">WARN</span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="s">&quot;Could not build omap_device for %s: %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">name</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">console_uart_id</span> <span class="o">==</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">no_console_suspend</span><span class="p">)</span>
		<span class="n">omap_device_disable_idle_on_suspend</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">mux</span> <span class="o">=</span> <span class="n">omap_hwmod_mux_init</span><span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">pads</span><span class="p">,</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">pads_cnt</span><span class="p">);</span>

	<span class="n">oh</span><span class="o">-&gt;</span><span class="n">dev_attr</span> <span class="o">=</span> <span class="n">uart</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">cpu_is_omap34xx</span><span class="p">()</span> <span class="o">||</span> <span class="n">cpu_is_omap44xx</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">pads</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uart_debug</span><span class="p">)</span>
		<span class="n">device_init_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_serial_board_init() - initialize all supported serial ports</span>
<span class="cm"> * @info: platform specific data pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes all available UARTs as serial ports. Platforms</span>
<span class="cm"> * can call this function when they want to have default behaviour</span>
<span class="cm"> * for serial ports (e.g initialize them all as serial ports).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">omap_serial_board_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_uart_port_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_uart_state</span> <span class="o">*</span><span class="n">uart</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_board_data</span> <span class="n">bdata</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">uart</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uart_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bdata</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
		<span class="n">bdata</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bdata</span><span class="p">.</span><span class="n">pads</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">bdata</span><span class="p">.</span><span class="n">pads_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">omap_serial_check_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdata</span><span class="p">,</span> <span class="n">uart</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
			<span class="n">omap_serial_init_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdata</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">omap_serial_init_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">[</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_serial_init() - initialize all supported serial ports</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes all available UARTs.</span>
<span class="cm"> * Platforms can call this function when they want to have default behaviour</span>
<span class="cm"> * for serial ports (e.g initialize them all as serial ports).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">omap_serial_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">omap_serial_board_init</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
