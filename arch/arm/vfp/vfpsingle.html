<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › vfp › vfpsingle.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>vfpsingle.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/arch/arm/vfp/vfpsingle.c</span>
<span class="cm"> *</span>
<span class="cm"> * This code is derived in part from John R. Housers softfloat library, which</span>
<span class="cm"> * carries the following notice:</span>
<span class="cm"> *</span>
<span class="cm"> * ===========================================================================</span>
<span class="cm"> * This C source file is part of the SoftFloat IEC/IEEE Floating-point</span>
<span class="cm"> * Arithmetic Package, Release 2.</span>
<span class="cm"> *</span>
<span class="cm"> * Written by John R. Hauser.  This work was made possible in part by the</span>
<span class="cm"> * International Computer Science Institute, located at Suite 600, 1947 Center</span>
<span class="cm"> * Street, Berkeley, California 94704.  Funding was partially provided by the</span>
<span class="cm"> * National Science Foundation under grant MIP-9311980.  The original version</span>
<span class="cm"> * of this code was written as part of a project to build a fixed-point vector</span>
<span class="cm"> * processor in collaboration with the University of California at Berkeley,</span>
<span class="cm"> * overseen by Profs. Nelson Morgan and John Wawrzynek.  More information</span>
<span class="cm"> * is available through the web page `http://HTTP.CS.Berkeley.EDU/~jhauser/</span>
<span class="cm"> * arithmetic/softfloat.html&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort</span>
<span class="cm"> * has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT</span>
<span class="cm"> * TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO</span>
<span class="cm"> * PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY</span>
<span class="cm"> * AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.</span>
<span class="cm"> *</span>
<span class="cm"> * Derivative works are acceptable, even for commercial purposes, so long as</span>
<span class="cm"> * (1) they include prominent notice that the work is derivative, and (2) they</span>
<span class="cm"> * include prominent notice akin to these three paragraphs for those parts of</span>
<span class="cm"> * this code that are retained.</span>
<span class="cm"> * ===========================================================================</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>

<span class="cp">#include &lt;asm/div64.h&gt;</span>
<span class="cp">#include &lt;asm/vfp.h&gt;</span>

<span class="cp">#include &quot;vfpinstr.h&quot;</span>
<span class="cp">#include &quot;vfp.h&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vfp_single</span> <span class="n">vfp_single_default_qnan</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">exponent</span>	<span class="o">=</span> <span class="mi">255</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sign</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">significand</span>	<span class="o">=</span> <span class="n">VFP_SINGLE_SIGNIFICAND_QNAN</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vfp_single_dump</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: %s: sign=%d exponent=%d significand=%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">str</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sign</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">exponent</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">significand</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vfp_single_normalise_denormal</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">-</span> <span class="n">fls</span><span class="p">(</span><span class="n">vs</span><span class="o">-&gt;</span><span class="n">significand</span><span class="p">);</span>

	<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;normalise_denormal: in&quot;</span><span class="p">,</span> <span class="n">vs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vs</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">-=</span> <span class="n">bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vs</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">&lt;&lt;=</span> <span class="n">bits</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;normalise_denormal: out&quot;</span><span class="p">,</span> <span class="n">vs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef DEBUG</span>
<span class="cp">#define vfp_single_normaliseround(sd,vsd,fpscr,except,func) __vfp_single_normaliseround(sd,vsd,fpscr,except)</span>
<span class="n">u32</span> <span class="n">__vfp_single_normaliseround</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">exceptions</span><span class="p">)</span>
<span class="cp">#else</span>
<span class="n">u32</span> <span class="n">vfp_single_normaliseround</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">exceptions</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="cp">#endif</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">significand</span><span class="p">,</span> <span class="n">incr</span><span class="p">,</span> <span class="n">rmode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">exponent</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">underflow</span><span class="p">;</span>

	<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;pack: in&quot;</span><span class="p">,</span> <span class="n">vs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Infinities and NaNs are a special case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vs</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">255</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vs</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">exceptions</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">pack</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Special-case zero.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vs</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vs</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">pack</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">exponent</span> <span class="o">=</span> <span class="n">vs</span><span class="o">-&gt;</span><span class="n">exponent</span><span class="p">;</span>
	<span class="n">significand</span> <span class="o">=</span> <span class="n">vs</span><span class="o">-&gt;</span><span class="n">significand</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Normalise first.  Note that we shift the significand up to</span>
<span class="cm">	 * bit 31, so we have VFP_SINGLE_LOW_BITS + 1 below the least</span>
<span class="cm">	 * significant bit.</span>
<span class="cm">	 */</span>
	<span class="n">shift</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">fls</span><span class="p">(</span><span class="n">significand</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&lt;</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="n">shift</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">exponent</span> <span class="o">-=</span> <span class="n">shift</span><span class="p">;</span>
		<span class="n">significand</span> <span class="o">&lt;&lt;=</span> <span class="n">shift</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">vs</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">=</span> <span class="n">exponent</span><span class="p">;</span>
	<span class="n">vs</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">=</span> <span class="n">significand</span><span class="p">;</span>
	<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;pack: normalised&quot;</span><span class="p">,</span> <span class="n">vs</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tiny number?</span>
<span class="cm">	 */</span>
	<span class="n">underflow</span> <span class="o">=</span> <span class="n">exponent</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">underflow</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">significand</span> <span class="o">=</span> <span class="n">vfp_shiftright32jamming</span><span class="p">(</span><span class="n">significand</span><span class="p">,</span> <span class="o">-</span><span class="n">exponent</span><span class="p">);</span>
		<span class="n">exponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="n">vs</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">=</span> <span class="n">exponent</span><span class="p">;</span>
		<span class="n">vs</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">=</span> <span class="n">significand</span><span class="p">;</span>
		<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;pack: tiny number&quot;</span><span class="p">,</span> <span class="n">vs</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">significand</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">VFP_SINGLE_LOW_BITS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
			<span class="n">underflow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Select rounding increment.</span>
<span class="cm">	 */</span>
	<span class="n">incr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rmode</span> <span class="o">=</span> <span class="n">fpscr</span> <span class="o">&amp;</span> <span class="n">FPSCR_RMODE_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rmode</span> <span class="o">==</span> <span class="n">FPSCR_ROUND_NEAREST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">VFP_SINGLE_LOW_BITS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">significand</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">VFP_SINGLE_LOW_BITS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">incr</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rmode</span> <span class="o">==</span> <span class="n">FPSCR_ROUND_TOZERO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">incr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">rmode</span> <span class="o">==</span> <span class="n">FPSCR_ROUND_PLUSINF</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">vs</span><span class="o">-&gt;</span><span class="n">sign</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">incr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">VFP_SINGLE_LOW_BITS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: rounding increment = 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">incr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Is our rounding going to overflow?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">significand</span> <span class="o">+</span> <span class="n">incr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">significand</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">exponent</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">significand</span> <span class="o">=</span> <span class="p">(</span><span class="n">significand</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">significand</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">incr</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="n">vs</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">=</span> <span class="n">exponent</span><span class="p">;</span>
		<span class="n">vs</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">=</span> <span class="n">significand</span><span class="p">;</span>
		<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;pack: overflow&quot;</span><span class="p">,</span> <span class="n">vs</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If any of the low bits (which will be shifted out of the</span>
<span class="cm">	 * number) are non-zero, the result is inexact.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">significand</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">VFP_SINGLE_LOW_BITS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">FPSCR_IXC</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do our rounding.</span>
<span class="cm">	 */</span>
	<span class="n">significand</span> <span class="o">+=</span> <span class="n">incr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Infinity?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exponent</span> <span class="o">&gt;=</span> <span class="mi">254</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">FPSCR_OFC</span> <span class="o">|</span> <span class="n">FPSCR_IXC</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">incr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vs</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">=</span> <span class="mi">253</span><span class="p">;</span>
			<span class="n">vs</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">=</span> <span class="mh">0x7fffffff</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">vs</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>		<span class="cm">/* infinity */</span>
			<span class="n">vs</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">significand</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">VFP_SINGLE_LOW_BITS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">exponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exponent</span> <span class="o">||</span> <span class="n">significand</span> <span class="o">&gt;</span> <span class="mh">0x80000000</span><span class="p">)</span>
			<span class="n">underflow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">underflow</span><span class="p">)</span>
			<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">FPSCR_UFC</span><span class="p">;</span>
		<span class="n">vs</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">=</span> <span class="n">exponent</span><span class="p">;</span>
		<span class="n">vs</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">=</span> <span class="n">significand</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">pack:</span>
	<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;pack: final&quot;</span><span class="p">,</span> <span class="n">vs</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="n">s32</span> <span class="n">d</span> <span class="o">=</span> <span class="n">vfp_single_pack</span><span class="p">(</span><span class="n">vs</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: %s: d(s%d)=%08x exceptions=%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span>
			 <span class="n">sd</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">exceptions</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">vfp_put_float</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">exceptions</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Propagate the NaN, setting exceptions if it is signalling.</span>
<span class="cm"> * &#39;n&#39; is always a NaN.  &#39;m&#39; may be a number, NaN or infinity.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span>
<span class="n">vfp_propagate_nan</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vsd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vsn</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vsm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">nan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tn</span><span class="p">,</span> <span class="n">tm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tn</span> <span class="o">=</span> <span class="n">vfp_single_type</span><span class="p">(</span><span class="n">vsn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">)</span>
		<span class="n">tm</span> <span class="o">=</span> <span class="n">vfp_single_type</span><span class="p">(</span><span class="n">vsm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fpscr</span> <span class="o">&amp;</span> <span class="n">FPSCR_DEFAULT_NAN</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Default NaN mode - always returns a quiet NaN</span>
<span class="cm">		 */</span>
		<span class="n">nan</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vfp_single_default_qnan</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Contemporary mode - select the first signalling</span>
<span class="cm">		 * NAN, or if neither are signalling, the first</span>
<span class="cm">		 * quiet NAN.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tn</span> <span class="o">==</span> <span class="n">VFP_SNAN</span> <span class="o">||</span> <span class="p">(</span><span class="n">tm</span> <span class="o">!=</span> <span class="n">VFP_SNAN</span> <span class="o">&amp;&amp;</span> <span class="n">tn</span> <span class="o">==</span> <span class="n">VFP_QNAN</span><span class="p">))</span>
			<span class="n">nan</span> <span class="o">=</span> <span class="n">vsn</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">nan</span> <span class="o">=</span> <span class="n">vsm</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make the NaN quiet.</span>
<span class="cm">		 */</span>
		<span class="n">nan</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">|=</span> <span class="n">VFP_SINGLE_SIGNIFICAND_QNAN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">vsd</span> <span class="o">=</span> <span class="o">*</span><span class="n">nan</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If one was a signalling NAN, raise invalid operation.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">tn</span> <span class="o">==</span> <span class="n">VFP_SNAN</span> <span class="o">||</span> <span class="n">tm</span> <span class="o">==</span> <span class="n">VFP_SNAN</span> <span class="o">?</span> <span class="n">FPSCR_IOC</span> <span class="o">:</span> <span class="n">VFP_NAN_FLAG</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Extended operations</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">vfp_single_fabs</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vfp_put_float</span><span class="p">(</span><span class="n">vfp_single_packed_abs</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">sd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">vfp_single_fcpy</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vfp_put_float</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">sd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">vfp_single_fneg</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vfp_put_float</span><span class="p">(</span><span class="n">vfp_single_packed_negate</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">sd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">sqrt_oddadjust</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x0004</span><span class="p">,</span> <span class="mh">0x0022</span><span class="p">,</span> <span class="mh">0x005d</span><span class="p">,</span> <span class="mh">0x00b1</span><span class="p">,</span> <span class="mh">0x011d</span><span class="p">,</span> <span class="mh">0x019f</span><span class="p">,</span> <span class="mh">0x0236</span><span class="p">,</span> <span class="mh">0x02e0</span><span class="p">,</span>
	<span class="mh">0x039c</span><span class="p">,</span> <span class="mh">0x0468</span><span class="p">,</span> <span class="mh">0x0545</span><span class="p">,</span> <span class="mh">0x0631</span><span class="p">,</span> <span class="mh">0x072b</span><span class="p">,</span> <span class="mh">0x0832</span><span class="p">,</span> <span class="mh">0x0946</span><span class="p">,</span> <span class="mh">0x0a67</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">sqrt_evenadjust</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x0a2d</span><span class="p">,</span> <span class="mh">0x08af</span><span class="p">,</span> <span class="mh">0x075a</span><span class="p">,</span> <span class="mh">0x0629</span><span class="p">,</span> <span class="mh">0x051a</span><span class="p">,</span> <span class="mh">0x0429</span><span class="p">,</span> <span class="mh">0x0356</span><span class="p">,</span> <span class="mh">0x029e</span><span class="p">,</span>
	<span class="mh">0x0200</span><span class="p">,</span> <span class="mh">0x0179</span><span class="p">,</span> <span class="mh">0x0109</span><span class="p">,</span> <span class="mh">0x00af</span><span class="p">,</span> <span class="mh">0x0068</span><span class="p">,</span> <span class="mh">0x0034</span><span class="p">,</span> <span class="mh">0x0012</span><span class="p">,</span> <span class="mh">0x0002</span>
<span class="p">};</span>

<span class="n">u32</span> <span class="nf">vfp_estimate_sqrt_significand</span><span class="p">(</span><span class="n">u32</span> <span class="n">exponent</span><span class="p">,</span> <span class="n">u32</span> <span class="n">significand</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">significand</span> <span class="o">&amp;</span> <span class="mh">0xc0000000</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x40000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;VFP: estimate_sqrt: invalid significand</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">a</span> <span class="o">=</span> <span class="n">significand</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">27</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exponent</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">z</span> <span class="o">=</span> <span class="mh">0x4000</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">17</span><span class="p">)</span> <span class="o">-</span> <span class="n">sqrt_oddadjust</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="n">z</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">/</span> <span class="n">z</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">);</span>
		<span class="n">a</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">z</span> <span class="o">=</span> <span class="mh">0x8000</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">17</span><span class="p">)</span> <span class="o">-</span> <span class="n">sqrt_evenadjust</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="n">z</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">z</span> <span class="o">+</span> <span class="n">z</span><span class="p">;</span>
		<span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span> <span class="o">&gt;=</span> <span class="mh">0x20000</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0xffff8000</span> <span class="o">:</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">s32</span><span class="p">)</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">{</span>
		<span class="n">u64</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">;</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">v</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fsqrt</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfp_single</span> <span class="n">vsm</span><span class="p">,</span> <span class="n">vsd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">tm</span><span class="p">;</span>

	<span class="n">vfp_single_unpack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="n">tm</span> <span class="o">=</span> <span class="n">vfp_single_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VFP_NAN</span><span class="o">|</span><span class="n">VFP_INFINITY</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vsd</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;</span> <span class="n">VFP_NAN</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">vfp_propagate_nan</span><span class="p">(</span><span class="n">vsp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">sign</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">sqrt_copy:</span>
			<span class="n">vsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vsm</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="nl">sqrt_invalid:</span>
			<span class="n">vsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vfp_single_default_qnan</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">FPSCR_IOC</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vfp_put_float</span><span class="p">(</span><span class="n">vfp_single_pack</span><span class="p">(</span><span class="n">vsp</span><span class="p">),</span> <span class="n">sd</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * sqrt(+/- 0) == +/- 0</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;</span> <span class="n">VFP_ZERO</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">sqrt_copy</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Normalise a denormalised number</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;</span> <span class="n">VFP_DENORMAL</span><span class="p">)</span>
		<span class="n">vfp_single_normalise_denormal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * sqrt(&lt;0) = invalid</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">sign</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">sqrt_invalid</span><span class="p">;</span>

	<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;sqrt&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Estimate the square root.</span>
<span class="cm">	 */</span>
	<span class="n">vsd</span><span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vsd</span><span class="p">.</span><span class="n">exponent</span> <span class="o">=</span> <span class="p">((</span><span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span> <span class="o">-</span> <span class="mi">127</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">127</span><span class="p">;</span>
	<span class="n">vsd</span><span class="p">.</span><span class="n">significand</span> <span class="o">=</span> <span class="n">vfp_estimate_sqrt_significand</span><span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">vsm</span><span class="p">.</span><span class="n">significand</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;sqrt estimate&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * And now adjust.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vsd</span><span class="p">.</span><span class="n">significand</span> <span class="o">&amp;</span> <span class="n">VFP_SINGLE_LOW_BITS_MASK</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vsd</span><span class="p">.</span><span class="n">significand</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vsd</span><span class="p">.</span><span class="n">significand</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">term</span><span class="p">;</span>
			<span class="n">s64</span> <span class="n">rem</span><span class="p">;</span>
			<span class="n">vsm</span><span class="p">.</span><span class="n">significand</span> <span class="o">&lt;&lt;=</span> <span class="o">!</span><span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">term</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">vsd</span><span class="p">.</span><span class="n">significand</span> <span class="o">*</span> <span class="n">vsd</span><span class="p">.</span><span class="n">significand</span><span class="p">;</span>
			<span class="n">rem</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">vsm</span><span class="p">.</span><span class="n">significand</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="n">term</span><span class="p">;</span>

			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: term=%016llx rem=%016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">rem</span><span class="p">);</span>

			<span class="k">while</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">vsd</span><span class="p">.</span><span class="n">significand</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">rem</span> <span class="o">+=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">vsd</span><span class="p">.</span><span class="n">significand</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">vsd</span><span class="p">.</span><span class="n">significand</span> <span class="o">|=</span> <span class="n">rem</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">vsd</span><span class="p">.</span><span class="n">significand</span> <span class="o">=</span> <span class="n">vfp_shiftright32jamming</span><span class="p">(</span><span class="n">vsd</span><span class="p">.</span><span class="n">significand</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">vfp_single_normaliseround</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsd</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;fsqrt&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Equal	:= ZC</span>
<span class="cm"> * Less than	:= N</span>
<span class="cm"> * Greater than	:= C</span>
<span class="cm"> * Unordered	:= CV</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_compare</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signal_on_qnan</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">vfp_get_float</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vfp_single_packed_exponent</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">255</span> <span class="o">&amp;&amp;</span> <span class="n">vfp_single_packed_mantissa</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">FPSCR_C</span> <span class="o">|</span> <span class="n">FPSCR_V</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_on_qnan</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">vfp_single_packed_mantissa</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">VFP_SINGLE_MANTISSA_BITS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span>
			<span class="cm">/*</span>
<span class="cm">			 * Signalling NaN, or signalling on quiet NaN</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">|=</span> <span class="n">FPSCR_IOC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vfp_single_packed_exponent</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">255</span> <span class="o">&amp;&amp;</span> <span class="n">vfp_single_packed_mantissa</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">FPSCR_C</span> <span class="o">|</span> <span class="n">FPSCR_V</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_on_qnan</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">vfp_single_packed_mantissa</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">VFP_SINGLE_MANTISSA_BITS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span>
			<span class="cm">/*</span>
<span class="cm">			 * Signalling NaN, or signalling on quiet NaN</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">|=</span> <span class="n">FPSCR_IOC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">m</span> <span class="o">||</span> <span class="n">vfp_single_packed_abs</span><span class="p">(</span><span class="n">d</span> <span class="o">|</span> <span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * equal</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">|=</span> <span class="n">FPSCR_Z</span> <span class="o">|</span> <span class="n">FPSCR_C</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vfp_single_packed_sign</span><span class="p">(</span><span class="n">d</span> <span class="o">^</span> <span class="n">m</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * different signs</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vfp_single_packed_sign</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
				<span class="cm">/*</span>
<span class="cm">				 * d is negative, so d &lt; m</span>
<span class="cm">				 */</span>
				<span class="n">ret</span> <span class="o">|=</span> <span class="n">FPSCR_N</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="cm">/*</span>
<span class="cm">				 * d is positive, so d &gt; m</span>
<span class="cm">				 */</span>
				<span class="n">ret</span> <span class="o">|=</span> <span class="n">FPSCR_C</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">vfp_single_packed_sign</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * d &lt; m</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">|=</span> <span class="n">FPSCR_N</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">vfp_single_packed_sign</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * d &gt; m</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">|=</span> <span class="n">FPSCR_C</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fcmp</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vfp_compare</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fcmpe</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vfp_compare</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fcmpz</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vfp_compare</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fcmpez</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vfp_compare</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fcvtd</span><span class="p">(</span><span class="kt">int</span> <span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfp_single</span> <span class="n">vsm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfp_double</span> <span class="n">vdd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">exceptions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vfp_single_unpack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>

	<span class="n">tm</span> <span class="o">=</span> <span class="n">vfp_single_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have a signalling NaN, signal invalid operation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">==</span> <span class="n">VFP_SNAN</span><span class="p">)</span>
		<span class="n">exceptions</span> <span class="o">=</span> <span class="n">FPSCR_IOC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;</span> <span class="n">VFP_DENORMAL</span><span class="p">)</span>
		<span class="n">vfp_single_normalise_denormal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">);</span>

	<span class="n">vdd</span><span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="n">vsm</span><span class="p">.</span><span class="n">sign</span><span class="p">;</span>
	<span class="n">vdd</span><span class="p">.</span><span class="n">significand</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">vsm</span><span class="p">.</span><span class="n">significand</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have an infinity or NaN, the exponent must be 2047.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VFP_INFINITY</span><span class="o">|</span><span class="n">VFP_NAN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vdd</span><span class="p">.</span><span class="n">exponent</span> <span class="o">=</span> <span class="mi">2047</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">==</span> <span class="n">VFP_QNAN</span><span class="p">)</span>
			<span class="n">vdd</span><span class="p">.</span><span class="n">significand</span> <span class="o">|=</span> <span class="n">VFP_DOUBLE_SIGNIFICAND_QNAN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">pack_nan</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;</span> <span class="n">VFP_ZERO</span><span class="p">)</span>
		<span class="n">vdd</span><span class="p">.</span><span class="n">exponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vdd</span><span class="p">.</span><span class="n">exponent</span> <span class="o">=</span> <span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1023</span> <span class="o">-</span> <span class="mi">127</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">vfp_double_normaliseround</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vdd</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">,</span> <span class="n">exceptions</span><span class="p">,</span> <span class="s">&quot;fcvtd&quot;</span><span class="p">);</span>

 <span class="nl">pack_nan:</span>
	<span class="n">vfp_put_double</span><span class="p">(</span><span class="n">vfp_double_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdd</span><span class="p">),</span> <span class="n">dd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">exceptions</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fuito</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfp_single</span> <span class="n">vs</span><span class="p">;</span>

	<span class="n">vs</span><span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vs</span><span class="p">.</span><span class="n">exponent</span> <span class="o">=</span> <span class="mi">127</span> <span class="o">+</span> <span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vs</span><span class="p">.</span><span class="n">significand</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">m</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">vfp_single_normaliseround</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vs</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;fuito&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fsito</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfp_single</span> <span class="n">vs</span><span class="p">;</span>

	<span class="n">vs</span><span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">vs</span><span class="p">.</span><span class="n">exponent</span> <span class="o">=</span> <span class="mi">127</span> <span class="o">+</span> <span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vs</span><span class="p">.</span><span class="n">significand</span> <span class="o">=</span> <span class="n">vs</span><span class="p">.</span><span class="n">sign</span> <span class="o">?</span> <span class="o">-</span><span class="n">m</span> <span class="o">:</span> <span class="n">m</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">vfp_single_normaliseround</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vs</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;fsito&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_ftoui</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfp_single</span> <span class="n">vsm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">d</span><span class="p">,</span> <span class="n">exceptions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rmode</span> <span class="o">=</span> <span class="n">fpscr</span> <span class="o">&amp;</span> <span class="n">FPSCR_RMODE_MASK</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tm</span><span class="p">;</span>

	<span class="n">vfp_single_unpack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;VSM&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do we have a denormalised number?</span>
<span class="cm">	 */</span>
	<span class="n">tm</span> <span class="o">=</span> <span class="n">vfp_single_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;</span> <span class="n">VFP_DENORMAL</span><span class="p">)</span>
		<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">FPSCR_IDC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;</span> <span class="n">VFP_NAN</span><span class="p">)</span>
		<span class="n">vsm</span><span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span> <span class="o">&gt;=</span> <span class="mi">127</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">vsm</span><span class="p">.</span><span class="n">sign</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mh">0xffffffff</span><span class="p">;</span>
		<span class="n">exceptions</span> <span class="o">=</span> <span class="n">FPSCR_IOC</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span> <span class="o">&gt;=</span> <span class="mi">127</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">127</span> <span class="o">+</span> <span class="mi">31</span> <span class="o">-</span> <span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">rem</span><span class="p">,</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * 2^0 &lt;= m &lt; 2^32-2^8</span>
<span class="cm">		 */</span>
		<span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">significand</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">;</span>
		<span class="n">rem</span> <span class="o">=</span> <span class="n">vsm</span><span class="p">.</span><span class="n">significand</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">33</span> <span class="o">-</span> <span class="n">shift</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rmode</span> <span class="o">==</span> <span class="n">FPSCR_ROUND_NEAREST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">incr</span> <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">d</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">incr</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rmode</span> <span class="o">==</span> <span class="n">FPSCR_ROUND_TOZERO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">incr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">rmode</span> <span class="o">==</span> <span class="n">FPSCR_ROUND_PLUSINF</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">sign</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">incr</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">rem</span> <span class="o">+</span> <span class="n">incr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">rem</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mh">0xffffffff</span><span class="p">)</span>
				<span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">FPSCR_IOC</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&amp;&amp;</span> <span class="n">vsm</span><span class="p">.</span><span class="n">sign</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">FPSCR_IOC</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rem</span><span class="p">)</span>
			<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">FPSCR_IXC</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span> <span class="o">|</span> <span class="n">vsm</span><span class="p">.</span><span class="n">significand</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">FPSCR_IXC</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rmode</span> <span class="o">==</span> <span class="n">FPSCR_ROUND_PLUSINF</span> <span class="o">&amp;&amp;</span> <span class="n">vsm</span><span class="p">.</span><span class="n">sign</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rmode</span> <span class="o">==</span> <span class="n">FPSCR_ROUND_MINUSINF</span> <span class="o">&amp;&amp;</span> <span class="n">vsm</span><span class="p">.</span><span class="n">sign</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">FPSCR_IOC</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: ftoui: d(s%d)=%08x exceptions=%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">exceptions</span><span class="p">);</span>

	<span class="n">vfp_put_float</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">exceptions</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_ftouiz</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vfp_single_ftoui</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">unused</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">FPSCR_ROUND_TOZERO</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_ftosi</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfp_single</span> <span class="n">vsm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">d</span><span class="p">,</span> <span class="n">exceptions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rmode</span> <span class="o">=</span> <span class="n">fpscr</span> <span class="o">&amp;</span> <span class="n">FPSCR_RMODE_MASK</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tm</span><span class="p">;</span>

	<span class="n">vfp_single_unpack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;VSM&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do we have a denormalised number?</span>
<span class="cm">	 */</span>
	<span class="n">tm</span> <span class="o">=</span> <span class="n">vfp_single_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vfp_single_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">VFP_DENORMAL</span><span class="p">)</span>
		<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">FPSCR_IDC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;</span> <span class="n">VFP_NAN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">FPSCR_IOC</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span> <span class="o">&gt;=</span> <span class="mi">127</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * m &gt;= 2^31-2^7: invalid</span>
<span class="cm">		 */</span>
		<span class="n">d</span> <span class="o">=</span> <span class="mh">0x7fffffff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">d</span> <span class="o">=</span> <span class="o">~</span><span class="n">d</span><span class="p">;</span>
		<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">FPSCR_IOC</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span> <span class="o">&gt;=</span> <span class="mi">127</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">127</span> <span class="o">+</span> <span class="mi">31</span> <span class="o">-</span> <span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">rem</span><span class="p">,</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* 2^0 &lt;= m &lt;= 2^31-2^7 */</span>
		<span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">significand</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">;</span>
		<span class="n">rem</span> <span class="o">=</span> <span class="n">vsm</span><span class="p">.</span><span class="n">significand</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">33</span> <span class="o">-</span> <span class="n">shift</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rmode</span> <span class="o">==</span> <span class="n">FPSCR_ROUND_NEAREST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">incr</span> <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">d</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">incr</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rmode</span> <span class="o">==</span> <span class="n">FPSCR_ROUND_TOZERO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">incr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">rmode</span> <span class="o">==</span> <span class="n">FPSCR_ROUND_PLUSINF</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">sign</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">incr</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">rem</span> <span class="o">+</span> <span class="n">incr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">rem</span> <span class="o">&amp;&amp;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mh">0xffffffff</span><span class="p">)</span>
			<span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="mh">0x7fffffff</span> <span class="o">+</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">sign</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">d</span> <span class="o">=</span> <span class="mh">0x7fffffff</span> <span class="o">+</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">sign</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">FPSCR_IOC</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rem</span><span class="p">)</span>
			<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">FPSCR_IXC</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">d</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span> <span class="o">|</span> <span class="n">vsm</span><span class="p">.</span><span class="n">significand</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">FPSCR_IXC</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rmode</span> <span class="o">==</span> <span class="n">FPSCR_ROUND_PLUSINF</span> <span class="o">&amp;&amp;</span> <span class="n">vsm</span><span class="p">.</span><span class="n">sign</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rmode</span> <span class="o">==</span> <span class="n">FPSCR_ROUND_MINUSINF</span> <span class="o">&amp;&amp;</span> <span class="n">vsm</span><span class="p">.</span><span class="n">sign</span><span class="p">)</span>
				<span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: ftosi: d(s%d)=%08x exceptions=%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">exceptions</span><span class="p">);</span>

	<span class="n">vfp_put_float</span><span class="p">((</span><span class="n">s32</span><span class="p">)</span><span class="n">d</span><span class="p">,</span> <span class="n">sd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">exceptions</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_ftosiz</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vfp_single_ftosi</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">unused</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">FPSCR_ROUND_TOZERO</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">op</span> <span class="n">fops_ext</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">FEXT_FCPY</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fcpy</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">FEXT_FABS</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fabs</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">FEXT_FNEG</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fneg</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">FEXT_FSQRT</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fsqrt</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">FEXT_FCMP</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fcmp</span><span class="p">,</span>   <span class="n">OP_SCALAR</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">FEXT_FCMPE</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fcmpe</span><span class="p">,</span>  <span class="n">OP_SCALAR</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">FEXT_FCMPZ</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fcmpz</span><span class="p">,</span>  <span class="n">OP_SCALAR</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">FEXT_FCMPEZ</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fcmpez</span><span class="p">,</span> <span class="n">OP_SCALAR</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">FEXT_FCVT</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fcvtd</span><span class="p">,</span>  <span class="n">OP_SCALAR</span><span class="o">|</span><span class="n">OP_DD</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">FEXT_FUITO</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fuito</span><span class="p">,</span>  <span class="n">OP_SCALAR</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">FEXT_FSITO</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fsito</span><span class="p">,</span>  <span class="n">OP_SCALAR</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">FEXT_FTOUI</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_ftoui</span><span class="p">,</span>  <span class="n">OP_SCALAR</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">FEXT_FTOUIZ</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_ftouiz</span><span class="p">,</span> <span class="n">OP_SCALAR</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">FEXT_FTOSI</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_ftosi</span><span class="p">,</span>  <span class="n">OP_SCALAR</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">FEXT_FTOSIZ</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_ftosiz</span><span class="p">,</span> <span class="n">OP_SCALAR</span> <span class="p">},</span>
<span class="p">};</span>





<span class="k">static</span> <span class="n">u32</span>
<span class="nf">vfp_single_fadd_nonnumber</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vsd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vsn</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vsm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vsp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">exceptions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tn</span><span class="p">,</span> <span class="n">tm</span><span class="p">;</span>

	<span class="n">tn</span> <span class="o">=</span> <span class="n">vfp_single_type</span><span class="p">(</span><span class="n">vsn</span><span class="p">);</span>
	<span class="n">tm</span> <span class="o">=</span> <span class="n">vfp_single_type</span><span class="p">(</span><span class="n">vsm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tn</span> <span class="o">&amp;</span> <span class="n">tm</span> <span class="o">&amp;</span> <span class="n">VFP_INFINITY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Two infinities.  Are they different signs?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vsn</span><span class="o">-&gt;</span><span class="n">sign</span> <span class="o">^</span> <span class="n">vsm</span><span class="o">-&gt;</span><span class="n">sign</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * different signs -&gt; invalid</span>
<span class="cm">			 */</span>
			<span class="n">exceptions</span> <span class="o">=</span> <span class="n">FPSCR_IOC</span><span class="p">;</span>
			<span class="n">vsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vfp_single_default_qnan</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * same signs -&gt; valid</span>
<span class="cm">			 */</span>
			<span class="n">vsp</span> <span class="o">=</span> <span class="n">vsn</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tn</span> <span class="o">&amp;</span> <span class="n">VFP_INFINITY</span> <span class="o">&amp;&amp;</span> <span class="n">tm</span> <span class="o">&amp;</span> <span class="n">VFP_NUMBER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * One infinity and one number -&gt; infinity</span>
<span class="cm">		 */</span>
		<span class="n">vsp</span> <span class="o">=</span> <span class="n">vsn</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * &#39;n&#39; is a NaN of some type</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">vfp_propagate_nan</span><span class="p">(</span><span class="n">vsd</span><span class="p">,</span> <span class="n">vsn</span><span class="p">,</span> <span class="n">vsm</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">vsd</span> <span class="o">=</span> <span class="o">*</span><span class="n">vsp</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">exceptions</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span>
<span class="nf">vfp_single_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vsd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vsn</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vsm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">exp_diff</span><span class="p">,</span> <span class="n">m_sig</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vsn</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span> <span class="o">||</span>
	    <span class="n">vsm</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;VFP: bad FP values in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;VSN&quot;</span><span class="p">,</span> <span class="n">vsn</span><span class="p">);</span>
		<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;VSM&quot;</span><span class="p">,</span> <span class="n">vsm</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that &#39;n&#39; is the largest magnitude number.  Note that</span>
<span class="cm">	 * if &#39;n&#39; and &#39;m&#39; have equal exponents, we do not swap them.</span>
<span class="cm">	 * This ensures that NaN propagation works correctly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vsn</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">&lt;</span> <span class="n">vsm</span><span class="o">-&gt;</span><span class="n">exponent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">vsn</span><span class="p">;</span>
		<span class="n">vsn</span> <span class="o">=</span> <span class="n">vsm</span><span class="p">;</span>
		<span class="n">vsm</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Is &#39;n&#39; an infinity or a NaN?  Note that &#39;m&#39; may be a number,</span>
<span class="cm">	 * infinity or a NaN here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vsn</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">vfp_single_fadd_nonnumber</span><span class="p">(</span><span class="n">vsd</span><span class="p">,</span> <span class="n">vsn</span><span class="p">,</span> <span class="n">vsm</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have two proper numbers, where &#39;vsn&#39; is the larger magnitude.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Copy &#39;n&#39; to &#39;d&#39; before doing the arithmetic.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">vsd</span> <span class="o">=</span> <span class="o">*</span><span class="n">vsn</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Align both numbers.</span>
<span class="cm">	 */</span>
	<span class="n">exp_diff</span> <span class="o">=</span> <span class="n">vsn</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">-</span> <span class="n">vsm</span><span class="o">-&gt;</span><span class="n">exponent</span><span class="p">;</span>
	<span class="n">m_sig</span> <span class="o">=</span> <span class="n">vfp_shiftright32jamming</span><span class="p">(</span><span class="n">vsm</span><span class="o">-&gt;</span><span class="n">significand</span><span class="p">,</span> <span class="n">exp_diff</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the signs are different, we are really subtracting.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vsn</span><span class="o">-&gt;</span><span class="n">sign</span> <span class="o">^</span> <span class="n">vsm</span><span class="o">-&gt;</span><span class="n">sign</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_sig</span> <span class="o">=</span> <span class="n">vsn</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">-</span> <span class="n">m_sig</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">s32</span><span class="p">)</span><span class="n">m_sig</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vsd</span><span class="o">-&gt;</span><span class="n">sign</span> <span class="o">=</span> <span class="n">vfp_sign_negate</span><span class="p">(</span><span class="n">vsd</span><span class="o">-&gt;</span><span class="n">sign</span><span class="p">);</span>
			<span class="n">m_sig</span> <span class="o">=</span> <span class="o">-</span><span class="n">m_sig</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_sig</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vsd</span><span class="o">-&gt;</span><span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="n">fpscr</span> <span class="o">&amp;</span> <span class="n">FPSCR_RMODE_MASK</span><span class="p">)</span> <span class="o">==</span>
				      <span class="n">FPSCR_ROUND_MINUSINF</span> <span class="o">?</span> <span class="mh">0x8000</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">m_sig</span> <span class="o">=</span> <span class="n">vsn</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">+</span> <span class="n">m_sig</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vsd</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">=</span> <span class="n">m_sig</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span>
<span class="nf">vfp_single_multiply</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vsd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vsn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">vsm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;VSN&quot;</span><span class="p">,</span> <span class="n">vsn</span><span class="p">);</span>
	<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;VSM&quot;</span><span class="p">,</span> <span class="n">vsm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that &#39;n&#39; is the largest magnitude number.  Note that</span>
<span class="cm">	 * if &#39;n&#39; and &#39;m&#39; have equal exponents, we do not swap them.</span>
<span class="cm">	 * This ensures that NaN propagation works correctly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vsn</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">&lt;</span> <span class="n">vsm</span><span class="o">-&gt;</span><span class="n">exponent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vfp_single</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">vsn</span><span class="p">;</span>
		<span class="n">vsn</span> <span class="o">=</span> <span class="n">vsm</span><span class="p">;</span>
		<span class="n">vsm</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: swapping M &lt;-&gt; N</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vsd</span><span class="o">-&gt;</span><span class="n">sign</span> <span class="o">=</span> <span class="n">vsn</span><span class="o">-&gt;</span><span class="n">sign</span> <span class="o">^</span> <span class="n">vsm</span><span class="o">-&gt;</span><span class="n">sign</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If &#39;n&#39; is an infinity or NaN, handle it.  &#39;m&#39; may be anything.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vsn</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vsn</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">||</span> <span class="p">(</span><span class="n">vsm</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">255</span> <span class="o">&amp;&amp;</span> <span class="n">vsm</span><span class="o">-&gt;</span><span class="n">significand</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">vfp_propagate_nan</span><span class="p">(</span><span class="n">vsd</span><span class="p">,</span> <span class="n">vsn</span><span class="p">,</span> <span class="n">vsm</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vsm</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">|</span> <span class="n">vsm</span><span class="o">-&gt;</span><span class="n">significand</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">vsd</span> <span class="o">=</span> <span class="n">vfp_single_default_qnan</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">FPSCR_IOC</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vsd</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">=</span> <span class="n">vsn</span><span class="o">-&gt;</span><span class="n">exponent</span><span class="p">;</span>
		<span class="n">vsd</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If &#39;m&#39; is zero, the result is always zero.  In this case,</span>
<span class="cm">	 * &#39;n&#39; may be zero or a number, but it doesn&#39;t matter which.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vsm</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">|</span> <span class="n">vsm</span><span class="o">-&gt;</span><span class="n">significand</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vsd</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">vsd</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We add 2 to the destination exponent for the same reason as</span>
<span class="cm">	 * the addition case - though this time we have +1 from each</span>
<span class="cm">	 * input operand.</span>
<span class="cm">	 */</span>
	<span class="n">vsd</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">=</span> <span class="n">vsn</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">+</span> <span class="n">vsm</span><span class="o">-&gt;</span><span class="n">exponent</span> <span class="o">-</span> <span class="mi">127</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">vsd</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">=</span> <span class="n">vfp_hi64to32jamming</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">vsn</span><span class="o">-&gt;</span><span class="n">significand</span> <span class="o">*</span> <span class="n">vsm</span><span class="o">-&gt;</span><span class="n">significand</span><span class="p">);</span>

	<span class="n">vfp_single_dump</span><span class="p">(</span><span class="s">&quot;VSD&quot;</span><span class="p">,</span> <span class="n">vsd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define NEG_MULTIPLY	(1 &lt;&lt; 0)</span>
<span class="cp">#define NEG_SUBTRACT	(1 &lt;&lt; 1)</span>

<span class="k">static</span> <span class="n">u32</span>
<span class="nf">vfp_single_multiply_accumulate</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">negate</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfp_single</span> <span class="n">vsd</span><span class="p">,</span> <span class="n">vsp</span><span class="p">,</span> <span class="n">vsn</span><span class="p">,</span> <span class="n">vsm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">exceptions</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">vfp_get_float</span><span class="p">(</span><span class="n">sn</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: s%u = %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="n">vfp_single_unpack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsn</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vsn</span><span class="p">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">vsn</span><span class="p">.</span><span class="n">significand</span><span class="p">)</span>
		<span class="n">vfp_single_normalise_denormal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsn</span><span class="p">);</span>

	<span class="n">vfp_single_unpack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">vsm</span><span class="p">.</span><span class="n">significand</span><span class="p">)</span>
		<span class="n">vfp_single_normalise_denormal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">);</span>

	<span class="n">exceptions</span> <span class="o">=</span> <span class="n">vfp_single_multiply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">negate</span> <span class="o">&amp;</span> <span class="n">NEG_MULTIPLY</span><span class="p">)</span>
		<span class="n">vsp</span><span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="n">vfp_sign_negate</span><span class="p">(</span><span class="n">vsp</span><span class="p">.</span><span class="n">sign</span><span class="p">);</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">vfp_get_float</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: s%u = %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="n">vfp_single_unpack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsn</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">negate</span> <span class="o">&amp;</span> <span class="n">NEG_SUBTRACT</span><span class="p">)</span>
		<span class="n">vsn</span><span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="n">vfp_sign_negate</span><span class="p">(</span><span class="n">vsn</span><span class="p">.</span><span class="n">sign</span><span class="p">);</span>

	<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">vfp_single_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsp</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">vfp_single_normaliseround</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsd</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">,</span> <span class="n">exceptions</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Standard operations</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * sd = sd + (sn * sm)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fmac</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vfp_single_multiply_accumulate</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;fmac&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sd = sd - (sn * sm)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fnmac</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vfp_single_multiply_accumulate</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">,</span> <span class="n">NEG_MULTIPLY</span><span class="p">,</span> <span class="s">&quot;fnmac&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sd = -sd + (sn * sm)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fmsc</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vfp_single_multiply_accumulate</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">,</span> <span class="n">NEG_SUBTRACT</span><span class="p">,</span> <span class="s">&quot;fmsc&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sd = -sd - (sn * sm)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fnmsc</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vfp_single_multiply_accumulate</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">,</span> <span class="n">NEG_SUBTRACT</span> <span class="o">|</span> <span class="n">NEG_MULTIPLY</span><span class="p">,</span> <span class="s">&quot;fnmsc&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sd = sn * sm</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fmul</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfp_single</span> <span class="n">vsd</span><span class="p">,</span> <span class="n">vsn</span><span class="p">,</span> <span class="n">vsm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">exceptions</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">n</span> <span class="o">=</span> <span class="n">vfp_get_float</span><span class="p">(</span><span class="n">sn</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: s%u = %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

	<span class="n">vfp_single_unpack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsn</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vsn</span><span class="p">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">vsn</span><span class="p">.</span><span class="n">significand</span><span class="p">)</span>
		<span class="n">vfp_single_normalise_denormal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsn</span><span class="p">);</span>

	<span class="n">vfp_single_unpack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">vsm</span><span class="p">.</span><span class="n">significand</span><span class="p">)</span>
		<span class="n">vfp_single_normalise_denormal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">);</span>

	<span class="n">exceptions</span> <span class="o">=</span> <span class="n">vfp_single_multiply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vfp_single_normaliseround</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsd</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">,</span> <span class="n">exceptions</span><span class="p">,</span> <span class="s">&quot;fmul&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sd = -(sn * sm)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fnmul</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfp_single</span> <span class="n">vsd</span><span class="p">,</span> <span class="n">vsn</span><span class="p">,</span> <span class="n">vsm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">exceptions</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">n</span> <span class="o">=</span> <span class="n">vfp_get_float</span><span class="p">(</span><span class="n">sn</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: s%u = %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

	<span class="n">vfp_single_unpack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsn</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vsn</span><span class="p">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">vsn</span><span class="p">.</span><span class="n">significand</span><span class="p">)</span>
		<span class="n">vfp_single_normalise_denormal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsn</span><span class="p">);</span>

	<span class="n">vfp_single_unpack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">vsm</span><span class="p">.</span><span class="n">significand</span><span class="p">)</span>
		<span class="n">vfp_single_normalise_denormal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">);</span>

	<span class="n">exceptions</span> <span class="o">=</span> <span class="n">vfp_single_multiply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>
	<span class="n">vsd</span><span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="n">vfp_sign_negate</span><span class="p">(</span><span class="n">vsd</span><span class="p">.</span><span class="n">sign</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vfp_single_normaliseround</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsd</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">,</span> <span class="n">exceptions</span><span class="p">,</span> <span class="s">&quot;fnmul&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sd = sn + sm</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fadd</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfp_single</span> <span class="n">vsd</span><span class="p">,</span> <span class="n">vsn</span><span class="p">,</span> <span class="n">vsm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">exceptions</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">n</span> <span class="o">=</span> <span class="n">vfp_get_float</span><span class="p">(</span><span class="n">sn</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: s%u = %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unpack and normalise denormals.</span>
<span class="cm">	 */</span>
	<span class="n">vfp_single_unpack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsn</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vsn</span><span class="p">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">vsn</span><span class="p">.</span><span class="n">significand</span><span class="p">)</span>
		<span class="n">vfp_single_normalise_denormal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsn</span><span class="p">);</span>

	<span class="n">vfp_single_unpack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">vsm</span><span class="p">.</span><span class="n">significand</span><span class="p">)</span>
		<span class="n">vfp_single_normalise_denormal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">);</span>

	<span class="n">exceptions</span> <span class="o">=</span> <span class="n">vfp_single_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">vfp_single_normaliseround</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsd</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">,</span> <span class="n">exceptions</span><span class="p">,</span> <span class="s">&quot;fadd&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sd = sn - sm</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fsub</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Subtraction is addition with one sign inverted.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">vfp_single_fadd</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="n">vfp_single_packed_negate</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">fpscr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sd = sn / sm</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">vfp_single_fdiv</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s32</span> <span class="n">m</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfp_single</span> <span class="n">vsd</span><span class="p">,</span> <span class="n">vsn</span><span class="p">,</span> <span class="n">vsm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">exceptions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">n</span> <span class="o">=</span> <span class="n">vfp_get_float</span><span class="p">(</span><span class="n">sn</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">tm</span><span class="p">,</span> <span class="n">tn</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: s%u = %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

	<span class="n">vfp_single_unpack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsn</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">vfp_single_unpack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>

	<span class="n">vsd</span><span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="n">vsn</span><span class="p">.</span><span class="n">sign</span> <span class="o">^</span> <span class="n">vsm</span><span class="p">.</span><span class="n">sign</span><span class="p">;</span>

	<span class="n">tn</span> <span class="o">=</span> <span class="n">vfp_single_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsn</span><span class="p">);</span>
	<span class="n">tm</span> <span class="o">=</span> <span class="n">vfp_single_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Is n a NAN?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tn</span> <span class="o">&amp;</span> <span class="n">VFP_NAN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">vsn_nan</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Is m a NAN?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;</span> <span class="n">VFP_NAN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">vsm_nan</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If n and m are infinity, the result is invalid</span>
<span class="cm">	 * If n and m are zero, the result is invalid</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;</span> <span class="n">tn</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VFP_INFINITY</span><span class="o">|</span><span class="n">VFP_ZERO</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If n is infinity, the result is infinity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tn</span> <span class="o">&amp;</span> <span class="n">VFP_INFINITY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">infinity</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If m is zero, raise div0 exception</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;</span> <span class="n">VFP_ZERO</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">divzero</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If m is infinity, or n is zero, the result is zero</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;</span> <span class="n">VFP_INFINITY</span> <span class="o">||</span> <span class="n">tn</span> <span class="o">&amp;</span> <span class="n">VFP_ZERO</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">zero</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tn</span> <span class="o">&amp;</span> <span class="n">VFP_DENORMAL</span><span class="p">)</span>
		<span class="n">vfp_single_normalise_denormal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;</span> <span class="n">VFP_DENORMAL</span><span class="p">)</span>
		<span class="n">vfp_single_normalise_denormal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ok, we have two numbers, we can perform division.</span>
<span class="cm">	 */</span>
	<span class="n">vsd</span><span class="p">.</span><span class="n">exponent</span> <span class="o">=</span> <span class="n">vsn</span><span class="p">.</span><span class="n">exponent</span> <span class="o">-</span> <span class="n">vsm</span><span class="p">.</span><span class="n">exponent</span> <span class="o">+</span> <span class="mi">127</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vsm</span><span class="p">.</span><span class="n">significand</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vsm</span><span class="p">.</span><span class="n">significand</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">vsn</span><span class="p">.</span><span class="n">significand</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vsn</span><span class="p">.</span><span class="n">significand</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vsd</span><span class="p">.</span><span class="n">exponent</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">{</span>
		<span class="n">u64</span> <span class="n">significand</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">vsn</span><span class="p">.</span><span class="n">significand</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">significand</span><span class="p">,</span> <span class="n">vsm</span><span class="p">.</span><span class="n">significand</span><span class="p">);</span>
		<span class="n">vsd</span><span class="p">.</span><span class="n">significand</span> <span class="o">=</span> <span class="n">significand</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vsd</span><span class="p">.</span><span class="n">significand</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">vsd</span><span class="p">.</span><span class="n">significand</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">vsm</span><span class="p">.</span><span class="n">significand</span> <span class="o">*</span> <span class="n">vsd</span><span class="p">.</span><span class="n">significand</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">vsn</span><span class="p">.</span><span class="n">significand</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">vfp_single_normaliseround</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsd</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;fdiv&quot;</span><span class="p">);</span>

 <span class="nl">vsn_nan:</span>
	<span class="n">exceptions</span> <span class="o">=</span> <span class="n">vfp_propagate_nan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>
 <span class="nl">pack:</span>
	<span class="n">vfp_put_float</span><span class="p">(</span><span class="n">vfp_single_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsd</span><span class="p">),</span> <span class="n">sd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">exceptions</span><span class="p">;</span>

 <span class="nl">vsm_nan:</span>
	<span class="n">exceptions</span> <span class="o">=</span> <span class="n">vfp_propagate_nan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vsd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vsn</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">pack</span><span class="p">;</span>

 <span class="nl">zero:</span>
	<span class="n">vsd</span><span class="p">.</span><span class="n">exponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vsd</span><span class="p">.</span><span class="n">significand</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">pack</span><span class="p">;</span>

 <span class="nl">divzero:</span>
	<span class="n">exceptions</span> <span class="o">=</span> <span class="n">FPSCR_DZC</span><span class="p">;</span>
 <span class="nl">infinity:</span>
	<span class="n">vsd</span><span class="p">.</span><span class="n">exponent</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
	<span class="n">vsd</span><span class="p">.</span><span class="n">significand</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">pack</span><span class="p">;</span>

 <span class="nl">invalid:</span>
	<span class="n">vfp_put_float</span><span class="p">(</span><span class="n">vfp_single_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfp_single_default_qnan</span><span class="p">),</span> <span class="n">sd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">FPSCR_IOC</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">op</span> <span class="n">fops</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">FOP_TO_IDX</span><span class="p">(</span><span class="n">FOP_FMAC</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fmac</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FOP_TO_IDX</span><span class="p">(</span><span class="n">FOP_FNMAC</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fnmac</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FOP_TO_IDX</span><span class="p">(</span><span class="n">FOP_FMSC</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fmsc</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FOP_TO_IDX</span><span class="p">(</span><span class="n">FOP_FNMSC</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fnmsc</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FOP_TO_IDX</span><span class="p">(</span><span class="n">FOP_FMUL</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fmul</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FOP_TO_IDX</span><span class="p">(</span><span class="n">FOP_FNMUL</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fnmul</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FOP_TO_IDX</span><span class="p">(</span><span class="n">FOP_FADD</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fadd</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FOP_TO_IDX</span><span class="p">(</span><span class="n">FOP_FSUB</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fsub</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">FOP_TO_IDX</span><span class="p">(</span><span class="n">FOP_FDIV</span><span class="p">)]</span>	<span class="o">=</span> <span class="p">{</span> <span class="n">vfp_single_fdiv</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">},</span>
<span class="p">};</span>

<span class="cp">#define FREG_BANK(x)	((x) &amp; 0x18)</span>
<span class="cp">#define FREG_IDX(x)	((x) &amp; 7)</span>

<span class="n">u32</span> <span class="nf">vfp_single_cpdo</span><span class="p">(</span><span class="n">u32</span> <span class="n">inst</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fpscr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">op</span> <span class="o">=</span> <span class="n">inst</span> <span class="o">&amp;</span> <span class="n">FOP_MASK</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">exceptions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sn</span> <span class="o">=</span> <span class="n">vfp_get_sn</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sm</span> <span class="o">=</span> <span class="n">vfp_get_sm</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vecitr</span><span class="p">,</span> <span class="n">veclen</span><span class="p">,</span> <span class="n">vecstride</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">op</span> <span class="o">*</span><span class="n">fop</span><span class="p">;</span>

	<span class="n">vecstride</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">fpscr</span> <span class="o">&amp;</span> <span class="n">FPSCR_STRIDE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">FPSCR_STRIDE_MASK</span><span class="p">);</span>

	<span class="n">fop</span> <span class="o">=</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">FOP_EXT</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">fops_ext</span><span class="p">[</span><span class="n">FEXT_TO_IDX</span><span class="p">(</span><span class="n">inst</span><span class="p">)]</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">fops</span><span class="p">[</span><span class="n">FOP_TO_IDX</span><span class="p">(</span><span class="n">op</span><span class="p">)];</span>

	<span class="cm">/*</span>
<span class="cm">	 * fcvtsd takes a dN register number as destination, not sN.</span>
<span class="cm">	 * Technically, if bit 0 of dd is set, this is an invalid</span>
<span class="cm">	 * instruction.  However, we ignore this for efficiency.</span>
<span class="cm">	 * It also only operates on scalars.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fop</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OP_DD</span><span class="p">)</span>
		<span class="n">dest</span> <span class="o">=</span> <span class="n">vfp_get_dd</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dest</span> <span class="o">=</span> <span class="n">vfp_get_sd</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If destination bank is zero, vector length is always &#39;1&#39;.</span>
<span class="cm">	 * ARM DDI0100F C5.1.3, C5.3.2.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fop</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OP_SCALAR</span><span class="p">)</span> <span class="o">||</span> <span class="n">FREG_BANK</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">veclen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">veclen</span> <span class="o">=</span> <span class="n">fpscr</span> <span class="o">&amp;</span> <span class="n">FPSCR_LENGTH_MASK</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: vecstride=%u veclen=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vecstride</span><span class="p">,</span>
		 <span class="p">(</span><span class="n">veclen</span> <span class="o">&gt;&gt;</span> <span class="n">FPSCR_LENGTH_BIT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fop</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">vecitr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vecitr</span> <span class="o">&lt;=</span> <span class="n">veclen</span><span class="p">;</span> <span class="n">vecitr</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">FPSCR_LENGTH_BIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s32</span> <span class="n">m</span> <span class="o">=</span> <span class="n">vfp_get_float</span><span class="p">(</span><span class="n">sm</span><span class="p">);</span>
		<span class="n">u32</span> <span class="n">except</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">type</span><span class="p">;</span>

		<span class="n">type</span> <span class="o">=</span> <span class="n">fop</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OP_DD</span> <span class="o">?</span> <span class="sc">&#39;d&#39;</span> <span class="o">:</span> <span class="sc">&#39;s&#39;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">FOP_EXT</span><span class="p">)</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: itr%d (%c%u) = op[%u] (s%u=%08x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">vecitr</span> <span class="o">&gt;&gt;</span> <span class="n">FPSCR_LENGTH_BIT</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span>
				 <span class="n">sm</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: itr%d (%c%u) = (s%u) op[%u] (s%u=%08x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">vecitr</span> <span class="o">&gt;&gt;</span> <span class="n">FPSCR_LENGTH_BIT</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span>
				 <span class="n">FOP_TO_IDX</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="n">sm</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>

		<span class="n">except</span> <span class="o">=</span> <span class="n">fop</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">fpscr</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VFP: itr%d: exceptions=%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">vecitr</span> <span class="o">&gt;&gt;</span> <span class="n">FPSCR_LENGTH_BIT</span><span class="p">,</span> <span class="n">except</span><span class="p">);</span>

		<span class="n">exceptions</span> <span class="o">|=</span> <span class="n">except</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * CHECK: It appears to be undefined whether we stop when</span>
<span class="cm">		 * we encounter an exception.  We continue.</span>
<span class="cm">		 */</span>
		<span class="n">dest</span> <span class="o">=</span> <span class="n">FREG_BANK</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">FREG_IDX</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">+</span> <span class="n">vecstride</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
		<span class="n">sn</span> <span class="o">=</span> <span class="n">FREG_BANK</span><span class="p">(</span><span class="n">sn</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">FREG_IDX</span><span class="p">(</span><span class="n">sn</span><span class="p">)</span> <span class="o">+</span> <span class="n">vecstride</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">FREG_BANK</span><span class="p">(</span><span class="n">sm</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">sm</span> <span class="o">=</span> <span class="n">FREG_BANK</span><span class="p">(</span><span class="n">sm</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">FREG_IDX</span><span class="p">(</span><span class="n">sm</span><span class="p">)</span> <span class="o">+</span> <span class="n">vecstride</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">exceptions</span><span class="p">;</span>

 <span class="nl">invalid:</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
