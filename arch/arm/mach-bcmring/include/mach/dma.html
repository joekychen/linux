<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mach-bcmring › include › mach › dma.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>dma.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*****************************************************************************</span>
<span class="cm">* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.</span>
<span class="cm">*</span>
<span class="cm">* Unless you and Broadcom execute a separate written software license</span>
<span class="cm">* agreement governing use of this software, this software is licensed to you</span>
<span class="cm">* under the terms of the GNU General Public License version 2, available at</span>
<span class="cm">* http://www.broadcom.com/licenses/GPLv2.php (the &quot;GPL&quot;).</span>
<span class="cm">*</span>
<span class="cm">* Notwithstanding the above, under no circumstances may you combine this</span>
<span class="cm">* software in any way with any other Broadcom software provided under a</span>
<span class="cm">* license other than the GPL, without Broadcom&#39;s express prior written</span>
<span class="cm">* consent.</span>
<span class="cm">*****************************************************************************/</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   @file   dma.h</span>
<span class="cm">*</span>
<span class="cm">*   @brief  API definitions for the linux DMA interface.</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="cp">#if !defined(ASM_ARM_ARCH_BCMRING_DMA_H)</span>
<span class="cp">#define ASM_ARM_ARCH_BCMRING_DMA_H</span>

<span class="cm">/* ---- Include Files ---------------------------------------------------- */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/semaphore.h&gt;</span>
<span class="cp">#include &lt;csp/dmacHw.h&gt;</span>
<span class="cp">#include &lt;mach/timer.h&gt;</span>

<span class="cm">/* ---- Constants and Types ---------------------------------------------- */</span>

<span class="cm">/* If DMA_DEBUG_TRACK_RESERVATION is set to a non-zero value, then the filename */</span>
<span class="cm">/* and line number of the reservation request will be recorded in the channel table */</span>

<span class="cp">#define DMA_DEBUG_TRACK_RESERVATION   1</span>

<span class="cp">#define DMA_NUM_CONTROLLERS     2</span>
<span class="cp">#define DMA_NUM_CHANNELS        8	</span><span class="cm">/* per controller */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">DMA_DEVICE_MEM_TO_MEM</span><span class="p">,</span>	<span class="cm">/* For memory to memory transfers */</span>
	<span class="n">DMA_DEVICE_I2S0_DEV_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_I2S0_MEM_TO_DEV</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_I2S1_DEV_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_I2S1_MEM_TO_DEV</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_APM_CODEC_A_DEV_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_APM_CODEC_A_MEM_TO_DEV</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_APM_CODEC_B_DEV_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_APM_CODEC_B_MEM_TO_DEV</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_APM_CODEC_C_DEV_TO_MEM</span><span class="p">,</span>	<span class="cm">/* Additional mic input for beam-forming */</span>
	<span class="n">DMA_DEVICE_APM_PCM0_DEV_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_APM_PCM0_MEM_TO_DEV</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_APM_PCM1_DEV_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_APM_PCM1_MEM_TO_DEV</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_SPUM_DEV_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_SPUM_MEM_TO_DEV</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_SPIH_DEV_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_SPIH_MEM_TO_DEV</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_UART_A_DEV_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_UART_A_MEM_TO_DEV</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_UART_B_DEV_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_UART_B_MEM_TO_DEV</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_PIF_MEM_TO_DEV</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_PIF_DEV_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_ESW_DEV_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_ESW_MEM_TO_DEV</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_VPM_MEM_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_CLCD_MEM_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_NAND_MEM_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_MEM_TO_VRAM</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_VRAM_TO_MEM</span><span class="p">,</span>

	<span class="cm">/* Add new entries before this line. */</span>

	<span class="n">DMA_NUM_DEVICE_ENTRIES</span><span class="p">,</span>
	<span class="n">DMA_DEVICE_NONE</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>	<span class="cm">/* Special value to indicate that no device is currently assigned. */</span>

<span class="p">}</span> <span class="n">DMA_Device_t</span><span class="p">;</span>

<span class="cm">/****************************************************************************</span>
<span class="cm">*</span>
<span class="cm">*   The DMA_Handle_t is the primary object used by callers of the API.</span>
<span class="cm">*</span>
<span class="cm">*****************************************************************************/</span>

<span class="cp">#define DMA_INVALID_HANDLE  ((DMA_Handle_t) -1)</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="n">DMA_Handle_t</span><span class="p">;</span>

<span class="cm">/****************************************************************************</span>
<span class="cm">*</span>
<span class="cm">*   The DMA_DescriptorRing_t contains a ring of descriptors which is used</span>
<span class="cm">*   to point to regions of memory.</span>
<span class="cm">*</span>
<span class="cm">*****************************************************************************/</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">virtAddr</span><span class="p">;</span>		<span class="cm">/* Virtual Address of the descriptor ring */</span>
	<span class="n">dma_addr_t</span> <span class="n">physAddr</span><span class="p">;</span>	<span class="cm">/* Physical address of the descriptor ring */</span>
	<span class="kt">int</span> <span class="n">descriptorsAllocated</span><span class="p">;</span>	<span class="cm">/* Number of descriptors allocated in the descriptor ring */</span>
	<span class="kt">size_t</span> <span class="n">bytesAllocated</span><span class="p">;</span>	<span class="cm">/* Number of bytes allocated in the descriptor ring */</span>

<span class="p">}</span> <span class="n">DMA_DescriptorRing_t</span><span class="p">;</span>

<span class="cm">/****************************************************************************</span>
<span class="cm">*</span>
<span class="cm">*   The DMA_DeviceAttribute_t contains information which describes a</span>
<span class="cm">*   particular DMA device (or peripheral).</span>
<span class="cm">*</span>
<span class="cm">*   It is anticipated that the arrary of DMA_DeviceAttribute_t&#39;s will be</span>
<span class="cm">*   statically initialized.</span>
<span class="cm">*</span>
<span class="cm">*****************************************************************************/</span>

<span class="cm">/* The device handler is called whenever a DMA operation completes. The reaon */</span>
<span class="cm">/* for it to be called will be a bitmask with one or more of the following bits */</span>
<span class="cm">/* set. */</span>

<span class="cp">#define DMA_HANDLER_REASON_BLOCK_COMPLETE       dmacHw_INTERRUPT_STATUS_BLOCK</span>
<span class="cp">#define DMA_HANDLER_REASON_TRANSFER_COMPLETE    dmacHw_INTERRUPT_STATUS_TRANS</span>
<span class="cp">#define DMA_HANDLER_REASON_ERROR                dmacHw_INTERRUPT_STATUS_ERROR</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">DMA_DeviceHandler_t</span><span class="p">)</span> <span class="p">(</span><span class="n">DMA_Device_t</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">userData</span><span class="p">);</span>

<span class="cp">#define DMA_DEVICE_FLAG_ON_DMA0             0x00000001</span>
<span class="cp">#define DMA_DEVICE_FLAG_ON_DMA1             0x00000002</span>
<span class="cp">#define DMA_DEVICE_FLAG_PORT_PER_DMAC       0x00000004	</span><span class="cm">/* If set, it means that the port used on DMAC0 is different from the port used on DMAC1 */</span><span class="cp"></span>
<span class="cp">#define DMA_DEVICE_FLAG_ALLOC_DMA1_FIRST    0x00000008	</span><span class="cm">/* If set, allocate from DMA1 before allocating from DMA0 */</span><span class="cp"></span>
<span class="cp">#define DMA_DEVICE_FLAG_IS_DEDICATED        0x00000100</span>
<span class="cp">#define DMA_DEVICE_FLAG_NO_ISR              0x00000200</span>
<span class="cp">#define DMA_DEVICE_FLAG_ALLOW_LARGE_FIFO    0x00000400</span>
<span class="cp">#define DMA_DEVICE_FLAG_IN_USE              0x00000800	</span><span class="cm">/* If set, device is in use on a channel */</span><span class="cp"></span>

<span class="cm">/* Note: Some DMA devices can be used from multiple DMA Controllers. The bitmask is used to */</span>
<span class="cm">/*       determine which DMA controllers a given device can be used from, and the interface */</span>
<span class="cm">/*       array determeines the actual interface number to use for a given controller. */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* Bitmask of DMA_DEVICE_FLAG_xxx constants */</span>
	<span class="kt">uint8_t</span> <span class="n">dedicatedController</span><span class="p">;</span>	<span class="cm">/* Controller number to use if DMA_DEVICE_FLAG_IS_DEDICATED is set. */</span>
	<span class="kt">uint8_t</span> <span class="n">dedicatedChannel</span><span class="p">;</span>	<span class="cm">/* Channel number to use if DMA_DEVICE_FLAG_IS_DEDICATED is set. */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>	<span class="cm">/* Will show up in the /proc entry */</span>

	<span class="kt">uint32_t</span> <span class="n">dmacPort</span><span class="p">[</span><span class="n">DMA_NUM_CONTROLLERS</span><span class="p">];</span>	<span class="cm">/* Specifies the port number when DMA_DEVICE_FLAG_PORT_PER_DMAC flag is set */</span>

	<span class="n">dmacHw_CONFIG_t</span> <span class="n">config</span><span class="p">;</span>	<span class="cm">/* Configuration to use when DMA&#39;ing using this device */</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">userData</span><span class="p">;</span>		<span class="cm">/* Passed to the devHandler */</span>
	<span class="n">DMA_DeviceHandler_t</span> <span class="n">devHandler</span><span class="p">;</span>	<span class="cm">/* Called when DMA operations finish. */</span>

	<span class="n">timer_tick_count_t</span> <span class="n">transferStartTime</span><span class="p">;</span>	<span class="cm">/* Time the current transfer was started */</span>

	<span class="cm">/* The following statistical information will be collected and presented in a proc entry. */</span>
	<span class="cm">/* Note: With a contiuous bandwidth of 1 Gb/sec, it would take 584 years to overflow */</span>
	<span class="cm">/*       a 64 bit counter. */</span>

	<span class="kt">uint64_t</span> <span class="n">numTransfers</span><span class="p">;</span>	<span class="cm">/* Number of DMA transfers performed */</span>
	<span class="kt">uint64_t</span> <span class="n">transferTicks</span><span class="p">;</span>	<span class="cm">/* Total time spent doing DMA transfers (measured in timer_tick_count_t&#39;s) */</span>
	<span class="kt">uint64_t</span> <span class="n">transferBytes</span><span class="p">;</span>	<span class="cm">/* Total bytes transferred */</span>
	<span class="kt">uint32_t</span> <span class="n">timesBlocked</span><span class="p">;</span>	<span class="cm">/* Number of times a channel was unavailable */</span>
	<span class="kt">uint32_t</span> <span class="n">numBytes</span><span class="p">;</span>	<span class="cm">/* Last transfer size */</span>

	<span class="cm">/* It&#39;s not possible to free memory which is allocated for the descriptors from within */</span>
	<span class="cm">/* the ISR. So make the presumption that a given device will tend to use the */</span>
	<span class="cm">/* same sized buffers over and over again, and we keep them around. */</span>

	<span class="n">DMA_DescriptorRing_t</span> <span class="n">ring</span><span class="p">;</span>	<span class="cm">/* Ring of descriptors allocated for this device */</span>

	<span class="cm">/* We stash away some of the information from the previous transfer. If back-to-back */</span>
	<span class="cm">/* transfers are performed from the same buffer, then we don&#39;t have to keep re-initializing */</span>
	<span class="cm">/* the descriptor buffers. */</span>

	<span class="kt">uint32_t</span> <span class="n">prevNumBytes</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">prevSrcData</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">prevDstData</span><span class="p">;</span>

<span class="p">}</span> <span class="n">DMA_DeviceAttribute_t</span><span class="p">;</span>

<span class="cm">/****************************************************************************</span>
<span class="cm">*</span>
<span class="cm">*   DMA_Channel_t, DMA_Controller_t, and DMA_State_t are really internal</span>
<span class="cm">*   data structures and don&#39;t belong in this header file, but are included</span>
<span class="cm">*   merely for discussion.</span>
<span class="cm">*</span>
<span class="cm">*   By the time this is implemented, these structures will be moved out into</span>
<span class="cm">*   the appropriate C source file instead.</span>
<span class="cm">*</span>
<span class="cm">*****************************************************************************/</span>

<span class="cm">/****************************************************************************</span>
<span class="cm">*</span>
<span class="cm">*   The DMA_Channel_t contains state information about each DMA channel. Some</span>
<span class="cm">*   of the channels are dedicated. Non-dedicated channels are shared</span>
<span class="cm">*   amongst the other devices.</span>
<span class="cm">*</span>
<span class="cm">*****************************************************************************/</span>

<span class="cp">#define DMA_CHANNEL_FLAG_IN_USE         0x00000001</span>
<span class="cp">#define DMA_CHANNEL_FLAG_IS_DEDICATED   0x00000002</span>
<span class="cp">#define DMA_CHANNEL_FLAG_NO_ISR         0x00000004</span>
<span class="cp">#define DMA_CHANNEL_FLAG_LARGE_FIFO     0x00000008</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* bitmask of DMA_CHANNEL_FLAG_xxx constants */</span>
	<span class="n">DMA_Device_t</span> <span class="n">devType</span><span class="p">;</span>	<span class="cm">/* Device this channel is currently reserved for */</span>
	<span class="n">DMA_Device_t</span> <span class="n">lastDevType</span><span class="p">;</span>	<span class="cm">/* Device type that used this previously */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>		<span class="cm">/* Name passed onto request_irq */</span>

<span class="cp">#if (DMA_DEBUG_TRACK_RESERVATION)</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fileName</span><span class="p">;</span>	<span class="cm">/* Place where channel reservation took place */</span>
	<span class="kt">int</span> <span class="n">lineNum</span><span class="p">;</span>		<span class="cm">/* Place where channel reservation took place */</span>
<span class="cp">#endif</span>
	<span class="n">dmacHw_HANDLE_t</span> <span class="n">dmacHwHandle</span><span class="p">;</span>	<span class="cm">/* low level channel handle. */</span>

<span class="p">}</span> <span class="n">DMA_Channel_t</span><span class="p">;</span>

<span class="cm">/****************************************************************************</span>
<span class="cm">*</span>
<span class="cm">*   The DMA_Controller_t contains state information about each DMA controller.</span>
<span class="cm">*</span>
<span class="cm">*   The freeChannelQ is stored in the controller data structure rather than</span>
<span class="cm">*   the channel data structure since several of the devices are accessible</span>
<span class="cm">*   from multiple controllers, and there is no way to know which controller</span>
<span class="cm">*   will become available first.</span>
<span class="cm">*</span>
<span class="cm">*****************************************************************************/</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">DMA_Channel_t</span> <span class="n">channel</span><span class="p">[</span><span class="n">DMA_NUM_CHANNELS</span><span class="p">];</span>

<span class="p">}</span> <span class="n">DMA_Controller_t</span><span class="p">;</span>

<span class="cm">/****************************************************************************</span>
<span class="cm">*</span>
<span class="cm">*   The DMA_Global_t contains all of the global state information used by</span>
<span class="cm">*   the DMA code.</span>
<span class="cm">*</span>
<span class="cm">*   Callers which need to allocate a shared channel will be queued up</span>
<span class="cm">*   on the freeChannelQ until a channel becomes available.</span>
<span class="cm">*</span>
<span class="cm">*****************************************************************************/</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">semaphore</span> <span class="n">lock</span><span class="p">;</span>	<span class="cm">/* acquired when manipulating table entries */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">freeChannelQ</span><span class="p">;</span>

	<span class="n">DMA_Controller_t</span> <span class="n">controller</span><span class="p">[</span><span class="n">DMA_NUM_CONTROLLERS</span><span class="p">];</span>

<span class="p">}</span> <span class="n">DMA_Global_t</span><span class="p">;</span>

<span class="cm">/* ---- Variable Externs ------------------------------------------------- */</span>

<span class="k">extern</span> <span class="n">DMA_DeviceAttribute_t</span> <span class="n">DMA_gDeviceAttribute</span><span class="p">[</span><span class="n">DMA_NUM_DEVICE_ENTRIES</span><span class="p">];</span>

<span class="cm">/* ---- Function Prototypes ---------------------------------------------- */</span>

<span class="cp">#if defined(__KERNEL__)</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Initializes the DMA module.</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*       0       - Success</span>
<span class="cm">*       &lt; 0     - Error</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#if (DMA_DEBUG_TRACK_RESERVATION)</span>
<span class="n">DMA_Handle_t</span> <span class="n">dma_request_channel_dbg</span><span class="p">(</span><span class="n">DMA_Device_t</span> <span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fileName</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">lineNum</span><span class="p">);</span>
<span class="cp">#define dma_request_channel(dev)  dma_request_channel_dbg(dev, __FILE__, __LINE__)</span>
<span class="cp">#else</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Reserves a channel for use with @a dev. If the device is setup to use</span>
<span class="cm">*   a shared channel, then this function will block until a free channel</span>
<span class="cm">*   becomes available.</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*       &gt;= 0    - A valid DMA Handle.</span>
<span class="cm">*       -EBUSY  - Device is currently being used.</span>
<span class="cm">*       -ENODEV - Device handed in is invalid.</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="n">DMA_Handle_t</span> <span class="n">dma_request_channel</span><span class="p">(</span><span class="n">DMA_Device_t</span> <span class="n">dev</span>	<span class="cm">/* Device to use with the allocated channel. */</span>
    <span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Frees a previously allocated DMA Handle.</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*        0      - DMA Handle was released successfully.</span>
<span class="cm">*       -EINVAL - Invalid DMA handle</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_free_channel</span><span class="p">(</span><span class="n">DMA_Handle_t</span> <span class="n">channel</span>	<span class="cm">/* DMA handle. */</span>
    <span class="p">);</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Determines if a given device has been configured as using a shared</span>
<span class="cm">*   channel.</span>
<span class="cm">*</span>
<span class="cm">*   @return boolean</span>
<span class="cm">*       0           Device uses a dedicated channel</span>
<span class="cm">*       non-zero    Device uses a shared channel</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_device_is_channel_shared</span><span class="p">(</span><span class="n">DMA_Device_t</span> <span class="n">dev</span>	<span class="cm">/* Device to check. */</span>
    <span class="p">);</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Allocates memory to hold a descriptor ring. The descriptor ring then</span>
<span class="cm">*   needs to be populated by making one or more calls to</span>
<span class="cm">*   dna_add_descriptors.</span>
<span class="cm">*</span>
<span class="cm">*   The returned descriptor ring will be automatically initialized.</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*       0           Descriptor ring was allocated successfully</span>
<span class="cm">*       -ENOMEM     Unable to allocate memory for the desired number of descriptors.</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_alloc_descriptor_ring</span><span class="p">(</span><span class="n">DMA_DescriptorRing_t</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>	<span class="cm">/* Descriptor ring to populate */</span>
			      <span class="kt">int</span> <span class="n">numDescriptors</span>	<span class="cm">/* Number of descriptors that need to be allocated. */</span>
    <span class="p">);</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Releases the memory which was previously allocated for a descriptor ring.</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">void</span> <span class="n">dma_free_descriptor_ring</span><span class="p">(</span><span class="n">DMA_DescriptorRing_t</span> <span class="o">*</span><span class="n">ring</span>	<span class="cm">/* Descriptor to release */</span>
    <span class="p">);</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Initializes a descriptor ring, so that descriptors can be added to it.</span>
<span class="cm">*   Once a descriptor ring has been allocated, it may be reinitialized for</span>
<span class="cm">*   use with additional/different regions of memory.</span>
<span class="cm">*</span>
<span class="cm">*   Note that if 7 descriptors are allocated, it&#39;s perfectly acceptable to</span>
<span class="cm">*   initialize the ring with a smaller number of descriptors. The amount</span>
<span class="cm">*   of memory allocated for the descriptor ring will not be reduced, and</span>
<span class="cm">*   the descriptor ring may be reinitialized later</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*       0           Descriptor ring was initialized successfully</span>
<span class="cm">*       -ENOMEM     The descriptor which was passed in has insufficient space</span>
<span class="cm">*                   to hold the desired number of descriptors.</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_init_descriptor_ring</span><span class="p">(</span><span class="n">DMA_DescriptorRing_t</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>	<span class="cm">/* Descriptor ring to initialize */</span>
			     <span class="kt">int</span> <span class="n">numDescriptors</span>	<span class="cm">/* Number of descriptors to initialize. */</span>
    <span class="p">);</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Determines the number of descriptors which would be required for a</span>
<span class="cm">*   transfer of the indicated memory region.</span>
<span class="cm">*</span>
<span class="cm">*   This function also needs to know which DMA device this transfer will</span>
<span class="cm">*   be destined for, so that the appropriate DMA configuration can be retrieved.</span>
<span class="cm">*   DMA parameters such as transfer width, and whether this is a memory-to-memory</span>
<span class="cm">*   or memory-to-peripheral, etc can all affect the actual number of descriptors</span>
<span class="cm">*   required.</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*       &gt; 0     Returns the number of descriptors required for the indicated transfer</span>
<span class="cm">*       -EINVAL Invalid device type for this kind of transfer</span>
<span class="cm">*               (i.e. the device is _MEM_TO_DEV and not _DEV_TO_MEM)</span>
<span class="cm">*       -ENOMEM Memory exhausted</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_calculate_descriptor_count</span><span class="p">(</span><span class="n">DMA_Device_t</span> <span class="n">device</span><span class="p">,</span>	<span class="cm">/* DMA Device that this will be associated with */</span>
				   <span class="n">dma_addr_t</span> <span class="n">srcData</span><span class="p">,</span>	<span class="cm">/* Place to get data to write to device */</span>
				   <span class="n">dma_addr_t</span> <span class="n">dstData</span><span class="p">,</span>	<span class="cm">/* Pointer to device data address */</span>
				   <span class="kt">size_t</span> <span class="n">numBytes</span>	<span class="cm">/* Number of bytes to transfer to the device */</span>
    <span class="p">);</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Adds a region of memory to the descriptor ring. Note that it may take</span>
<span class="cm">*   multiple descriptors for each region of memory. It is the callers</span>
<span class="cm">*   responsibility to allocate a sufficiently large descriptor ring.</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*       0       Descriptors were added successfully</span>
<span class="cm">*       -EINVAL Invalid device type for this kind of transfer</span>
<span class="cm">*               (i.e. the device is _MEM_TO_DEV and not _DEV_TO_MEM)</span>
<span class="cm">*       -ENOMEM Memory exhausted</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_add_descriptors</span><span class="p">(</span><span class="n">DMA_DescriptorRing_t</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>	<span class="cm">/* Descriptor ring to add descriptors to */</span>
			<span class="n">DMA_Device_t</span> <span class="n">device</span><span class="p">,</span>	<span class="cm">/* DMA Device that descriptors are for */</span>
			<span class="n">dma_addr_t</span> <span class="n">srcData</span><span class="p">,</span>	<span class="cm">/* Place to get data (memory or device) */</span>
			<span class="n">dma_addr_t</span> <span class="n">dstData</span><span class="p">,</span>	<span class="cm">/* Place to put data (memory or device) */</span>
			<span class="kt">size_t</span> <span class="n">numBytes</span>	<span class="cm">/* Number of bytes to transfer to the device */</span>
    <span class="p">);</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Sets the descriptor ring associated with a device.</span>
<span class="cm">*</span>
<span class="cm">*   Once set, the descriptor ring will be associated with the device, even</span>
<span class="cm">*   across channel request/free calls. Passing in a NULL descriptor ring</span>
<span class="cm">*   will release any descriptor ring currently associated with the device.</span>
<span class="cm">*</span>
<span class="cm">*   Note: If you call dma_transfer, or one of the other dma_alloc_ functions</span>
<span class="cm">*         the descriptor ring may be released and reallocated.</span>
<span class="cm">*</span>
<span class="cm">*   Note: This function will release the descriptor memory for any current</span>
<span class="cm">*         descriptor ring associated with this device.</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_set_device_descriptor_ring</span><span class="p">(</span><span class="n">DMA_Device_t</span> <span class="n">device</span><span class="p">,</span>	<span class="cm">/* Device to update the descriptor ring for. */</span>
				   <span class="n">DMA_DescriptorRing_t</span> <span class="o">*</span><span class="n">ring</span>	<span class="cm">/* Descriptor ring to add descriptors to */</span>
    <span class="p">);</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Retrieves the descriptor ring associated with a device.</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_get_device_descriptor_ring</span><span class="p">(</span><span class="n">DMA_Device_t</span> <span class="n">device</span><span class="p">,</span>	<span class="cm">/* Device to retrieve the descriptor ring for. */</span>
				   <span class="n">DMA_DescriptorRing_t</span> <span class="o">*</span><span class="n">ring</span>	<span class="cm">/* Place to store retrieved ring */</span>
    <span class="p">);</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Allocates buffers for the descriptors. This is normally done automatically</span>
<span class="cm">*   but needs to be done explicitly when initiating a dma from interrupt</span>
<span class="cm">*   context.</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*       0       Descriptors were allocated successfully</span>
<span class="cm">*       -EINVAL Invalid device type for this kind of transfer</span>
<span class="cm">*               (i.e. the device is _MEM_TO_DEV and not _DEV_TO_MEM)</span>
<span class="cm">*       -ENOMEM Memory exhausted</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_alloc_descriptors</span><span class="p">(</span><span class="n">DMA_Handle_t</span> <span class="n">handle</span><span class="p">,</span>	<span class="cm">/* DMA Handle */</span>
			  <span class="n">dmacHw_TRANSFER_TYPE_e</span> <span class="n">transferType</span><span class="p">,</span>	<span class="cm">/* Type of transfer being performed */</span>
			  <span class="n">dma_addr_t</span> <span class="n">srcData</span><span class="p">,</span>	<span class="cm">/* Place to get data to write to device */</span>
			  <span class="n">dma_addr_t</span> <span class="n">dstData</span><span class="p">,</span>	<span class="cm">/* Pointer to device data address */</span>
			  <span class="kt">size_t</span> <span class="n">numBytes</span>	<span class="cm">/* Number of bytes to transfer to the device */</span>
    <span class="p">);</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Allocates and sets up descriptors for a double buffered circular buffer.</span>
<span class="cm">*</span>
<span class="cm">*   This is primarily intended to be used for things like the ingress samples</span>
<span class="cm">*   from a microphone.</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*       &gt; 0     Number of descriptors actually allocated.</span>
<span class="cm">*       -EINVAL Invalid device type for this kind of transfer</span>
<span class="cm">*               (i.e. the device is _MEM_TO_DEV and not _DEV_TO_MEM)</span>
<span class="cm">*       -ENOMEM Memory exhausted</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_alloc_double_dst_descriptors</span><span class="p">(</span><span class="n">DMA_Handle_t</span> <span class="n">handle</span><span class="p">,</span>	<span class="cm">/* DMA Handle */</span>
				     <span class="n">dma_addr_t</span> <span class="n">srcData</span><span class="p">,</span>	<span class="cm">/* Physical address of source data */</span>
				     <span class="n">dma_addr_t</span> <span class="n">dstData1</span><span class="p">,</span>	<span class="cm">/* Physical address of first destination buffer */</span>
				     <span class="n">dma_addr_t</span> <span class="n">dstData2</span><span class="p">,</span>	<span class="cm">/* Physical address of second destination buffer */</span>
				     <span class="kt">size_t</span> <span class="n">numBytes</span>	<span class="cm">/* Number of bytes in each destination buffer */</span>
    <span class="p">);</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Initiates a transfer when the descriptors have already been setup.</span>
<span class="cm">*</span>
<span class="cm">*   This is a special case, and normally, the dma_transfer_xxx functions should</span>
<span class="cm">*   be used.</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*       0       Transfer was started successfully</span>
<span class="cm">*       -ENODEV Invalid handle</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_start_transfer</span><span class="p">(</span><span class="n">DMA_Handle_t</span> <span class="n">handle</span><span class="p">);</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Stops a previously started DMA transfer.</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*       0       Transfer was stopped successfully</span>
<span class="cm">*       -ENODEV Invalid handle</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_stop_transfer</span><span class="p">(</span><span class="n">DMA_Handle_t</span> <span class="n">handle</span><span class="p">);</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Waits for a DMA to complete by polling. This function is only intended</span>
<span class="cm">*   to be used for testing. Interrupts should be used for most DMA operations.</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_wait_transfer_done</span><span class="p">(</span><span class="n">DMA_Handle_t</span> <span class="n">handle</span><span class="p">);</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Initiates a DMA transfer</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*       0       Transfer was started successfully</span>
<span class="cm">*       -EINVAL Invalid device type for this kind of transfer</span>
<span class="cm">*               (i.e. the device is _MEM_TO_DEV and not _DEV_TO_MEM)</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_transfer</span><span class="p">(</span><span class="n">DMA_Handle_t</span> <span class="n">handle</span><span class="p">,</span>	<span class="cm">/* DMA Handle */</span>
		 <span class="n">dmacHw_TRANSFER_TYPE_e</span> <span class="n">transferType</span><span class="p">,</span>	<span class="cm">/* Type of transfer being performed */</span>
		 <span class="n">dma_addr_t</span> <span class="n">srcData</span><span class="p">,</span>	<span class="cm">/* Place to get data to write to device */</span>
		 <span class="n">dma_addr_t</span> <span class="n">dstData</span><span class="p">,</span>	<span class="cm">/* Pointer to device data address */</span>
		 <span class="kt">size_t</span> <span class="n">numBytes</span>	<span class="cm">/* Number of bytes to transfer to the device */</span>
    <span class="p">);</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Initiates a transfer from memory to a device.</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*       0       Transfer was started successfully</span>
<span class="cm">*       -EINVAL Invalid device type for this kind of transfer</span>
<span class="cm">*               (i.e. the device is _DEV_TO_MEM and not _MEM_TO_DEV)</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dma_transfer_to_device</span><span class="p">(</span><span class="n">DMA_Handle_t</span> <span class="n">handle</span><span class="p">,</span>	<span class="cm">/* DMA Handle */</span>
					 <span class="n">dma_addr_t</span> <span class="n">srcData</span><span class="p">,</span>	<span class="cm">/* Place to get data to write to device (physical address) */</span>
					 <span class="n">dma_addr_t</span> <span class="n">dstData</span><span class="p">,</span>	<span class="cm">/* Pointer to device data address (physical address) */</span>
					 <span class="kt">size_t</span> <span class="n">numBytes</span>	<span class="cm">/* Number of bytes to transfer to the device */</span>
    <span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">dma_transfer</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
			    <span class="n">dmacHw_TRANSFER_TYPE_MEM_TO_PERIPHERAL</span><span class="p">,</span>
			    <span class="n">srcData</span><span class="p">,</span> <span class="n">dstData</span><span class="p">,</span> <span class="n">numBytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Initiates a transfer from a device to memory.</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*       0       Transfer was started successfully</span>
<span class="cm">*       -EINVAL Invalid device type for this kind of transfer</span>
<span class="cm">*               (i.e. the device is _MEM_TO_DEV and not _DEV_TO_MEM)</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dma_transfer_from_device</span><span class="p">(</span><span class="n">DMA_Handle_t</span> <span class="n">handle</span><span class="p">,</span>	<span class="cm">/* DMA Handle */</span>
					   <span class="n">dma_addr_t</span> <span class="n">srcData</span><span class="p">,</span>	<span class="cm">/* Pointer to the device data address (physical address) */</span>
					   <span class="n">dma_addr_t</span> <span class="n">dstData</span><span class="p">,</span>	<span class="cm">/* Place to store data retrieved from the device (physical address) */</span>
					   <span class="kt">size_t</span> <span class="n">numBytes</span>	<span class="cm">/* Number of bytes to retrieve from the device */</span>
    <span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">dma_transfer</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
			    <span class="n">dmacHw_TRANSFER_TYPE_PERIPHERAL_TO_MEM</span><span class="p">,</span>
			    <span class="n">srcData</span><span class="p">,</span> <span class="n">dstData</span><span class="p">,</span> <span class="n">numBytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Initiates a memory to memory transfer.</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*       0       Transfer was started successfully</span>
<span class="cm">*       -EINVAL Invalid device type for this kind of transfer</span>
<span class="cm">*               (i.e. the device wasn&#39;t DMA_DEVICE_MEM_TO_MEM)</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dma_transfer_mem_to_mem</span><span class="p">(</span><span class="n">DMA_Handle_t</span> <span class="n">handle</span><span class="p">,</span>	<span class="cm">/* DMA Handle */</span>
					  <span class="n">dma_addr_t</span> <span class="n">srcData</span><span class="p">,</span>	<span class="cm">/* Place to transfer data from (physical address) */</span>
					  <span class="n">dma_addr_t</span> <span class="n">dstData</span><span class="p">,</span>	<span class="cm">/* Place to transfer data to (physical address) */</span>
					  <span class="kt">size_t</span> <span class="n">numBytes</span>	<span class="cm">/* Number of bytes to transfer */</span>
    <span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">dma_transfer</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
			    <span class="n">dmacHw_TRANSFER_TYPE_MEM_TO_MEM</span><span class="p">,</span>
			    <span class="n">srcData</span><span class="p">,</span> <span class="n">dstData</span><span class="p">,</span> <span class="n">numBytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/**</span>
<span class="cm">*   Set the callback function which will be called when a transfer completes.</span>
<span class="cm">*   If a NULL callback function is set, then no callback will occur.</span>
<span class="cm">*</span>
<span class="cm">*   @note   @a devHandler will be called from IRQ context.</span>
<span class="cm">*</span>
<span class="cm">*   @return</span>
<span class="cm">*       0       - Success</span>
<span class="cm">*       -ENODEV - Device handed in is invalid.</span>
<span class="cm">*/</span>
<span class="cm">/****************************************************************************/</span>

<span class="kt">int</span> <span class="n">dma_set_device_handler</span><span class="p">(</span><span class="n">DMA_Device_t</span> <span class="n">dev</span><span class="p">,</span>	<span class="cm">/* Device to set the callback for. */</span>
			   <span class="n">DMA_DeviceHandler_t</span> <span class="n">devHandler</span><span class="p">,</span>	<span class="cm">/* Function to call when the DMA completes */</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">userData</span>	<span class="cm">/* Pointer which will be passed to devHandler. */</span>
    <span class="p">);</span>

<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* ASM_ARM_ARCH_BCMRING_DMA_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
