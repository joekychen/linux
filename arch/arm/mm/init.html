<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mm › init.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>init.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/arch/arm/mm/init.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1995-2005 Russell King</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/nodemask.h&gt;</span>
<span class="cp">#include &lt;linux/initrd.h&gt;</span>
<span class="cp">#include &lt;linux/of_fdt.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/dma-contiguous.h&gt;</span>

<span class="cp">#include &lt;asm/mach-types.h&gt;</span>
<span class="cp">#include &lt;asm/memblock.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/sizes.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/fixmap.h&gt;</span>

<span class="cp">#include &lt;asm/mach/arch.h&gt;</span>
<span class="cp">#include &lt;asm/mach/map.h&gt;</span>

<span class="cp">#include &quot;mm.h&quot;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_initrd_start</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_initrd_size</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_initrd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">endp</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">endp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">phys_initrd_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">phys_initrd_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;initrd&quot;</span><span class="p">,</span> <span class="n">early_initrd</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parse_tag_initrd</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tag</span> <span class="o">*</span><span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;ATAG_INITRD is deprecated; &quot;</span>
		<span class="s">&quot;please update your bootloader.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">phys_initrd_start</span> <span class="o">=</span> <span class="n">__virt_to_phys</span><span class="p">(</span><span class="n">tag</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">initrd</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
	<span class="n">phys_initrd_size</span> <span class="o">=</span> <span class="n">tag</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">initrd</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__tagtable</span><span class="p">(</span><span class="n">ATAG_INITRD</span><span class="p">,</span> <span class="n">parse_tag_initrd</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parse_tag_initrd2</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tag</span> <span class="o">*</span><span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phys_initrd_start</span> <span class="o">=</span> <span class="n">tag</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">initrd</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
	<span class="n">phys_initrd_size</span> <span class="o">=</span> <span class="n">tag</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">initrd</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__tagtable</span><span class="p">(</span><span class="n">ATAG_INITRD2</span><span class="p">,</span> <span class="n">parse_tag_initrd2</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_OF_FLATTREE</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">early_init_dt_setup_initrd_arch</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phys_initrd_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">phys_initrd_size</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_OF_FLATTREE */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * This keeps memory configuration data used by a couple memory</span>
<span class="cm"> * initialization functions, as well as show_mem() for the skipping</span>
<span class="cm"> * of holes in the memory map.  It is populated by arm_add_memory().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">meminfo</span> <span class="n">meminfo</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">show_mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shared</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cached</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">slab</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">meminfo</span> <span class="o">*</span> <span class="n">mi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">meminfo</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Mem-info:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">show_free_areas</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>

	<span class="n">for_each_bank</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mi</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">membank</span> <span class="o">*</span><span class="n">bank</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pfn1</span><span class="p">,</span> <span class="n">pfn2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

		<span class="n">pfn1</span> <span class="o">=</span> <span class="n">bank_pfn_start</span><span class="p">(</span><span class="n">bank</span><span class="p">);</span>
		<span class="n">pfn2</span> <span class="o">=</span> <span class="n">bank_pfn_end</span><span class="p">(</span><span class="n">bank</span><span class="p">);</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn1</span><span class="p">);</span>
		<span class="n">end</span>  <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">total</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">reserved</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">cached</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">slab</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">free</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">shared</span> <span class="o">+=</span> <span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">page</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">page</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d pages of RAM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d free pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">free</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d reserved pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reserved</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d slab pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slab</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d pages shared</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">shared</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d pages swap cached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cached</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">find_limits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">min</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">max_low</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">max_high</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">meminfo</span> <span class="o">*</span><span class="n">mi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">meminfo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* This assumes the meminfo array is properly sorted */</span>
	<span class="o">*</span><span class="n">min</span> <span class="o">=</span> <span class="n">bank_pfn_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">for_each_bank</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mi</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">highmem</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
	<span class="o">*</span><span class="n">max_low</span> <span class="o">=</span> <span class="n">bank_pfn_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="o">*</span><span class="n">max_high</span> <span class="o">=</span> <span class="n">bank_pfn_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">[</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_banks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">arm_bootmem_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">boot_pages</span><span class="p">;</span>
	<span class="n">phys_addr_t</span> <span class="n">bitmap</span><span class="p">;</span>
	<span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate the bootmem bitmap page.  This must be in a region</span>
<span class="cm">	 * of memory which has already been mapped.</span>
<span class="cm">	 */</span>
	<span class="n">boot_pages</span> <span class="o">=</span> <span class="n">bootmem_bootmap_pages</span><span class="p">(</span><span class="n">end_pfn</span> <span class="o">-</span> <span class="n">start_pfn</span><span class="p">);</span>
	<span class="n">bitmap</span> <span class="o">=</span> <span class="n">memblock_alloc_base</span><span class="p">(</span><span class="n">boot_pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">L1_CACHE_BYTES</span><span class="p">,</span>
				<span class="n">__pfn_to_phys</span><span class="p">(</span><span class="n">end_pfn</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialise the bootmem allocator, handing the</span>
<span class="cm">	 * memory banks over to bootmem.</span>
<span class="cm">	 */</span>
	<span class="n">node_set_online</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">pgdat</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">init_bootmem_node</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">bitmap</span><span class="p">),</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">);</span>

	<span class="cm">/* Free the lowmem regions from memblock into bootmem. */</span>
	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">memblock_region_memory_base_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">memblock_region_memory_end_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">end_pfn</span><span class="p">)</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">end_pfn</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">free_bootmem</span><span class="p">(</span><span class="n">__pfn_to_phys</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Reserve the lowmem memblock reserved regions in bootmem. */</span>
	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">reserved</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">memblock_region_reserved_base_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">memblock_region_reserved_end_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">end_pfn</span><span class="p">)</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">end_pfn</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">reserve_bootmem</span><span class="p">(</span><span class="n">__pfn_to_phys</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>
			        <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">BOOTMEM_DEFAULT</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_ZONE_DMA</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arm_dma_zone_size</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arm_dma_zone_size</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The DMA mask corresponding to the maximum bus address allocatable</span>
<span class="cm"> * using GFP_DMA.  The default here places no restriction on DMA</span>
<span class="cm"> * allocations.  This must be the smallest DMA mask in the system,</span>
<span class="cm"> * so a successful GFP_DMA allocation will always satisfy this.</span>
<span class="cm"> */</span>
<span class="n">phys_addr_t</span> <span class="n">arm_dma_limit</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">arm_adjust_dma_zone</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">hole</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dma_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">dma_size</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">size</span><span class="p">[</span><span class="n">ZONE_NORMAL</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dma_size</span><span class="p">;</span>
	<span class="n">size</span><span class="p">[</span><span class="n">ZONE_DMA</span><span class="p">]</span> <span class="o">=</span> <span class="n">dma_size</span><span class="p">;</span>
	<span class="n">hole</span><span class="p">[</span><span class="n">ZONE_NORMAL</span><span class="p">]</span> <span class="o">=</span> <span class="n">hole</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">hole</span><span class="p">[</span><span class="n">ZONE_DMA</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_dma_zone</span><span class="p">(</span><span class="k">struct</span> <span class="n">machine_desc</span> <span class="o">*</span><span class="n">mdesc</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mdesc</span><span class="o">-&gt;</span><span class="n">dma_zone_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">arm_dma_zone_size</span> <span class="o">=</span> <span class="n">mdesc</span><span class="o">-&gt;</span><span class="n">dma_zone_size</span><span class="p">;</span>
		<span class="n">arm_dma_limit</span> <span class="o">=</span> <span class="n">PHYS_OFFSET</span> <span class="o">+</span> <span class="n">arm_dma_zone_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">arm_dma_limit</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">arm_bootmem_free</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_low</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_high</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zone_size</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">],</span> <span class="n">zhole_size</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialise the zones.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">zone_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zone_size</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * The memory size has already been determined.  If we need</span>
<span class="cm">	 * to do anything fancy with the allocation of this memory</span>
<span class="cm">	 * to the zones, now is the time to do it.</span>
<span class="cm">	 */</span>
	<span class="n">zone_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_low</span> <span class="o">-</span> <span class="n">min</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="n">zone_size</span><span class="p">[</span><span class="n">ZONE_HIGHMEM</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_high</span> <span class="o">-</span> <span class="n">max_low</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the size of the holes.</span>
<span class="cm">	 *  holes = node_size - sum(bank_sizes)</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">zhole_size</span><span class="p">,</span> <span class="n">zone_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zhole_size</span><span class="p">));</span>
	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">memblock_region_memory_base_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">memblock_region_memory_end_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">max_low</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">low_end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">max_low</span><span class="p">);</span>
			<span class="n">zhole_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">low_end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">max_low</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">high_start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">max_low</span><span class="p">);</span>
			<span class="n">zhole_size</span><span class="p">[</span><span class="n">ZONE_HIGHMEM</span><span class="p">]</span> <span class="o">-=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">high_start</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
	<span class="cm">/*</span>
<span class="cm">	 * Adjust the sizes according to any special requirements for</span>
<span class="cm">	 * this machine type.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arm_dma_zone_size</span><span class="p">)</span>
		<span class="n">arm_adjust_dma_zone</span><span class="p">(</span><span class="n">zone_size</span><span class="p">,</span> <span class="n">zhole_size</span><span class="p">,</span>
			<span class="n">arm_dma_zone_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">free_area_init_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">zone_size</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">zhole_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HAVE_ARCH_PFN_VALID</span>
<span class="kt">int</span> <span class="nf">pfn_valid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memblock_is_memory</span><span class="p">(</span><span class="n">__pfn_to_phys</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pfn_valid</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CONFIG_SPARSEMEM</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">arm_memory_present</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">arm_memory_present</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>

	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
		<span class="n">memory_present</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">memblock_region_memory_base_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">),</span>
			       <span class="n">memblock_region_memory_end_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">arm_memblock_steal_permitted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="n">phys_addr_t</span> <span class="n">__init</span> <span class="nf">arm_memblock_steal</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phys_addr_t</span> <span class="n">phys</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">arm_memblock_steal_permitted</span><span class="p">);</span>

	<span class="n">phys</span> <span class="o">=</span> <span class="n">memblock_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
	<span class="n">memblock_free</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">memblock_remove</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">phys</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">arm_memblock_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">meminfo</span> <span class="o">*</span><span class="n">mi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">machine_desc</span> <span class="o">*</span><span class="n">mdesc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">nr_banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">memblock_add</span><span class="p">(</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">,</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>

	<span class="cm">/* Register the kernel text, kernel data and initrd with memblock. */</span>
<span class="cp">#ifdef CONFIG_XIP_KERNEL</span>
	<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">_sdata</span><span class="p">),</span> <span class="n">_end</span> <span class="o">-</span> <span class="n">_sdata</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">_stext</span><span class="p">),</span> <span class="n">_end</span> <span class="o">-</span> <span class="n">_stext</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phys_initrd_size</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">memblock_is_region_memory</span><span class="p">(</span><span class="n">phys_initrd_start</span><span class="p">,</span> <span class="n">phys_initrd_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;INITRD: 0x%08lx+0x%08lx is not a memory region - disabling initrd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">phys_initrd_start</span><span class="p">,</span> <span class="n">phys_initrd_size</span><span class="p">);</span>
		<span class="n">phys_initrd_start</span> <span class="o">=</span> <span class="n">phys_initrd_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phys_initrd_size</span> <span class="o">&amp;&amp;</span>
	    <span class="n">memblock_is_region_reserved</span><span class="p">(</span><span class="n">phys_initrd_start</span><span class="p">,</span> <span class="n">phys_initrd_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;INITRD: 0x%08lx+0x%08lx overlaps in-use memory region - disabling initrd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">phys_initrd_start</span><span class="p">,</span> <span class="n">phys_initrd_size</span><span class="p">);</span>
		<span class="n">phys_initrd_start</span> <span class="o">=</span> <span class="n">phys_initrd_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phys_initrd_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">phys_initrd_start</span><span class="p">,</span> <span class="n">phys_initrd_size</span><span class="p">);</span>

		<span class="cm">/* Now convert initrd to virtual addresses */</span>
		<span class="n">initrd_start</span> <span class="o">=</span> <span class="n">__phys_to_virt</span><span class="p">(</span><span class="n">phys_initrd_start</span><span class="p">);</span>
		<span class="n">initrd_end</span> <span class="o">=</span> <span class="n">initrd_start</span> <span class="o">+</span> <span class="n">phys_initrd_size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">arm_mm_memblock_reserve</span><span class="p">();</span>
	<span class="n">arm_dt_memblock_reserve</span><span class="p">();</span>

	<span class="cm">/* reserve any platform specific memblock areas */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mdesc</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">)</span>
		<span class="n">mdesc</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * reserve memory for DMA contigouos allocations,</span>
<span class="cm">	 * must come from DMA area inside low memory</span>
<span class="cm">	 */</span>
	<span class="n">dma_contiguous_reserve</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">arm_dma_limit</span><span class="p">,</span> <span class="n">arm_lowmem_limit</span><span class="p">));</span>

	<span class="n">arm_memblock_steal_permitted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">memblock_allow_resize</span><span class="p">();</span>
	<span class="n">memblock_dump_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">bootmem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min</span><span class="p">,</span> <span class="n">max_low</span><span class="p">,</span> <span class="n">max_high</span><span class="p">;</span>

	<span class="n">max_low</span> <span class="o">=</span> <span class="n">max_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">find_limits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">min</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_low</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_high</span><span class="p">);</span>

	<span class="n">arm_bootmem_init</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max_low</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sparsemem tries to allocate bootmem in memory_present(),</span>
<span class="cm">	 * so must be done after the fixed reservations</span>
<span class="cm">	 */</span>
	<span class="n">arm_memory_present</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * sparse_init() needs the bootmem allocator up and running.</span>
<span class="cm">	 */</span>
	<span class="n">sparse_init</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now free the memory - free_area_init_node needs</span>
<span class="cm">	 * the sparse mem_map arrays initialized by sparse_init()</span>
<span class="cm">	 * for memmap_init_zone(), otherwise all PFNs are invalid.</span>
<span class="cm">	 */</span>
	<span class="n">arm_bootmem_free</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max_low</span><span class="p">,</span> <span class="n">max_high</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This doesn&#39;t seem to be used by the Linux memory manager any</span>
<span class="cm">	 * more, but is used by ll_rw_block.  If we can get rid of it, we</span>
<span class="cm">	 * also get rid of some of the stuff above as well.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: max_low_pfn and max_pfn reflect the number of _pages_ in</span>
<span class="cm">	 * the system, not the maximum PFN.</span>
<span class="cm">	 */</span>
	<span class="n">max_low_pfn</span> <span class="o">=</span> <span class="n">max_low</span> <span class="o">-</span> <span class="n">PHYS_PFN_OFFSET</span><span class="p">;</span>
	<span class="n">max_pfn</span> <span class="o">=</span> <span class="n">max_high</span> <span class="o">-</span> <span class="n">PHYS_PFN_OFFSET</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">free_area</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">pfn</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">pfn</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">init_page_count</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">pages</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Freeing %s memory: %dK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Poison init memory with an undefined instruction (ARM) or a branch to an</span>
<span class="cm"> * undefined instruction (Thumb).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">poison_init_mem</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0xe7fddef0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">free_memmap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">start_pg</span><span class="p">,</span> <span class="o">*</span><span class="n">end_pg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pg</span><span class="p">,</span> <span class="n">pgend</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Convert start_pfn/end_pfn to a struct page pointer.</span>
<span class="cm">	 */</span>
	<span class="n">start_pg</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">start_pfn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">end_pg</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">end_pfn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Convert to physical addresses, and</span>
<span class="cm">	 * round start upwards and end downwards.</span>
<span class="cm">	 */</span>
	<span class="n">pg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">start_pg</span><span class="p">));</span>
	<span class="n">pgend</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__pa</span><span class="p">(</span><span class="n">end_pg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are free pages between these,</span>
<span class="cm">	 * free the section of the memmap array.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pg</span> <span class="o">&lt;</span> <span class="n">pgend</span><span class="p">)</span>
		<span class="n">free_bootmem</span><span class="p">(</span><span class="n">pg</span><span class="p">,</span> <span class="n">pgend</span> <span class="o">-</span> <span class="n">pg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The mem_map array can get very big.  Free the unused area of the memory map.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">free_unused_memmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">meminfo</span> <span class="o">*</span><span class="n">mi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bank_start</span><span class="p">,</span> <span class="n">prev_bank_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This relies on each bank being in address order.</span>
<span class="cm">	 * The banks are sorted previously in bootmem_init().</span>
<span class="cm">	 */</span>
	<span class="n">for_each_bank</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mi</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">membank</span> <span class="o">*</span><span class="n">bank</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">bank_start</span> <span class="o">=</span> <span class="n">bank_pfn_start</span><span class="p">(</span><span class="n">bank</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SPARSEMEM</span>
		<span class="cm">/*</span>
<span class="cm">		 * Take care not to free memmap entries that don&#39;t exist</span>
<span class="cm">		 * due to SPARSEMEM sections which aren&#39;t present.</span>
<span class="cm">		 */</span>
		<span class="n">bank_start</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bank_start</span><span class="p">,</span>
				 <span class="n">ALIGN</span><span class="p">(</span><span class="n">prev_bank_end</span><span class="p">,</span> <span class="n">PAGES_PER_SECTION</span><span class="p">));</span>
<span class="cp">#else</span>
		<span class="cm">/*</span>
<span class="cm">		 * Align down here since the VM subsystem insists that the</span>
<span class="cm">		 * memmap entries are valid from the bank start aligned to</span>
<span class="cm">		 * MAX_ORDER_NR_PAGES.</span>
<span class="cm">		 */</span>
		<span class="n">bank_start</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">bank_start</span><span class="p">,</span> <span class="n">MAX_ORDER_NR_PAGES</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we had a previous bank, and there is a space</span>
<span class="cm">		 * between the current bank and the previous, free it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_bank_end</span> <span class="o">&amp;&amp;</span> <span class="n">prev_bank_end</span> <span class="o">&lt;</span> <span class="n">bank_start</span><span class="p">)</span>
			<span class="n">free_memmap</span><span class="p">(</span><span class="n">prev_bank_end</span><span class="p">,</span> <span class="n">bank_start</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Align up here since the VM subsystem insists that the</span>
<span class="cm">		 * memmap entries are valid from the bank end aligned to</span>
<span class="cm">		 * MAX_ORDER_NR_PAGES.</span>
<span class="cm">		 */</span>
		<span class="n">prev_bank_end</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">bank_pfn_end</span><span class="p">(</span><span class="n">bank</span><span class="p">),</span> <span class="n">MAX_ORDER_NR_PAGES</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SPARSEMEM</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">prev_bank_end</span><span class="p">,</span> <span class="n">PAGES_PER_SECTION</span><span class="p">))</span>
		<span class="n">free_memmap</span><span class="p">(</span><span class="n">prev_bank_end</span><span class="p">,</span>
			    <span class="n">ALIGN</span><span class="p">(</span><span class="n">prev_bank_end</span><span class="p">,</span> <span class="n">PAGES_PER_SECTION</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">free_highpages</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_low</span> <span class="o">=</span> <span class="n">max_low_pfn</span> <span class="o">+</span> <span class="n">PHYS_PFN_OFFSET</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

	<span class="cm">/* set highmem page free */</span>
	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">mem</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">memblock_region_memory_base_pfn</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">memblock_region_memory_end_pfn</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>

		<span class="cm">/* Ignore complete lowmem entries */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">max_low</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Truncate partial highmem entries */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">max_low</span><span class="p">)</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">max_low</span><span class="p">;</span>

		<span class="cm">/* Find and exclude any reserved regions */</span>
		<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">reserved</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">res_start</span><span class="p">,</span> <span class="n">res_end</span><span class="p">;</span>

			<span class="n">res_start</span> <span class="o">=</span> <span class="n">memblock_region_reserved_base_pfn</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
			<span class="n">res_end</span> <span class="o">=</span> <span class="n">memblock_region_reserved_end_pfn</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">res_end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res_start</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span>
				<span class="n">res_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res_start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="n">res_start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res_end</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="n">res_end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res_start</span> <span class="o">!=</span> <span class="n">start</span><span class="p">)</span>
				<span class="n">totalhigh_pages</span> <span class="o">+=</span> <span class="n">free_area</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">res_start</span><span class="p">,</span>
							     <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">res_end</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* And now free anything which remains */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="n">totalhigh_pages</span> <span class="o">+=</span> <span class="n">free_area</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="n">totalhigh_pages</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mem_init() marks the free areas in the mem_map and tells us how much</span>
<span class="cm"> * memory is free.  This is done after various parts of the system have</span>
<span class="cm"> * claimed their memory after the kernel image.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">mem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reserved_pages</span><span class="p">,</span> <span class="n">free_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HAVE_TCM</span>
	<span class="cm">/* These pointers are filled in on TCM detection */</span>
	<span class="k">extern</span> <span class="n">u32</span> <span class="n">dtcm_end</span><span class="p">;</span>
	<span class="k">extern</span> <span class="n">u32</span> <span class="n">itcm_end</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">max_mapnr</span>   <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">max_pfn</span> <span class="o">+</span> <span class="n">PHYS_PFN_OFFSET</span><span class="p">)</span> <span class="o">-</span> <span class="n">mem_map</span><span class="p">;</span>

	<span class="cm">/* this will put all unused low memory onto the freelists */</span>
	<span class="n">free_unused_memmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">meminfo</span><span class="p">);</span>

	<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="n">free_all_bootmem</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_SA1111</span>
	<span class="cm">/* now that our DMA memory is actually so designated, we can free it */</span>
	<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="n">free_area</span><span class="p">(</span><span class="n">PHYS_PFN_OFFSET</span><span class="p">,</span>
				    <span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">swapper_pg_dir</span><span class="p">)),</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">free_highpages</span><span class="p">();</span>

	<span class="n">reserved_pages</span> <span class="o">=</span> <span class="n">free_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_bank</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">meminfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">membank</span> <span class="o">*</span><span class="n">bank</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">meminfo</span><span class="p">.</span><span class="n">bank</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pfn1</span><span class="p">,</span> <span class="n">pfn2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

		<span class="n">pfn1</span> <span class="o">=</span> <span class="n">bank_pfn_start</span><span class="p">(</span><span class="n">bank</span><span class="p">);</span>
		<span class="n">pfn2</span> <span class="o">=</span> <span class="n">bank_pfn_end</span><span class="p">(</span><span class="n">bank</span><span class="p">);</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn1</span><span class="p">);</span>
		<span class="n">end</span>  <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">reserved_pages</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">free_pages</span><span class="o">++</span><span class="p">;</span>
			<span class="n">page</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">page</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since our memory may not be contiguous, calculate the</span>
<span class="cm">	 * real number of pages we have in this system</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Memory:&quot;</span><span class="p">);</span>
	<span class="n">num_physpages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span> <span class="o">=</span> <span class="n">memblock_region_memory_end_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">memblock_region_memory_base_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">num_physpages</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %ldMB&quot;</span><span class="p">,</span> <span class="n">pages</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; = %luMB total</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num_physpages</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Memory: %luk/%luk available, %luk reserved, %luK highmem</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">nr_free_pages</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="n">free_pages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="n">reserved_pages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="n">totalhigh_pages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">));</span>

<span class="cp">#define MLK(b, t) b, t, ((t) - (b)) &gt;&gt; 10</span>
<span class="cp">#define MLM(b, t) b, t, ((t) - (b)) &gt;&gt; 20</span>
<span class="cp">#define MLK_ROUNDUP(b, t) b, t, DIV_ROUND_UP(((t) - (b)), SZ_1K)</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Virtual kernel memory layout:</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;    vector  : 0x%08lx - 0x%08lx   (%4ld kB)</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#ifdef CONFIG_HAVE_TCM</span>
			<span class="s">&quot;    DTCM    : 0x%08lx - 0x%08lx   (%4ld kB)</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;    ITCM    : 0x%08lx - 0x%08lx   (%4ld kB)</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#endif</span>
			<span class="s">&quot;    fixmap  : 0x%08lx - 0x%08lx   (%4ld kB)</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;    vmalloc : 0x%08lx - 0x%08lx   (%4ld MB)</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;    lowmem  : 0x%08lx - 0x%08lx   (%4ld MB)</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
			<span class="s">&quot;    pkmap   : 0x%08lx - 0x%08lx   (%4ld MB)</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_MODULES</span>
			<span class="s">&quot;    modules : 0x%08lx - 0x%08lx   (%4ld MB)</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#endif</span>
			<span class="s">&quot;      .text : 0x%p&quot;</span> <span class="s">&quot; - 0x%p&quot;</span> <span class="s">&quot;   (%4d kB)</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;      .init : 0x%p&quot;</span> <span class="s">&quot; - 0x%p&quot;</span> <span class="s">&quot;   (%4d kB)</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;      .data : 0x%p&quot;</span> <span class="s">&quot; - 0x%p&quot;</span> <span class="s">&quot;   (%4d kB)</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;       .bss : 0x%p&quot;</span> <span class="s">&quot; - 0x%p&quot;</span> <span class="s">&quot;   (%4d kB)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>

			<span class="n">MLK</span><span class="p">(</span><span class="n">UL</span><span class="p">(</span><span class="n">CONFIG_VECTORS_BASE</span><span class="p">),</span> <span class="n">UL</span><span class="p">(</span><span class="n">CONFIG_VECTORS_BASE</span><span class="p">)</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">)),</span>
<span class="cp">#ifdef CONFIG_HAVE_TCM</span>
			<span class="n">MLK</span><span class="p">(</span><span class="n">DTCM_OFFSET</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dtcm_end</span><span class="p">),</span>
			<span class="n">MLK</span><span class="p">(</span><span class="n">ITCM_OFFSET</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">itcm_end</span><span class="p">),</span>
<span class="cp">#endif</span>
			<span class="n">MLK</span><span class="p">(</span><span class="n">FIXADDR_START</span><span class="p">,</span> <span class="n">FIXADDR_TOP</span><span class="p">),</span>
			<span class="n">MLM</span><span class="p">(</span><span class="n">VMALLOC_START</span><span class="p">,</span> <span class="n">VMALLOC_END</span><span class="p">),</span>
			<span class="n">MLM</span><span class="p">(</span><span class="n">PAGE_OFFSET</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">high_memory</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
			<span class="n">MLM</span><span class="p">(</span><span class="n">PKMAP_BASE</span><span class="p">,</span> <span class="p">(</span><span class="n">PKMAP_BASE</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">LAST_PKMAP</span><span class="p">)</span> <span class="o">*</span>
				<span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">)),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_MODULES</span>
			<span class="n">MLM</span><span class="p">(</span><span class="n">MODULES_VADDR</span><span class="p">,</span> <span class="n">MODULES_END</span><span class="p">),</span>
<span class="cp">#endif</span>

			<span class="n">MLK_ROUNDUP</span><span class="p">(</span><span class="n">_text</span><span class="p">,</span> <span class="n">_etext</span><span class="p">),</span>
			<span class="n">MLK_ROUNDUP</span><span class="p">(</span><span class="n">__init_begin</span><span class="p">,</span> <span class="n">__init_end</span><span class="p">),</span>
			<span class="n">MLK_ROUNDUP</span><span class="p">(</span><span class="n">_sdata</span><span class="p">,</span> <span class="n">_edata</span><span class="p">),</span>
			<span class="n">MLK_ROUNDUP</span><span class="p">(</span><span class="n">__bss_start</span><span class="p">,</span> <span class="n">__bss_stop</span><span class="p">));</span>

<span class="cp">#undef MLK</span>
<span class="cp">#undef MLM</span>
<span class="cp">#undef MLK_ROUNDUP</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check boundaries twice: Some fundamental inconsistencies can</span>
<span class="cm">	 * be detected at build time already.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_MMU</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">TASK_SIZE</span>				<span class="o">&gt;</span> <span class="n">MODULES_VADDR</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">TASK_SIZE</span> 				<span class="o">&gt;</span> <span class="n">MODULES_VADDR</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">PKMAP_BASE</span> <span class="o">+</span> <span class="n">LAST_PKMAP</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span> <span class="o">&gt;</span> <span class="n">PAGE_OFFSET</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PKMAP_BASE</span> <span class="o">+</span> <span class="n">LAST_PKMAP</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span>	<span class="o">&gt;</span> <span class="n">PAGE_OFFSET</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&gt;=</span> <span class="mi">16384</span> <span class="o">&amp;&amp;</span> <span class="n">num_physpages</span> <span class="o">&lt;=</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_overcommit_memory</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * On a machine this small we won&#39;t get</span>
<span class="cm">		 * anywhere without overcommit, so turn</span>
<span class="cm">		 * it on by default.</span>
<span class="cm">		 */</span>
		<span class="n">sysctl_overcommit_memory</span> <span class="o">=</span> <span class="n">OVERCOMMIT_ALWAYS</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_initmem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_HAVE_TCM</span>
	<span class="k">extern</span> <span class="kt">char</span> <span class="n">__tcm_start</span><span class="p">,</span> <span class="n">__tcm_end</span><span class="p">;</span>

	<span class="n">poison_init_mem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__tcm_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__tcm_end</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">__tcm_start</span><span class="p">);</span>
	<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="n">free_area</span><span class="p">(</span><span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__tcm_start</span><span class="p">)),</span>
				    <span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__tcm_end</span><span class="p">)),</span>
				    <span class="s">&quot;TCM link&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">poison_init_mem</span><span class="p">(</span><span class="n">__init_begin</span><span class="p">,</span> <span class="n">__init_end</span> <span class="o">-</span> <span class="n">__init_begin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">machine_is_integrator</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">machine_is_cintegrator</span><span class="p">())</span>
		<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="n">free_area</span><span class="p">(</span><span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">__init_begin</span><span class="p">)),</span>
					    <span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">__init_end</span><span class="p">)),</span>
					    <span class="s">&quot;init&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">keep_initrd</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">free_initrd_mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">keep_initrd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">poison_init_mem</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">start</span><span class="p">,</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
		<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="n">free_area</span><span class="p">(</span><span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">start</span><span class="p">)),</span>
					    <span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">end</span><span class="p">)),</span>
					    <span class="s">&quot;initrd&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">keepinitrd_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">__unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">keep_initrd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;keepinitrd&quot;</span><span class="p">,</span> <span class="n">keepinitrd_setup</span><span class="p">);</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
