<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mm › dma-mapping.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>dma-mapping.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/arch/arm/mm/dma-mapping.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2000-2004 Russell King</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> *  DMA uncached mapping support.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/dma-contiguous.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/iommu.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>

<span class="cp">#include &lt;asm/memory.h&gt;</span>
<span class="cp">#include &lt;asm/highmem.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/sizes.h&gt;</span>
<span class="cp">#include &lt;asm/mach/arch.h&gt;</span>
<span class="cp">#include &lt;asm/dma-iommu.h&gt;</span>
<span class="cp">#include &lt;asm/mach/map.h&gt;</span>
<span class="cp">#include &lt;asm/system_info.h&gt;</span>
<span class="cp">#include &lt;asm/dma-contiguous.h&gt;</span>

<span class="cp">#include &quot;mm.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * The DMA API is built upon the notion of &quot;buffer ownership&quot;.  A buffer</span>
<span class="cm"> * is either exclusively owned by the CPU (and therefore may be accessed</span>
<span class="cm"> * by it) or exclusively owned by the DMA device.  These helper functions</span>
<span class="cm"> * represent the transitions between these two ownership states.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, however, that on later ARMs, this notion does not work due to</span>
<span class="cm"> * speculative prefetches.  We model our approach on the assumption that</span>
<span class="cm"> * the CPU does do speculative prefetches, which means we clean caches</span>
<span class="cm"> * before transfers and delay cache invalidation until transfer completion.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__dma_page_cpu_to_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
		<span class="kt">size_t</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__dma_page_dev_to_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
		<span class="kt">size_t</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * arm_dma_map_page - map a portion of a page for streaming DMA</span>
<span class="cm"> * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices</span>
<span class="cm"> * @page: page that buffer resides in</span>
<span class="cm"> * @offset: offset into page for start of buffer</span>
<span class="cm"> * @size: size of buffer to map</span>
<span class="cm"> * @dir: DMA transfer direction</span>
<span class="cm"> *</span>
<span class="cm"> * Ensure that any data held in the cache is appropriately discarded</span>
<span class="cm"> * or written back.</span>
<span class="cm"> *</span>
<span class="cm"> * The device owns this memory once this call has completed.  The CPU</span>
<span class="cm"> * can regain ownership by calling dma_unmap_page().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="nf">arm_dma_map_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
	     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_is_coherent</span><span class="p">())</span>
		<span class="n">__dma_page_cpu_to_dev</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pfn_to_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * arm_dma_unmap_page - unmap a buffer previously mapped through dma_map_page()</span>
<span class="cm"> * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices</span>
<span class="cm"> * @handle: DMA address of buffer</span>
<span class="cm"> * @size: size of buffer (same as passed to dma_map_page)</span>
<span class="cm"> * @dir: DMA transfer direction (same as passed to dma_map_page)</span>
<span class="cm"> *</span>
<span class="cm"> * Unmap a page streaming mode DMA translation.  The handle and size</span>
<span class="cm"> * must match what was provided in the previous dma_map_page() call.</span>
<span class="cm"> * All other usages are undefined.</span>
<span class="cm"> *</span>
<span class="cm"> * After this call, reads by the CPU to the buffer are guaranteed to see</span>
<span class="cm"> * whatever the device wrote there.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">arm_dma_unmap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">handle</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_is_coherent</span><span class="p">())</span>
		<span class="n">__dma_page_dev_to_cpu</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">dma_to_pfn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">handle</span><span class="p">)),</span>
				      <span class="n">handle</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">arm_dma_sync_single_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">dma_addr_t</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">handle</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">dma_to_pfn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">handle</span><span class="o">-</span><span class="n">offset</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_is_coherent</span><span class="p">())</span>
		<span class="n">__dma_page_dev_to_cpu</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">arm_dma_sync_single_for_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">dma_addr_t</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">handle</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">dma_to_pfn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">handle</span><span class="o">-</span><span class="n">offset</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_is_coherent</span><span class="p">())</span>
		<span class="n">__dma_page_cpu_to_dev</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">arm_dma_set_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">dma_mask</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="n">arm_dma_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc</span>			<span class="o">=</span> <span class="n">arm_dma_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free</span>			<span class="o">=</span> <span class="n">arm_dma_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>			<span class="o">=</span> <span class="n">arm_dma_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_page</span>		<span class="o">=</span> <span class="n">arm_dma_map_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_page</span>		<span class="o">=</span> <span class="n">arm_dma_unmap_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_sg</span>			<span class="o">=</span> <span class="n">arm_dma_map_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_sg</span>		<span class="o">=</span> <span class="n">arm_dma_unmap_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_single_for_cpu</span>	<span class="o">=</span> <span class="n">arm_dma_sync_single_for_cpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_single_for_device</span>	<span class="o">=</span> <span class="n">arm_dma_sync_single_for_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_sg_for_cpu</span>	<span class="o">=</span> <span class="n">arm_dma_sync_sg_for_cpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_sg_for_device</span>	<span class="o">=</span> <span class="n">arm_dma_sync_sg_for_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_dma_mask</span>		<span class="o">=</span> <span class="n">arm_dma_set_mask</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arm_dma_ops</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">get_coherent_dma_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">arm_dma_limit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">coherent_dma_mask</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Sanity check the DMA mask - it must be non-zero, and</span>
<span class="cm">		 * must be able to be satisfied by a DMA allocation.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;coherent DMA mask is unset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">arm_dma_limit</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;coherent DMA mask %#llx is smaller &quot;</span>
				 <span class="s">&quot;than system GFP_DMA mask %#llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">arm_dma_limit</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dma_clear_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ensure that the allocated pages are zeroed, and that any data</span>
<span class="cm">	 * lurking in the kernel direct-mapped region is invalidated.</span>
<span class="cm">	 */</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">dmac_flush_range</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">outer_flush_range</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a DMA buffer for &#39;dev&#39; of size &#39;size&#39; using the</span>
<span class="cm"> * specified gfp mask.  Note that &#39;size&#39; must be page aligned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">__dma_alloc_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now split the huge page and free the excess pages</span>
<span class="cm">	 */</span>
	<span class="n">split_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">page</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span> <span class="n">e</span> <span class="o">=</span> <span class="n">page</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">);</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">__dma_clear_buffer</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free a DMA buffer.  &#39;size&#39; must be page aligned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dma_free_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">page</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">page</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MMU</span>

<span class="cp">#define CONSISTENT_OFFSET(x)	(((unsigned long)(x) - consistent_base) &gt;&gt; PAGE_SHIFT)</span>
<span class="cp">#define CONSISTENT_PTE_INDEX(x) (((unsigned long)(x) - consistent_base) &gt;&gt; PMD_SHIFT)</span>

<span class="cm">/*</span>
<span class="cm"> * These are the page tables (2MB each) covering uncached, DMA consistent allocations</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pte_t</span> <span class="o">**</span><span class="n">consistent_pte</span><span class="p">;</span>

<span class="cp">#define DEFAULT_CONSISTENT_DMA_SIZE SZ_2M</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">consistent_base</span> <span class="o">=</span> <span class="n">CONSISTENT_END</span> <span class="o">-</span> <span class="n">DEFAULT_CONSISTENT_DMA_SIZE</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_consistent_dma_size</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span> <span class="o">=</span> <span class="n">CONSISTENT_END</span> <span class="o">-</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">SZ_2M</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">consistent_pte</span><span class="p">);</span> <span class="cm">/* Check we&#39;re called before DMA region init */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">base</span> <span class="o">&lt;</span> <span class="n">VMALLOC_END</span><span class="p">);</span>

	<span class="cm">/* Grow region to accommodate specified size  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&lt;</span> <span class="n">consistent_base</span><span class="p">)</span>
		<span class="n">consistent_base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include &quot;vmregion.h&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">arm_vmregion_head</span> <span class="n">consistent_head</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">vm_lock</span>	<span class="o">=</span> <span class="n">__SPIN_LOCK_UNLOCKED</span><span class="p">(</span><span class="o">&amp;</span><span class="n">consistent_head</span><span class="p">.</span><span class="n">vm_lock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">vm_list</span>	<span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">consistent_head</span><span class="p">.</span><span class="n">vm_list</span><span class="p">),</span>
	<span class="p">.</span><span class="n">vm_end</span>		<span class="o">=</span> <span class="n">CONSISTENT_END</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
<span class="cp">#error ARM Coherent DMA allocator does not (yet) support huge TLB</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Initialise the consistent memory allocation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">consistent_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span> <span class="o">=</span> <span class="n">consistent_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_ptes</span> <span class="o">=</span> <span class="p">(</span><span class="n">CONSISTENT_END</span> <span class="o">-</span> <span class="n">base</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PMD_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_CMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_ARM_DMA_USE_IOMMU</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">consistent_pte</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">num_ptes</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">consistent_pte</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: no memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;DMA memory: 0x%08lx - 0x%08lx:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">CONSISTENT_END</span><span class="p">);</span>
	<span class="n">consistent_head</span><span class="p">.</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>

		<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: no pud tables</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: no pmd tables</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>

		<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_alloc_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: no pte tables</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">consistent_pte</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pte</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">+=</span> <span class="n">PMD_SIZE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">base</span> <span class="o">&lt;</span> <span class="n">CONSISTENT_END</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">core_initcall</span><span class="p">(</span><span class="n">consistent_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">__alloc_from_contiguous</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				     <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">ret_page</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">arm_vmregion_head</span> <span class="n">coherent_head</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">vm_lock</span>	<span class="o">=</span> <span class="n">__SPIN_LOCK_UNLOCKED</span><span class="p">(</span><span class="o">&amp;</span><span class="n">coherent_head</span><span class="p">.</span><span class="n">vm_lock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">vm_list</span>	<span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">coherent_head</span><span class="p">.</span><span class="n">vm_list</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="n">coherent_pool_size</span> <span class="o">=</span> <span class="n">DEFAULT_CONSISTENT_DMA_SIZE</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_coherent_pool</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">coherent_pool_size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;coherent_pool&quot;</span><span class="p">,</span> <span class="n">early_coherent_pool</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Initialise the coherent pool for atomic allocations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">coherent_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgprot_t</span> <span class="n">prot</span> <span class="o">=</span> <span class="n">pgprot_dmacoherent</span><span class="p">(</span><span class="n">pgprot_kernel</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">coherent_pool_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_CMA</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">__alloc_from_contiguous</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">coherent_head</span><span class="p">.</span><span class="n">vm_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
		<span class="n">coherent_head</span><span class="p">.</span><span class="n">vm_end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;DMA: preallocated %u KiB pool for atomic coherent allocations</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">size</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;DMA: failed to allocate %u KiB pool for atomic coherent allocation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">size</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * CMA is activated by core_initcall, so we must be called after it.</span>
<span class="cm"> */</span>
<span class="n">postcore_initcall</span><span class="p">(</span><span class="n">coherent_init</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dma_contig_early_reserve</span> <span class="p">{</span>
	<span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dma_contig_early_reserve</span> <span class="n">dma_mmu_remap</span><span class="p">[</span><span class="n">MAX_CMA_AREAS</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dma_mmu_remap_num</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">dma_contiguous_early_fixup</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_mmu_remap</span><span class="p">[</span><span class="n">dma_mmu_remap_num</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">dma_mmu_remap</span><span class="p">[</span><span class="n">dma_mmu_remap_num</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">dma_mmu_remap_num</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">dma_contiguous_remap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dma_mmu_remap_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phys_addr_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">dma_mmu_remap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span><span class="p">;</span>
		<span class="n">phys_addr_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">dma_mmu_remap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">map_desc</span> <span class="n">map</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">arm_lowmem_limit</span><span class="p">)</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">arm_lowmem_limit</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">map</span><span class="p">.</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="n">map</span><span class="p">.</span><span class="k">virtual</span> <span class="o">=</span> <span class="n">__phys_to_virt</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="n">map</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">map</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">MT_MEMORY_DMA_READY</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Clear previous low-memory mapping</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">__phys_to_virt</span><span class="p">(</span><span class="n">start</span><span class="p">);</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">__phys_to_virt</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>
		     <span class="n">addr</span> <span class="o">+=</span> <span class="n">PMD_SIZE</span><span class="p">)</span>
			<span class="n">pmd_clear</span><span class="p">(</span><span class="n">pmd_off_k</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>

		<span class="n">iotable_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">__dma_alloc_remap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">arm_vmregion</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">align</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">consistent_pte</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: not initialised</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Align the virtual region allocation - maximum alignment is</span>
<span class="cm">	 * a section size, minimum is a page size.  This helps reduce</span>
<span class="cm">	 * fragmentation of the DMA space, and also prevents allocations</span>
<span class="cm">	 * smaller than a section from crossing a section boundary.</span>
<span class="cm">	 */</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&gt;</span> <span class="n">SECTION_SHIFT</span><span class="p">)</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="n">SECTION_SHIFT</span><span class="p">;</span>
	<span class="n">align</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate a virtual address in the consistent mapping region.</span>
<span class="cm">	 */</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">arm_vmregion_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">consistent_head</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			    <span class="n">gfp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">__GFP_DMA</span> <span class="o">|</span> <span class="n">__GFP_HIGHMEM</span><span class="p">),</span> <span class="n">caller</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">CONSISTENT_PTE_INDEX</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">);</span>
		<span class="n">u32</span> <span class="n">off</span> <span class="o">=</span> <span class="n">CONSISTENT_OFFSET</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PTRS_PER_PTE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">pte</span> <span class="o">=</span> <span class="n">consistent_pte</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">off</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>

			<span class="n">set_pte_ext</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">prot</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">page</span><span class="o">++</span><span class="p">;</span>
			<span class="n">pte</span><span class="o">++</span><span class="p">;</span>
			<span class="n">off</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="n">PTRS_PER_PTE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">pte</span> <span class="o">=</span> <span class="n">consistent_pte</span><span class="p">[</span><span class="o">++</span><span class="n">idx</span><span class="p">];</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">-=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="n">dsb</span><span class="p">();</span>

		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dma_free_remap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">arm_vmregion</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">off</span><span class="p">;</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">arm_vmregion_find_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">consistent_head</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cpu_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: trying to free invalid coherent area: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">cpu_addr</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: freeing wrong coherent size (%ld != %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">CONSISTENT_PTE_INDEX</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">);</span>
	<span class="n">off</span> <span class="o">=</span> <span class="n">CONSISTENT_OFFSET</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PTRS_PER_PTE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">ptep</span> <span class="o">=</span> <span class="n">consistent_pte</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">off</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">ptep_get_and_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>

		<span class="n">ptep</span><span class="o">++</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">off</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="n">PTRS_PER_PTE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ptep</span> <span class="o">=</span> <span class="n">consistent_pte</span><span class="p">[</span><span class="o">++</span><span class="n">idx</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
			<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;%s: bad page in kernel page table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">-=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">flush_tlb_kernel_range</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>

	<span class="n">arm_vmregion_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">consistent_head</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__dma_update_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="n">pgtable_t</span> <span class="n">token</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">pgprot_t</span> <span class="n">prot</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">pgprot_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="n">set_pte_ext</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">prot</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dma_remap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">apply_to_page_range</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">__dma_update_pte</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prot</span><span class="p">);</span>
	<span class="n">dsb</span><span class="p">();</span>
	<span class="n">flush_tlb_kernel_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">__alloc_remap_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
				 <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">ret_page</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">__dma_alloc_buffer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">__dma_alloc_remap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">caller</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__dma_free_buffer</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">ret_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">__alloc_from_pool</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">ret_page</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">arm_vmregion</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">align</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">coherent_head</span><span class="p">.</span><span class="n">vm_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: coherent pool not initialised!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Align the region allocation - allocations from pool are rather</span>
<span class="cm">	 * small, so align them to their order in pages, minimum is a page</span>
<span class="cm">	 * size. This helps reduce fragmentation of the DMA space.</span>
<span class="cm">	 */</span>
	<span class="n">align</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">arm_vmregion_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">coherent_head</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">caller</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ret_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__free_from_pool</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cpu_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">arm_vmregion</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">coherent_head</span><span class="p">.</span><span class="n">vm_start</span> <span class="o">||</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">coherent_head</span><span class="p">.</span><span class="n">vm_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">arm_vmregion_find_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">coherent_head</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: freeing wrong coherent size (%ld != %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">arm_vmregion_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">coherent_head</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">__alloc_from_contiguous</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				     <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">ret_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">dma_alloc_from_contiguous</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">__dma_clear_buffer</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">__dma_remap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ret_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__free_from_contiguous</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__dma_remap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pgprot_kernel</span><span class="p">);</span>
	<span class="n">dma_release_from_contiguous</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pgprot_t</span> <span class="nf">__get_dma_pgprot</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">prot</span> <span class="o">=</span> <span class="n">dma_get_attr</span><span class="p">(</span><span class="n">DMA_ATTR_WRITE_COMBINE</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span> <span class="o">?</span>
			    <span class="n">pgprot_writecombine</span><span class="p">(</span><span class="n">prot</span><span class="p">)</span> <span class="o">:</span>
			    <span class="n">pgprot_dmacoherent</span><span class="p">(</span><span class="n">prot</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">prot</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define nommu() 0</span>

<span class="cp">#else	</span><span class="cm">/* !CONFIG_MMU */</span><span class="cp"></span>

<span class="cp">#define nommu() 1</span>

<span class="cp">#define __get_dma_pgprot(attrs, prot)	__pgprot(0)</span>
<span class="cp">#define __alloc_remap_buffer(dev, size, gfp, prot, ret, c)	NULL</span>
<span class="cp">#define __alloc_from_pool(dev, size, ret_page, c)		NULL</span>
<span class="cp">#define __alloc_from_contiguous(dev, size, prot, ret)		NULL</span>
<span class="cp">#define __free_from_pool(cpu_addr, size)			0</span>
<span class="cp">#define __free_from_contiguous(dev, page, size)			do { } while (0)</span>
<span class="cp">#define __dma_free_remap(cpu_addr, size)			do { } while (0)</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_MMU */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">__alloc_simple_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">ret_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">__dma_alloc_buffer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ret_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">__dma_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
			 <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">get_coherent_dma_mask</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DMA_API_DEBUG</span>
	<span class="n">u64</span> <span class="n">limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;coherent allocation too big (requested %#x mask %#llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">size</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&lt;</span> <span class="mh">0xffffffffULL</span><span class="p">)</span>
		<span class="n">gfp</span> <span class="o">|=</span> <span class="n">GFP_DMA</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Following is a work-around (a.k.a. hack) to prevent pages</span>
<span class="cm">	 * with __GFP_COMP being passed to split_page() which cannot</span>
<span class="cm">	 * handle them.  The real problem is that this flag probably</span>
<span class="cm">	 * should be 0 on ARM as it is not supported on this</span>
<span class="cm">	 * platform; see CONFIG_HUGETLBFS.</span>
<span class="cm">	 */</span>
	<span class="n">gfp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">__GFP_COMP</span><span class="p">);</span>

	<span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">DMA_ERROR_CODE</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_is_coherent</span><span class="p">()</span> <span class="o">||</span> <span class="n">nommu</span><span class="p">())</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">__alloc_simple_buffer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_CMA</span><span class="p">))</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">__alloc_remap_buffer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="n">caller</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">gfp</span> <span class="o">&amp;</span> <span class="n">GFP_ATOMIC</span><span class="p">)</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">__alloc_from_pool</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="n">caller</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">__alloc_from_contiguous</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span>
		<span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">pfn_to_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate DMA-coherent memory space and return both the kernel remapped</span>
<span class="cm"> * virtual and bus address for that space.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">arm_dma_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
		    <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgprot_t</span> <span class="n">prot</span> <span class="o">=</span> <span class="n">__get_dma_pgprot</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">pgprot_kernel</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">memory</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_alloc_from_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memory</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">memory</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__dma_alloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span>
			   <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create userspace mapping for the DMA-coherent memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">arm_dma_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		 <span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MMU</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">dma_to_pfn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">);</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">__get_dma_pgprot</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_mmap_from_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">cpu_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">remap_pfn_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span>
			      <span class="n">pfn</span> <span class="o">+</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">,</span>
			      <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span>
			      <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_MMU */</span><span class="cp"></span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free a buffer as defined by the above mapping.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">arm_dma_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">,</span>
		  <span class="n">dma_addr_t</span> <span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">dma_to_pfn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">handle</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_release_from_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">cpu_addr</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_is_coherent</span><span class="p">()</span> <span class="o">||</span> <span class="n">nommu</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">__dma_free_buffer</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_CMA</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__dma_free_remap</span><span class="p">(</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">__dma_free_buffer</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__free_from_pool</span><span class="p">(</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Non-atomic allocations cannot be freed with IRQs disabled</span>
<span class="cm">		 */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">irqs_disabled</span><span class="p">());</span>
		<span class="n">__free_from_contiguous</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_cache_maint_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">op</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * A single sg entry may refer to multiple physically contiguous</span>
<span class="cm">	 * pages.  But we still need to process highmem pages individually.</span>
<span class="cm">	 * If highmem is not configured then the bulk of this loop gets</span>
<span class="cm">	 * optimized out.</span>
<span class="cm">	 */</span>
	<span class="kt">size_t</span> <span class="n">left</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">page</span> <span class="o">+=</span> <span class="n">offset</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
					<span class="n">offset</span> <span class="o">%=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">vaddr</span> <span class="o">=</span> <span class="n">kmap_high_get</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vaddr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">vaddr</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
				<span class="n">op</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
				<span class="n">kunmap_high</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cache_is_vipt</span><span class="p">())</span> <span class="p">{</span>
				<span class="cm">/* unmapped pages might still be cached */</span>
				<span class="n">vaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">op</span><span class="p">(</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
				<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">vaddr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
			<span class="n">op</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">page</span><span class="o">++</span><span class="p">;</span>
		<span class="n">left</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">left</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Make an area consistent for devices.</span>
<span class="cm"> * Note: Drivers should NOT use this function directly, as it will break</span>
<span class="cm"> * platforms with CONFIG_DMABOUNCE.</span>
<span class="cm"> * Use the driver DMA support - see dma-mapping.h (dma_sync_*)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dma_page_cpu_to_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">;</span>

	<span class="n">dma_cache_maint_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dmac_map_area</span><span class="p">);</span>

	<span class="n">paddr</span> <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">off</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outer_inv_range</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">outer_clean_range</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* FIXME: non-speculating: flush on bidirectional mappings? */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dma_page_dev_to_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span> <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">off</span><span class="p">;</span>

	<span class="cm">/* FIXME: non-speculating: not required */</span>
	<span class="cm">/* don&#39;t bother invalidating if DMA to device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">!=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
		<span class="n">outer_inv_range</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">dma_cache_maint_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dmac_unmap_area</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mark the D-cache clean for this page to avoid extra flushing.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">!=</span> <span class="n">DMA_TO_DEVICE</span> <span class="o">&amp;&amp;</span> <span class="n">off</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">PG_dcache_clean</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * arm_dma_map_sg - map a set of SG buffers for streaming mode DMA</span>
<span class="cm"> * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices</span>
<span class="cm"> * @sg: list of buffers</span>
<span class="cm"> * @nents: number of buffers to map</span>
<span class="cm"> * @dir: DMA transfer direction</span>
<span class="cm"> *</span>
<span class="cm"> * Map a set of buffers described by scatterlist in streaming mode for DMA.</span>
<span class="cm"> * This is the scatter-gather version of the dma_map_single interface.</span>
<span class="cm"> * Here the scatter gather list elements are each tagged with the</span>
<span class="cm"> * appropriate dma address and length.  They are obtained via</span>
<span class="cm"> * sg_dma_{address,length}.</span>
<span class="cm"> *</span>
<span class="cm"> * Device ownership issues as mentioned for dma_map_single are the same</span>
<span class="cm"> * here.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">arm_dma_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">get_dma_ops</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_NEED_SG_DMA_LENGTH</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">map_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg_page</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
						<span class="n">s</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">bad_mapping</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">nents</span><span class="p">;</span>

 <span class="nl">bad_mapping:</span>
	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">unmap_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">dir</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * arm_dma_unmap_sg - unmap a set of SG buffers mapped by dma_map_sg</span>
<span class="cm"> * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices</span>
<span class="cm"> * @sg: list of buffers</span>
<span class="cm"> * @nents: number of buffers to unmap (same as was passed to dma_map_sg)</span>
<span class="cm"> * @dir: DMA transfer direction (same as was passed to dma_map_sg)</span>
<span class="cm"> *</span>
<span class="cm"> * Unmap a set of streaming mode DMA translations.  Again, CPU access</span>
<span class="cm"> * rules concerning calls here are the same as for dma_unmap_single().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">arm_dma_unmap_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">get_dma_ops</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">unmap_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">dir</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * arm_dma_sync_sg_for_cpu</span>
<span class="cm"> * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices</span>
<span class="cm"> * @sg: list of buffers</span>
<span class="cm"> * @nents: number of buffers to map (returned from dma_map_sg)</span>
<span class="cm"> * @dir: DMA transfer direction (same as was passed to dma_map_sg)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">arm_dma_sync_sg_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">get_dma_ops</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">sync_single_for_cpu</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
					 <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * arm_dma_sync_sg_for_device</span>
<span class="cm"> * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices</span>
<span class="cm"> * @sg: list of buffers</span>
<span class="cm"> * @nents: number of buffers to map (returned from dma_map_sg)</span>
<span class="cm"> * @dir: DMA transfer direction (same as was passed to dma_map_sg)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">arm_dma_sync_sg_for_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">get_dma_ops</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">sync_single_for_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
					    <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return whether the given device DMA address mask can be supported</span>
<span class="cm"> * properly.  For example, if your device can only drive the low 24-bits</span>
<span class="cm"> * during bus mastering, then you would pass 0x00ffffff as the mask</span>
<span class="cm"> * to this function.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dma_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">arm_dma_limit</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dma_supported</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arm_dma_set_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">dma_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">||</span> <span class="o">!</span><span class="n">dma_supported</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="o">*</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="n">dma_mask</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PREALLOC_DMA_DEBUG_ENTRIES	4096</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dma_debug_do_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MMU</span>
	<span class="n">arm_vmregion_create_proc</span><span class="p">(</span><span class="s">&quot;dma-mappings&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">consistent_head</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">dma_debug_init</span><span class="p">(</span><span class="n">PREALLOC_DMA_DEBUG_ENTRIES</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">fs_initcall</span><span class="p">(</span><span class="n">dma_debug_do_init</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ARM_DMA_USE_IOMMU</span>

<span class="cm">/* IOMMU */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">dma_addr_t</span> <span class="nf">__alloc_iova</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_iommu_mapping</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				      <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">align</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="p">((</span><span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span>
		 <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&gt;</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">)</span>
		<span class="n">align</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">order</span> <span class="o">-</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">bitmap_find_next_zero_area</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="n">count</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DMA_ERROR_CODE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bitmap_set</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__free_iova</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_iommu_mapping</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			       <span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">-</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
			     <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="p">((</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span>
			      <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">bitmap_clear</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="nf">__iommu_alloc_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">array_size</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">array_size</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">array_size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">array_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">__fls</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>

		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">gfp</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">order</span><span class="p">)</span>
			<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">gfp</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">,</span> <span class="o">--</span><span class="n">order</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">order</span><span class="p">)</span>
			<span class="n">split_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">order</span><span class="p">);</span>
		<span class="n">j</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">j</span><span class="p">)</span>
			<span class="n">pages</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>

		<span class="n">__dma_clear_buffer</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pages</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">__free_pages</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">array_size</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__iommu_free_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">array_size</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">__free_pages</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">array_size</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create a CPU mapping for a specified pages</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">__iommu_alloc_remap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">arm_vmregion</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">align</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">consistent_pte</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: not initialised</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Align the virtual region allocation - maximum alignment is</span>
<span class="cm">	 * a section size, minimum is a page size.  This helps reduce</span>
<span class="cm">	 * fragmentation of the DMA space, and also prevents allocations</span>
<span class="cm">	 * smaller than a section from crossing a section boundary.</span>
<span class="cm">	 */</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&gt;</span> <span class="n">SECTION_SHIFT</span><span class="p">)</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="n">SECTION_SHIFT</span><span class="p">;</span>
	<span class="n">align</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate a virtual address in the consistent mapping region.</span>
<span class="cm">	 */</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">arm_vmregion_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">consistent_head</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			    <span class="n">gfp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">__GFP_DMA</span> <span class="o">|</span> <span class="n">__GFP_HIGHMEM</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">CONSISTENT_PTE_INDEX</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">off</span> <span class="o">=</span> <span class="n">CONSISTENT_OFFSET</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PTRS_PER_PTE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">pte</span> <span class="o">=</span> <span class="n">consistent_pte</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">off</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>

			<span class="n">set_pte_ext</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">prot</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">pte</span><span class="o">++</span><span class="p">;</span>
			<span class="n">off</span><span class="o">++</span><span class="p">;</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="n">PTRS_PER_PTE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">pte</span> <span class="o">=</span> <span class="n">consistent_pte</span><span class="p">[</span><span class="o">++</span><span class="n">idx</span><span class="p">];</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">);</span>

		<span class="n">dsb</span><span class="p">();</span>

		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create a mapping in device IO address space for specified pages</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">dma_addr_t</span>
<span class="nf">__iommu_create_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_iommu_mapping</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">archdata</span><span class="p">.</span><span class="n">mapping</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">iova</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">DMA_ERROR_CODE</span><span class="p">;</span>

	<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">__alloc_iova</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_addr</span> <span class="o">==</span> <span class="n">DMA_ERROR_CODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dma_addr</span><span class="p">;</span>

	<span class="n">iova</span> <span class="o">=</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">phys_addr_t</span> <span class="n">phys</span> <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">next_pfn</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">!=</span> <span class="n">next_pfn</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_map</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">phys</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="n">iova</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dma_addr</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">iommu_unmap</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">iova</span><span class="o">-</span><span class="n">dma_addr</span><span class="p">);</span>
	<span class="n">__free_iova</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">DMA_ERROR_CODE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__iommu_remove_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_iommu_mapping</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">archdata</span><span class="p">.</span><span class="n">mapping</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * add optional in-page offset from iova to size and align</span>
<span class="cm">	 * result to page size</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">((</span><span class="n">iova</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">iova</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="n">iommu_unmap</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">__free_iova</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">arm_iommu_alloc_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
	    <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgprot_t</span> <span class="n">prot</span> <span class="o">=</span> <span class="n">__get_dma_pgprot</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">pgprot_kernel</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">DMA_ERROR_CODE</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="n">pages</span> <span class="o">=</span> <span class="n">__iommu_alloc_buffer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">__iommu_create_mapping</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">handle</span> <span class="o">==</span> <span class="n">DMA_ERROR_CODE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_buffer</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">__iommu_alloc_remap</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_mapping</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>

<span class="nl">err_mapping:</span>
	<span class="n">__iommu_remove_mapping</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="nl">err_buffer:</span>
	<span class="n">__iommu_free_buffer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arm_iommu_mmap_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		    <span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">arm_vmregion</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">__get_dma_pgprot</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">arm_vmregion_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">consistent_head</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cpu_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uaddr</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">usize</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">vm_insert_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span> <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Remapping memory, error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">uaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">usize</span> <span class="o">-=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">usize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * free a page as defined by the above mapping.</span>
<span class="cm"> * Must not be called with IRQs disabled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">arm_iommu_free_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">,</span>
			  <span class="n">dma_addr_t</span> <span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">arm_vmregion</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">arm_vmregion_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">consistent_head</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cpu_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
		<span class="n">__dma_free_remap</span><span class="p">(</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">__iommu_remove_mapping</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">__iommu_free_buffer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Map a part of the scatter-gather list into contiguous io address space</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__map_sg_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_iommu_mapping</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">archdata</span><span class="p">.</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span> <span class="n">iova_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">DMA_ERROR_CODE</span><span class="p">;</span>

	<span class="n">iova_base</span> <span class="o">=</span> <span class="n">iova</span> <span class="o">=</span> <span class="n">__alloc_iova</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iova</span> <span class="o">==</span> <span class="n">DMA_ERROR_CODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">phys_addr_t</span> <span class="n">phys</span> <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_is_coherent</span><span class="p">())</span>
			<span class="n">__dma_page_cpu_to_dev</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_map</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">phys</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">iova</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">iova_base</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">iommu_unmap</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">iova_base</span><span class="p">,</span> <span class="n">count</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">__free_iova</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">iova_base</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * arm_iommu_map_sg - map a set of SG buffers for streaming mode DMA</span>
<span class="cm"> * @dev: valid struct device pointer</span>
<span class="cm"> * @sg: list of buffers</span>
<span class="cm"> * @nents: number of buffers to map</span>
<span class="cm"> * @dir: DMA transfer direction</span>
<span class="cm"> *</span>
<span class="cm"> * Map a set of buffers described by scatterlist in streaming mode for DMA.</span>
<span class="cm"> * The scatter gather list elements are merged together (if possible) and</span>
<span class="cm"> * tagged with the appropriate dma address and length. They are obtained via</span>
<span class="cm"> * sg_dma_{address,length}.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">arm_iommu_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
		     <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sg</span><span class="p">,</span> <span class="o">*</span><span class="n">dma</span> <span class="o">=</span> <span class="n">sg</span><span class="p">,</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">dma_get_max_seg_size</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="n">DMA_ERROR_CODE</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">||</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">||</span> <span class="n">size</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__map_sg_chunk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">,</span>
			    <span class="n">dir</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bad_mapping</span><span class="p">;</span>

			<span class="n">dma</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
			<span class="n">dma</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

			<span class="n">size</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
			<span class="n">dma</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__map_sg_chunk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_mapping</span><span class="p">;</span>

	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>

<span class="nl">bad_mapping:</span>
	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">__iommu_remove_mapping</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * arm_iommu_unmap_sg - unmap a set of SG buffers mapped by dma_map_sg</span>
<span class="cm"> * @dev: valid struct device pointer</span>
<span class="cm"> * @sg: list of buffers</span>
<span class="cm"> * @nents: number of buffers to unmap (same as was passed to dma_map_sg)</span>
<span class="cm"> * @dir: DMA transfer direction (same as was passed to dma_map_sg)</span>
<span class="cm"> *</span>
<span class="cm"> * Unmap a set of streaming mode DMA translations.  Again, CPU access</span>
<span class="cm"> * rules concerning calls here are the same as for dma_unmap_single().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">arm_iommu_unmap_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sg_dma_len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
			<span class="n">__iommu_remove_mapping</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
					       <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_is_coherent</span><span class="p">())</span>
			<span class="n">__dma_page_dev_to_cpu</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
					      <span class="n">s</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * arm_iommu_sync_sg_for_cpu</span>
<span class="cm"> * @dev: valid struct device pointer</span>
<span class="cm"> * @sg: list of buffers</span>
<span class="cm"> * @nents: number of buffers to map (returned from dma_map_sg)</span>
<span class="cm"> * @dir: DMA transfer direction (same as was passed to dma_map_sg)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">arm_iommu_sync_sg_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_is_coherent</span><span class="p">())</span>
			<span class="n">__dma_page_dev_to_cpu</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * arm_iommu_sync_sg_for_device</span>
<span class="cm"> * @dev: valid struct device pointer</span>
<span class="cm"> * @sg: list of buffers</span>
<span class="cm"> * @nents: number of buffers to map (returned from dma_map_sg)</span>
<span class="cm"> * @dir: DMA transfer direction (same as was passed to dma_map_sg)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">arm_iommu_sync_sg_for_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_is_coherent</span><span class="p">())</span>
			<span class="n">__dma_page_cpu_to_dev</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * arm_iommu_map_page</span>
<span class="cm"> * @dev: valid struct device pointer</span>
<span class="cm"> * @page: page that buffer resides in</span>
<span class="cm"> * @offset: offset into page for start of buffer</span>
<span class="cm"> * @size: size of buffer to map</span>
<span class="cm"> * @dir: DMA transfer direction</span>
<span class="cm"> *</span>
<span class="cm"> * IOMMU aware version of arm_dma_map_page()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="nf">arm_iommu_map_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
	     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_iommu_mapping</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">archdata</span><span class="p">.</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_is_coherent</span><span class="p">())</span>
		<span class="n">__dma_page_cpu_to_dev</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

	<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">__alloc_iova</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_addr</span> <span class="o">==</span> <span class="n">DMA_ERROR_CODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dma_addr</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_map</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dma_addr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">__free_iova</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">DMA_ERROR_CODE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * arm_iommu_unmap_page</span>
<span class="cm"> * @dev: valid struct device pointer</span>
<span class="cm"> * @handle: DMA address of buffer</span>
<span class="cm"> * @size: size of buffer (same as passed to dma_map_page)</span>
<span class="cm"> * @dir: DMA transfer direction (same as passed to dma_map_page)</span>
<span class="cm"> *</span>
<span class="cm"> * IOMMU aware version of arm_dma_unmap_page()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">arm_iommu_unmap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">handle</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_iommu_mapping</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">archdata</span><span class="p">.</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">iova</span> <span class="o">=</span> <span class="n">handle</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">phys_to_page</span><span class="p">(</span><span class="n">iommu_iova_to_phys</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">iova</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">handle</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iova</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_is_coherent</span><span class="p">())</span>
		<span class="n">__dma_page_dev_to_cpu</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

	<span class="n">iommu_unmap</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">__free_iova</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">arm_iommu_sync_single_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">dma_addr_t</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_iommu_mapping</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">archdata</span><span class="p">.</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">iova</span> <span class="o">=</span> <span class="n">handle</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">phys_to_page</span><span class="p">(</span><span class="n">iommu_iova_to_phys</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">iova</span><span class="p">));</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">handle</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iova</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_is_coherent</span><span class="p">())</span>
		<span class="n">__dma_page_dev_to_cpu</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">arm_iommu_sync_single_for_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">dma_addr_t</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_iommu_mapping</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">archdata</span><span class="p">.</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">iova</span> <span class="o">=</span> <span class="n">handle</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">phys_to_page</span><span class="p">(</span><span class="n">iommu_iova_to_phys</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">iova</span><span class="p">));</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">handle</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iova</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__dma_page_cpu_to_dev</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="n">iommu_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc</span>		<span class="o">=</span> <span class="n">arm_iommu_alloc_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free</span>		<span class="o">=</span> <span class="n">arm_iommu_free_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>		<span class="o">=</span> <span class="n">arm_iommu_mmap_attrs</span><span class="p">,</span>

	<span class="p">.</span><span class="n">map_page</span>		<span class="o">=</span> <span class="n">arm_iommu_map_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_page</span>		<span class="o">=</span> <span class="n">arm_iommu_unmap_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_single_for_cpu</span>	<span class="o">=</span> <span class="n">arm_iommu_sync_single_for_cpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_single_for_device</span>	<span class="o">=</span> <span class="n">arm_iommu_sync_single_for_device</span><span class="p">,</span>

	<span class="p">.</span><span class="n">map_sg</span>			<span class="o">=</span> <span class="n">arm_iommu_map_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_sg</span>		<span class="o">=</span> <span class="n">arm_iommu_unmap_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_sg_for_cpu</span>	<span class="o">=</span> <span class="n">arm_iommu_sync_sg_for_cpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_sg_for_device</span>	<span class="o">=</span> <span class="n">arm_iommu_sync_sg_for_device</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * arm_iommu_create_mapping</span>
<span class="cm"> * @bus: pointer to the bus holding the client device (for IOMMU calls)</span>
<span class="cm"> * @base: start address of the valid IO address space</span>
<span class="cm"> * @size: size of the valid IO address space</span>
<span class="cm"> * @order: accuracy of the IO addresses allocations</span>
<span class="cm"> *</span>
<span class="cm"> * Creates a mapping structure which holds information about used/unused</span>
<span class="cm"> * IO address ranges, which is required to perform memory allocation and</span>
<span class="cm"> * mapping with IOMMU aware functions.</span>
<span class="cm"> *</span>
<span class="cm"> * The client device need to be attached to the mapping with</span>
<span class="cm"> * arm_iommu_attach_device function.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dma_iommu_mapping</span> <span class="o">*</span>
<span class="nf">arm_iommu_create_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">base</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">+</span> <span class="n">order</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bitmap_size</span> <span class="o">=</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dma_iommu_mapping</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_iommu_mapping</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">bitmap</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">bitmap_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err2</span><span class="p">;</span>

	<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">=</span> <span class="n">BITS_PER_BYTE</span> <span class="o">*</span> <span class="n">bitmap_size</span><span class="p">;</span>
	<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">=</span> <span class="n">iommu_domain_alloc</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err3</span><span class="p">;</span>

	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mapping</span><span class="p">;</span>
<span class="nl">err3:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
<span class="nl">err2:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_iommu_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_iommu_mapping</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_iommu_mapping</span><span class="p">,</span> <span class="n">kref</span><span class="p">);</span>

	<span class="n">iommu_domain_free</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arm_iommu_release_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_iommu_mapping</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">release_iommu_mapping</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * arm_iommu_attach_device</span>
<span class="cm"> * @dev: valid struct device pointer</span>
<span class="cm"> * @mapping: io address space mapping structure (returned from</span>
<span class="cm"> *	arm_iommu_create_mapping)</span>
<span class="cm"> *</span>
<span class="cm"> * Attaches specified io address space mapping to the provided device,</span>
<span class="cm"> * this replaces the dma operations (dma_map_ops pointer) with the</span>
<span class="cm"> * IOMMU aware version. More than one client might be attached to</span>
<span class="cm"> * the same io address space mapping.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">arm_iommu_attach_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dma_iommu_mapping</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">iommu_attach_device</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">archdata</span><span class="p">.</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">;</span>
	<span class="n">set_dma_ops</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iommu_ops</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Attached IOMMU controller to %s device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
