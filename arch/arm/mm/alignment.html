<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mm › alignment.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>alignment.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/arch/arm/mm/alignment.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1995  Linus Torvalds</span>
<span class="cm"> *  Modifications for ARM processor (c) 1995-2001 Russell King</span>
<span class="cm"> *  Thumb alignment fault fixups (c) 2004 MontaVista Software, Inc.</span>
<span class="cm"> *  - Adapted from gdb/sim/arm/thumbemu.c -- Thumb instruction emulation.</span>
<span class="cm"> *    Copyright (C) 1996, Cygnus Software Technologies Ltd.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>

<span class="cp">#include &lt;asm/cp15.h&gt;</span>
<span class="cp">#include &lt;asm/system_info.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cp">#include &quot;fault.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * 32-bit misaligned trap handler (c) 1998 San Mehat (CCC) -July 1998</span>
<span class="cm"> * /proc/sys/debug/alignment, modified and integrated into</span>
<span class="cm"> * Linux 2.1 by Russell King</span>
<span class="cm"> *</span>
<span class="cm"> * Speed optimisations and better fault handling by Russell King.</span>
<span class="cm"> *</span>
<span class="cm"> * *** NOTE ***</span>
<span class="cm"> * This code is not portable to processors with late data abort handling.</span>
<span class="cm"> */</span>
<span class="cp">#define CODING_BITS(i)	(i &amp; 0x0e000000)</span>

<span class="cp">#define LDST_I_BIT(i)	(i &amp; (1 &lt;&lt; 26))		</span><span class="cm">/* Immediate constant	*/</span><span class="cp"></span>
<span class="cp">#define LDST_P_BIT(i)	(i &amp; (1 &lt;&lt; 24))		</span><span class="cm">/* Preindex		*/</span><span class="cp"></span>
<span class="cp">#define LDST_U_BIT(i)	(i &amp; (1 &lt;&lt; 23))		</span><span class="cm">/* Add offset		*/</span><span class="cp"></span>
<span class="cp">#define LDST_W_BIT(i)	(i &amp; (1 &lt;&lt; 21))		</span><span class="cm">/* Writeback		*/</span><span class="cp"></span>
<span class="cp">#define LDST_L_BIT(i)	(i &amp; (1 &lt;&lt; 20))		</span><span class="cm">/* Load			*/</span><span class="cp"></span>

<span class="cp">#define LDST_P_EQ_U(i)	((((i) ^ ((i) &gt;&gt; 1)) &amp; (1 &lt;&lt; 23)) == 0)</span>

<span class="cp">#define LDSTHD_I_BIT(i)	(i &amp; (1 &lt;&lt; 22))		</span><span class="cm">/* double/half-word immed */</span><span class="cp"></span>
<span class="cp">#define LDM_S_BIT(i)	(i &amp; (1 &lt;&lt; 22))		</span><span class="cm">/* write CPSR from SPSR	*/</span><span class="cp"></span>

<span class="cp">#define RN_BITS(i)	((i &gt;&gt; 16) &amp; 15)	</span><span class="cm">/* Rn			*/</span><span class="cp"></span>
<span class="cp">#define RD_BITS(i)	((i &gt;&gt; 12) &amp; 15)	</span><span class="cm">/* Rd			*/</span><span class="cp"></span>
<span class="cp">#define RM_BITS(i)	(i &amp; 15)		</span><span class="cm">/* Rm			*/</span><span class="cp"></span>

<span class="cp">#define REGMASK_BITS(i)	(i &amp; 0xffff)</span>
<span class="cp">#define OFFSET_BITS(i)	(i &amp; 0x0fff)</span>

<span class="cp">#define IS_SHIFT(i)	(i &amp; 0x0ff0)</span>
<span class="cp">#define SHIFT_BITS(i)	((i &gt;&gt; 7) &amp; 0x1f)</span>
<span class="cp">#define SHIFT_TYPE(i)	(i &amp; 0x60)</span>
<span class="cp">#define SHIFT_LSL	0x00</span>
<span class="cp">#define SHIFT_LSR	0x20</span>
<span class="cp">#define SHIFT_ASR	0x40</span>
<span class="cp">#define SHIFT_RORRRX	0x60</span>

<span class="cp">#define BAD_INSTR 	0xdeadc0de</span>

<span class="cm">/* Thumb-2 32 bit format per ARMv7 DDI0406A A6.3, either f800h,e800h,f800h */</span>
<span class="cp">#define IS_T32(hi16) \</span>
<span class="cp">	(((hi16) &amp; 0xe000) == 0xe000 &amp;&amp; ((hi16) &amp; 0x1800))</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ai_user</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ai_sys</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ai_skipped</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ai_half</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ai_word</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ai_dword</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ai_multi</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ai_usermode</span><span class="p">;</span>

<span class="n">core_param</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">ai_usermode</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span>

<span class="cp">#define UM_WARN		(1 &lt;&lt; 0)</span>
<span class="cp">#define UM_FIXUP	(1 &lt;&lt; 1)</span>
<span class="cp">#define UM_SIGNAL	(1 &lt;&lt; 2)</span>

<span class="cm">/* Return true if and only if the ARMv6 unaligned access model is in use. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">cpu_is_v6_unaligned</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_architecture</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">CPU_ARCH_ARMv6</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cr_alignment</span> <span class="o">&amp;</span> <span class="n">CR_U</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">safe_usermode</span><span class="p">(</span><span class="kt">int</span> <span class="n">new_usermode</span><span class="p">,</span> <span class="n">bool</span> <span class="n">warn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * ARMv6 and later CPUs can perform unaligned accesses for</span>
<span class="cm">	 * most single load and store instructions up to word size.</span>
<span class="cm">	 * LDM, STM, LDRD and STRD still need to be handled.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Ignoring the alignment fault is not an option on these</span>
<span class="cm">	 * CPUs since we spin re-faulting the instruction without</span>
<span class="cm">	 * making any progress.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_v6_unaligned</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">new_usermode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UM_FIXUP</span> <span class="o">|</span> <span class="n">UM_SIGNAL</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">new_usermode</span> <span class="o">|=</span> <span class="n">UM_FIXUP</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">warn</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;alignment: ignoring faults is unsafe on this CPU.  Defaulting to fixup mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">new_usermode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">usermode_action</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;ignored&quot;</span><span class="p">,</span>
	<span class="s">&quot;warn&quot;</span><span class="p">,</span>
	<span class="s">&quot;fixup&quot;</span><span class="p">,</span>
	<span class="s">&quot;fixup+warn&quot;</span><span class="p">,</span>
	<span class="s">&quot;signal&quot;</span><span class="p">,</span>
	<span class="s">&quot;signal+warn&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alignment_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;User:</span><span class="se">\t\t</span><span class="s">%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ai_user</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;System:</span><span class="se">\t\t</span><span class="s">%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ai_sys</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Skipped:</span><span class="se">\t</span><span class="s">%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ai_skipped</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Half:</span><span class="se">\t\t</span><span class="s">%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ai_half</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Word:</span><span class="se">\t\t</span><span class="s">%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ai_word</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_architecture</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">CPU_ARCH_ARMv5TE</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;DWord:</span><span class="se">\t\t</span><span class="s">%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ai_dword</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Multi:</span><span class="se">\t\t</span><span class="s">%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ai_multi</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;User faults:</span><span class="se">\t</span><span class="s">%i (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ai_usermode</span><span class="p">,</span>
			<span class="n">usermode_action</span><span class="p">[</span><span class="n">ai_usermode</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alignment_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">alignment_proc_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">alignment_proc_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">mode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">buffer</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span> <span class="o">&lt;=</span> <span class="sc">&#39;5&#39;</span><span class="p">)</span>
			<span class="n">ai_usermode</span> <span class="o">=</span> <span class="n">safe_usermode</span><span class="p">(</span><span class="n">mode</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">alignment_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">alignment_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">alignment_proc_write</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="k">union</span> <span class="n">offset_union</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">un</span><span class="p">;</span>
	  <span class="kt">signed</span> <span class="kt">long</span> <span class="n">sn</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define TYPE_ERROR	0</span>
<span class="cp">#define TYPE_FAULT	1</span>
<span class="cp">#define TYPE_LDST	2</span>
<span class="cp">#define TYPE_DONE	3</span>

<span class="cp">#ifdef __ARMEB__</span>
<span class="cp">#define BE		1</span>
<span class="cp">#define FIRST_BYTE_16	&quot;mov	%1, %1, ror #8\n&quot;</span>
<span class="cp">#define FIRST_BYTE_32	&quot;mov	%1, %1, ror #24\n&quot;</span>
<span class="cp">#define NEXT_BYTE	&quot;ror #24&quot;</span>
<span class="cp">#else</span>
<span class="cp">#define BE		0</span>
<span class="cp">#define FIRST_BYTE_16</span>
<span class="cp">#define FIRST_BYTE_32</span>
<span class="cp">#define NEXT_BYTE	&quot;lsr #8&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#define __get8_unaligned_check(ins,val,addr,err)	\</span>
<span class="cp">	__asm__(					\</span>
<span class="cp"> ARM(	&quot;1:	&quot;ins&quot;	%1, [%2], #1\n&quot;	)		\</span>
<span class="cp"> THUMB(	&quot;1:	&quot;ins&quot;	%1, [%2]\n&quot;	)		\</span>
<span class="cp"> THUMB(	&quot;	add	%2, %2, #1\n&quot;	)		\</span>
<span class="cp">	&quot;2:\n&quot;						\</span>
<span class="cp">	&quot;	.pushsection .fixup,\&quot;ax\&quot;\n&quot;		\</span>
<span class="cp">	&quot;	.align	2\n&quot;				\</span>
<span class="cp">	&quot;3:	mov	%0, #1\n&quot;			\</span>
<span class="cp">	&quot;	b	2b\n&quot;				\</span>
<span class="cp">	&quot;	.popsection\n&quot;				\</span>
<span class="cp">	&quot;	.pushsection __ex_table,\&quot;a\&quot;\n&quot;	\</span>
<span class="cp">	&quot;	.align	3\n&quot;				\</span>
<span class="cp">	&quot;	.long	1b, 3b\n&quot;			\</span>
<span class="cp">	&quot;	.popsection\n&quot;				\</span>
<span class="cp">	: &quot;=r&quot; (err), &quot;=&amp;r&quot; (val), &quot;=r&quot; (addr)		\</span>
<span class="cp">	: &quot;0&quot; (err), &quot;2&quot; (addr))</span>

<span class="cp">#define __get16_unaligned_check(ins,val,addr)			\</span>
<span class="cp">	do {							\</span>
<span class="cp">		unsigned int err = 0, v, a = addr;		\</span>
<span class="cp">		__get8_unaligned_check(ins,v,a,err);		\</span>
<span class="cp">		val =  v &lt;&lt; ((BE) ? 8 : 0);			\</span>
<span class="cp">		__get8_unaligned_check(ins,v,a,err);		\</span>
<span class="cp">		val |= v &lt;&lt; ((BE) ? 0 : 8);			\</span>
<span class="cp">		if (err)					\</span>
<span class="cp">			goto fault;				\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define get16_unaligned_check(val,addr) \</span>
<span class="cp">	__get16_unaligned_check(&quot;ldrb&quot;,val,addr)</span>

<span class="cp">#define get16t_unaligned_check(val,addr) \</span>
<span class="cp">	__get16_unaligned_check(&quot;ldrbt&quot;,val,addr)</span>

<span class="cp">#define __get32_unaligned_check(ins,val,addr)			\</span>
<span class="cp">	do {							\</span>
<span class="cp">		unsigned int err = 0, v, a = addr;		\</span>
<span class="cp">		__get8_unaligned_check(ins,v,a,err);		\</span>
<span class="cp">		val =  v &lt;&lt; ((BE) ? 24 :  0);			\</span>
<span class="cp">		__get8_unaligned_check(ins,v,a,err);		\</span>
<span class="cp">		val |= v &lt;&lt; ((BE) ? 16 :  8);			\</span>
<span class="cp">		__get8_unaligned_check(ins,v,a,err);		\</span>
<span class="cp">		val |= v &lt;&lt; ((BE) ?  8 : 16);			\</span>
<span class="cp">		__get8_unaligned_check(ins,v,a,err);		\</span>
<span class="cp">		val |= v &lt;&lt; ((BE) ?  0 : 24);			\</span>
<span class="cp">		if (err)					\</span>
<span class="cp">			goto fault;				\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define get32_unaligned_check(val,addr) \</span>
<span class="cp">	__get32_unaligned_check(&quot;ldrb&quot;,val,addr)</span>

<span class="cp">#define get32t_unaligned_check(val,addr) \</span>
<span class="cp">	__get32_unaligned_check(&quot;ldrbt&quot;,val,addr)</span>

<span class="cp">#define __put16_unaligned_check(ins,val,addr)			\</span>
<span class="cp">	do {							\</span>
<span class="cp">		unsigned int err = 0, v = val, a = addr;	\</span>
<span class="cp">		__asm__( FIRST_BYTE_16				\</span>
<span class="cp">	 ARM(	&quot;1:	&quot;ins&quot;	%1, [%2], #1\n&quot;	)		\</span>
<span class="cp">	 THUMB(	&quot;1:	&quot;ins&quot;	%1, [%2]\n&quot;	)		\</span>
<span class="cp">	 THUMB(	&quot;	add	%2, %2, #1\n&quot;	)		\</span>
<span class="cp">		&quot;	mov	%1, %1, &quot;NEXT_BYTE&quot;\n&quot;		\</span>
<span class="cp">		&quot;2:	&quot;ins&quot;	%1, [%2]\n&quot;			\</span>
<span class="cp">		&quot;3:\n&quot;						\</span>
<span class="cp">		&quot;	.pushsection .fixup,\&quot;ax\&quot;\n&quot;		\</span>
<span class="cp">		&quot;	.align	2\n&quot;				\</span>
<span class="cp">		&quot;4:	mov	%0, #1\n&quot;			\</span>
<span class="cp">		&quot;	b	3b\n&quot;				\</span>
<span class="cp">		&quot;	.popsection\n&quot;				\</span>
<span class="cp">		&quot;	.pushsection __ex_table,\&quot;a\&quot;\n&quot;	\</span>
<span class="cp">		&quot;	.align	3\n&quot;				\</span>
<span class="cp">		&quot;	.long	1b, 4b\n&quot;			\</span>
<span class="cp">		&quot;	.long	2b, 4b\n&quot;			\</span>
<span class="cp">		&quot;	.popsection\n&quot;				\</span>
<span class="cp">		: &quot;=r&quot; (err), &quot;=&amp;r&quot; (v), &quot;=&amp;r&quot; (a)		\</span>
<span class="cp">		: &quot;0&quot; (err), &quot;1&quot; (v), &quot;2&quot; (a));			\</span>
<span class="cp">		if (err)					\</span>
<span class="cp">			goto fault;				\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define put16_unaligned_check(val,addr)  \</span>
<span class="cp">	__put16_unaligned_check(&quot;strb&quot;,val,addr)</span>

<span class="cp">#define put16t_unaligned_check(val,addr) \</span>
<span class="cp">	__put16_unaligned_check(&quot;strbt&quot;,val,addr)</span>

<span class="cp">#define __put32_unaligned_check(ins,val,addr)			\</span>
<span class="cp">	do {							\</span>
<span class="cp">		unsigned int err = 0, v = val, a = addr;	\</span>
<span class="cp">		__asm__( FIRST_BYTE_32				\</span>
<span class="cp">	 ARM(	&quot;1:	&quot;ins&quot;	%1, [%2], #1\n&quot;	)		\</span>
<span class="cp">	 THUMB(	&quot;1:	&quot;ins&quot;	%1, [%2]\n&quot;	)		\</span>
<span class="cp">	 THUMB(	&quot;	add	%2, %2, #1\n&quot;	)		\</span>
<span class="cp">		&quot;	mov	%1, %1, &quot;NEXT_BYTE&quot;\n&quot;		\</span>
<span class="cp">	 ARM(	&quot;2:	&quot;ins&quot;	%1, [%2], #1\n&quot;	)		\</span>
<span class="cp">	 THUMB(	&quot;2:	&quot;ins&quot;	%1, [%2]\n&quot;	)		\</span>
<span class="cp">	 THUMB(	&quot;	add	%2, %2, #1\n&quot;	)		\</span>
<span class="cp">		&quot;	mov	%1, %1, &quot;NEXT_BYTE&quot;\n&quot;		\</span>
<span class="cp">	 ARM(	&quot;3:	&quot;ins&quot;	%1, [%2], #1\n&quot;	)		\</span>
<span class="cp">	 THUMB(	&quot;3:	&quot;ins&quot;	%1, [%2]\n&quot;	)		\</span>
<span class="cp">	 THUMB(	&quot;	add	%2, %2, #1\n&quot;	)		\</span>
<span class="cp">		&quot;	mov	%1, %1, &quot;NEXT_BYTE&quot;\n&quot;		\</span>
<span class="cp">		&quot;4:	&quot;ins&quot;	%1, [%2]\n&quot;			\</span>
<span class="cp">		&quot;5:\n&quot;						\</span>
<span class="cp">		&quot;	.pushsection .fixup,\&quot;ax\&quot;\n&quot;		\</span>
<span class="cp">		&quot;	.align	2\n&quot;				\</span>
<span class="cp">		&quot;6:	mov	%0, #1\n&quot;			\</span>
<span class="cp">		&quot;	b	5b\n&quot;				\</span>
<span class="cp">		&quot;	.popsection\n&quot;				\</span>
<span class="cp">		&quot;	.pushsection __ex_table,\&quot;a\&quot;\n&quot;	\</span>
<span class="cp">		&quot;	.align	3\n&quot;				\</span>
<span class="cp">		&quot;	.long	1b, 6b\n&quot;			\</span>
<span class="cp">		&quot;	.long	2b, 6b\n&quot;			\</span>
<span class="cp">		&quot;	.long	3b, 6b\n&quot;			\</span>
<span class="cp">		&quot;	.long	4b, 6b\n&quot;			\</span>
<span class="cp">		&quot;	.popsection\n&quot;				\</span>
<span class="cp">		: &quot;=r&quot; (err), &quot;=&amp;r&quot; (v), &quot;=&amp;r&quot; (a)		\</span>
<span class="cp">		: &quot;0&quot; (err), &quot;1&quot; (v), &quot;2&quot; (a));			\</span>
<span class="cp">		if (err)					\</span>
<span class="cp">			goto fault;				\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define put32_unaligned_check(val,addr) \</span>
<span class="cp">	__put32_unaligned_check(&quot;strb&quot;, val, addr)</span>

<span class="cp">#define put32t_unaligned_check(val,addr) \</span>
<span class="cp">	__put32_unaligned_check(&quot;strbt&quot;, val, addr)</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">do_alignment_finish_ldst</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="k">union</span> <span class="n">offset_union</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LDST_U_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span>
		<span class="n">offset</span><span class="p">.</span><span class="n">un</span> <span class="o">=</span> <span class="o">-</span><span class="n">offset</span><span class="p">.</span><span class="n">un</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LDST_P_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">.</span><span class="n">un</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LDST_P_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">)</span> <span class="o">||</span> <span class="n">LDST_W_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">RN_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">)]</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">do_alignment_ldrhstrh</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rd</span> <span class="o">=</span> <span class="n">RD_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">);</span>

	<span class="n">ai_half</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">user</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">LDST_L_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">get16_unaligned_check</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

		<span class="cm">/* signed half-word? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">signed</span> <span class="kt">long</span><span class="p">)((</span><span class="kt">signed</span> <span class="kt">short</span><span class="p">)</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">put16_unaligned_check</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">],</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">TYPE_LDST</span><span class="p">;</span>

 <span class="nl">user:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">LDST_L_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">get16t_unaligned_check</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

		<span class="cm">/* signed half-word? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">signed</span> <span class="kt">long</span><span class="p">)((</span><span class="kt">signed</span> <span class="kt">short</span><span class="p">)</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">put16t_unaligned_check</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">],</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">TYPE_LDST</span><span class="p">;</span>

 <span class="nl">fault:</span>
	<span class="k">return</span> <span class="n">TYPE_FAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">do_alignment_ldrdstrd</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instr</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rd</span> <span class="o">=</span> <span class="n">RD_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rd2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">load</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0xfe000000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xe8000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ARMv7 Thumb-2 32-bit LDRD/STRD */</span>
		<span class="n">rd2</span> <span class="o">=</span> <span class="p">(</span><span class="n">instr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="n">load</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">LDST_L_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">rd</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">rd</span> <span class="o">==</span> <span class="mi">14</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">load</span> <span class="o">=</span> <span class="p">((</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xd0</span><span class="p">);</span>
		<span class="n">rd2</span> <span class="o">=</span> <span class="n">rd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ai_dword</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">user</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">load</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">get32_unaligned_check</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">get32_unaligned_check</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd2</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">put32_unaligned_check</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">],</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">put32_unaligned_check</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd2</span><span class="p">],</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">TYPE_LDST</span><span class="p">;</span>

 <span class="nl">user:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">load</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">get32t_unaligned_check</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">get32t_unaligned_check</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd2</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">put32t_unaligned_check</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">],</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">put32t_unaligned_check</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd2</span><span class="p">],</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">TYPE_LDST</span><span class="p">;</span>
 <span class="nl">bad:</span>
	<span class="k">return</span> <span class="n">TYPE_ERROR</span><span class="p">;</span>
 <span class="nl">fault:</span>
	<span class="k">return</span> <span class="n">TYPE_FAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">do_alignment_ldrstr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rd</span> <span class="o">=</span> <span class="n">RD_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">);</span>

	<span class="n">ai_word</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">LDST_P_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">LDST_W_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span> <span class="o">||</span> <span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">trans</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">LDST_L_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">get32_unaligned_check</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">put32_unaligned_check</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">],</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">TYPE_LDST</span><span class="p">;</span>

 <span class="nl">trans:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">LDST_L_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">get32t_unaligned_check</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">put32t_unaligned_check</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">],</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">TYPE_LDST</span><span class="p">;</span>

 <span class="nl">fault:</span>
	<span class="k">return</span> <span class="n">TYPE_FAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * LDM/STM alignment handler.</span>
<span class="cm"> *</span>
<span class="cm"> * There are 4 variants of this instruction:</span>
<span class="cm"> *</span>
<span class="cm"> * B = rn pointer before instruction, A = rn pointer after instruction</span>
<span class="cm"> *              ------ increasing address -----&gt;</span>
<span class="cm"> *	        |    | r0 | r1 | ... | rx |    |</span>
<span class="cm"> * PU = 01             B                    A</span>
<span class="cm"> * PU = 11        B                    A</span>
<span class="cm"> * PU = 00        A                    B</span>
<span class="cm"> * PU = 10             A                    B</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">do_alignment_ldmstm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rd</span><span class="p">,</span> <span class="n">rn</span><span class="p">,</span> <span class="n">correction</span><span class="p">,</span> <span class="n">nr_regs</span><span class="p">,</span> <span class="n">regbits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">eaddr</span><span class="p">,</span> <span class="n">newaddr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">LDM_S_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>

	<span class="n">correction</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* processor implementation defined */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_pc</span> <span class="o">+=</span> <span class="n">correction</span><span class="p">;</span>

	<span class="n">ai_multi</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* count the number of registers in the mask to be transferred */</span>
	<span class="n">nr_regs</span> <span class="o">=</span> <span class="n">hweight16</span><span class="p">(</span><span class="n">REGMASK_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">rn</span> <span class="o">=</span> <span class="n">RN_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">);</span>
	<span class="n">newaddr</span> <span class="o">=</span> <span class="n">eaddr</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rn</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LDST_U_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span>
		<span class="n">nr_regs</span> <span class="o">=</span> <span class="o">-</span><span class="n">nr_regs</span><span class="p">;</span>
	<span class="n">newaddr</span> <span class="o">+=</span> <span class="n">nr_regs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LDST_U_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span>
		<span class="n">eaddr</span> <span class="o">=</span> <span class="n">newaddr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">LDST_P_EQ_U</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span>	<span class="cm">/* U = P */</span>
		<span class="n">eaddr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For alignment faults on the ARM922T/ARM920T the MMU  makes</span>
<span class="cm">	 * the FSR (and hence addr) equal to the updated base address</span>
<span class="cm">	 * of the multiple access rather than the restored value.</span>
<span class="cm">	 * Switch this message off if we&#39;ve got a ARM92[02], otherwise</span>
<span class="cm">	 * [ls]dm alignment faults are noisy!</span>
<span class="cm">	 */</span>
<span class="cp">#if !(defined CONFIG_CPU_ARM922T)  &amp;&amp; !(defined CONFIG_CPU_ARM920T)</span>
	<span class="cm">/*</span>
<span class="cm">	 * This is a &quot;hint&quot; - we already have eaddr worked out by the</span>
<span class="cm">	 * processor for us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">eaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;LDMSTM: PC = %08lx, instr = %08lx, &quot;</span>
			<span class="s">&quot;addr = %08lx, eaddr = %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">instruction_pointer</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">instr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">eaddr</span><span class="p">);</span>
		<span class="n">show_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">regbits</span> <span class="o">=</span> <span class="n">REGMASK_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">),</span> <span class="n">rd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">regbits</span><span class="p">;</span>
		     <span class="n">regbits</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rd</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">regbits</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">LDST_L_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span> <span class="p">{</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
					<span class="n">get32t_unaligned_check</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">eaddr</span><span class="p">);</span>
					<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">put32t_unaligned_check</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">],</span> <span class="n">eaddr</span><span class="p">);</span>
				<span class="n">eaddr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">regbits</span> <span class="o">=</span> <span class="n">REGMASK_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">),</span> <span class="n">rd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">regbits</span><span class="p">;</span>
		     <span class="n">regbits</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rd</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">regbits</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">LDST_L_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span> <span class="p">{</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
					<span class="n">get32_unaligned_check</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">eaddr</span><span class="p">);</span>
					<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">put32_unaligned_check</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rd</span><span class="p">],</span> <span class="n">eaddr</span><span class="p">);</span>
				<span class="n">eaddr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">LDST_W_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rn</span><span class="p">]</span> <span class="o">=</span> <span class="n">newaddr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LDST_L_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">REGMASK_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)))</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_pc</span> <span class="o">-=</span> <span class="n">correction</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">TYPE_DONE</span><span class="p">;</span>

<span class="nl">fault:</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_pc</span> <span class="o">-=</span> <span class="n">correction</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">TYPE_FAULT</span><span class="p">;</span>

<span class="nl">bad:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Alignment trap: not handling ldm with s-bit set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">TYPE_ERROR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert Thumb ld/st instruction forms to equivalent ARM instructions so</span>
<span class="cm"> * we can reuse ARM userland alignment fault fixups for Thumb.</span>
<span class="cm"> *</span>
<span class="cm"> * This implementation was initially based on the algorithm found in</span>
<span class="cm"> * gdb/sim/arm/thumbemu.c. It is basically just a code reduction of same</span>
<span class="cm"> * to convert only Thumb ld/st instruction forms to equivalent ARM forms.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTES:</span>
<span class="cm"> * 1. Comments below refer to ARM ARM DDI0100E Thumb Instruction sections.</span>
<span class="cm"> * 2. If for some reason we&#39;re passed an non-ld/st Thumb instruction to</span>
<span class="cm"> *    decode, we return 0xdeadc0de. This should never happen under normal</span>
<span class="cm"> *    circumstances but if it does, we&#39;ve got other problems to deal with</span>
<span class="cm"> *    elsewhere and we obviously can&#39;t fix those problems here.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">thumb2arm</span><span class="p">(</span><span class="n">u16</span> <span class="n">tinstr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">11</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="mh">0xf800</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* 6.5.1 Format 1: */</span>
	<span class="k">case</span> <span class="mh">0x6000</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span>:				<span class="cm">/* 7.1.52 STR(1) */</span>
	<span class="k">case</span> <span class="mh">0x6800</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span>:				<span class="cm">/* 7.1.26 LDR(1) */</span>
	<span class="k">case</span> <span class="mh">0x7000</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span>:				<span class="cm">/* 7.1.55 STRB(1) */</span>
	<span class="k">case</span> <span class="mh">0x7800</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span>:				<span class="cm">/* 7.1.30 LDRB(1) */</span>
		<span class="k">return</span> <span class="mh">0xe5800000</span> <span class="o">|</span>
			<span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">12</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">22</span><span class="o">-</span><span class="mi">12</span><span class="p">))</span> <span class="o">|</span>	<span class="cm">/* fixup */</span>
			<span class="p">(</span><span class="n">L</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">)</span> <span class="o">|</span>				<span class="cm">/* L==1? */</span>
			<span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">12</span><span class="o">-</span><span class="mi">0</span><span class="p">))</span> <span class="o">|</span>		<span class="cm">/* Rd */</span>
			<span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">16</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span> <span class="o">|</span>		<span class="cm">/* Rn */</span>
			<span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">31</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">))</span> <span class="o">&gt;&gt;</span>			<span class="cm">/* immed_5 */</span>
				<span class="p">(</span><span class="mi">6</span> <span class="o">-</span> <span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">12</span><span class="p">))</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">2</span><span class="p">)));</span>
	<span class="k">case</span> <span class="mh">0x8000</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span>:				<span class="cm">/* 7.1.57 STRH(1) */</span>
	<span class="k">case</span> <span class="mh">0x8800</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span>:				<span class="cm">/* 7.1.32 LDRH(1) */</span>
		<span class="k">return</span> <span class="mh">0xe1c000b0</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">L</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">)</span> <span class="o">|</span>				<span class="cm">/* L==1? */</span>
			<span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">12</span><span class="o">-</span><span class="mi">0</span><span class="p">))</span> <span class="o">|</span>		<span class="cm">/* Rd */</span>
			<span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">16</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span> <span class="o">|</span>		<span class="cm">/* Rn */</span>
			<span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">6</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">|</span>	 <span class="cm">/* immed_5[2:0] */</span>
			<span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">9</span><span class="o">-</span><span class="mi">8</span><span class="p">));</span>	 <span class="cm">/* immed_5[4:3] */</span>

	<span class="cm">/* 6.5.1 Format 2: */</span>
	<span class="k">case</span> <span class="mh">0x5000</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span>:
	<span class="k">case</span> <span class="mh">0x5800</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span>:
		<span class="p">{</span>
			<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">subset</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
				<span class="mh">0xe7800000</span><span class="p">,</span>		<span class="cm">/* 7.1.53 STR(2) */</span>
				<span class="mh">0xe18000b0</span><span class="p">,</span>		<span class="cm">/* 7.1.58 STRH(2) */</span>
				<span class="mh">0xe7c00000</span><span class="p">,</span>		<span class="cm">/* 7.1.56 STRB(2) */</span>
				<span class="mh">0xe19000d0</span><span class="p">,</span>		<span class="cm">/* 7.1.34 LDRSB */</span>
				<span class="mh">0xe7900000</span><span class="p">,</span>		<span class="cm">/* 7.1.27 LDR(2) */</span>
				<span class="mh">0xe19000b0</span><span class="p">,</span>		<span class="cm">/* 7.1.33 LDRH(2) */</span>
				<span class="mh">0xe7d00000</span><span class="p">,</span>		<span class="cm">/* 7.1.31 LDRB(2) */</span>
				<span class="mh">0xe19000f0</span>		<span class="cm">/* 7.1.35 LDRSH */</span>
			<span class="p">};</span>
			<span class="k">return</span> <span class="n">subset</span><span class="p">[(</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">]</span> <span class="o">|</span>
			    <span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">12</span><span class="o">-</span><span class="mi">0</span><span class="p">))</span> <span class="o">|</span>	<span class="cm">/* Rd */</span>
			    <span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">16</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span> <span class="o">|</span>	<span class="cm">/* Rn */</span>
			    <span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">6</span><span class="o">-</span><span class="mi">0</span><span class="p">));</span>	<span class="cm">/* Rm */</span>
		<span class="p">}</span>

	<span class="cm">/* 6.5.1 Format 3: */</span>
	<span class="k">case</span> <span class="mh">0x4800</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span>:				<span class="cm">/* 7.1.28 LDR(3) */</span>
		<span class="cm">/* NOTE: This case is not technically possible. We&#39;re</span>
<span class="cm">		 *	 loading 32-bit memory data via PC relative</span>
<span class="cm">		 *	 addressing mode. So we can and should eliminate</span>
<span class="cm">		 *	 this case. But I&#39;ll leave it here for now.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mh">0xe59f0000</span> <span class="o">|</span>
		    <span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">12</span><span class="o">-</span><span class="mi">8</span><span class="p">))</span> <span class="o">|</span>		<span class="cm">/* Rd */</span>
		    <span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">0</span><span class="p">));</span>			<span class="cm">/* immed_8 */</span>

	<span class="cm">/* 6.5.1 Format 4: */</span>
	<span class="k">case</span> <span class="mh">0x9000</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span>:				<span class="cm">/* 7.1.54 STR(3) */</span>
	<span class="k">case</span> <span class="mh">0x9800</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span>:				<span class="cm">/* 7.1.29 LDR(4) */</span>
		<span class="k">return</span> <span class="mh">0xe58d0000</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">L</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">)</span> <span class="o">|</span>				<span class="cm">/* L==1? */</span>
			<span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">12</span><span class="o">-</span><span class="mi">8</span><span class="p">))</span> <span class="o">|</span>		<span class="cm">/* Rd */</span>
			<span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>			<span class="cm">/* immed_8 */</span>

	<span class="cm">/* 6.6.1 Format 1: */</span>
	<span class="k">case</span> <span class="mh">0xc000</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span>:				<span class="cm">/* 7.1.51 STMIA */</span>
	<span class="k">case</span> <span class="mh">0xc800</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span>:				<span class="cm">/* 7.1.25 LDMIA */</span>
		<span class="p">{</span>
			<span class="n">u32</span> <span class="n">Rn</span> <span class="o">=</span> <span class="p">(</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">7</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">W</span> <span class="o">=</span> <span class="p">((</span><span class="n">L</span><span class="o">&lt;&lt;</span><span class="n">Rn</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tinstr</span><span class="o">&amp;</span><span class="mi">255</span><span class="p">))</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">21</span><span class="p">;</span>

			<span class="k">return</span> <span class="mh">0xe8800000</span> <span class="o">|</span> <span class="n">W</span> <span class="o">|</span> <span class="p">(</span><span class="n">L</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">Rn</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">tinstr</span><span class="o">&amp;</span><span class="mi">255</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="cm">/* 6.6.1 Format 2: */</span>
	<span class="k">case</span> <span class="mh">0xb000</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span>:				<span class="cm">/* 7.1.48 PUSH */</span>
	<span class="k">case</span> <span class="mh">0xb800</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span>:				<span class="cm">/* 7.1.47 POP */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">))</span> <span class="o">==</span> <span class="mh">0x0400</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">subset</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
				<span class="mh">0xe92d0000</span><span class="p">,</span>	<span class="cm">/* STMDB sp!,{registers} */</span>
				<span class="mh">0xe92d4000</span><span class="p">,</span>	<span class="cm">/* STMDB sp!,{registers,lr} */</span>
				<span class="mh">0xe8bd0000</span><span class="p">,</span>	<span class="cm">/* LDMIA sp!,{registers} */</span>
				<span class="mh">0xe8bd8000</span>	<span class="cm">/* LDMIA sp!,{registers,pc} */</span>
			<span class="p">};</span>
			<span class="k">return</span> <span class="n">subset</span><span class="p">[(</span><span class="n">L</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)]</span> <span class="o">|</span>
			    <span class="p">(</span><span class="n">tinstr</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">);</span>		<span class="cm">/* register_list */</span>
		<span class="p">}</span>
		<span class="cm">/* Else fall through for illegal instruction case */</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">BAD_INSTR</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert Thumb-2 32 bit LDM, STM, LDRD, STRD to equivalent instruction</span>
<span class="cm"> * handlable by ARM alignment handler, also find the corresponding handler,</span>
<span class="cm"> * so that we can reuse ARM userland alignment fault fixups for Thumb.</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstr: original Thumb-2 instruction; returns new handlable instruction</span>
<span class="cm"> * @regs: register context.</span>
<span class="cm"> * @poffset: return offset from faulted addr for later writeback</span>
<span class="cm"> *</span>
<span class="cm"> * NOTES:</span>
<span class="cm"> * 1. Comments below refer to ARMv7 DDI0406A Thumb Instruction sections.</span>
<span class="cm"> * 2. Register name Rt from ARMv7 is same as Rd from ARMv6 (Rd is Rt)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">do_alignment_t32_to_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pinstr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
			    <span class="k">union</span> <span class="n">offset_union</span> <span class="o">*</span><span class="n">poffset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instr</span> <span class="o">=</span> <span class="o">*</span><span class="n">pinstr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tinst1</span> <span class="o">=</span> <span class="p">(</span><span class="n">instr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tinst2</span> <span class="o">=</span> <span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">poffset</span><span class="o">-&gt;</span><span class="n">un</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">tinst1</span> <span class="o">&amp;</span> <span class="mh">0xffe0</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* A6.3.5 Load/Store multiple */</span>
	<span class="k">case</span> <span class="mh">0xe880</span>:		<span class="cm">/* STM/STMIA/STMEA,LDM/LDMIA, PUSH/POP T2 */</span>
	<span class="k">case</span> <span class="mh">0xe8a0</span>:		<span class="cm">/* ...above writeback version */</span>
	<span class="k">case</span> <span class="mh">0xe900</span>:		<span class="cm">/* STMDB/STMFD, LDMDB/LDMEA */</span>
	<span class="k">case</span> <span class="mh">0xe920</span>:		<span class="cm">/* ...above writeback version */</span>
		<span class="cm">/* no need offset decision since handler calculates it */</span>
		<span class="k">return</span> <span class="n">do_alignment_ldmstm</span><span class="p">;</span>

	<span class="k">case</span> <span class="mh">0xf840</span>:		<span class="cm">/* POP/PUSH T3 (single register) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">RN_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">13</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tinst2</span> <span class="o">&amp;</span> <span class="mh">0x09ff</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0904</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">L</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">LDST_L_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">));</span>
			<span class="k">const</span> <span class="n">u32</span> <span class="n">subset</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
				<span class="mh">0xe92d0000</span><span class="p">,</span>	<span class="cm">/* STMDB sp!,{registers} */</span>
				<span class="mh">0xe8bd0000</span><span class="p">,</span>	<span class="cm">/* LDMIA sp!,{registers} */</span>
			<span class="p">};</span>
			<span class="o">*</span><span class="n">pinstr</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="n">L</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RD_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">));</span>
			<span class="k">return</span> <span class="n">do_alignment_ldmstm</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Else fall through for illegal instruction case */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* A6.3.6 Load/store double, STRD/LDRD(immed, lit, reg) */</span>
	<span class="k">case</span> <span class="mh">0xe860</span>:
	<span class="k">case</span> <span class="mh">0xe960</span>:
	<span class="k">case</span> <span class="mh">0xe8e0</span>:
	<span class="k">case</span> <span class="mh">0xe9e0</span>:
		<span class="n">poffset</span><span class="o">-&gt;</span><span class="n">un</span> <span class="o">=</span> <span class="p">(</span><span class="n">tinst2</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xe940</span>:
	<span class="k">case</span> <span class="mh">0xe9c0</span>:
		<span class="k">return</span> <span class="n">do_alignment_ldrdstrd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * No need to handle load/store instructions up to word size</span>
<span class="cm">	 * since ARMv6 and later CPUs can perform unaligned accesses.</span>
<span class="cm">	 */</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">do_alignment</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fsr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">offset_union</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">instrptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">mm_segment_t</span> <span class="n">fs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fault</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tinstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">isize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">thumb2_32b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">interrupts_enabled</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">instrptr</span> <span class="o">=</span> <span class="n">instruction_pointer</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="n">fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thumb_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fault</span> <span class="o">=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">tinstr</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)(</span><span class="n">instrptr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fault</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_architecture</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">CPU_ARCH_ARMv7</span> <span class="o">&amp;&amp;</span>
			    <span class="n">IS_T32</span><span class="p">(</span><span class="n">tinstr</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Thumb-2 32-bit */</span>
				<span class="n">u16</span> <span class="n">tinst2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">fault</span> <span class="o">=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">tinst2</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)(</span><span class="n">instrptr</span><span class="o">+</span><span class="mi">2</span><span class="p">));</span>
				<span class="n">instr</span> <span class="o">=</span> <span class="p">(</span><span class="n">tinstr</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">tinst2</span><span class="p">;</span>
				<span class="n">thumb2_32b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">isize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">instr</span> <span class="o">=</span> <span class="n">thumb2arm</span><span class="p">(</span><span class="n">tinstr</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">fault</span> <span class="o">=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">instrptr</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fault</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">TYPE_FAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_or_fault</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">user</span><span class="p">;</span>

	<span class="n">ai_sys</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

 <span class="nl">fixup:</span>

	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_pc</span> <span class="o">+=</span> <span class="n">isize</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">CODING_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x00000000</span>:	<span class="cm">/* 3.13.4 load/store instruction extensions */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">LDSTHD_I_BIT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span>
			<span class="n">offset</span><span class="p">.</span><span class="n">un</span> <span class="o">=</span> <span class="p">(</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0xf00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span> <span class="o">|</span> <span class="p">(</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">offset</span><span class="p">.</span><span class="n">un</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">RM_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">)];</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0x000000f0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x000000b0</span> <span class="o">||</span> <span class="cm">/* LDRH, STRH */</span>
		    <span class="p">(</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0x001000f0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x001000f0</span><span class="p">)</span>   <span class="cm">/* LDRSH */</span>
			<span class="n">handler</span> <span class="o">=</span> <span class="n">do_alignment_ldrhstrh</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0x001000f0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x000000d0</span> <span class="o">||</span> <span class="cm">/* LDRD */</span>
			 <span class="p">(</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0x001000f0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x000000f0</span><span class="p">)</span>   <span class="cm">/* STRD */</span>
			<span class="n">handler</span> <span class="o">=</span> <span class="n">do_alignment_ldrdstrd</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0x01f00ff0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x01000090</span><span class="p">)</span> <span class="cm">/* SWP */</span>
			<span class="k">goto</span> <span class="n">swp</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mh">0x04000000</span>:	<span class="cm">/* ldr or str immediate */</span>
		<span class="n">offset</span><span class="p">.</span><span class="n">un</span> <span class="o">=</span> <span class="n">OFFSET_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">);</span>
		<span class="n">handler</span> <span class="o">=</span> <span class="n">do_alignment_ldrstr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mh">0x06000000</span>:	<span class="cm">/* ldr or str register */</span>
		<span class="n">offset</span><span class="p">.</span><span class="n">un</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">RM_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">)];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_SHIFT</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shiftval</span> <span class="o">=</span> <span class="n">SHIFT_BITS</span><span class="p">(</span><span class="n">instr</span><span class="p">);</span>

			<span class="k">switch</span><span class="p">(</span><span class="n">SHIFT_TYPE</span><span class="p">(</span><span class="n">instr</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SHIFT_LSL</span>:
				<span class="n">offset</span><span class="p">.</span><span class="n">un</span> <span class="o">&lt;&lt;=</span> <span class="n">shiftval</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SHIFT_LSR</span>:
				<span class="n">offset</span><span class="p">.</span><span class="n">un</span> <span class="o">&gt;&gt;=</span> <span class="n">shiftval</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SHIFT_ASR</span>:
				<span class="n">offset</span><span class="p">.</span><span class="n">sn</span> <span class="o">&gt;&gt;=</span> <span class="n">shiftval</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SHIFT_RORRRX</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">shiftval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">offset</span><span class="p">.</span><span class="n">un</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_cpsr</span> <span class="o">&amp;</span> <span class="n">PSR_C_BIT</span><span class="p">)</span>
						<span class="n">offset</span><span class="p">.</span><span class="n">un</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">offset</span><span class="p">.</span><span class="n">un</span> <span class="o">=</span> <span class="n">offset</span><span class="p">.</span><span class="n">un</span> <span class="o">&gt;&gt;</span> <span class="n">shiftval</span> <span class="o">|</span>
							  <span class="n">offset</span><span class="p">.</span><span class="n">un</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">shiftval</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">handler</span> <span class="o">=</span> <span class="n">do_alignment_ldrstr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mh">0x08000000</span>:	<span class="cm">/* ldm or stm, or thumb-2 32bit instruction */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">thumb2_32b</span><span class="p">)</span>
			<span class="n">handler</span> <span class="o">=</span> <span class="n">do_alignment_t32_to_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instr</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">handler</span> <span class="o">=</span> <span class="n">do_alignment_ldmstm</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handler</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">handler</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">instr</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_ERROR</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_FAULT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_pc</span> <span class="o">-=</span> <span class="n">isize</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_or_fault</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_LDST</span><span class="p">)</span>
		<span class="n">do_alignment_finish_ldst</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">instr</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">bad_or_fault:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_ERROR</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We got a fault - fix it up, or die.</span>
<span class="cm">	 */</span>
	<span class="n">do_bad_area</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">fsr</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">swp:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Alignment trap: not handling swp instruction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

 <span class="nl">bad:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Oops, we didn&#39;t handle the instruction.</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Alignment trap: not handling instruction &quot;</span>
		<span class="s">&quot;%0*lx at [&lt;%08lx&gt;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">isize</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
		<span class="n">isize</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">?</span> <span class="n">tinstr</span> <span class="o">:</span> <span class="n">instr</span><span class="p">,</span> <span class="n">instrptr</span><span class="p">);</span>
	<span class="n">ai_skipped</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

 <span class="nl">user:</span>
	<span class="n">ai_user</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ai_usermode</span> <span class="o">&amp;</span> <span class="n">UM_WARN</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Alignment trap: %s (%d) PC=0x%08lx Instr=0x%0*lx &quot;</span>
		       <span class="s">&quot;Address=0x%08lx FSR 0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span>
			<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">instrptr</span><span class="p">,</span>
			<span class="n">isize</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">isize</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">?</span> <span class="n">tinstr</span> <span class="o">:</span> <span class="n">instr</span><span class="p">,</span>
		        <span class="n">addr</span><span class="p">,</span> <span class="n">fsr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ai_usermode</span> <span class="o">&amp;</span> <span class="n">UM_FIXUP</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fixup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ai_usermode</span> <span class="o">&amp;</span> <span class="n">UM_SIGNAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">siginfo_t</span> <span class="n">si</span><span class="p">;</span>

		<span class="n">si</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGBUS</span><span class="p">;</span>
		<span class="n">si</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">si</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">BUS_ADRALN</span><span class="p">;</span>
		<span class="n">si</span><span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>

		<span class="n">force_sig_info</span><span class="p">(</span><span class="n">si</span><span class="p">.</span><span class="n">si_signo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re about to disable the alignment trap and return to</span>
<span class="cm">		 * user space.  But if an interrupt occurs before actually</span>
<span class="cm">		 * reaching user space, then the IRQ vector entry code will</span>
<span class="cm">		 * notice that we were still in kernel space and therefore</span>
<span class="cm">		 * the alignment trap won&#39;t be re-enabled in that case as it</span>
<span class="cm">		 * is presumed to be always on from kernel space.</span>
<span class="cm">		 * Let&#39;s prevent that race by disabling interrupts here (they</span>
<span class="cm">		 * are disabled on the way back to user space anyway in</span>
<span class="cm">		 * entry-common.S) and disable the alignment trap only if</span>
<span class="cm">		 * there is no work pending for this thread.</span>
<span class="cm">		 */</span>
		<span class="n">raw_local_irq_disable</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">_TIF_WORK_MASK</span><span class="p">))</span>
			<span class="n">set_cr</span><span class="p">(</span><span class="n">cr_no_alignment</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This needs to be done after sysctl_init, otherwise sys/ will be</span>
<span class="cm"> * overwritten.  Actually, this shouldn&#39;t be in sys/ at all since</span>
<span class="cm"> * it isn&#39;t a sysctl, and it doesn&#39;t contain sysctl information.</span>
<span class="cm"> * We now locate it in /proc/cpu/alignment instead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">alignment_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;cpu/alignment&quot;</span><span class="p">,</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">alignment_proc_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_v6_unaligned</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">cr_alignment</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CR_A</span><span class="p">;</span>
		<span class="n">cr_no_alignment</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CR_A</span><span class="p">;</span>
		<span class="n">set_cr</span><span class="p">(</span><span class="n">cr_alignment</span><span class="p">);</span>
		<span class="n">ai_usermode</span> <span class="o">=</span> <span class="n">safe_usermode</span><span class="p">(</span><span class="n">ai_usermode</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hook_fault_code</span><span class="p">(</span><span class="n">FAULT_CODE_ALIGNMENT</span><span class="p">,</span> <span class="n">do_alignment</span><span class="p">,</span> <span class="n">SIGBUS</span><span class="p">,</span> <span class="n">BUS_ADRALN</span><span class="p">,</span>
			<span class="s">&quot;alignment exception&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * ARMv6K and ARMv7 use fault status 3 (0b00011) as Access Flag section</span>
<span class="cm">	 * fault, not as alignment error.</span>
<span class="cm">	 *</span>
<span class="cm">	 * TODO: handle ARMv6K properly. Runtime check for &#39;K&#39; extension is</span>
<span class="cm">	 * needed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_architecture</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">CPU_ARCH_ARMv6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hook_fault_code</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">do_alignment</span><span class="p">,</span> <span class="n">SIGBUS</span><span class="p">,</span> <span class="n">BUS_ADRALN</span><span class="p">,</span>
				<span class="s">&quot;alignment exception&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">fs_initcall</span><span class="p">(</span><span class="n">alignment_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
