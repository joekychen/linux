<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mach-integrator › pci_v3.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pci_v3.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/arch/arm/mach-integrator/pci_v3.c</span>
<span class="cm"> *</span>
<span class="cm"> *  PCI functions for V3 host PCI bridge</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1999 ARM Limited</span>
<span class="cm"> *  Copyright (C) 2000-2001 Deep Blue Solutions Ltd</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>

<span class="cp">#include &lt;mach/hardware.h&gt;</span>
<span class="cp">#include &lt;mach/platform.h&gt;</span>
<span class="cp">#include &lt;mach/irqs.h&gt;</span>

<span class="cp">#include &lt;asm/signal.h&gt;</span>
<span class="cp">#include &lt;asm/mach/pci.h&gt;</span>
<span class="cp">#include &lt;asm/irq_regs.h&gt;</span>

<span class="cp">#include &lt;asm/hardware/pci_v3.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * The V3 PCI interface chip in Integrator provides several windows from</span>
<span class="cm"> * local bus memory into the PCI memory areas.   Unfortunately, there</span>
<span class="cm"> * are not really enough windows for our usage, therefore we reuse </span>
<span class="cm"> * one of the windows for access to PCI configuration space.  The</span>
<span class="cm"> * memory map is as follows:</span>
<span class="cm"> * </span>
<span class="cm"> * Local Bus Memory         Usage</span>
<span class="cm"> * </span>
<span class="cm"> * 40000000 - 4FFFFFFF      PCI memory.  256M non-prefetchable</span>
<span class="cm"> * 50000000 - 5FFFFFFF      PCI memory.  256M prefetchable</span>
<span class="cm"> * 60000000 - 60FFFFFF      PCI IO.  16M</span>
<span class="cm"> * 61000000 - 61FFFFFF      PCI Configuration. 16M</span>
<span class="cm"> * </span>
<span class="cm"> * There are three V3 windows, each described by a pair of V3 registers.</span>
<span class="cm"> * These are LB_BASE0/LB_MAP0, LB_BASE1/LB_MAP1 and LB_BASE2/LB_MAP2.</span>
<span class="cm"> * Base0 and Base1 can be used for any type of PCI memory access.   Base2</span>
<span class="cm"> * can be used either for PCI I/O or for I20 accesses.  By default, uHAL</span>
<span class="cm"> * uses this only for PCI IO space.</span>
<span class="cm"> * </span>
<span class="cm"> * Normally these spaces are mapped using the following base registers:</span>
<span class="cm"> * </span>
<span class="cm"> * Usage Local Bus Memory         Base/Map registers used</span>
<span class="cm"> * </span>
<span class="cm"> * Mem   40000000 - 4FFFFFFF      LB_BASE0/LB_MAP0</span>
<span class="cm"> * Mem   50000000 - 5FFFFFFF      LB_BASE1/LB_MAP1</span>
<span class="cm"> * IO    60000000 - 60FFFFFF      LB_BASE2/LB_MAP2</span>
<span class="cm"> * Cfg   61000000 - 61FFFFFF</span>
<span class="cm"> * </span>
<span class="cm"> * This means that I20 and PCI configuration space accesses will fail.</span>
<span class="cm"> * When PCI configuration accesses are needed (via the uHAL PCI </span>
<span class="cm"> * configuration space primitives) we must remap the spaces as follows:</span>
<span class="cm"> * </span>
<span class="cm"> * Usage Local Bus Memory         Base/Map registers used</span>
<span class="cm"> * </span>
<span class="cm"> * Mem   40000000 - 4FFFFFFF      LB_BASE0/LB_MAP0</span>
<span class="cm"> * Mem   50000000 - 5FFFFFFF      LB_BASE0/LB_MAP0</span>
<span class="cm"> * IO    60000000 - 60FFFFFF      LB_BASE2/LB_MAP2</span>
<span class="cm"> * Cfg   61000000 - 61FFFFFF      LB_BASE1/LB_MAP1</span>
<span class="cm"> * </span>
<span class="cm"> * To make this work, the code depends on overlapping windows working.</span>
<span class="cm"> * The V3 chip translates an address by checking its range within </span>
<span class="cm"> * each of the BASE/MAP pairs in turn (in ascending register number</span>
<span class="cm"> * order).  It will use the first matching pair.   So, for example,</span>
<span class="cm"> * if the same address is mapped by both LB_BASE0/LB_MAP0 and</span>
<span class="cm"> * LB_BASE1/LB_MAP1, the V3 will use the translation from </span>
<span class="cm"> * LB_BASE0/LB_MAP0.</span>
<span class="cm"> * </span>
<span class="cm"> * To allow PCI Configuration space access, the code enlarges the</span>
<span class="cm"> * window mapped by LB_BASE0/LB_MAP0 from 256M to 512M.  This occludes</span>
<span class="cm"> * the windows currently mapped by LB_BASE1/LB_MAP1 so that it can</span>
<span class="cm"> * be remapped for use by configuration cycles.</span>
<span class="cm"> * </span>
<span class="cm"> * At the end of the PCI Configuration space accesses, </span>
<span class="cm"> * LB_BASE1/LB_MAP1 is reset to map PCI Memory.  Finally the window</span>
<span class="cm"> * mapped by LB_BASE0/LB_MAP0 is reduced in size from 512M to 256M to</span>
<span class="cm"> * reveal the now restored LB_BASE1/LB_MAP1 window.</span>
<span class="cm"> * </span>
<span class="cm"> * NOTE: We do not set up I2O mapping.  I suspect that this is only</span>
<span class="cm"> * for an intelligent (target) device.  Using I2O disables most of</span>
<span class="cm"> * the mappings into PCI memory.</span>
<span class="cm"> */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>V3 access routines</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define v3_writeb(o,v) __raw_writeb(v, PCI_V3_VADDR + (unsigned int)(o))</span>
<span class="cp">#define v3_readb(o)    (__raw_readb(PCI_V3_VADDR + (unsigned int)(o)))</span>

<span class="cp">#define v3_writew(o,v) __raw_writew(v, PCI_V3_VADDR + (unsigned int)(o))</span>
<span class="cp">#define v3_readw(o)    (__raw_readw(PCI_V3_VADDR + (unsigned int)(o)))</span>

<span class="cp">#define v3_writel(o,v) __raw_writel(v, PCI_V3_VADDR + (unsigned int)(o))</span>
<span class="cp">#define v3_readl(o)    (__raw_readl(PCI_V3_VADDR + (unsigned int)(o)))</span>

<span class="cm">/*============================================================================</span>
<span class="cm"> *</span>
<span class="cm"> * routine:	uHALir_PCIMakeConfigAddress()</span>
<span class="cm"> *</span>
<span class="cm"> * parameters:	bus = which bus</span>
<span class="cm"> *              device = which device</span>
<span class="cm"> *              function = which function</span>
<span class="cm"> *		offset = configuration space register we are interested in</span>
<span class="cm"> *</span>
<span class="cm"> * description:	this routine will generate a platform dependent config</span>
<span class="cm"> *		address.</span>
<span class="cm"> *</span>
<span class="cm"> * calls:	none</span>
<span class="cm"> *</span>
<span class="cm"> * returns:	configuration address to play on the PCI bus</span>
<span class="cm"> *</span>
<span class="cm"> * To generate the appropriate PCI configuration cycles in the PCI </span>
<span class="cm"> * configuration address space, you present the V3 with the following pattern </span>
<span class="cm"> * (which is very nearly a type 1 (except that the lower two bits are 00 and</span>
<span class="cm"> * not 01).   In order for this mapping to work you need to set up one of</span>
<span class="cm"> * the local to PCI aperatures to 16Mbytes in length translating to</span>
<span class="cm"> * PCI configuration space starting at 0x0000.0000.</span>
<span class="cm"> *</span>
<span class="cm"> * PCI configuration cycles look like this:</span>
<span class="cm"> *</span>
<span class="cm"> * Type 0:</span>
<span class="cm"> *</span>
<span class="cm"> *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 </span>
<span class="cm"> *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0</span>
<span class="cm"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> * | | |D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|0|</span>
<span class="cm"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *</span>
<span class="cm"> *	31:11	Device select bit.</span>
<span class="cm"> * 	10:8	Function number</span>
<span class="cm"> * 	 7:2	Register number</span>
<span class="cm"> *</span>
<span class="cm"> * Type 1:</span>
<span class="cm"> *</span>
<span class="cm"> *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 </span>
<span class="cm"> *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0</span>
<span class="cm"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> * | | | | | | | | | | |B|B|B|B|B|B|B|B|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|1|</span>
<span class="cm"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="cm"> *</span>
<span class="cm"> *	31:24	reserved</span>
<span class="cm"> *	23:16	bus number (8 bits = 128 possible buses)</span>
<span class="cm"> *	15:11	Device number (5 bits)</span>
<span class="cm"> *	10:8	function number</span>
<span class="cm"> *	 7:2	register number</span>
<span class="cm"> *  </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_RAW_SPINLOCK</span><span class="p">(</span><span class="n">v3_lock</span><span class="p">);</span>

<span class="cp">#define PCI_BUS_NONMEM_START	0x00000000</span>
<span class="cp">#define PCI_BUS_NONMEM_SIZE	SZ_256M</span>

<span class="cp">#define PCI_BUS_PREMEM_START	PCI_BUS_NONMEM_START + PCI_BUS_NONMEM_SIZE</span>
<span class="cp">#define PCI_BUS_PREMEM_SIZE	SZ_256M</span>

<span class="cp">#if PCI_BUS_NONMEM_START &amp; 0x000fffff</span>
<span class="cp">#error PCI_BUS_NONMEM_START must be megabyte aligned</span>
<span class="cp">#endif</span>
<span class="cp">#if PCI_BUS_PREMEM_START &amp; 0x000fffff</span>
<span class="cp">#error PCI_BUS_PREMEM_START must be megabyte aligned</span>
<span class="cp">#endif</span>

<span class="cp">#undef V3_LB_BASE_PREFETCH</span>
<span class="cp">#define V3_LB_BASE_PREFETCH 0</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">v3_open_config_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address</span><span class="p">,</span> <span class="n">mapaddress</span><span class="p">,</span> <span class="n">busnr</span><span class="p">;</span>

	<span class="n">busnr</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Trap out illegal values</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">busnr</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devfn</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">busnr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">devfn</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * local bus segment so need a type 0 config cycle</span>
<span class="cm">		 *</span>
<span class="cm">		 * build the PCI configuration &quot;address&quot; with one-hot in</span>
<span class="cm">		 * A31-A11</span>
<span class="cm">		 *</span>
<span class="cm">		 * mapaddress:</span>
<span class="cm">		 *  3:1 = config cycle (101)</span>
<span class="cm">		 *  0   = PCI A1 &amp; A0 are 0 (0)</span>
<span class="cm">		 */</span>
		<span class="n">address</span> <span class="o">=</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">devfn</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">mapaddress</span> <span class="o">=</span> <span class="n">V3_LB_MAP_TYPE_CONFIG</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * high order bits are handled by the MAP register</span>
<span class="cm">			 */</span>
			<span class="n">mapaddress</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">slot</span> <span class="o">-</span> <span class="mi">5</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="cm">/*</span>
<span class="cm">			 * low order bits handled directly in the address</span>
<span class="cm">			 */</span>
			<span class="n">address</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">slot</span> <span class="o">+</span> <span class="mi">11</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        	<span class="cm">/*</span>
<span class="cm">		 * not the local bus segment so need a type 1 config cycle</span>
<span class="cm">		 *</span>
<span class="cm">		 * address:</span>
<span class="cm">		 *  23:16 = bus number</span>
<span class="cm">		 *  15:11 = slot number (7:3 of devfn)</span>
<span class="cm">		 *  10:8  = func number (2:0 of devfn)</span>
<span class="cm">		 *</span>
<span class="cm">		 * mapaddress:</span>
<span class="cm">		 *  3:1 = config cycle (101)</span>
<span class="cm">		 *  0   = PCI A1 &amp; A0 from host bus (1)</span>
<span class="cm">		 */</span>
		<span class="n">mapaddress</span> <span class="o">=</span> <span class="n">V3_LB_MAP_TYPE_CONFIG</span> <span class="o">|</span> <span class="n">V3_LB_MAP_AD_LOW_EN</span><span class="p">;</span>
		<span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="n">busnr</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">devfn</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up base0 to see all 512Mbytes of memory space (not</span>
<span class="cm">	 * prefetchable), this frees up base1 for re-use by</span>
<span class="cm">	 * configuration memory</span>
<span class="cm">	 */</span>
	<span class="n">v3_writel</span><span class="p">(</span><span class="n">V3_LB_BASE0</span><span class="p">,</span> <span class="n">v3_addr_to_lb_base</span><span class="p">(</span><span class="n">PHYS_PCI_MEM_BASE</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">V3_LB_BASE_ADR_SIZE_512MB</span> <span class="o">|</span> <span class="n">V3_LB_BASE_ENABLE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up base1/map1 to point into configuration space.</span>
<span class="cm">	 */</span>
	<span class="n">v3_writel</span><span class="p">(</span><span class="n">V3_LB_BASE1</span><span class="p">,</span> <span class="n">v3_addr_to_lb_base</span><span class="p">(</span><span class="n">PHYS_PCI_CONFIG_BASE</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">V3_LB_BASE_ADR_SIZE_16MB</span> <span class="o">|</span> <span class="n">V3_LB_BASE_ENABLE</span><span class="p">);</span>
	<span class="n">v3_writew</span><span class="p">(</span><span class="n">V3_LB_MAP1</span><span class="p">,</span> <span class="n">mapaddress</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">PCI_CONFIG_VADDR</span> <span class="o">+</span> <span class="n">address</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">v3_close_config_window</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Reassign base1 for use by prefetchable PCI memory</span>
<span class="cm">	 */</span>
	<span class="n">v3_writel</span><span class="p">(</span><span class="n">V3_LB_BASE1</span><span class="p">,</span> <span class="n">v3_addr_to_lb_base</span><span class="p">(</span><span class="n">PHYS_PCI_MEM_BASE</span> <span class="o">+</span> <span class="n">SZ_256M</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">V3_LB_BASE_ADR_SIZE_256MB</span> <span class="o">|</span> <span class="n">V3_LB_BASE_PREFETCH</span> <span class="o">|</span>
			<span class="n">V3_LB_BASE_ENABLE</span><span class="p">);</span>
	<span class="n">v3_writew</span><span class="p">(</span><span class="n">V3_LB_MAP1</span><span class="p">,</span> <span class="n">v3_addr_to_lb_map</span><span class="p">(</span><span class="n">PCI_BUS_PREMEM_START</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">V3_LB_MAP_TYPE_MEM_MULTIPLE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * And shrink base0 back to a 256M window (NOTE: MAP0 already correct)</span>
<span class="cm">	 */</span>
	<span class="n">v3_writel</span><span class="p">(</span><span class="n">V3_LB_BASE0</span><span class="p">,</span> <span class="n">v3_addr_to_lb_base</span><span class="p">(</span><span class="n">PHYS_PCI_MEM_BASE</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">V3_LB_BASE_ADR_SIZE_256MB</span> <span class="o">|</span> <span class="n">V3_LB_BASE_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">v3_read_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v3_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">v3_open_config_window</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readb</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readw</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">v3_close_config_window</span><span class="p">();</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v3_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">v3_write_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v3_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">v3_open_config_window</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">__raw_writeb</span><span class="p">((</span><span class="n">u8</span><span class="p">)</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">__raw_readb</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">__raw_writew</span><span class="p">((</span><span class="n">u16</span><span class="p">)</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">__raw_readw</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">__raw_readl</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">v3_close_config_window</span><span class="p">();</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v3_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pci_ops</span> <span class="n">pci_v3_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>	<span class="o">=</span> <span class="n">v3_read_config</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>	<span class="o">=</span> <span class="n">v3_write_config</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">non_mem</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;PCI non-prefetchable&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">PHYS_PCI_MEM_BASE</span> <span class="o">+</span> <span class="n">PCI_BUS_NONMEM_START</span><span class="p">,</span>
	<span class="p">.</span><span class="n">end</span>	<span class="o">=</span> <span class="n">PHYS_PCI_MEM_BASE</span> <span class="o">+</span> <span class="n">PCI_BUS_NONMEM_START</span> <span class="o">+</span> <span class="n">PCI_BUS_NONMEM_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>	<span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">pre_mem</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;PCI prefetchable&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">PHYS_PCI_MEM_BASE</span> <span class="o">+</span> <span class="n">PCI_BUS_PREMEM_START</span><span class="p">,</span>
	<span class="p">.</span><span class="n">end</span>	<span class="o">=</span> <span class="n">PHYS_PCI_MEM_BASE</span> <span class="o">+</span> <span class="n">PCI_BUS_PREMEM_START</span> <span class="o">+</span> <span class="n">PCI_BUS_PREMEM_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>	<span class="o">=</span> <span class="n">IORESOURCE_MEM</span> <span class="o">|</span> <span class="n">IORESOURCE_PREFETCH</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pci_v3_setup_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_sys_data</span> <span class="o">*</span><span class="n">sys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">non_mem</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PCI: unable to allocate non-prefetchable &quot;</span>
		       <span class="s">&quot;memory region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pre_mem</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">release_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">non_mem</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PCI: unable to allocate prefetchable &quot;</span>
		       <span class="s">&quot;memory region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * the IO resource for this bus</span>
<span class="cm">	 * the mem resource for this bus</span>
<span class="cm">	 * the prefetch mem resource for this bus</span>
<span class="cm">	 */</span>
	<span class="n">pci_add_resource_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sys</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">ioport_resource</span><span class="p">,</span> <span class="n">sys</span><span class="o">-&gt;</span><span class="n">io_offset</span><span class="p">);</span>
	<span class="n">pci_add_resource_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sys</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">non_mem</span><span class="p">,</span> <span class="n">sys</span><span class="o">-&gt;</span><span class="n">mem_offset</span><span class="p">);</span>
	<span class="n">pci_add_resource_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sys</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pre_mem</span><span class="p">,</span> <span class="n">sys</span><span class="o">-&gt;</span><span class="n">mem_offset</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These don&#39;t seem to be implemented on the Integrator I have, which</span>
<span class="cm"> * means I can&#39;t get additional information on the reason for the pm2fb</span>
<span class="cm"> * problems.  I suppose I&#39;ll just have to mind-meld with the machine. ;)</span>
<span class="cm"> */</span>
<span class="cp">#define SC_PCI     IO_ADDRESS(INTEGRATOR_SC_PCIENABLE)</span>
<span class="cp">#define SC_LBFADDR IO_ADDRESS(INTEGRATOR_SC_BASE + 0x20)</span>
<span class="cp">#define SC_LBFCODE IO_ADDRESS(INTEGRATOR_SC_BASE + 0x24)</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">v3_pci_fault</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fsr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">instruction_pointer</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">pc</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	char buf[128];</span>

<span class="c">	sprintf(buf, &quot;V3 fault: addr 0x%08lx, FSR 0x%03x, PC 0x%08lx [%08lx] LBFADDR=%08x LBFCODE=%02x ISTAT=%02x\n&quot;,</span>
<span class="c">		addr, fsr, pc, instr, __raw_readl(SC_LBFADDR), __raw_readl(SC_LBFCODE) &amp; 255,</span>
<span class="c">		v3_readb(V3_LB_ISTAT));</span>
<span class="c">	printk(KERN_DEBUG &quot;%s&quot;, buf);</span>
<span class="cp">#endif</span>

	<span class="n">v3_writeb</span><span class="p">(</span><span class="n">V3_LB_ISTAT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">SC_PCI</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the instruction being executed was a read,</span>
<span class="cm">	 * make it look like it read all-ones.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0x0c100000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x04100000</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">instr</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0x00400000</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">val</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">reg</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_pc</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0x0e100090</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00100090</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">instr</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>

		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">reg</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_pc</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">v3_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">dummy</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">devid</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_LL</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">get_irq_regs</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">instruction_pointer</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">pc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">printascii</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;V3 int %d: pc=0x%08lx [%08lx] LBFADDR=%08x LBFCODE=%02x &quot;</span>
		<span class="s">&quot;ISTAT=%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">IRQ_AP_V3INT</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">instr</span><span class="p">,</span>
		<span class="n">__raw_readl</span><span class="p">(</span><span class="n">SC_LBFADDR</span><span class="p">),</span>
		<span class="n">__raw_readl</span><span class="p">(</span><span class="n">SC_LBFCODE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">,</span>
		<span class="n">v3_readb</span><span class="p">(</span><span class="n">V3_LB_ISTAT</span><span class="p">));</span>
	<span class="n">printascii</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">v3_writew</span><span class="p">(</span><span class="n">V3_PCI_STAT</span><span class="p">,</span> <span class="mh">0xf000</span><span class="p">);</span>
	<span class="n">v3_writeb</span><span class="p">(</span><span class="n">V3_LB_ISTAT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">SC_PCI</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_LL</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the instruction being executed was a read,</span>
<span class="cm">	 * make it look like it read all-ones.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">instr</span> <span class="o">&amp;</span> <span class="mh">0x0c100000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x04100000</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">instr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;   reg%d = %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">reg</span><span class="p">]);</span>
		<span class="n">printascii</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">pci_v3_setup</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_sys_data</span> <span class="o">*</span><span class="n">sys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sys</span><span class="o">-&gt;</span><span class="n">mem_offset</span> <span class="o">=</span> <span class="n">PHYS_PCI_MEM_BASE</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_v3_setup_resources</span><span class="p">(</span><span class="n">sys</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * V3_LB_BASE? - local bus address</span>
<span class="cm"> * V3_LB_MAP?  - pci bus address</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">pci_v3_preinit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pcibios_min_io</span> <span class="o">=</span> <span class="mh">0x6000</span><span class="p">;</span>
	<span class="n">pcibios_min_mem</span> <span class="o">=</span> <span class="mh">0x00100000</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hook in our fault handler for PCI errors</span>
<span class="cm">	 */</span>
	<span class="n">hook_fault_code</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">v3_pci_fault</span><span class="p">,</span> <span class="n">SIGBUS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;external abort on linefetch&quot;</span><span class="p">);</span>
	<span class="n">hook_fault_code</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">v3_pci_fault</span><span class="p">,</span> <span class="n">SIGBUS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;external abort on linefetch&quot;</span><span class="p">);</span>
	<span class="n">hook_fault_code</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">v3_pci_fault</span><span class="p">,</span> <span class="n">SIGBUS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;external abort on non-linefetch&quot;</span><span class="p">);</span>
	<span class="n">hook_fault_code</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">v3_pci_fault</span><span class="p">,</span> <span class="n">SIGBUS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;external abort on non-linefetch&quot;</span><span class="p">);</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v3_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unlock V3 registers, but only if they were previously locked.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v3_readw</span><span class="p">(</span><span class="n">V3_SYSTEM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">V3_SYSTEM_M_LOCK</span><span class="p">)</span>
		<span class="n">v3_writew</span><span class="p">(</span><span class="n">V3_SYSTEM</span><span class="p">,</span> <span class="mh">0xa05f</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup window 0 - PCI non-prefetchable memory</span>
<span class="cm">	 *  Local: 0x40000000 Bus: 0x00000000 Size: 256MB</span>
<span class="cm">	 */</span>
	<span class="n">v3_writel</span><span class="p">(</span><span class="n">V3_LB_BASE0</span><span class="p">,</span> <span class="n">v3_addr_to_lb_base</span><span class="p">(</span><span class="n">PHYS_PCI_MEM_BASE</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">V3_LB_BASE_ADR_SIZE_256MB</span> <span class="o">|</span> <span class="n">V3_LB_BASE_ENABLE</span><span class="p">);</span>
	<span class="n">v3_writew</span><span class="p">(</span><span class="n">V3_LB_MAP0</span><span class="p">,</span> <span class="n">v3_addr_to_lb_map</span><span class="p">(</span><span class="n">PCI_BUS_NONMEM_START</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">V3_LB_MAP_TYPE_MEM</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup window 1 - PCI prefetchable memory</span>
<span class="cm">	 *  Local: 0x50000000 Bus: 0x10000000 Size: 256MB</span>
<span class="cm">	 */</span>
	<span class="n">v3_writel</span><span class="p">(</span><span class="n">V3_LB_BASE1</span><span class="p">,</span> <span class="n">v3_addr_to_lb_base</span><span class="p">(</span><span class="n">PHYS_PCI_MEM_BASE</span> <span class="o">+</span> <span class="n">SZ_256M</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">V3_LB_BASE_ADR_SIZE_256MB</span> <span class="o">|</span> <span class="n">V3_LB_BASE_PREFETCH</span> <span class="o">|</span>
			<span class="n">V3_LB_BASE_ENABLE</span><span class="p">);</span>
	<span class="n">v3_writew</span><span class="p">(</span><span class="n">V3_LB_MAP1</span><span class="p">,</span> <span class="n">v3_addr_to_lb_map</span><span class="p">(</span><span class="n">PCI_BUS_PREMEM_START</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">V3_LB_MAP_TYPE_MEM_MULTIPLE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup window 2 - PCI IO</span>
<span class="cm">	 */</span>
	<span class="n">v3_writel</span><span class="p">(</span><span class="n">V3_LB_BASE2</span><span class="p">,</span> <span class="n">v3_addr_to_lb_base2</span><span class="p">(</span><span class="n">PHYS_PCI_IO_BASE</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">V3_LB_BASE_ENABLE</span><span class="p">);</span>
	<span class="n">v3_writew</span><span class="p">(</span><span class="n">V3_LB_MAP2</span><span class="p">,</span> <span class="n">v3_addr_to_lb_map2</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable PCI to host IO cycles</span>
<span class="cm">	 */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">v3_readw</span><span class="p">(</span><span class="n">V3_PCI_CFG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">V3_PCI_CFG_M_I2O_EN</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">|=</span> <span class="n">V3_PCI_CFG_M_IO_REG_DIS</span> <span class="o">|</span> <span class="n">V3_PCI_CFG_M_IO_DIS</span><span class="p">;</span>
	<span class="n">v3_writew</span><span class="p">(</span><span class="n">V3_PCI_CFG</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;FIFO_CFG: %04x  FIFO_PRIO: %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">v3_readw</span><span class="p">(</span><span class="n">V3_FIFO_CFG</span><span class="p">),</span> <span class="n">v3_readw</span><span class="p">(</span><span class="n">V3_FIFO_PRIORITY</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the V3 FIFO such that writes have higher priority than</span>
<span class="cm">	 * reads, and local bus write causes local bus read fifo flush.</span>
<span class="cm">	 * Same for PCI.</span>
<span class="cm">	 */</span>
	<span class="n">v3_writew</span><span class="p">(</span><span class="n">V3_FIFO_PRIORITY</span><span class="p">,</span> <span class="mh">0x0a0a</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Re-lock the system register.</span>
<span class="cm">	 */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">v3_readw</span><span class="p">(</span><span class="n">V3_SYSTEM</span><span class="p">)</span> <span class="o">|</span> <span class="n">V3_SYSTEM_M_LOCK</span><span class="p">;</span>
	<span class="n">v3_writew</span><span class="p">(</span><span class="n">V3_SYSTEM</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear any error conditions, and enable write errors.</span>
<span class="cm">	 */</span>
	<span class="n">v3_writeb</span><span class="p">(</span><span class="n">V3_LB_ISTAT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">v3_writew</span><span class="p">(</span><span class="n">V3_LB_CFG</span><span class="p">,</span> <span class="n">v3_readw</span><span class="p">(</span><span class="n">V3_LB_CFG</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">));</span>
	<span class="n">v3_writeb</span><span class="p">(</span><span class="n">V3_LB_IMASK</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">SC_PCI</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Grab the PCI error interrupt.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">IRQ_AP_V3INT</span><span class="p">,</span> <span class="n">v3_irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;V3&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PCI: unable to grab PCI error &quot;</span>
		       <span class="s">&quot;interrupt: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v3_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">pci_v3_postinit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pci_cmd</span><span class="p">;</span>

	<span class="n">pci_cmd</span> <span class="o">=</span> <span class="n">PCI_COMMAND_MEMORY</span> <span class="o">|</span>
		  <span class="n">PCI_COMMAND_MASTER</span> <span class="o">|</span> <span class="n">PCI_COMMAND_INVALIDATE</span><span class="p">;</span>

	<span class="n">v3_writew</span><span class="p">(</span><span class="n">V3_PCI_CMD</span><span class="p">,</span> <span class="n">pci_cmd</span><span class="p">);</span>

	<span class="n">v3_writeb</span><span class="p">(</span><span class="n">V3_LB_ISTAT</span><span class="p">,</span> <span class="o">~</span><span class="mh">0x40</span><span class="p">);</span>
	<span class="n">v3_writeb</span><span class="p">(</span><span class="n">V3_LB_IMASK</span><span class="p">,</span> <span class="mh">0x68</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	ret = request_irq(IRQ_AP_LBUSTIMEOUT, lb_timeout, 0, &quot;bus timeout&quot;, NULL);</span>
<span class="c">	if (ret)</span>
<span class="c">		printk(KERN_ERR &quot;PCI: unable to grab local bus timeout &quot;</span>
<span class="c">		       &quot;interrupt: %d\n&quot;, ret);</span>
<span class="cp">#endif</span>

	<span class="n">register_isa_ports</span><span class="p">(</span><span class="n">PHYS_PCI_MEM_BASE</span><span class="p">,</span> <span class="n">PHYS_PCI_IO_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
