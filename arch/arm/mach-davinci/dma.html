<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mach-davinci › dma.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>dma.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * EDMA3 support for DaVinci</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2009 Texas Instruments.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;mach/edma.h&gt;</span>

<span class="cm">/* Offsets matching &quot;struct edmacc_param&quot; */</span>
<span class="cp">#define PARM_OPT		0x00</span>
<span class="cp">#define PARM_SRC		0x04</span>
<span class="cp">#define PARM_A_B_CNT		0x08</span>
<span class="cp">#define PARM_DST		0x0c</span>
<span class="cp">#define PARM_SRC_DST_BIDX	0x10</span>
<span class="cp">#define PARM_LINK_BCNTRLD	0x14</span>
<span class="cp">#define PARM_SRC_DST_CIDX	0x18</span>
<span class="cp">#define PARM_CCNT		0x1c</span>

<span class="cp">#define PARM_SIZE		0x20</span>

<span class="cm">/* Offsets for EDMA CC global channel registers and their shadows */</span>
<span class="cp">#define SH_ER		0x00	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define SH_ECR		0x08	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define SH_ESR		0x10	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define SH_CER		0x18	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define SH_EER		0x20	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define SH_EECR		0x28	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define SH_EESR		0x30	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define SH_SER		0x38	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define SH_SECR		0x40	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define SH_IER		0x50	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define SH_IECR		0x58	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define SH_IESR		0x60	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define SH_IPR		0x68	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define SH_ICR		0x70	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define SH_IEVAL	0x78</span>
<span class="cp">#define SH_QER		0x80</span>
<span class="cp">#define SH_QEER		0x84</span>
<span class="cp">#define SH_QEECR	0x88</span>
<span class="cp">#define SH_QEESR	0x8c</span>
<span class="cp">#define SH_QSER		0x90</span>
<span class="cp">#define SH_QSECR	0x94</span>
<span class="cp">#define SH_SIZE		0x200</span>

<span class="cm">/* Offsets for EDMA CC global registers */</span>
<span class="cp">#define EDMA_REV	0x0000</span>
<span class="cp">#define EDMA_CCCFG	0x0004</span>
<span class="cp">#define EDMA_QCHMAP	0x0200	</span><span class="cm">/* 8 registers */</span><span class="cp"></span>
<span class="cp">#define EDMA_DMAQNUM	0x0240	</span><span class="cm">/* 8 registers (4 on OMAP-L1xx) */</span><span class="cp"></span>
<span class="cp">#define EDMA_QDMAQNUM	0x0260</span>
<span class="cp">#define EDMA_QUETCMAP	0x0280</span>
<span class="cp">#define EDMA_QUEPRI	0x0284</span>
<span class="cp">#define EDMA_EMR	0x0300	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define EDMA_EMCR	0x0308	</span><span class="cm">/* 64 bits */</span><span class="cp"></span>
<span class="cp">#define EDMA_QEMR	0x0310</span>
<span class="cp">#define EDMA_QEMCR	0x0314</span>
<span class="cp">#define EDMA_CCERR	0x0318</span>
<span class="cp">#define EDMA_CCERRCLR	0x031c</span>
<span class="cp">#define EDMA_EEVAL	0x0320</span>
<span class="cp">#define EDMA_DRAE	0x0340	</span><span class="cm">/* 4 x 64 bits*/</span><span class="cp"></span>
<span class="cp">#define EDMA_QRAE	0x0380	</span><span class="cm">/* 4 registers */</span><span class="cp"></span>
<span class="cp">#define EDMA_QUEEVTENTRY	0x0400	</span><span class="cm">/* 2 x 16 registers */</span><span class="cp"></span>
<span class="cp">#define EDMA_QSTAT	0x0600	</span><span class="cm">/* 2 registers */</span><span class="cp"></span>
<span class="cp">#define EDMA_QWMTHRA	0x0620</span>
<span class="cp">#define EDMA_QWMTHRB	0x0624</span>
<span class="cp">#define EDMA_CCSTAT	0x0640</span>

<span class="cp">#define EDMA_M		0x1000	</span><span class="cm">/* global channel registers */</span><span class="cp"></span>
<span class="cp">#define EDMA_ECR	0x1008</span>
<span class="cp">#define EDMA_ECRH	0x100C</span>
<span class="cp">#define EDMA_SHADOW0	0x2000	</span><span class="cm">/* 4 regions shadowing global channels */</span><span class="cp"></span>
<span class="cp">#define EDMA_PARM	0x4000	</span><span class="cm">/* 128 param entries */</span><span class="cp"></span>

<span class="cp">#define PARM_OFFSET(param_no)	(EDMA_PARM + ((param_no) &lt;&lt; 5))</span>

<span class="cp">#define EDMA_DCHMAP	0x0100  </span><span class="cm">/* 64 registers */</span><span class="cp"></span>
<span class="cp">#define CHMAP_EXIST	BIT(24)</span>

<span class="cp">#define EDMA_MAX_DMACH           64</span>
<span class="cp">#define EDMA_MAX_PARAMENTRY     512</span>

<span class="cm">/*****************************************************************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">EDMA_MAX_CC</span><span class="p">];</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">edma_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edma_write</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edma_modify</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">and</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">or</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">val</span> <span class="o">=</span> <span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="n">and</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">or</span><span class="p">;</span>
	<span class="n">edma_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edma_and</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">and</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">val</span> <span class="o">=</span> <span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="n">and</span><span class="p">;</span>
	<span class="n">edma_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edma_or</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">or</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">val</span> <span class="o">=</span> <span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">or</span><span class="p">;</span>
	<span class="n">edma_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">edma_read_array</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edma_write_array</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">edma_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edma_modify_array</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">and</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">or</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">edma_modify</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="n">and</span><span class="p">,</span> <span class="n">or</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edma_or_array</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">or</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">edma_or</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="n">or</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edma_or_array2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">or</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">edma_or</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">((</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="n">or</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edma_write_array2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">edma_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">((</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">edma_shadow0_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_SHADOW0</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">edma_shadow0_read_array</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_SHADOW0</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edma_shadow0_write</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">edma_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_SHADOW0</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edma_shadow0_write_array</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">edma_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_SHADOW0</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">edma_parm_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">param_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_PARM</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">param_no</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edma_parm_write</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">param_no</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">edma_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_PARM</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">param_no</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edma_parm_modify</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">param_no</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">and</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">or</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">edma_modify</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_PARM</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">param_no</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span> <span class="n">and</span><span class="p">,</span> <span class="n">or</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edma_parm_and</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">param_no</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">and</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">edma_and</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_PARM</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">param_no</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span> <span class="n">and</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">edma_parm_or</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">param_no</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">or</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">edma_or</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_PARM</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">param_no</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span> <span class="n">or</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_bits</span><span class="p">(</span><span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">len</span><span class="o">--</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_bits</span><span class="p">(</span><span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">len</span><span class="o">--</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************/</span>

<span class="cm">/* actual number of DMA channels and slots on this silicon */</span>
<span class="k">struct</span> <span class="n">edma</span> <span class="p">{</span>
	<span class="cm">/* how many dma resources of each type */</span>
	<span class="kt">unsigned</span>	<span class="n">num_channels</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">num_region</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">num_slots</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">num_tc</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">num_cc</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dma_event_q</span> 	<span class="n">default_queue</span><span class="p">;</span>

	<span class="cm">/* list of channels with no even trigger; terminated by &quot;-1&quot; */</span>
	<span class="k">const</span> <span class="n">s8</span>	<span class="o">*</span><span class="n">noevent</span><span class="p">;</span>

	<span class="cm">/* The edma_inuse bit for each PaRAM slot is clear unless the</span>
<span class="cm">	 * channel is in use ... by ARM or DSP, for QDMA, or whatever.</span>
<span class="cm">	 */</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">edma_inuse</span><span class="p">,</span> <span class="n">EDMA_MAX_PARAMENTRY</span><span class="p">);</span>

	<span class="cm">/* The edma_unused bit for each channel is clear unless</span>
<span class="cm">	 * it is not being used on this platform. It uses a bit</span>
<span class="cm">	 * of SOC-specific initialization code.</span>
<span class="cm">	 */</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">edma_unused</span><span class="p">,</span> <span class="n">EDMA_MAX_DMACH</span><span class="p">);</span>

	<span class="kt">unsigned</span>	<span class="n">irq_res_start</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">irq_res_end</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dma_interrupt_data</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ch_status</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">intr_data</span><span class="p">[</span><span class="n">EDMA_MAX_DMACH</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">edma</span> <span class="o">*</span><span class="n">edma_cc</span><span class="p">[</span><span class="n">EDMA_MAX_CC</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">arch_num_cc</span><span class="p">;</span>

<span class="cm">/* dummy param set used to (re)initialize parameter RAM slots */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">edmacc_param</span> <span class="n">dummy_paramset</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">link_bcntrld</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ccnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*****************************************************************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">map_dmach_queue</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">ch_no</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">dma_event_q</span> <span class="n">queue_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">ch_no</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* default to low priority queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue_no</span> <span class="o">==</span> <span class="n">EVENTQ_DEFAULT</span><span class="p">)</span>
		<span class="n">queue_no</span> <span class="o">=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">default_queue</span><span class="p">;</span>

	<span class="n">queue_no</span> <span class="o">&amp;=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">edma_modify_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_DMAQNUM</span><span class="p">,</span> <span class="p">(</span><span class="n">ch_no</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">),</span>
			<span class="o">~</span><span class="p">(</span><span class="mh">0x7</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">),</span> <span class="n">queue_no</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">map_queue_tc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue_no</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tc_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">queue_no</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">edma_modify</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_QUETCMAP</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x7</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">),</span> <span class="p">((</span><span class="n">tc_no</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">assign_priority_to_queue</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue_no</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">queue_no</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">edma_modify</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_QUEPRI</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x7</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">),</span>
			<span class="p">((</span><span class="n">priority</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * map_dmach_param - Maps channel number to param entry number</span>
<span class="cm"> *</span>
<span class="cm"> * This maps the dma channel number to param entry numberter. In</span>
<span class="cm"> * other words using the DMA channel mapping registers a param entry</span>
<span class="cm"> * can be mapped to any channel</span>
<span class="cm"> *</span>
<span class="cm"> * Callers are responsible for ensuring the channel mapping logic is</span>
<span class="cm"> * included in that particular EDMA variant (Eg : dm646x)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">map_dmach_param</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EDMA_MAX_DMACH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">edma_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_DCHMAP</span> <span class="p">,</span> <span class="n">i</span> <span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">setup_dma_interrupt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">lch</span><span class="p">,</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="n">channel</span><span class="p">,</span> <span class="n">u16</span> <span class="n">ch_status</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">lch</span><span class="p">);</span>
	<span class="n">lch</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">lch</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">callback</span><span class="p">)</span>
		<span class="n">edma_shadow0_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_IECR</span><span class="p">,</span> <span class="n">lch</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">,</span>
				<span class="n">BIT</span><span class="p">(</span><span class="n">lch</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">));</span>

	<span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">intr_data</span><span class="p">[</span><span class="n">lch</span><span class="p">].</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span><span class="p">;</span>
	<span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">intr_data</span><span class="p">[</span><span class="n">lch</span><span class="p">].</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">edma_shadow0_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_ICR</span><span class="p">,</span> <span class="n">lch</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">,</span>
				<span class="n">BIT</span><span class="p">(</span><span class="n">lch</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">));</span>
		<span class="n">edma_shadow0_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_IESR</span><span class="p">,</span> <span class="n">lch</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">,</span>
				<span class="n">BIT</span><span class="p">(</span><span class="n">lch</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">irq2ctlr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">irq_res_start</span> <span class="o">&amp;&amp;</span> <span class="n">irq</span> <span class="o">&lt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">irq_res_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">irq_res_start</span> <span class="o">&amp;&amp;</span>
		<span class="n">irq</span> <span class="o">&lt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">irq_res_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * DMA interrupt handler</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">dma_irq_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ctlr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sh_ier</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sh_ipr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bank</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">irq2ctlr</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctlr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;dma_irq_handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">sh_ipr</span> <span class="o">=</span> <span class="n">edma_shadow0_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_IPR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sh_ipr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sh_ipr</span> <span class="o">=</span> <span class="n">edma_shadow0_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_IPR</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sh_ipr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
		<span class="n">sh_ier</span> <span class="o">=</span> <span class="n">edma_shadow0_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_IER</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bank</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sh_ier</span> <span class="o">=</span> <span class="n">edma_shadow0_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_IER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bank</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">slot</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">channel</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;IPR%d %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bank</span><span class="p">,</span> <span class="n">sh_ipr</span><span class="p">);</span>

		<span class="n">slot</span> <span class="o">=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">sh_ipr</span><span class="p">);</span>
		<span class="n">sh_ipr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BIT</span><span class="p">(</span><span class="n">slot</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sh_ier</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="n">slot</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">channel</span> <span class="o">=</span> <span class="p">(</span><span class="n">bank</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="n">slot</span><span class="p">;</span>
			<span class="cm">/* Clear the corresponding IPR bits */</span>
			<span class="n">edma_shadow0_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_ICR</span><span class="p">,</span> <span class="n">bank</span><span class="p">,</span>
					<span class="n">BIT</span><span class="p">(</span><span class="n">slot</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">intr_data</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">callback</span><span class="p">)</span>
				<span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">intr_data</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">callback</span><span class="p">(</span>
					<span class="n">channel</span><span class="p">,</span> <span class="n">DMA_COMPLETE</span><span class="p">,</span>
					<span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">intr_data</span><span class="p">[</span><span class="n">channel</span><span class="p">].</span><span class="n">data</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">sh_ipr</span><span class="p">);</span>

	<span class="n">edma_shadow0_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_IEVAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * DMA error interrupt handler</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">dma_ccerr_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctlr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">irq2ctlr</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctlr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;dma_ccerr_handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">edma_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_EMR</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">edma_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_EMR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_QEMR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_CCERR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edma_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_EMR</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">edma_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_EMR</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;EMR%d %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
					<span class="n">edma_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_EMR</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">edma_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_EMR</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">&amp;</span>
							<span class="n">BIT</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* Clear the corresponding EMR bits */</span>
					<span class="n">edma_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_EMCR</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
							<span class="n">BIT</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
					<span class="cm">/* Clear any SER */</span>
					<span class="n">edma_shadow0_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_SECR</span><span class="p">,</span>
								<span class="n">j</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">intr_data</span><span class="p">[</span><span class="n">k</span><span class="p">].</span>
								<span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">intr_data</span><span class="p">[</span><span class="n">k</span><span class="p">].</span>
						<span class="n">callback</span><span class="p">(</span><span class="n">k</span><span class="p">,</span>
						<span class="n">DMA_CC_ERROR</span><span class="p">,</span>
						<span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">intr_data</span>
						<span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">data</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_QEMR</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;QEMR %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_QEMR</span><span class="p">));</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_QEMR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* Clear the corresponding IPR bits */</span>
					<span class="n">edma_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_QEMCR</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
					<span class="n">edma_shadow0_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_QSECR</span><span class="p">,</span>
								<span class="n">BIT</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

					<span class="cm">/* NOTE:  not reported!! */</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_CCERR</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;CCERR %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_CCERR</span><span class="p">));</span>
			<span class="cm">/* FIXME:  CCERR.BIT(16) ignored!  much better</span>
<span class="cm">			 * to just write CCERRCLR with CCERR value...</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_CCERR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* Clear the corresponding IPR bits */</span>
					<span class="n">edma_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_CCERRCLR</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

					<span class="cm">/* NOTE:  not reported!! */</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">edma_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_EMR</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">edma_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_EMR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_QEMR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">edma_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_CCERR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">edma_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_EEVAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Transfer controller error interrupt handlers</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cp">#define tc_errs_handled	false	</span><span class="cm">/* disabled as long as they&#39;re NOPs */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">dma_tc0err_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;dma_tc0err_handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">dma_tc1err_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;dma_tc1err_handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">reserve_contiguous_slots</span><span class="p">(</span><span class="kt">int</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_slots</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start_slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">num_slots</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stop_slot</span> <span class="o">=</span> <span class="n">start_slot</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">tmp_inuse</span><span class="p">,</span> <span class="n">EDMA_MAX_PARAMENTRY</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start_slot</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">j</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_inuse</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Record our current beginning slot */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">num_slots</span><span class="p">)</span>
				<span class="n">stop_slot</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

			<span class="n">count</span><span class="o">--</span><span class="p">;</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">tmp_inuse</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">tmp_inuse</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">EDMA_CONT_PARAMS_FIXED_EXACT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">stop_slot</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">count</span> <span class="o">=</span> <span class="n">num_slots</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to clear any bits that we set</span>
<span class="cm">	 * if we run out parameter RAM slots, i.e we do find a set</span>
<span class="cm">	 * of contiguous parameter RAM slots but do not find the exact number</span>
<span class="cm">	 * requested as we may reach the total number of parameter RAM slots</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">)</span>
		<span class="n">stop_slot</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">j</span> <span class="o">=</span> <span class="n">start_slot</span><span class="p">;</span>
	<span class="n">for_each_set_bit_from</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">tmp_inuse</span><span class="p">,</span> <span class="n">stop_slot</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_inuse</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">num_slots</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
		<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span> <span class="o">+</span> <span class="n">PARM_OFFSET</span><span class="p">(</span><span class="n">j</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">dummy_paramset</span><span class="p">,</span> <span class="n">PARM_SIZE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">EDMA_CTLR_CHAN</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">num_slots</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">prepare_unused_channel_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">num_resources</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_DMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">),</span>
					<span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_unused</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-----------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">unused_chan_list_done</span><span class="p">;</span>

<span class="cm">/* Resource alloc/free:  dma channels, parameter RAM slots */</span>

<span class="cm">/**</span>
<span class="cm"> * edma_alloc_channel - allocate DMA channel and paired parameter RAM</span>
<span class="cm"> * @channel: specific channel to allocate; negative for &quot;any unmapped channel&quot;</span>
<span class="cm"> * @callback: optional; to be issued on DMA completion or errors</span>
<span class="cm"> * @data: passed to callback</span>
<span class="cm"> * @eventq_no: an EVENTQ_* constant, used to choose which Transfer</span>
<span class="cm"> *	Controller (TC) executes requests using this channel.  Use</span>
<span class="cm"> *	EVENTQ_DEFAULT unless you really need a high priority queue.</span>
<span class="cm"> *</span>
<span class="cm"> * This allocates a DMA channel and its associated parameter RAM slot.</span>
<span class="cm"> * The parameter RAM is initialized to hold a dummy transfer.</span>
<span class="cm"> *</span>
<span class="cm"> * Normal use is to pass a specific channel number as @channel, to make</span>
<span class="cm"> * use of hardware events mapped to that channel.  When the channel will</span>
<span class="cm"> * be used only for software triggering or event chaining, channels not</span>
<span class="cm"> * mapped to hardware events (or mapped to unused events) are preferable.</span>
<span class="cm"> *</span>
<span class="cm"> * DMA transfers start from a channel using edma_start(), or by</span>
<span class="cm"> * chaining.  When the transfer described in that channel&#39;s parameter RAM</span>
<span class="cm"> * slot completes, that slot&#39;s data may be reloaded through a link.</span>
<span class="cm"> *</span>
<span class="cm"> * DMA errors are only reported to the @callback associated with the</span>
<span class="cm"> * channel driving that transfer, but transfer completion callbacks can</span>
<span class="cm"> * be sent to another channel under control of the TCC field in</span>
<span class="cm"> * the option word of the transfer&#39;s parameter RAM set.  Drivers must not</span>
<span class="cm"> * use DMA transfer completion callbacks for channels they did not allocate.</span>
<span class="cm"> * (The same applies to TCC codes used in transfer chaining.)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of the channel, else negative errno.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">edma_alloc_channel</span><span class="p">(</span><span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="n">channel</span><span class="p">,</span> <span class="n">u16</span> <span class="n">ch_status</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">dma_event_q</span> <span class="n">eventq_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctlr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unused_chan_list_done</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Scan all the platform devices to find out the EDMA channels</span>
<span class="cm">		 * used and clear them in the unused list, making the rest</span>
<span class="cm">		 * available for ARM usage.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bus_for_each_dev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_bus_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="n">prepare_unused_channel_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">unused_chan_list_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arch_num_cc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
				<span class="n">channel</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">edma_cc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_unused</span><span class="p">,</span>
						<span class="n">edma_cc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span><span class="p">,</span>
						<span class="n">channel</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span>
						<span class="n">edma_cc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_inuse</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">ctlr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">channel</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&gt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_inuse</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ensure access through shadow region 0 */</span>
	<span class="n">edma_or_array2</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_DRAE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">channel</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="n">channel</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">));</span>

	<span class="cm">/* ensure no events are pending */</span>
	<span class="n">edma_stop</span><span class="p">(</span><span class="n">EDMA_CTLR_CHAN</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">channel</span><span class="p">));</span>
	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span> <span class="o">+</span> <span class="n">PARM_OFFSET</span><span class="p">(</span><span class="n">channel</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">dummy_paramset</span><span class="p">,</span> <span class="n">PARM_SIZE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">callback</span><span class="p">)</span>
		<span class="n">setup_dma_interrupt</span><span class="p">(</span><span class="n">EDMA_CTLR_CHAN</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">channel</span><span class="p">),</span>
					<span class="n">callback</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="n">map_dmach_queue</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">eventq_no</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">EDMA_CTLR_CHAN</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_alloc_channel</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * edma_free_channel - deallocate DMA channel</span>
<span class="cm"> * @channel: dma channel returned from edma_alloc_channel()</span>
<span class="cm"> *</span>
<span class="cm"> * This deallocates the DMA channel and associated parameter RAM slot</span>
<span class="cm"> * allocated by edma_alloc_channel().</span>
<span class="cm"> *</span>
<span class="cm"> * Callers are responsible for ensuring the channel is inactive, and</span>
<span class="cm"> * will not be reactivated by linking, chaining, or software calls to</span>
<span class="cm"> * edma_start().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_free_channel</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="n">channel</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&gt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">setup_dma_interrupt</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="cm">/* REVISIT should probably take out of shadow region 0 */</span>

	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span> <span class="o">+</span> <span class="n">PARM_OFFSET</span><span class="p">(</span><span class="n">channel</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">dummy_paramset</span><span class="p">,</span> <span class="n">PARM_SIZE</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_inuse</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_free_channel</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edma_alloc_slot - allocate DMA parameter RAM</span>
<span class="cm"> * @slot: specific slot to allocate; negative for &quot;any unused slot&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * This allocates a parameter RAM slot, initializing it to hold a</span>
<span class="cm"> * dummy transfer.  Slots allocated using this routine have not been</span>
<span class="cm"> * mapped to a hardware DMA channel, and will normally be used by</span>
<span class="cm"> * linking to them from a slot associated with a DMA channel.</span>
<span class="cm"> *</span>
<span class="cm"> * Normal use is to pass EDMA_SLOT_ANY as the @slot, but specific</span>
<span class="cm"> * slots may be allocated on behalf of DSP firmware.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of the slot, else negative errno.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">edma_alloc_slot</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="n">slot</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_inuse</span><span class="p">,</span>
					<span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_inuse</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span> <span class="o">||</span>
			<span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_inuse</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span> <span class="o">+</span> <span class="n">PARM_OFFSET</span><span class="p">(</span><span class="n">slot</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">dummy_paramset</span><span class="p">,</span> <span class="n">PARM_SIZE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">EDMA_CTLR_CHAN</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_alloc_slot</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edma_free_slot - deallocate DMA parameter RAM</span>
<span class="cm"> * @slot: parameter RAM slot returned from edma_alloc_slot()</span>
<span class="cm"> *</span>
<span class="cm"> * This deallocates the parameter RAM slot allocated by edma_alloc_slot().</span>
<span class="cm"> * Callers are responsible for ensuring the slot is inactive, and will</span>
<span class="cm"> * not be activated.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_free_slot</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span> <span class="o">||</span>
		<span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span> <span class="o">+</span> <span class="n">PARM_OFFSET</span><span class="p">(</span><span class="n">slot</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">dummy_paramset</span><span class="p">,</span> <span class="n">PARM_SIZE</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_inuse</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_free_slot</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * edma_alloc_cont_slots- alloc contiguous parameter RAM slots</span>
<span class="cm"> * The API will return the starting point of a set of</span>
<span class="cm"> * contiguous parameter RAM slots that have been requested</span>
<span class="cm"> *</span>
<span class="cm"> * @id: can only be EDMA_CONT_PARAMS_ANY or EDMA_CONT_PARAMS_FIXED_EXACT</span>
<span class="cm"> * or EDMA_CONT_PARAMS_FIXED_NOT_EXACT</span>
<span class="cm"> * @count: number of contiguous Paramter RAM slots</span>
<span class="cm"> * @slot  - the start value of Parameter RAM slot that should be passed if id</span>
<span class="cm"> * is EDMA_CONT_PARAMS_FIXED_EXACT or EDMA_CONT_PARAMS_FIXED_NOT_EXACT</span>
<span class="cm"> *</span>
<span class="cm"> * If id is EDMA_CONT_PARAMS_ANY then the API starts looking for a set of</span>
<span class="cm"> * contiguous Parameter RAM slots from parameter RAM 64 in the case of</span>
<span class="cm"> * DaVinci SOCs and 32 in the case of DA8xx SOCs.</span>
<span class="cm"> *</span>
<span class="cm"> * If id is EDMA_CONT_PARAMS_FIXED_EXACT then the API starts looking for a</span>
<span class="cm"> * set of contiguous parameter RAM slots from the &quot;slot&quot; that is passed as an</span>
<span class="cm"> * argument to the API.</span>
<span class="cm"> *</span>
<span class="cm"> * If id is EDMA_CONT_PARAMS_FIXED_NOT_EXACT then the API initially tries</span>
<span class="cm"> * starts looking for a set of contiguous parameter RAMs from the &quot;slot&quot;</span>
<span class="cm"> * that is passed as an argument to the API. On failure the API will try to</span>
<span class="cm"> * find a set of contiguous Parameter RAM slots from the remaining Parameter</span>
<span class="cm"> * RAM slots</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">edma_alloc_cont_slots</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The start slot requested should be greater than</span>
<span class="cm">	 * the number of channels and lesser than the total number</span>
<span class="cm">	 * of slots</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">id</span> <span class="o">!=</span> <span class="n">EDMA_CONT_PARAMS_ANY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span> <span class="o">||</span>
		<span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The number of parameter RAM slots requested cannot be less than 1</span>
<span class="cm">	 * and cannot be more than the number of slots minus the number of</span>
<span class="cm">	 * channels</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">count</span> <span class="o">&gt;</span>
		<span class="p">(</span><span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span> <span class="o">-</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EDMA_CONT_PARAMS_ANY</span>:
		<span class="k">return</span> <span class="n">reserve_contiguous_slots</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
						 <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">EDMA_CONT_PARAMS_FIXED_EXACT</span>:
	<span class="k">case</span> <span class="n">EDMA_CONT_PARAMS_FIXED_NOT_EXACT</span>:
		<span class="k">return</span> <span class="n">reserve_contiguous_slots</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_alloc_cont_slots</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edma_free_cont_slots - deallocate DMA parameter RAM slots</span>
<span class="cm"> * @slot: first parameter RAM of a set of parameter RAM slots to be freed</span>
<span class="cm"> * @count: the number of contiguous parameter RAM slots to be freed</span>
<span class="cm"> *</span>
<span class="cm"> * This deallocates the parameter RAM slots allocated by</span>
<span class="cm"> * edma_alloc_cont_slots.</span>
<span class="cm"> * Callers/applications need to keep track of sets of contiguous</span>
<span class="cm"> * parameter RAM slots that have been allocated using the edma_alloc_cont_slots</span>
<span class="cm"> * API.</span>
<span class="cm"> * Callers are responsible for ensuring the slots are inactive, and will</span>
<span class="cm"> * not be activated.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">edma_free_cont_slots</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">,</span> <span class="n">slot_to_free</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span> <span class="o">||</span>
		<span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span> <span class="o">||</span>
		<span class="n">count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">slot</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">slot_to_free</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

		<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span> <span class="o">+</span> <span class="n">PARM_OFFSET</span><span class="p">(</span><span class="n">slot_to_free</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">dummy_paramset</span><span class="p">,</span> <span class="n">PARM_SIZE</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">slot_to_free</span><span class="p">,</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_inuse</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_free_cont_slots</span><span class="p">);</span>

<span class="cm">/*-----------------------------------------------------------------------*/</span>

<span class="cm">/* Parameter RAM operations (i) -- read/write partial slots */</span>

<span class="cm">/**</span>
<span class="cm"> * edma_set_src - set initial DMA source address in parameter RAM slot</span>
<span class="cm"> * @slot: parameter RAM slot being configured</span>
<span class="cm"> * @src_port: physical address of source (memory, controller FIFO, etc)</span>
<span class="cm"> * @addressMode: INCR, except in very rare cases</span>
<span class="cm"> * @fifoWidth: ignored unless @addressMode is FIFO, else specifies the</span>
<span class="cm"> *	width to use when addressing the fifo (e.g. W8BIT, W32BIT)</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the source address is modified during the DMA transfer</span>
<span class="cm"> * according to edma_set_src_index().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_set_src</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">slot</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">src_port</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">address_mode</span> <span class="n">mode</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fifo_width</span> <span class="n">width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">edma_parm_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_OPT</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* set SAM and program FWID */</span>
			<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">EDMA_FWID</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">SAM</span> <span class="o">|</span> <span class="p">((</span><span class="n">width</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* clear SAM */</span>
			<span class="n">i</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SAM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">edma_parm_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_OPT</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="cm">/* set the source port address</span>
<span class="cm">		   in source register of param structure */</span>
		<span class="n">edma_parm_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_SRC</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">src_port</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_set_src</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edma_set_dest - set initial DMA destination address in parameter RAM slot</span>
<span class="cm"> * @slot: parameter RAM slot being configured</span>
<span class="cm"> * @dest_port: physical address of destination (memory, controller FIFO, etc)</span>
<span class="cm"> * @addressMode: INCR, except in very rare cases</span>
<span class="cm"> * @fifoWidth: ignored unless @addressMode is FIFO, else specifies the</span>
<span class="cm"> *	width to use when addressing the fifo (e.g. W8BIT, W32BIT)</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the destination address is modified during the DMA transfer</span>
<span class="cm"> * according to edma_set_dest_index().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_set_dest</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">slot</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dest_port</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">address_mode</span> <span class="n">mode</span><span class="p">,</span> <span class="k">enum</span> <span class="n">fifo_width</span> <span class="n">width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">edma_parm_read</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_OPT</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* set DAM and program FWID */</span>
			<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">EDMA_FWID</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">DAM</span> <span class="o">|</span> <span class="p">((</span><span class="n">width</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* clear DAM */</span>
			<span class="n">i</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DAM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">edma_parm_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_OPT</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="cm">/* set the destination port address</span>
<span class="cm">		   in dest register of param structure */</span>
		<span class="n">edma_parm_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_DST</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">dest_port</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_set_dest</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edma_get_position - returns the current transfer points</span>
<span class="cm"> * @slot: parameter RAM slot being examined</span>
<span class="cm"> * @src: pointer to source port position</span>
<span class="cm"> * @dst: pointer to destination port position</span>
<span class="cm"> *</span>
<span class="cm"> * Returns current source and destination addresses for a particular</span>
<span class="cm"> * parameter RAM slot.  Its channel should not be active when this is called.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_get_position</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">slot</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edmacc_param</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>

	<span class="n">edma_read_slot</span><span class="p">(</span><span class="n">EDMA_CTLR_CHAN</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">slot</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">src</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">src</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">dst</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_get_position</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edma_set_src_index - configure DMA source address indexing</span>
<span class="cm"> * @slot: parameter RAM slot being configured</span>
<span class="cm"> * @src_bidx: byte offset between source arrays in a frame</span>
<span class="cm"> * @src_cidx: byte offset between source frames in a block</span>
<span class="cm"> *</span>
<span class="cm"> * Offsets are specified to support either contiguous or discontiguous</span>
<span class="cm"> * memory transfers, or repeated access to a hardware register, as needed.</span>
<span class="cm"> * When accessing hardware registers, both offsets are normally zero.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_set_src_index</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">slot</span><span class="p">,</span> <span class="n">s16</span> <span class="n">src_bidx</span><span class="p">,</span> <span class="n">s16</span> <span class="n">src_cidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">edma_parm_modify</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_SRC_DST_BIDX</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span>
				<span class="mh">0xffff0000</span><span class="p">,</span> <span class="n">src_bidx</span><span class="p">);</span>
		<span class="n">edma_parm_modify</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_SRC_DST_CIDX</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span>
				<span class="mh">0xffff0000</span><span class="p">,</span> <span class="n">src_cidx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_set_src_index</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edma_set_dest_index - configure DMA destination address indexing</span>
<span class="cm"> * @slot: parameter RAM slot being configured</span>
<span class="cm"> * @dest_bidx: byte offset between destination arrays in a frame</span>
<span class="cm"> * @dest_cidx: byte offset between destination frames in a block</span>
<span class="cm"> *</span>
<span class="cm"> * Offsets are specified to support either contiguous or discontiguous</span>
<span class="cm"> * memory transfers, or repeated access to a hardware register, as needed.</span>
<span class="cm"> * When accessing hardware registers, both offsets are normally zero.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_set_dest_index</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">slot</span><span class="p">,</span> <span class="n">s16</span> <span class="n">dest_bidx</span><span class="p">,</span> <span class="n">s16</span> <span class="n">dest_cidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">edma_parm_modify</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_SRC_DST_BIDX</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span>
				<span class="mh">0x0000ffff</span><span class="p">,</span> <span class="n">dest_bidx</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">edma_parm_modify</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_SRC_DST_CIDX</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span>
				<span class="mh">0x0000ffff</span><span class="p">,</span> <span class="n">dest_cidx</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_set_dest_index</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edma_set_transfer_params - configure DMA transfer parameters</span>
<span class="cm"> * @slot: parameter RAM slot being configured</span>
<span class="cm"> * @acnt: how many bytes per array (at least one)</span>
<span class="cm"> * @bcnt: how many arrays per frame (at least one)</span>
<span class="cm"> * @ccnt: how many frames per block (at least one)</span>
<span class="cm"> * @bcnt_rld: used only for A-Synchronized transfers; this specifies</span>
<span class="cm"> *	the value to reload into bcnt when it decrements to zero</span>
<span class="cm"> * @sync_mode: ASYNC or ABSYNC</span>
<span class="cm"> *</span>
<span class="cm"> * See the EDMA3 documentation to understand how to configure and link</span>
<span class="cm"> * transfers using the fields in PaRAM slots.  If you are not doing it</span>
<span class="cm"> * all at once with edma_write_slot(), you will use this routine</span>
<span class="cm"> * plus two calls each for source and destination, setting the initial</span>
<span class="cm"> * address and saying how to index that address.</span>
<span class="cm"> *</span>
<span class="cm"> * An example of an A-Synchronized transfer is a serial link using a</span>
<span class="cm"> * single word shift register.  In that case, @acnt would be equal to</span>
<span class="cm"> * that word size; the serial controller issues a DMA synchronization</span>
<span class="cm"> * event to transfer each word, and memory access by the DMA transfer</span>
<span class="cm"> * controller will be word-at-a-time.</span>
<span class="cm"> *</span>
<span class="cm"> * An example of an AB-Synchronized transfer is a device using a FIFO.</span>
<span class="cm"> * In that case, @acnt equals the FIFO width and @bcnt equals its depth.</span>
<span class="cm"> * The controller with the FIFO issues DMA synchronization events when</span>
<span class="cm"> * the FIFO threshold is reached, and the DMA transfer controller will</span>
<span class="cm"> * transfer one frame to (or from) the FIFO.  It will probably use</span>
<span class="cm"> * efficient burst modes to access memory.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_set_transfer_params</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">slot</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">acnt</span><span class="p">,</span> <span class="n">u16</span> <span class="n">bcnt</span><span class="p">,</span> <span class="n">u16</span> <span class="n">ccnt</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">bcnt_rld</span><span class="p">,</span> <span class="k">enum</span> <span class="n">sync_dimension</span> <span class="n">sync_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">edma_parm_modify</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_LINK_BCNTRLD</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span>
				<span class="mh">0x0000ffff</span><span class="p">,</span> <span class="n">bcnt_rld</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">ASYNC</span><span class="p">)</span>
			<span class="n">edma_parm_and</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_OPT</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="o">~</span><span class="n">SYNCDIM</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">edma_parm_or</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_OPT</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">SYNCDIM</span><span class="p">);</span>
		<span class="cm">/* Set the acount, bcount, ccount registers */</span>
		<span class="n">edma_parm_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_A_B_CNT</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="p">(</span><span class="n">bcnt</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">acnt</span><span class="p">);</span>
		<span class="n">edma_parm_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_CCNT</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">ccnt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_set_transfer_params</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edma_link - link one parameter RAM slot to another</span>
<span class="cm"> * @from: parameter RAM slot originating the link</span>
<span class="cm"> * @to: parameter RAM slot which is the link target</span>
<span class="cm"> *</span>
<span class="cm"> * The originating slot should not be part of any active DMA transfer.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_link</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr_from</span><span class="p">,</span> <span class="n">ctlr_to</span><span class="p">;</span>

	<span class="n">ctlr_from</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
	<span class="n">from</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
	<span class="n">ctlr_to</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
	<span class="n">to</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">&gt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr_from</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to</span> <span class="o">&gt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr_to</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">edma_parm_modify</span><span class="p">(</span><span class="n">ctlr_from</span><span class="p">,</span> <span class="n">PARM_LINK_BCNTRLD</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="mh">0xffff0000</span><span class="p">,</span>
				<span class="n">PARM_OFFSET</span><span class="p">(</span><span class="n">to</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_link</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edma_unlink - cut link from one parameter RAM slot</span>
<span class="cm"> * @from: parameter RAM slot originating the link</span>
<span class="cm"> *</span>
<span class="cm"> * The originating slot should not be part of any active DMA transfer.</span>
<span class="cm"> * Its link is set to 0xffff.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_unlink</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
	<span class="n">from</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">&gt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">edma_parm_or</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">PARM_LINK_BCNTRLD</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_unlink</span><span class="p">);</span>

<span class="cm">/*-----------------------------------------------------------------------*/</span>

<span class="cm">/* Parameter RAM operations (ii) -- read/write whole parameter sets */</span>

<span class="cm">/**</span>
<span class="cm"> * edma_write_slot - write parameter RAM data for slot</span>
<span class="cm"> * @slot: number of parameter RAM slot being modified</span>
<span class="cm"> * @param: data to be written into parameter RAM slot</span>
<span class="cm"> *</span>
<span class="cm"> * Use this to assign all parameters of a transfer at once.  This</span>
<span class="cm"> * allows more efficient setup of transfers than issuing multiple</span>
<span class="cm"> * calls to set up those parameters in small pieces, and provides</span>
<span class="cm"> * complete control over all transfer options.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_write_slot</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">slot</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">edmacc_param</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span> <span class="o">+</span> <span class="n">PARM_OFFSET</span><span class="p">(</span><span class="n">slot</span><span class="p">),</span> <span class="n">param</span><span class="p">,</span>
			<span class="n">PARM_SIZE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_write_slot</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edma_read_slot - read parameter RAM data from slot</span>
<span class="cm"> * @slot: number of parameter RAM slot being copied</span>
<span class="cm"> * @param: where to store copy of parameter RAM data</span>
<span class="cm"> *</span>
<span class="cm"> * Use this to read data from a parameter RAM slot, perhaps to</span>
<span class="cm"> * save them as a template for later reuse.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_read_slot</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">slot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">edmacc_param</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span> <span class="o">+</span> <span class="n">PARM_OFFSET</span><span class="p">(</span><span class="n">slot</span><span class="p">),</span>
			<span class="n">PARM_SIZE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_read_slot</span><span class="p">);</span>

<span class="cm">/*-----------------------------------------------------------------------*/</span>

<span class="cm">/* Various EDMA channel control operations */</span>

<span class="cm">/**</span>
<span class="cm"> * edma_pause - pause dma on a channel</span>
<span class="cm"> * @channel: on which edma_start() has been called</span>
<span class="cm"> *</span>
<span class="cm"> * This temporarily disables EDMA hardware events on the specified channel,</span>
<span class="cm"> * preventing them from triggering new transfers on its behalf</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_pause</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="n">channel</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">channel</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>

		<span class="n">edma_shadow0_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_EECR</span><span class="p">,</span> <span class="n">channel</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_pause</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edma_resume - resumes dma on a paused channel</span>
<span class="cm"> * @channel: on which edma_pause() has been called</span>
<span class="cm"> *</span>
<span class="cm"> * This re-enables EDMA hardware events on the specified channel.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_resume</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="n">channel</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">channel</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>

		<span class="n">edma_shadow0_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_EESR</span><span class="p">,</span> <span class="n">channel</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_resume</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edma_start - start dma on a channel</span>
<span class="cm"> * @channel: channel being activated</span>
<span class="cm"> *</span>
<span class="cm"> * Channels with event associations will be triggered by their hardware</span>
<span class="cm"> * events, and channels without such associations will be triggered by</span>
<span class="cm"> * software.  (At this writing there is no interface for using software</span>
<span class="cm"> * triggers except with channels that don&#39;t support hardware triggers.)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, else negative errno.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">edma_start</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="n">channel</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">channel</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">channel</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>

		<span class="cm">/* EDMA channels without event association */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_unused</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EDMA: ESR%d %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
				<span class="n">edma_shadow0_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_ESR</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>
			<span class="n">edma_shadow0_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_ESR</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* EDMA channel with event association */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EDMA: ER%d %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
			<span class="n">edma_shadow0_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_ER</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>
		<span class="cm">/* Clear any pending event or error */</span>
		<span class="n">edma_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_ECR</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="n">edma_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_EMCR</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="cm">/* Clear any SER */</span>
		<span class="n">edma_shadow0_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_SECR</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="n">edma_shadow0_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_EESR</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EDMA: EER%d %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
			<span class="n">edma_shadow0_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_EER</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_start</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * edma_stop - stops dma on the channel passed</span>
<span class="cm"> * @channel: channel being deactivated</span>
<span class="cm"> *</span>
<span class="cm"> * When @lch is a channel, any active transfer is paused and</span>
<span class="cm"> * all pending hardware events are cleared.  The current transfer</span>
<span class="cm"> * may not be resumed, and the channel&#39;s Parameter RAM should be</span>
<span class="cm"> * reinitialized before being reused.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_stop</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="n">channel</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">channel</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">channel</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>

		<span class="n">edma_shadow0_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_EECR</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="n">edma_shadow0_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_ECR</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="n">edma_shadow0_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_SECR</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="n">edma_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_EMCR</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EDMA: EER%d %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
				<span class="n">edma_shadow0_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_EER</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>

		<span class="cm">/* REVISIT:  consider guarding against inappropriate event</span>
<span class="cm">		 * chaining by overwriting with dummy_paramset.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_stop</span><span class="p">);</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * It cleans ParamEntry qand bring back EDMA to initial state if media has</span>
<span class="cm"> * been removed before EDMA has finished.It is usedful for removable media.</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *      ch_no     - channel no</span>
<span class="cm"> *</span>
<span class="cm"> * Return: zero on success, or corresponding error no on failure</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME this should not be needed ... edma_stop() should suffice.</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="kt">void</span> <span class="nf">edma_clean_channel</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="n">channel</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">channel</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EDMA: EMR%d %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
				<span class="n">edma_read_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_EMR</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>
		<span class="n">edma_shadow0_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_ECR</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="cm">/* Clear the corresponding EMR bits */</span>
		<span class="n">edma_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_EMCR</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="cm">/* Clear any SER */</span>
		<span class="n">edma_shadow0_write_array</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">SH_SECR</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="n">edma_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_CCERRCLR</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_clean_channel</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * edma_clear_event - clear an outstanding event on the DMA channel</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *	channel - channel number</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">edma_clear_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">ctlr</span><span class="p">;</span>

	<span class="n">ctlr</span> <span class="o">=</span> <span class="n">EDMA_CTLR</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="n">channel</span> <span class="o">=</span> <span class="n">EDMA_CHAN_SLOT</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&gt;=</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">ctlr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span>
		<span class="n">edma_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_ECR</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="n">channel</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">edma_write</span><span class="p">(</span><span class="n">ctlr</span><span class="p">,</span> <span class="n">EDMA_ECRH</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="n">channel</span> <span class="o">-</span> <span class="mi">32</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">edma_clear_event</span><span class="p">);</span>

<span class="cm">/*-----------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">edma_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edma_soc_info</span>	<span class="o">**</span><span class="n">info</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">s8</span>		<span class="p">(</span><span class="o">*</span><span class="n">queue_priority_mapping</span><span class="p">)[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">const</span> <span class="n">s8</span>		<span class="p">(</span><span class="o">*</span><span class="n">queue_tc_mapping</span><span class="p">)[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">ln</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">s16</span>		<span class="p">(</span><span class="o">*</span><span class="n">rsv_chans</span><span class="p">)[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">const</span> <span class="n">s16</span>		<span class="p">(</span><span class="o">*</span><span class="n">rsv_slots</span><span class="p">)[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">irq</span><span class="p">[</span><span class="n">EDMA_MAX_CC</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
	<span class="kt">int</span>			<span class="n">err_irq</span><span class="p">[</span><span class="n">EDMA_MAX_CC</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
	<span class="k">struct</span> <span class="n">resource</span>		<span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">EDMA_MAX_CC</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>
	<span class="n">resource_size_t</span>		<span class="n">len</span><span class="p">[</span><span class="n">EDMA_MAX_CC</span><span class="p">];</span>
	<span class="kt">char</span>			<span class="n">res_name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="kt">char</span>			<span class="n">irq_name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">EDMA_MAX_CC</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">res_name</span><span class="p">,</span> <span class="s">&quot;edma_cc%d&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
		<span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">platform_get_resource_byname</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span>
						<span class="n">res_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">||</span> <span class="o">!</span><span class="n">info</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">len</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>

		<span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">request_mem_region</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
			<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">edma_cc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">edma</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">edma_cc</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">edma_cc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">info</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">n_channel</span><span class="p">,</span>
							<span class="n">EDMA_MAX_DMACH</span><span class="p">);</span>
		<span class="n">edma_cc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">info</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">n_slot</span><span class="p">,</span>
							<span class="n">EDMA_MAX_PARAMENTRY</span><span class="p">);</span>
		<span class="n">edma_cc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_cc</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">info</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">n_cc</span><span class="p">,</span>
							<span class="n">EDMA_MAX_CC</span><span class="p">);</span>

		<span class="n">edma_cc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">default_queue</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">default_queue</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMA REG BASE ADDR=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_slots</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">PARM_OFFSET</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
					<span class="o">&amp;</span><span class="n">dummy_paramset</span><span class="p">,</span> <span class="n">PARM_SIZE</span><span class="p">);</span>

		<span class="cm">/* Mark all channels as unused */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">edma_cc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_unused</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">edma_cc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_unused</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rsv</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Clear the reserved channels in unused list */</span>
			<span class="n">rsv_chans</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_chans</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rsv_chans</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rsv_chans</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">off</span> <span class="o">=</span> <span class="n">rsv_chans</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
					<span class="n">ln</span> <span class="o">=</span> <span class="n">rsv_chans</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
					<span class="n">clear_bits</span><span class="p">(</span><span class="n">off</span><span class="p">,</span> <span class="n">ln</span><span class="p">,</span>
						<span class="n">edma_cc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_unused</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="cm">/* Set the reserved slots in inuse list */</span>
			<span class="n">rsv_slots</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_slots</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rsv_slots</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rsv_slots</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">off</span> <span class="o">=</span> <span class="n">rsv_slots</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
					<span class="n">ln</span> <span class="o">=</span> <span class="n">rsv_slots</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
					<span class="n">set_bits</span><span class="p">(</span><span class="n">off</span><span class="p">,</span> <span class="n">ln</span><span class="p">,</span>
						<span class="n">edma_cc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">edma_inuse</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">sprintf</span><span class="p">(</span><span class="n">irq_name</span><span class="p">,</span> <span class="s">&quot;edma%d&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
		<span class="n">irq</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">platform_get_irq_byname</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">irq_name</span><span class="p">);</span>
		<span class="n">edma_cc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">irq_res_start</span> <span class="o">=</span> <span class="n">irq</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dma_irq_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;edma&quot;</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;request_irq %d failed --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">irq</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">status</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sprintf</span><span class="p">(</span><span class="n">irq_name</span><span class="p">,</span> <span class="s">&quot;edma%d_err&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
		<span class="n">err_irq</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">platform_get_irq_byname</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">irq_name</span><span class="p">);</span>
		<span class="n">edma_cc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">irq_res_end</span> <span class="o">=</span> <span class="n">err_irq</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">err_irq</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dma_ccerr_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="s">&quot;edma_error&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;request_irq %d failed --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">err_irq</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">status</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edma_cc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">map_dmach_queue</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">info</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">default_queue</span><span class="p">);</span>

		<span class="n">queue_tc_mapping</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">queue_tc_mapping</span><span class="p">;</span>
		<span class="n">queue_priority_mapping</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">queue_priority_mapping</span><span class="p">;</span>

		<span class="cm">/* Event queue to TC mapping */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">queue_tc_mapping</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">map_queue_tc</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">queue_tc_mapping</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">queue_tc_mapping</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>

		<span class="cm">/* Event queue priority mapping */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">queue_priority_mapping</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">assign_priority_to_queue</span><span class="p">(</span><span class="n">j</span><span class="p">,</span>
						<span class="n">queue_priority_mapping</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
						<span class="n">queue_priority_mapping</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>

		<span class="cm">/* Map the channel to param entry if channel mapping logic</span>
<span class="cm">		 * exist</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edma_read</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">EDMA_CCCFG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CHMAP_EXIST</span><span class="p">)</span>
			<span class="n">map_dmach_param</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">n_region</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">edma_write_array2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">EDMA_DRAE</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
			<span class="n">edma_write_array2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">EDMA_DRAE</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
			<span class="n">edma_write_array</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">EDMA_QRAE</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">arch_num_cc</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tc_errs_handled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">IRQ_TCERRINT0</span><span class="p">,</span> <span class="n">dma_tc0err_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="s">&quot;edma_tc0&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;request_irq %d failed --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">IRQ_TCERRINT0</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">IRQ_TCERRINT</span><span class="p">,</span> <span class="n">dma_tc1err_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="s">&quot;edma_tc1&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;request_irq %d --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">IRQ_TCERRINT</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EDMA_MAX_CC</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_irq</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">err_irq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">fail1:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EDMA_MAX_CC</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">release_mem_region</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">iounmap</span><span class="p">(</span><span class="n">edmacc_regs_base</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">edma_cc</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">edma_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;edma&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">edma_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">platform_driver_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edma_driver</span><span class="p">,</span> <span class="n">edma_probe</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">arch_initcall</span><span class="p">(</span><span class="n">edma_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
