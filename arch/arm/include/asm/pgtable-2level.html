<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › include › asm › pgtable-2level.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pgtable-2level.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  arch/arm/include/asm/pgtable-2level.h</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1995-2002 Russell King</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _ASM_PGTABLE_2LEVEL_H</span>
<span class="cp">#define _ASM_PGTABLE_2LEVEL_H</span>

<span class="cm">/*</span>
<span class="cm"> * Hardware-wise, we have a two level page table structure, where the first</span>
<span class="cm"> * level has 4096 entries, and the second level has 256 entries.  Each entry</span>
<span class="cm"> * is one 32-bit word.  Most of the bits in the second level entry are used</span>
<span class="cm"> * by hardware, and there aren&#39;t any &quot;accessed&quot; and &quot;dirty&quot; bits.</span>
<span class="cm"> *</span>
<span class="cm"> * Linux on the other hand has a three level page table structure, which can</span>
<span class="cm"> * be wrapped to fit a two level page table structure easily - using the PGD</span>
<span class="cm"> * and PTE only.  However, Linux also expects one &quot;PTE&quot; table per page, and</span>
<span class="cm"> * at least a &quot;dirty&quot; bit.</span>
<span class="cm"> *</span>
<span class="cm"> * Therefore, we tweak the implementation slightly - we tell Linux that we</span>
<span class="cm"> * have 2048 entries in the first level, each of which is 8 bytes (iow, two</span>
<span class="cm"> * hardware pointers to the second level.)  The second level contains two</span>
<span class="cm"> * hardware PTE tables arranged contiguously, preceded by Linux versions</span>
<span class="cm"> * which contain the state information Linux needs.  We, therefore, end up</span>
<span class="cm"> * with 512 entries in the &quot;PTE&quot; level.</span>
<span class="cm"> *</span>
<span class="cm"> * This leads to the page tables having the following layout:</span>
<span class="cm"> *</span>
<span class="cm"> *    pgd             pte</span>
<span class="cm"> * |        |</span>
<span class="cm"> * +--------+</span>
<span class="cm"> * |        |       +------------+ +0</span>
<span class="cm"> * +- - - - +       | Linux pt 0 |</span>
<span class="cm"> * |        |       +------------+ +1024</span>
<span class="cm"> * +--------+ +0    | Linux pt 1 |</span>
<span class="cm"> * |        |-----&gt; +------------+ +2048</span>
<span class="cm"> * +- - - - + +4    |  h/w pt 0  |</span>
<span class="cm"> * |        |-----&gt; +------------+ +3072</span>
<span class="cm"> * +--------+ +8    |  h/w pt 1  |</span>
<span class="cm"> * |        |       +------------+ +4096</span>
<span class="cm"> *</span>
<span class="cm"> * See L_PTE_xxx below for definitions of bits in the &quot;Linux pt&quot;, and</span>
<span class="cm"> * PTE_xxx for definitions of bits appearing in the &quot;h/w pt&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * PMD_xxx definitions refer to bits in the first level page table.</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;dirty&quot; bit is emulated by only granting hardware write permission</span>
<span class="cm"> * iff the page is marked &quot;writable&quot; and &quot;dirty&quot; in the Linux PTE.  This</span>
<span class="cm"> * means that a write to a clean page will cause a permission fault, and</span>
<span class="cm"> * the Linux MM layer will mark the page dirty via handle_pte_fault().</span>
<span class="cm"> * For the hardware to notice the permission change, the TLB entry must</span>
<span class="cm"> * be flushed, and ptep_set_access_flags() does that for us.</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;accessed&quot; or &quot;young&quot; bit is emulated by a similar method; we only</span>
<span class="cm"> * allow accesses to the page if the &quot;young&quot; bit is set.  Accesses to the</span>
<span class="cm"> * page will cause a fault, and handle_pte_fault() will set the young bit</span>
<span class="cm"> * for us as long as the page is marked present in the corresponding Linux</span>
<span class="cm"> * PTE entry.  Again, ptep_set_access_flags() will ensure that the TLB is</span>
<span class="cm"> * up to date.</span>
<span class="cm"> *</span>
<span class="cm"> * However, when the &quot;young&quot; bit is cleared, we deny access to the page</span>
<span class="cm"> * by clearing the hardware PTE.  Currently Linux does not flush the TLB</span>
<span class="cm"> * for us in this case, which means the TLB will retain the transation</span>
<span class="cm"> * until either the TLB entry is evicted under pressure, or a context</span>
<span class="cm"> * switch which changes the user space mapping occurs.</span>
<span class="cm"> */</span>
<span class="cp">#define PTRS_PER_PTE		512</span>
<span class="cp">#define PTRS_PER_PMD		1</span>
<span class="cp">#define PTRS_PER_PGD		2048</span>

<span class="cp">#define PTE_HWTABLE_PTRS	(PTRS_PER_PTE)</span>
<span class="cp">#define PTE_HWTABLE_OFF		(PTE_HWTABLE_PTRS * sizeof(pte_t))</span>
<span class="cp">#define PTE_HWTABLE_SIZE	(PTRS_PER_PTE * sizeof(u32))</span>

<span class="cm">/*</span>
<span class="cm"> * PMD_SHIFT determines the size of the area a second-level page table can map</span>
<span class="cm"> * PGDIR_SHIFT determines what a third-level page table entry can map</span>
<span class="cm"> */</span>
<span class="cp">#define PMD_SHIFT		21</span>
<span class="cp">#define PGDIR_SHIFT		21</span>

<span class="cp">#define PMD_SIZE		(1UL &lt;&lt; PMD_SHIFT)</span>
<span class="cp">#define PMD_MASK		(~(PMD_SIZE-1))</span>
<span class="cp">#define PGDIR_SIZE		(1UL &lt;&lt; PGDIR_SHIFT)</span>
<span class="cp">#define PGDIR_MASK		(~(PGDIR_SIZE-1))</span>

<span class="cm">/*</span>
<span class="cm"> * section address mask and size definitions.</span>
<span class="cm"> */</span>
<span class="cp">#define SECTION_SHIFT		20</span>
<span class="cp">#define SECTION_SIZE		(1UL &lt;&lt; SECTION_SHIFT)</span>
<span class="cp">#define SECTION_MASK		(~(SECTION_SIZE-1))</span>

<span class="cm">/*</span>
<span class="cm"> * ARMv6 supersection address mask and size definitions.</span>
<span class="cm"> */</span>
<span class="cp">#define SUPERSECTION_SHIFT	24</span>
<span class="cp">#define SUPERSECTION_SIZE	(1UL &lt;&lt; SUPERSECTION_SHIFT)</span>
<span class="cp">#define SUPERSECTION_MASK	(~(SUPERSECTION_SIZE-1))</span>

<span class="cp">#define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)</span>

<span class="cm">/*</span>
<span class="cm"> * &quot;Linux&quot; PTE definitions.</span>
<span class="cm"> *</span>
<span class="cm"> * We keep two sets of PTEs - the hardware and the linux version.</span>
<span class="cm"> * This allows greater flexibility in the way we map the Linux bits</span>
<span class="cm"> * onto the hardware tables, and allows us to have YOUNG and DIRTY</span>
<span class="cm"> * bits.</span>
<span class="cm"> *</span>
<span class="cm"> * The PTE table pointer refers to the hardware entries; the &quot;Linux&quot;</span>
<span class="cm"> * entries are stored 1024 bytes below.</span>
<span class="cm"> */</span>
<span class="cp">#define L_PTE_PRESENT		(_AT(pteval_t, 1) &lt;&lt; 0)</span>
<span class="cp">#define L_PTE_YOUNG		(_AT(pteval_t, 1) &lt;&lt; 1)</span>
<span class="cp">#define L_PTE_FILE		(_AT(pteval_t, 1) &lt;&lt; 2)	</span><span class="cm">/* only when !PRESENT */</span><span class="cp"></span>
<span class="cp">#define L_PTE_DIRTY		(_AT(pteval_t, 1) &lt;&lt; 6)</span>
<span class="cp">#define L_PTE_RDONLY		(_AT(pteval_t, 1) &lt;&lt; 7)</span>
<span class="cp">#define L_PTE_USER		(_AT(pteval_t, 1) &lt;&lt; 8)</span>
<span class="cp">#define L_PTE_XN		(_AT(pteval_t, 1) &lt;&lt; 9)</span>
<span class="cp">#define L_PTE_SHARED		(_AT(pteval_t, 1) &lt;&lt; 10)	</span><span class="cm">/* shared(v6), coherent(xsc3) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * These are the memory types, defined to be compatible with</span>
<span class="cm"> * pre-ARMv6 CPUs cacheable and bufferable bits:   XXCB</span>
<span class="cm"> */</span>
<span class="cp">#define L_PTE_MT_UNCACHED	(_AT(pteval_t, 0x00) &lt;&lt; 2)	</span><span class="cm">/* 0000 */</span><span class="cp"></span>
<span class="cp">#define L_PTE_MT_BUFFERABLE	(_AT(pteval_t, 0x01) &lt;&lt; 2)	</span><span class="cm">/* 0001 */</span><span class="cp"></span>
<span class="cp">#define L_PTE_MT_WRITETHROUGH	(_AT(pteval_t, 0x02) &lt;&lt; 2)	</span><span class="cm">/* 0010 */</span><span class="cp"></span>
<span class="cp">#define L_PTE_MT_WRITEBACK	(_AT(pteval_t, 0x03) &lt;&lt; 2)	</span><span class="cm">/* 0011 */</span><span class="cp"></span>
<span class="cp">#define L_PTE_MT_MINICACHE	(_AT(pteval_t, 0x06) &lt;&lt; 2)	</span><span class="cm">/* 0110 (sa1100, xscale) */</span><span class="cp"></span>
<span class="cp">#define L_PTE_MT_WRITEALLOC	(_AT(pteval_t, 0x07) &lt;&lt; 2)	</span><span class="cm">/* 0111 */</span><span class="cp"></span>
<span class="cp">#define L_PTE_MT_DEV_SHARED	(_AT(pteval_t, 0x04) &lt;&lt; 2)	</span><span class="cm">/* 0100 */</span><span class="cp"></span>
<span class="cp">#define L_PTE_MT_DEV_NONSHARED	(_AT(pteval_t, 0x0c) &lt;&lt; 2)	</span><span class="cm">/* 1100 */</span><span class="cp"></span>
<span class="cp">#define L_PTE_MT_DEV_WC		(_AT(pteval_t, 0x09) &lt;&lt; 2)	</span><span class="cm">/* 1001 */</span><span class="cp"></span>
<span class="cp">#define L_PTE_MT_DEV_CACHED	(_AT(pteval_t, 0x0b) &lt;&lt; 2)	</span><span class="cm">/* 1011 */</span><span class="cp"></span>
<span class="cp">#define L_PTE_MT_MASK		(_AT(pteval_t, 0x0f) &lt;&lt; 2)</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cm">/*</span>
<span class="cm"> * The &quot;pud_xxx()&quot; functions here are trivial when the pmd is folded into</span>
<span class="cm"> * the pud: the pud entry is never bad, always exists, and can&#39;t be set or</span>
<span class="cm"> * cleared.</span>
<span class="cm"> */</span>
<span class="cp">#define pud_none(pud)		(0)</span>
<span class="cp">#define pud_bad(pud)		(0)</span>
<span class="cp">#define pud_present(pud)	(1)</span>
<span class="cp">#define pud_clear(pudp)		do { } while (0)</span>
<span class="cp">#define set_pud(pud,pudp)	do { } while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="nf">pmd_offset</span><span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pud</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define pmd_bad(pmd)		(pmd_val(pmd) &amp; 2)</span>

<span class="cp">#define copy_pmd(pmdpd,pmdps)		\</span>
<span class="cp">	do {				\</span>
<span class="cp">		pmdpd[0] = pmdps[0];	\</span>
<span class="cp">		pmdpd[1] = pmdps[1];	\</span>
<span class="cp">		flush_pmd_entry(pmdpd);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define pmd_clear(pmdp)			\</span>
<span class="cp">	do {				\</span>
<span class="cp">		pmdp[0] = __pmd(0);	\</span>
<span class="cp">		pmdp[1] = __pmd(0);	\</span>
<span class="cp">		clean_pmd_entry(pmdp);	\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/* we don&#39;t need complex calculations here as the pmd is folded into the pgd */</span>
<span class="cp">#define pmd_addr_end(addr,end) (end)</span>

<span class="cp">#define set_pte_ext(ptep,pte,ext) cpu_set_pte_ext(ptep,pte,ext)</span>

<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_PGTABLE_2LEVEL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
