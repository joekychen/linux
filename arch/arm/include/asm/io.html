<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › include › asm › io.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>io.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  arch/arm/include/asm/io.h</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1996-2000 Russell King</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * Modifications:</span>
<span class="cm"> *  16-Sep-1996	RMK	Inlined the inx/outx functions &amp; optimised for both</span>
<span class="cm"> *			constant addresses and variable addresses.</span>
<span class="cm"> *  04-Dec-1997	RMK	Moved a lot of this stuff to the new architecture</span>
<span class="cm"> *			specific IO header files.</span>
<span class="cm"> *  27-Mar-1999	PJB	Second parameter of memcpy_toio is const..</span>
<span class="cm"> *  04-Apr-1999	PJB	Added check_signature.</span>
<span class="cm"> *  12-Dec-1999	RMK	More cleanups</span>
<span class="cm"> *  18-Jun-2000 RMK	Removed virt_to_* and friends definitions</span>
<span class="cm"> *  05-Oct-2004 BJD     Moved memory string functions to use void __iomem</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __ASM_ARM_IO_H</span>
<span class="cp">#define __ASM_ARM_IO_H</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/memory.h&gt;</span>
<span class="cp">#include &lt;asm-generic/pci_iomap.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * ISA I/O bus memory addresses are 1:1 with the physical address.</span>
<span class="cm"> */</span>
<span class="cp">#define isa_virt_to_bus virt_to_phys</span>
<span class="cp">#define isa_page_to_bus page_to_phys</span>
<span class="cp">#define isa_bus_to_virt phys_to_virt</span>

<span class="cm">/*</span>
<span class="cm"> * Generic IO read/write.  These perform native-endian accesses.  Note</span>
<span class="cm"> * that some architectures will want to re-define __raw_{read,write}w.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__raw_writesb</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytelen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__raw_writesw</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wordlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__raw_writesl</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">longlen</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__raw_readsb</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytelen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__raw_readsw</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wordlen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__raw_readsl</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">longlen</span><span class="p">);</span>

<span class="cp">#define __raw_writeb(v,a)	((void)(__chk_io_ptr(a), *(volatile unsigned char __force  *)(a) = (v)))</span>
<span class="cp">#define __raw_writew(v,a)	((void)(__chk_io_ptr(a), *(volatile unsigned short __force *)(a) = (v)))</span>
<span class="cp">#define __raw_writel(v,a)	((void)(__chk_io_ptr(a), *(volatile unsigned int __force   *)(a) = (v)))</span>

<span class="cp">#define __raw_readb(a)		(__chk_io_ptr(a), *(volatile unsigned char __force  *)(a))</span>
<span class="cp">#define __raw_readw(a)		(__chk_io_ptr(a), *(volatile unsigned short __force *)(a))</span>
<span class="cp">#define __raw_readl(a)		(__chk_io_ptr(a), *(volatile unsigned int __force   *)(a))</span>

<span class="cm">/*</span>
<span class="cm"> * Architecture ioremap implementation.</span>
<span class="cm"> */</span>
<span class="cp">#define MT_DEVICE		0</span>
<span class="cp">#define MT_DEVICE_NONSHARED	1</span>
<span class="cp">#define MT_DEVICE_CACHED	2</span>
<span class="cp">#define MT_DEVICE_WC		3</span>
<span class="cm">/*</span>
<span class="cm"> * types 4 onwards can be found in asm/mach/map.h and are undefined</span>
<span class="cm"> * for ioremap</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * __arm_ioremap takes CPU physical address.</span>
<span class="cm"> * __arm_ioremap_pfn takes a Page Frame Number and an offset into that page</span>
<span class="cm"> * The _caller variety takes a __builtin_return_address(0) value for</span>
<span class="cm"> * /proc/vmalloc to use - and should only be used in non-inline functions.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">__arm_ioremap_pfn_caller</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
	<span class="kt">size_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">__arm_ioremap_caller</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">__arm_ioremap_pfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">__arm_ioremap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">__arm_ioremap_exec</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">bool</span> <span class="n">cached</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iounmap</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__arm_iounmap</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">arch_ioremap_caller</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">arch_iounmap</span><span class="p">)(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Bad read/write accesses...</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__readwrite_bug</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fn</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * A typesafe __io() helper</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">__typesafe_io</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define IOMEM(x)	((void __force __iomem *)(x))</span>

<span class="cm">/* IO barriers */</span>
<span class="cp">#ifdef CONFIG_ARM_DMA_MEM_BUFFERABLE</span>
<span class="cp">#include &lt;asm/barrier.h&gt;</span>
<span class="cp">#define __iormb()		rmb()</span>
<span class="cp">#define __iowmb()		wmb()</span>
<span class="cp">#else</span>
<span class="cp">#define __iormb()		do { } while (0)</span>
<span class="cp">#define __iowmb()		do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Now, pick up the machine-defined IO definitions</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_NEED_MACH_IO_H</span>
<span class="cp">#include &lt;mach/io.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#define __io(a)		__typesafe_io((a) &amp; IO_SPACE_LIMIT)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * This is the limit of PC card/PCI/ISA IO space, which is by default</span>
<span class="cm"> * 64K if we have PC card, PCI or ISA support.  Otherwise, default to</span>
<span class="cm"> * zero to prevent ISA/PCI drivers claiming IO space (and potentially</span>
<span class="cm"> * oopsing.)</span>
<span class="cm"> *</span>
<span class="cm"> * Only set this larger if you really need inb() et.al. to operate over</span>
<span class="cm"> * a larger address space.  Note that SOC_COMMON ioremaps each sockets</span>
<span class="cm"> * IO space area, and so inb() et.al. must be defined to operate as per</span>
<span class="cm"> * readb() et.al. on such platforms.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef IO_SPACE_LIMIT</span>
<span class="cp">#if defined(CONFIG_PCMCIA_SOC_COMMON) || defined(CONFIG_PCMCIA_SOC_COMMON_MODULE)</span>
<span class="cp">#define IO_SPACE_LIMIT ((resource_size_t)0xffffffff)</span>
<span class="cp">#elif defined(CONFIG_PCI) || defined(CONFIG_ISA) || defined(CONFIG_PCCARD)</span>
<span class="cp">#define IO_SPACE_LIMIT ((resource_size_t)0xffff)</span>
<span class="cp">#else</span>
<span class="cp">#define IO_SPACE_LIMIT ((resource_size_t)0)</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *  IO port access primitives</span>
<span class="cm"> *  -------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * The ARM doesn&#39;t have special IO access instructions; all IO is memory</span>
<span class="cm"> * mapped.  Note that these are defined to perform little endian accesses</span>
<span class="cm"> * only.  Their primary purpose is to access PCI and ISA peripherals.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that for a big endian machine, this implies that the following</span>
<span class="cm"> * big endian mode connectivity is in place, as described by numerous</span>
<span class="cm"> * ARM documents:</span>
<span class="cm"> *</span>
<span class="cm"> *    PCI:  D0-D7   D8-D15 D16-D23 D24-D31</span>
<span class="cm"> *    ARM: D24-D31 D16-D23  D8-D15  D0-D7</span>
<span class="cm"> *</span>
<span class="cm"> * The machine specific io.h include defines __io to translate an &quot;IO&quot;</span>
<span class="cm"> * address to a memory address.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we prevent GCC re-ordering or caching values in expressions</span>
<span class="cm"> * by introducing sequence points into the in*() definitions.  Note that</span>
<span class="cm"> * __raw_* do not guarantee this behaviour.</span>
<span class="cm"> *</span>
<span class="cm"> * The {in,out}[bwl] macros are for emulating x86-style PCI/ISA IO space.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __io</span>
<span class="cp">#define outb(v,p)	({ __iowmb(); __raw_writeb(v,__io(p)); })</span>
<span class="cp">#define outw(v,p)	({ __iowmb(); __raw_writew((__force __u16) \</span>
<span class="cp">					cpu_to_le16(v),__io(p)); })</span>
<span class="cp">#define outl(v,p)	({ __iowmb(); __raw_writel((__force __u32) \</span>
<span class="cp">					cpu_to_le32(v),__io(p)); })</span>

<span class="cp">#define inb(p)	({ __u8 __v = __raw_readb(__io(p)); __iormb(); __v; })</span>
<span class="cp">#define inw(p)	({ __u16 __v = le16_to_cpu((__force __le16) \</span>
<span class="cp">			__raw_readw(__io(p))); __iormb(); __v; })</span>
<span class="cp">#define inl(p)	({ __u32 __v = le32_to_cpu((__force __le32) \</span>
<span class="cp">			__raw_readl(__io(p))); __iormb(); __v; })</span>

<span class="cp">#define outsb(p,d,l)		__raw_writesb(__io(p),d,l)</span>
<span class="cp">#define outsw(p,d,l)		__raw_writesw(__io(p),d,l)</span>
<span class="cp">#define outsl(p,d,l)		__raw_writesl(__io(p),d,l)</span>

<span class="cp">#define insb(p,d,l)		__raw_readsb(__io(p),d,l)</span>
<span class="cp">#define insw(p,d,l)		__raw_readsw(__io(p),d,l)</span>
<span class="cp">#define insl(p,d,l)		__raw_readsl(__io(p),d,l)</span>
<span class="cp">#endif</span>

<span class="cp">#define outb_p(val,port)	outb((val),(port))</span>
<span class="cp">#define outw_p(val,port)	outw((val),(port))</span>
<span class="cp">#define outl_p(val,port)	outl((val),(port))</span>
<span class="cp">#define inb_p(port)		inb((port))</span>
<span class="cp">#define inw_p(port)		inw((port))</span>
<span class="cp">#define inl_p(port)		inl((port))</span>

<span class="cp">#define outsb_p(port,from,len)	outsb(port,from,len)</span>
<span class="cp">#define outsw_p(port,from,len)	outsw(port,from,len)</span>
<span class="cp">#define outsl_p(port,from,len)	outsl(port,from,len)</span>
<span class="cp">#define insb_p(port,to,len)	insb(port,to,len)</span>
<span class="cp">#define insw_p(port,to,len)	insw(port,to,len)</span>
<span class="cp">#define insl_p(port,to,len)	insl(port,to,len)</span>

<span class="cm">/*</span>
<span class="cm"> * String version of IO memory access ops:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_memcpy_fromio</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_memcpy_toio</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_memset_io</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>

<span class="cp">#define mmiowb()</span>

<span class="cm">/*</span>
<span class="cm"> *  Memory access primitives</span>
<span class="cm"> *  ------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * These perform PCI memory accesses via an ioremap region.  They don&#39;t</span>
<span class="cm"> * take an address as such, but a cookie.</span>
<span class="cm"> *</span>
<span class="cm"> * Again, this are defined to perform little endian accesses.  See the</span>
<span class="cm"> * IO port primitives for more information.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef readl</span>
<span class="cp">#define readb_relaxed(c) ({ u8  __r = __raw_readb(c); __r; })</span>
<span class="cp">#define readw_relaxed(c) ({ u16 __r = le16_to_cpu((__force __le16) \</span>
<span class="cp">					__raw_readw(c)); __r; })</span>
<span class="cp">#define readl_relaxed(c) ({ u32 __r = le32_to_cpu((__force __le32) \</span>
<span class="cp">					__raw_readl(c)); __r; })</span>

<span class="cp">#define writeb_relaxed(v,c)	__raw_writeb(v,c)</span>
<span class="cp">#define writew_relaxed(v,c)	__raw_writew((__force u16) cpu_to_le16(v),c)</span>
<span class="cp">#define writel_relaxed(v,c)	__raw_writel((__force u32) cpu_to_le32(v),c)</span>

<span class="cp">#define readb(c)		({ u8  __v = readb_relaxed(c); __iormb(); __v; })</span>
<span class="cp">#define readw(c)		({ u16 __v = readw_relaxed(c); __iormb(); __v; })</span>
<span class="cp">#define readl(c)		({ u32 __v = readl_relaxed(c); __iormb(); __v; })</span>

<span class="cp">#define writeb(v,c)		({ __iowmb(); writeb_relaxed(v,c); })</span>
<span class="cp">#define writew(v,c)		({ __iowmb(); writew_relaxed(v,c); })</span>
<span class="cp">#define writel(v,c)		({ __iowmb(); writel_relaxed(v,c); })</span>

<span class="cp">#define readsb(p,d,l)		__raw_readsb(p,d,l)</span>
<span class="cp">#define readsw(p,d,l)		__raw_readsw(p,d,l)</span>
<span class="cp">#define readsl(p,d,l)		__raw_readsl(p,d,l)</span>

<span class="cp">#define writesb(p,d,l)		__raw_writesb(p,d,l)</span>
<span class="cp">#define writesw(p,d,l)		__raw_writesw(p,d,l)</span>
<span class="cp">#define writesl(p,d,l)		__raw_writesl(p,d,l)</span>

<span class="cp">#define memset_io(c,v,l)	_memset_io(c,(v),(l))</span>
<span class="cp">#define memcpy_fromio(a,c,l)	_memcpy_fromio((a),c,(l))</span>
<span class="cp">#define memcpy_toio(c,a,l)	_memcpy_toio(c,(a),(l))</span>

<span class="cp">#endif	</span><span class="cm">/* readl */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * ioremap and friends.</span>
<span class="cm"> *</span>
<span class="cm"> * ioremap takes a PCI memory address, as specified in</span>
<span class="cm"> * Documentation/io-mapping.txt.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define ioremap(cookie,size)		__arm_ioremap((cookie), (size), MT_DEVICE)</span>
<span class="cp">#define ioremap_nocache(cookie,size)	__arm_ioremap((cookie), (size), MT_DEVICE)</span>
<span class="cp">#define ioremap_cached(cookie,size)	__arm_ioremap((cookie), (size), MT_DEVICE_CACHED)</span>
<span class="cp">#define ioremap_wc(cookie,size)		__arm_ioremap((cookie), (size), MT_DEVICE_WC)</span>
<span class="cp">#define iounmap				__arm_iounmap</span>

<span class="cm">/*</span>
<span class="cm"> * io{read,write}{8,16,32} macros</span>
<span class="cm"> */</span>
<span class="cp">#ifndef ioread8</span>
<span class="cp">#define ioread8(p)	({ unsigned int __v = __raw_readb(p); __iormb(); __v; })</span>
<span class="cp">#define ioread16(p)	({ unsigned int __v = le16_to_cpu((__force __le16)__raw_readw(p)); __iormb(); __v; })</span>
<span class="cp">#define ioread32(p)	({ unsigned int __v = le32_to_cpu((__force __le32)__raw_readl(p)); __iormb(); __v; })</span>

<span class="cp">#define ioread16be(p)	({ unsigned int __v = be16_to_cpu((__force __be16)__raw_readw(p)); __iormb(); __v; })</span>
<span class="cp">#define ioread32be(p)	({ unsigned int __v = be32_to_cpu((__force __be32)__raw_readl(p)); __iormb(); __v; })</span>

<span class="cp">#define iowrite8(v,p)	({ __iowmb(); __raw_writeb(v, p); })</span>
<span class="cp">#define iowrite16(v,p)	({ __iowmb(); __raw_writew((__force __u16)cpu_to_le16(v), p); })</span>
<span class="cp">#define iowrite32(v,p)	({ __iowmb(); __raw_writel((__force __u32)cpu_to_le32(v), p); })</span>

<span class="cp">#define iowrite16be(v,p) ({ __iowmb(); __raw_writew((__force __u16)cpu_to_be16(v), p); })</span>
<span class="cp">#define iowrite32be(v,p) ({ __iowmb(); __raw_writel((__force __u32)cpu_to_be32(v), p); })</span>

<span class="cp">#define ioread8_rep(p,d,c)	__raw_readsb(p,d,c)</span>
<span class="cp">#define ioread16_rep(p,d,c)	__raw_readsw(p,d,c)</span>
<span class="cp">#define ioread32_rep(p,d,c)	__raw_readsl(p,d,c)</span>

<span class="cp">#define iowrite8_rep(p,s,c)	__raw_writesb(p,s,c)</span>
<span class="cp">#define iowrite16_rep(p,s,c)	__raw_writesw(p,s,c)</span>
<span class="cp">#define iowrite32_rep(p,s,c)	__raw_writesl(p,s,c)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioport_map</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ioport_unmap</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">pci_dev</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_iounmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * can the hardware map this into one segment or not, given no other</span>
<span class="cm"> * constraints.</span>
<span class="cm"> */</span>
<span class="cp">#define BIOVEC_MERGEABLE(vec1, vec2)	\</span>
<span class="cp">	((bvec_to_phys((vec1)) + (vec1)-&gt;bv_len) == bvec_to_phys((vec2)))</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="cp">#define ARCH_HAS_VALID_PHYS_ADDR_RANGE</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">valid_phys_addr_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">valid_mmap_phys_addr_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">devmem_is_allowed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Convert a physical pointer to a virtual kernel pointer for /dev/mem</span>
<span class="cm"> * access</span>
<span class="cm"> */</span>
<span class="cp">#define xlate_dev_mem_ptr(p)	__va(p)</span>

<span class="cm">/*</span>
<span class="cm"> * Convert a virtual cached pointer to an uncached pointer</span>
<span class="cm"> */</span>
<span class="cp">#define xlate_dev_kmem_ptr(p)	p</span>

<span class="cm">/*</span>
<span class="cm"> * Register ISA memory and port locations for glibc iopl/inb/outb</span>
<span class="cm"> * emulation.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">register_isa_ports</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mmio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">io</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">io_shift</span><span class="p">);</span>

<span class="cp">#endif	</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif	</span><span class="cm">/* __ASM_ARM_IO_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
