<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › kernel › kprobes-test.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>kprobes-test.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * arch/arm/kernel/kprobes-test.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2011 Jon Medhurst &lt;tixy@yxit.co.uk&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file contains test code for ARM kprobes.</span>
<span class="cm"> *</span>
<span class="cm"> * The top level function run_all_tests() executes tests for all of the</span>
<span class="cm"> * supported instruction sets: ARM, 16-bit Thumb, and 32-bit Thumb. These tests</span>
<span class="cm"> * fall into two categories; run_api_tests() checks basic functionality of the</span>
<span class="cm"> * kprobes API, and run_test_cases() is a comprehensive test for kprobes</span>
<span class="cm"> * instruction decoding and simulation.</span>
<span class="cm"> *</span>
<span class="cm"> * run_test_cases() first checks the kprobes decoding table for self consistency</span>
<span class="cm"> * (using table_test()) then executes a series of test cases for each of the CPU</span>
<span class="cm"> * instruction forms. coverage_start() and coverage_end() are used to verify</span>
<span class="cm"> * that these test cases cover all of the possible combinations of instructions</span>
<span class="cm"> * described by the kprobes decoding tables.</span>
<span class="cm"> *</span>
<span class="cm"> * The individual test cases are in kprobes-test-arm.c and kprobes-test-thumb.c</span>
<span class="cm"> * which use the macros defined in kprobes-test.h. The rest of this</span>
<span class="cm"> * documentation will describe the operation of the framework used by these</span>
<span class="cm"> * test cases.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * TESTING METHODOLOGY</span>
<span class="cm"> * -------------------</span>
<span class="cm"> *</span>
<span class="cm"> * The methodology used to test an ARM instruction &#39;test_insn&#39; is to use</span>
<span class="cm"> * inline assembler like:</span>
<span class="cm"> *</span>
<span class="cm"> * test_before: nop</span>
<span class="cm"> * test_case:	test_insn</span>
<span class="cm"> * test_after:	nop</span>
<span class="cm"> *</span>
<span class="cm"> * When the test case is run a kprobe is placed of each nop. The</span>
<span class="cm"> * post-handler of the test_before probe is used to modify the saved CPU</span>
<span class="cm"> * register context to that which we require for the test case. The</span>
<span class="cm"> * pre-handler of the of the test_after probe saves a copy of the CPU</span>
<span class="cm"> * register context. In this way we can execute test_insn with a specific</span>
<span class="cm"> * register context and see the results afterwards.</span>
<span class="cm"> *</span>
<span class="cm"> * To actually test the kprobes instruction emulation we perform the above</span>
<span class="cm"> * step a second time but with an additional kprobe on the test_case</span>
<span class="cm"> * instruction itself. If the emulation is accurate then the results seen</span>
<span class="cm"> * by the test_after probe will be identical to the first run which didn&#39;t</span>
<span class="cm"> * have a probe on test_case.</span>
<span class="cm"> *</span>
<span class="cm"> * Each test case is run several times with a variety of variations in the</span>
<span class="cm"> * flags value of stored in CPSR, and for Thumb code, different ITState.</span>
<span class="cm"> *</span>
<span class="cm"> * For instructions which can modify PC, a second test_after probe is used</span>
<span class="cm"> * like this:</span>
<span class="cm"> *</span>
<span class="cm"> * test_before: nop</span>
<span class="cm"> * test_case:	test_insn</span>
<span class="cm"> * test_after:	nop</span>
<span class="cm"> *		b test_done</span>
<span class="cm"> * test_after2: nop</span>
<span class="cm"> * test_done:</span>
<span class="cm"> *</span>
<span class="cm"> * The test case is constructed such that test_insn branches to</span>
<span class="cm"> * test_after2, or, if testing a conditional instruction, it may just</span>
<span class="cm"> * continue to test_after. The probes inserted at both locations let us</span>
<span class="cm"> * determine which happened. A similar approach is used for testing</span>
<span class="cm"> * backwards branches...</span>
<span class="cm"> *</span>
<span class="cm"> *		b test_before</span>
<span class="cm"> *		b test_done  @ helps to cope with off by 1 branches</span>
<span class="cm"> * test_after2: nop</span>
<span class="cm"> *		b test_done</span>
<span class="cm"> * test_before: nop</span>
<span class="cm"> * test_case:	test_insn</span>
<span class="cm"> * test_after:	nop</span>
<span class="cm"> * test_done:</span>
<span class="cm"> *</span>
<span class="cm"> * The macros used to generate the assembler instructions describe above</span>
<span class="cm"> * are TEST_INSTRUCTION, TEST_BRANCH_F (branch forwards) and TEST_BRANCH_B</span>
<span class="cm"> * (branch backwards). In these, the local variables numbered 1, 50, 2 and</span>
<span class="cm"> * 99 represent: test_before, test_case, test_after2 and test_done.</span>
<span class="cm"> *</span>
<span class="cm"> * FRAMEWORK</span>
<span class="cm"> * ---------</span>
<span class="cm"> *</span>
<span class="cm"> * Each test case is wrapped between the pair of macros TESTCASE_START and</span>
<span class="cm"> * TESTCASE_END. As well as performing the inline assembler boilerplate,</span>
<span class="cm"> * these call out to the kprobes_test_case_start() and</span>
<span class="cm"> * kprobes_test_case_end() functions which drive the execution of the test</span>
<span class="cm"> * case. The specific arguments to use for each test case are stored as</span>
<span class="cm"> * inline data constructed using the various TEST_ARG_* macros. Putting</span>
<span class="cm"> * this all together, a simple test case may look like:</span>
<span class="cm"> *</span>
<span class="cm"> *	TESTCASE_START(&quot;Testing mov r0, r7&quot;)</span>
<span class="cm"> *	TEST_ARG_REG(7, 0x12345678) // Set r7=0x12345678</span>
<span class="cm"> *	TEST_ARG_END(&quot;&quot;)</span>
<span class="cm"> *	TEST_INSTRUCTION(&quot;mov r0, r7&quot;)</span>
<span class="cm"> *	TESTCASE_END</span>
<span class="cm"> *</span>
<span class="cm"> * Note, in practice the single convenience macro TEST_R would be used for this</span>
<span class="cm"> * instead.</span>
<span class="cm"> *</span>
<span class="cm"> * The above would expand to assembler looking something like:</span>
<span class="cm"> *</span>
<span class="cm"> *	@ TESTCASE_START</span>
<span class="cm"> *	bl	__kprobes_test_case_start</span>
<span class="cm"> *	@ start of inline data...</span>
<span class="cm"> *	.ascii &quot;mov r0, r7&quot;	@ text title for test case</span>
<span class="cm"> *	.byte	0</span>
<span class="cm"> *	.align	2</span>
<span class="cm"> *</span>
<span class="cm"> *	@ TEST_ARG_REG</span>
<span class="cm"> *	.byte	ARG_TYPE_REG</span>
<span class="cm"> *	.byte	7</span>
<span class="cm"> *	.short	0</span>
<span class="cm"> *	.word	0x1234567</span>
<span class="cm"> *</span>
<span class="cm"> *	@ TEST_ARG_END</span>
<span class="cm"> *	.byte	ARG_TYPE_END</span>
<span class="cm"> *	.byte	TEST_ISA	@ flags, including ISA being tested</span>
<span class="cm"> *	.short	50f-0f		@ offset of &#39;test_before&#39;</span>
<span class="cm"> *	.short	2f-0f		@ offset of &#39;test_after2&#39; (if relevent)</span>
<span class="cm"> *	.short	99f-0f		@ offset of &#39;test_done&#39;</span>
<span class="cm"> *	@ start of test case code...</span>
<span class="cm"> *	0:</span>
<span class="cm"> *	.code	TEST_ISA	@ switch to ISA being tested</span>
<span class="cm"> *</span>
<span class="cm"> *	@ TEST_INSTRUCTION</span>
<span class="cm"> *	50:	nop		@ location for &#39;test_before&#39; probe</span>
<span class="cm"> *	1:	mov r0, r7	@ the test case instruction &#39;test_insn&#39;</span>
<span class="cm"> *		nop		@ location for &#39;test_after&#39; probe</span>
<span class="cm"> *</span>
<span class="cm"> *	// TESTCASE_END</span>
<span class="cm"> *	2:</span>
<span class="cm"> *	99:	bl __kprobes_test_case_end_##TEST_ISA</span>
<span class="cm"> *	.code	NONMAL_ISA</span>
<span class="cm"> *</span>
<span class="cm"> * When the above is execute the following happens...</span>
<span class="cm"> *</span>
<span class="cm"> * __kprobes_test_case_start() is an assembler wrapper which sets up space</span>
<span class="cm"> * for a stack buffer and calls the C function kprobes_test_case_start().</span>
<span class="cm"> * This C function will do some initial processing of the inline data and</span>
<span class="cm"> * setup some global state. It then inserts the test_before and test_after</span>
<span class="cm"> * kprobes and returns a value which causes the assembler wrapper to jump</span>
<span class="cm"> * to the start of the test case code, (local label &#39;0&#39;).</span>
<span class="cm"> *</span>
<span class="cm"> * When the test case code executes, the test_before probe will be hit and</span>
<span class="cm"> * test_before_post_handler will call setup_test_context(). This fills the</span>
<span class="cm"> * stack buffer and CPU registers with a test pattern and then processes</span>
<span class="cm"> * the test case arguments. In our example there is one TEST_ARG_REG which</span>
<span class="cm"> * indicates that R7 should be loaded with the value 0x12345678.</span>
<span class="cm"> *</span>
<span class="cm"> * When the test_before probe ends, the test case continues and executes</span>
<span class="cm"> * the &quot;mov r0, r7&quot; instruction. It then hits the test_after probe and the</span>
<span class="cm"> * pre-handler for this (test_after_pre_handler) will save a copy of the</span>
<span class="cm"> * CPU register context. This should now have R0 holding the same value as</span>
<span class="cm"> * R7.</span>
<span class="cm"> *</span>
<span class="cm"> * Finally we get to the call to __kprobes_test_case_end_{32,16}. This is</span>
<span class="cm"> * an assembler wrapper which switches back to the ISA used by the test</span>
<span class="cm"> * code and calls the C function kprobes_test_case_end().</span>
<span class="cm"> *</span>
<span class="cm"> * For each run through the test case, test_case_run_count is incremented</span>
<span class="cm"> * by one. For even runs, kprobes_test_case_end() saves a copy of the</span>
<span class="cm"> * register and stack buffer contents from the test case just run. It then</span>
<span class="cm"> * inserts a kprobe on the test case instruction &#39;test_insn&#39; and returns a</span>
<span class="cm"> * value to cause the test case code to be re-run.</span>
<span class="cm"> *</span>
<span class="cm"> * For odd numbered runs, kprobes_test_case_end() compares the register and</span>
<span class="cm"> * stack buffer contents to those that were saved on the previous even</span>
<span class="cm"> * numbered run (the one without the kprobe on test_insn). These should be</span>
<span class="cm"> * the same if the kprobe instruction simulation routine is correct.</span>
<span class="cm"> *</span>
<span class="cm"> * The pair of test case runs is repeated with different combinations of</span>
<span class="cm"> * flag values in CPSR and, for Thumb, different ITState. This is</span>
<span class="cm"> * controlled by test_context_cpsr().</span>
<span class="cm"> *</span>
<span class="cm"> * BUILDING TEST CASES</span>
<span class="cm"> * -------------------</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * As an aid to building test cases, the stack buffer is initialised with</span>
<span class="cm"> * some special values:</span>
<span class="cm"> *</span>
<span class="cm"> *   [SP+13*4]	Contains SP+120. This can be used to test instructions</span>
<span class="cm"> *		which load a value into SP.</span>
<span class="cm"> *</span>
<span class="cm"> *   [SP+15*4]	When testing branching instructions using TEST_BRANCH_{F,B},</span>
<span class="cm"> *		this holds the target address of the branch, &#39;test_after2&#39;.</span>
<span class="cm"> *		This can be used to test instructions which load a PC value</span>
<span class="cm"> *		from memory.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>

<span class="cp">#include &lt;asm/opcodes.h&gt;</span>

<span class="cp">#include &quot;kprobes.h&quot;</span>
<span class="cp">#include &quot;kprobes-test.h&quot;</span>


<span class="cp">#define BENCHMARKING	1</span>


<span class="cm">/*</span>
<span class="cm"> * Test basic API</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">test_regs_ok</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">test_func_instance</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pre_handler_called</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">post_handler_called</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">jprobe_func_called</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">kretprobe_handler_called</span><span class="p">;</span>

<span class="cp">#define FUNC_ARG1 0x12345678</span>
<span class="cp">#define FUNC_ARG2 0xabcdef</span>


<span class="cp">#ifndef CONFIG_THUMB2_KERNEL</span>

<span class="kt">long</span> <span class="n">arm_func</span><span class="p">(</span><span class="kt">long</span> <span class="n">r0</span><span class="p">,</span> <span class="kt">long</span> <span class="n">r1</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__used</span> <span class="n">__naked</span> <span class="nf">__arm_kprobes_test_func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;.arm					</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;.type arm_func, %%function		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;arm_func:				</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;adds	r0, r0, r1			</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bx	lr				</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;.code &quot;</span><span class="n">NORMAL_ISA</span>	 <span class="cm">/* Back to Thumb if necessary */</span>
		<span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r0&quot;</span><span class="p">,</span> <span class="s">&quot;r1&quot;</span><span class="p">,</span> <span class="s">&quot;cc&quot;</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_THUMB2_KERNEL */</span><span class="cp"></span>

<span class="kt">long</span> <span class="n">thumb16_func</span><span class="p">(</span><span class="kt">long</span> <span class="n">r0</span><span class="p">,</span> <span class="kt">long</span> <span class="n">r1</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">thumb32even_func</span><span class="p">(</span><span class="kt">long</span> <span class="n">r0</span><span class="p">,</span> <span class="kt">long</span> <span class="n">r1</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">thumb32odd_func</span><span class="p">(</span><span class="kt">long</span> <span class="n">r0</span><span class="p">,</span> <span class="kt">long</span> <span class="n">r1</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__used</span> <span class="n">__naked</span> <span class="nf">__thumb_kprobes_test_funcs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;.type thumb16_func, %%function		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;thumb16_func:				</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;adds.n	r0, r0, r1			</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bx	lr				</span><span class="se">\n\t</span><span class="s">&quot;</span>

		<span class="s">&quot;.align					</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;.type thumb32even_func, %%function	</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;thumb32even_func:			</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;adds.w	r0, r0, r1			</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bx	lr				</span><span class="se">\n\t</span><span class="s">&quot;</span>

		<span class="s">&quot;.align					</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;nop.n					</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;.type thumb32odd_func, %%function	</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;thumb32odd_func:			</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;adds.w	r0, r0, r1			</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bx	lr				</span><span class="se">\n\t</span><span class="s">&quot;</span>

		<span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r0&quot;</span><span class="p">,</span> <span class="s">&quot;r1&quot;</span><span class="p">,</span> <span class="s">&quot;cc&quot;</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_THUMB2_KERNEL */</span><span class="cp"></span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">call_test_func</span><span class="p">(</span><span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">long</span><span class="p">,</span> <span class="kt">long</span><span class="p">),</span> <span class="n">bool</span> <span class="n">check_test_regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="o">++</span><span class="n">test_func_instance</span><span class="p">;</span>
	<span class="n">test_regs_ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">FUNC_ARG1</span><span class="p">,</span> <span class="n">FUNC_ARG2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">FUNC_ARG1</span> <span class="o">+</span> <span class="n">FUNC_ARG2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: call_test_func: func returned %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_test_regs</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_regs_ok</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: test regs not OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">pre_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pre_handler_called</span> <span class="o">=</span> <span class="n">test_func_instance</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_r0</span> <span class="o">==</span> <span class="n">FUNC_ARG1</span> <span class="o">&amp;&amp;</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_r1</span> <span class="o">==</span> <span class="n">FUNC_ARG2</span><span class="p">)</span>
		<span class="n">test_regs_ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">post_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">post_handler_called</span> <span class="o">=</span> <span class="n">test_func_instance</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_r0</span> <span class="o">!=</span> <span class="n">FUNC_ARG1</span> <span class="o">+</span> <span class="n">FUNC_ARG2</span> <span class="o">||</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_r1</span> <span class="o">!=</span> <span class="n">FUNC_ARG2</span><span class="p">)</span>
		<span class="n">test_regs_ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kprobe</span> <span class="n">the_kprobe</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">addr</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pre_handler</span>	<span class="o">=</span> <span class="n">pre_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">post_handler</span>	<span class="o">=</span> <span class="n">post_handler</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">test_kprobe</span><span class="p">(</span><span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">long</span><span class="p">,</span> <span class="kt">long</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">the_kprobe</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">func</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_kprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_kprobe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: register_kprobe failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_test_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">unregister_kprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_kprobe</span><span class="p">);</span>
	<span class="n">the_kprobe</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Clear disable flag to allow reuse */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pre_handler_called</span> <span class="o">!=</span> <span class="n">test_func_instance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: kprobe pre_handler not called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">post_handler_called</span> <span class="o">!=</span> <span class="n">test_func_instance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: kprobe post_handler not called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">call_test_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pre_handler_called</span> <span class="o">==</span> <span class="n">test_func_instance</span> <span class="o">||</span>
				<span class="n">post_handler_called</span> <span class="o">==</span> <span class="n">test_func_instance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: probe called after unregistering</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">jprobe_func</span><span class="p">(</span><span class="kt">long</span> <span class="n">r0</span><span class="p">,</span> <span class="kt">long</span> <span class="n">r1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">jprobe_func_called</span> <span class="o">=</span> <span class="n">test_func_instance</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r0</span> <span class="o">==</span> <span class="n">FUNC_ARG1</span> <span class="o">&amp;&amp;</span> <span class="n">r1</span> <span class="o">==</span> <span class="n">FUNC_ARG2</span><span class="p">)</span>
		<span class="n">test_regs_ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">jprobe_return</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">jprobe</span> <span class="n">the_jprobe</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">entry</span>		<span class="o">=</span> <span class="n">jprobe_func</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">test_jprobe</span><span class="p">(</span><span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">long</span><span class="p">,</span> <span class="kt">long</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">the_jprobe</span><span class="p">.</span><span class="n">kp</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">func</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_jprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_jprobe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: register_jprobe failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_test_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">unregister_jprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_jprobe</span><span class="p">);</span>
	<span class="n">the_jprobe</span><span class="p">.</span><span class="n">kp</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Clear disable flag to allow reuse */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jprobe_func_called</span> <span class="o">!=</span> <span class="n">test_func_instance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: jprobe handler function not called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">call_test_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jprobe_func_called</span> <span class="o">==</span> <span class="n">test_func_instance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: probe called after unregistering</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span>
<span class="nf">kretprobe_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe_instance</span> <span class="o">*</span><span class="n">ri</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kretprobe_handler_called</span> <span class="o">=</span> <span class="n">test_func_instance</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs_return_value</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">==</span> <span class="n">FUNC_ARG1</span> <span class="o">+</span> <span class="n">FUNC_ARG2</span><span class="p">)</span>
		<span class="n">test_regs_ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kretprobe</span> <span class="n">the_kretprobe</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span>	<span class="o">=</span> <span class="n">kretprobe_handler</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">test_kretprobe</span><span class="p">(</span><span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">long</span><span class="p">,</span> <span class="kt">long</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">the_kretprobe</span><span class="p">.</span><span class="n">kp</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">func</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_kretprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_kretprobe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: register_kretprobe failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_test_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">unregister_kretprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_kretprobe</span><span class="p">);</span>
	<span class="n">the_kretprobe</span><span class="p">.</span><span class="n">kp</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Clear disable flag to allow reuse */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kretprobe_handler_called</span> <span class="o">!=</span> <span class="n">test_func_instance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: kretprobe handler not called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">call_test_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jprobe_func_called</span> <span class="o">==</span> <span class="n">test_func_instance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: kretprobe called after unregistering</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">run_api_tests</span><span class="p">(</span><span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">long</span><span class="p">,</span> <span class="kt">long</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;    kprobe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">test_kprobe</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;    jprobe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">test_jprobe</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;    kretprobe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">test_kretprobe</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Benchmarking</span>
<span class="cm"> */</span>

<span class="cp">#if BENCHMARKING</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__naked</span> <span class="nf">benchmark_nop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;nop		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bx	lr&quot;</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_THUMB2_KERNEL</span>
<span class="cp">#define wide &quot;.w&quot;</span>
<span class="cp">#else</span>
<span class="cp">#define wide</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__naked</span> <span class="nf">benchmark_pushpop1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;stmdb&quot;</span><span class="n">wide</span><span class="s">&quot;	sp!, {r3-r11,lr}  </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;ldmia&quot;</span><span class="n">wide</span><span class="s">&quot;	sp!, {r3-r11,pc}&quot;</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__naked</span> <span class="nf">benchmark_pushpop2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;stmdb&quot;</span><span class="n">wide</span><span class="s">&quot;	sp!, {r0-r8,lr}  </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;ldmia&quot;</span><span class="n">wide</span><span class="s">&quot;	sp!, {r0-r8,pc}&quot;</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__naked</span> <span class="nf">benchmark_pushpop3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;stmdb&quot;</span><span class="n">wide</span><span class="s">&quot;	sp!, {r4,lr}  </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;ldmia&quot;</span><span class="n">wide</span><span class="s">&quot;	sp!, {r4,pc}&quot;</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__naked</span> <span class="nf">benchmark_pushpop4</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;stmdb&quot;</span><span class="n">wide</span><span class="s">&quot;	sp!, {r0,lr}  </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;ldmia&quot;</span><span class="n">wide</span><span class="s">&quot;	sp!, {r0,pc}&quot;</span>
	<span class="p">);</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_THUMB2_KERNEL</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__naked</span> <span class="nf">benchmark_pushpop_thumb</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;push.n	{r0-r7,lr}  </span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;pop.n	{r0-r7,pc}&quot;</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span>
<span class="nf">benchmark_pre_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">benchmark</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="p">;</span> <span class="n">n</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t0</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
			<span class="n">fn</span><span class="p">();</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">250000000</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span> <span class="cm">/* Stop once we took more than 0.25 seconds */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">t</span> <span class="o">/</span> <span class="n">n</span><span class="p">;</span> <span class="cm">/* Time for one iteration in nanoseconds */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kprobe_benchmark</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span><span class="p">),</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="n">k</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">addr</span>		<span class="o">=</span> <span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">fn</span> <span class="o">+</span> <span class="n">offset</span><span class="p">),</span>
		<span class="p">.</span><span class="n">pre_handler</span>	<span class="o">=</span> <span class="n">benchmark_pre_handler</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">register_kprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: register_kprobe failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">benchmark</span><span class="p">(</span><span class="n">fn</span><span class="p">);</span>

	<span class="n">unregister_kprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">benchmarks</span> <span class="p">{</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">offset</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">title</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">run_benchmarks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">benchmarks</span> <span class="n">list</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span><span class="o">&amp;</span><span class="n">benchmark_nop</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;nop&quot;</span><span class="p">},</span>
		<span class="cm">/*</span>
<span class="cm">		 * benchmark_pushpop{1,3} will have the optimised</span>
<span class="cm">		 * instruction emulation, whilst benchmark_pushpop{2,4} will</span>
<span class="cm">		 * be the equivalent unoptimised instructions.</span>
<span class="cm">		 */</span>
		<span class="p">{</span><span class="o">&amp;</span><span class="n">benchmark_pushpop1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;stmdb	sp!, {r3-r11,lr}&quot;</span><span class="p">},</span>
		<span class="p">{</span><span class="o">&amp;</span><span class="n">benchmark_pushpop1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;ldmia	sp!, {r3-r11,pc}&quot;</span><span class="p">},</span>
		<span class="p">{</span><span class="o">&amp;</span><span class="n">benchmark_pushpop2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;stmdb	sp!, {r0-r8,lr}&quot;</span><span class="p">},</span>
		<span class="p">{</span><span class="o">&amp;</span><span class="n">benchmark_pushpop2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;ldmia	sp!, {r0-r8,pc}&quot;</span><span class="p">},</span>
		<span class="p">{</span><span class="o">&amp;</span><span class="n">benchmark_pushpop3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;stmdb	sp!, {r4,lr}&quot;</span><span class="p">},</span>
		<span class="p">{</span><span class="o">&amp;</span><span class="n">benchmark_pushpop3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;ldmia	sp!, {r4,pc}&quot;</span><span class="p">},</span>
		<span class="p">{</span><span class="o">&amp;</span><span class="n">benchmark_pushpop4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;stmdb	sp!, {r0,lr}&quot;</span><span class="p">},</span>
		<span class="p">{</span><span class="o">&amp;</span><span class="n">benchmark_pushpop4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;ldmia	sp!, {r0,pc}&quot;</span><span class="p">},</span>
<span class="cp">#ifdef CONFIG_THUMB2_KERNEL</span>
		<span class="p">{</span><span class="o">&amp;</span><span class="n">benchmark_pushpop_thumb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;push.n	{r0-r7,lr}&quot;</span><span class="p">},</span>
		<span class="p">{</span><span class="o">&amp;</span><span class="n">benchmark_pushpop_thumb</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;pop.n	{r0-r7,pc}&quot;</span><span class="p">},</span>
<span class="cp">#endif</span>
		<span class="p">{</span><span class="mi">0</span><span class="p">}</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">benchmarks</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">;</span> <span class="o">++</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kprobe_benchmark</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;    %dns for kprobe %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">title</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* BENCHMARKING */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * Decoding table self-consistency tests</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">decode_struct_sizes</span><span class="p">[</span><span class="n">NUM_DECODE_TYPES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">DECODE_TYPE_TABLE</span><span class="p">]</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">decode_table</span><span class="p">),</span>
	<span class="p">[</span><span class="n">DECODE_TYPE_CUSTOM</span><span class="p">]</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">decode_custom</span><span class="p">),</span>
	<span class="p">[</span><span class="n">DECODE_TYPE_SIMULATE</span><span class="p">]</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">decode_simulate</span><span class="p">),</span>
	<span class="p">[</span><span class="n">DECODE_TYPE_EMULATE</span><span class="p">]</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">decode_emulate</span><span class="p">),</span>
	<span class="p">[</span><span class="n">DECODE_TYPE_OR</span><span class="p">]</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">decode_or</span><span class="p">),</span>
	<span class="p">[</span><span class="n">DECODE_TYPE_REJECT</span><span class="p">]</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">decode_reject</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">table_iter</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">decode_item</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span>
			<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">decode_header</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">decode_header</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">decode_header</span> <span class="o">*</span><span class="p">)</span><span class="n">table</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">decode_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">type_regs</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">DECODE_TYPE_MASK</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">DECODE_TYPE_END</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

		<span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">decode_header</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">h</span> <span class="o">+</span> <span class="n">decode_struct_sizes</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>

	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">table_test_fail</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">decode_header</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">message</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: kprobes test failure </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> (mask %08x, value %08x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">message</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">table_test_args</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">union</span> <span class="n">decode_item</span> <span class="o">*</span><span class="n">root_table</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">parent_mask</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">parent_value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">table_test_fn</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">decode_header</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">table_test_args</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">table_test_args</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">decode_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">type_regs</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">DECODE_TYPE_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">table_test_fail</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="s">&quot;Match value has bits not in mask&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">parent_mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">parent_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">table_test_fail</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="s">&quot;Mask has bits not in parent mask&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">bits</span> <span class="o">^</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">parent_value</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">parent_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">table_test_fail</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="s">&quot;Value is inconsistent with parent&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">DECODE_TYPE_TABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">decode_table</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">decode_table</span> <span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">table_test_args</span> <span class="n">args2</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
		<span class="n">args2</span><span class="p">.</span><span class="n">parent_mask</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
		<span class="n">args2</span><span class="p">.</span><span class="n">parent_value</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">table_iter</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">table</span><span class="p">,</span> <span class="n">table_test_fn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">table_test</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">decode_item</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">table_test_args</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">root_table</span>	<span class="o">=</span> <span class="n">table</span><span class="p">,</span>
		<span class="p">.</span><span class="n">parent_mask</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">parent_value</span>	<span class="o">=</span> <span class="mi">0</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="n">table_iter</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">root_table</span><span class="p">,</span> <span class="n">table_test_fn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Decoding table test coverage analysis</span>
<span class="cm"> *</span>
<span class="cm"> * coverage_start() builds a coverage_table which contains a list of</span>
<span class="cm"> * coverage_entry&#39;s to match each entry in the specified kprobes instruction</span>
<span class="cm"> * decoding table.</span>
<span class="cm"> *</span>
<span class="cm"> * When test cases are run, coverage_add() is called to process each case.</span>
<span class="cm"> * This looks up the corresponding entry in the coverage_table and sets it as</span>
<span class="cm"> * being matched, as well as clearing the regs flag appropriate for the test.</span>
<span class="cm"> *</span>
<span class="cm"> * After all test cases have been run, coverage_end() is called to check that</span>
<span class="cm"> * all entries in coverage_table have been matched and that all regs flags are</span>
<span class="cm"> * cleared. I.e. that all possible combinations of instructions described by</span>
<span class="cm"> * the kprobes decoding tables have had a test case executed for them.</span>
<span class="cm"> */</span>

<span class="n">bool</span> <span class="n">coverage_fail</span><span class="p">;</span>

<span class="cp">#define MAX_COVERAGE_ENTRIES 256</span>

<span class="k">struct</span> <span class="n">coverage_entry</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">decode_header</span>	<span class="o">*</span><span class="n">header</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">regs</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">nesting</span><span class="p">;</span>
	<span class="kt">char</span>				<span class="n">matched</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">coverage_table</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">coverage_entry</span>	<span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">num_entries</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">nesting</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">coverage_table</span> <span class="n">coverage</span><span class="p">;</span>

<span class="cp">#define COVERAGE_ANY_REG	(1&lt;&lt;0)</span>
<span class="cp">#define COVERAGE_SP		(1&lt;&lt;1)</span>
<span class="cp">#define COVERAGE_PC		(1&lt;&lt;2)</span>
<span class="cp">#define COVERAGE_PCWB		(1&lt;&lt;3)</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">coverage_register_lookup</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">REG_TYPE_ANY</span><span class="p">]</span>		<span class="o">=</span> <span class="n">COVERAGE_ANY_REG</span> <span class="o">|</span> <span class="n">COVERAGE_SP</span> <span class="o">|</span> <span class="n">COVERAGE_PC</span><span class="p">,</span>
	<span class="p">[</span><span class="n">REG_TYPE_SAMEAS16</span><span class="p">]</span>	<span class="o">=</span> <span class="n">COVERAGE_ANY_REG</span><span class="p">,</span>
	<span class="p">[</span><span class="n">REG_TYPE_SP</span><span class="p">]</span>		<span class="o">=</span> <span class="n">COVERAGE_SP</span><span class="p">,</span>
	<span class="p">[</span><span class="n">REG_TYPE_PC</span><span class="p">]</span>		<span class="o">=</span> <span class="n">COVERAGE_PC</span><span class="p">,</span>
	<span class="p">[</span><span class="n">REG_TYPE_NOSP</span><span class="p">]</span>		<span class="o">=</span> <span class="n">COVERAGE_ANY_REG</span> <span class="o">|</span> <span class="n">COVERAGE_SP</span><span class="p">,</span>
	<span class="p">[</span><span class="n">REG_TYPE_NOSPPC</span><span class="p">]</span>	<span class="o">=</span> <span class="n">COVERAGE_ANY_REG</span> <span class="o">|</span> <span class="n">COVERAGE_SP</span> <span class="o">|</span> <span class="n">COVERAGE_PC</span><span class="p">,</span>
	<span class="p">[</span><span class="n">REG_TYPE_NOPC</span><span class="p">]</span>		<span class="o">=</span> <span class="n">COVERAGE_ANY_REG</span> <span class="o">|</span> <span class="n">COVERAGE_PC</span><span class="p">,</span>
	<span class="p">[</span><span class="n">REG_TYPE_NOPCWB</span><span class="p">]</span>	<span class="o">=</span> <span class="n">COVERAGE_ANY_REG</span> <span class="o">|</span> <span class="n">COVERAGE_PC</span> <span class="o">|</span> <span class="n">COVERAGE_PCWB</span><span class="p">,</span>
	<span class="p">[</span><span class="n">REG_TYPE_NOPCX</span><span class="p">]</span>	<span class="o">=</span> <span class="n">COVERAGE_ANY_REG</span><span class="p">,</span>
	<span class="p">[</span><span class="n">REG_TYPE_NOSPPCX</span><span class="p">]</span>	<span class="o">=</span> <span class="n">COVERAGE_ANY_REG</span> <span class="o">|</span> <span class="n">COVERAGE_SP</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">unsigned</span> <span class="nf">coverage_start_registers</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">decode_header</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">regs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">type_regs</span><span class="p">.</span><span class="n">bits</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">DECODE_TYPE_BITS</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="n">regs</span> <span class="o">|=</span> <span class="n">coverage_register_lookup</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">regs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">coverage_start_fn</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">decode_header</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">coverage_table</span> <span class="o">*</span><span class="n">coverage</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">coverage_table</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">decode_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">type_regs</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">DECODE_TYPE_MASK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">coverage_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">coverage</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">coverage</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">coverage</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">==</span> <span class="n">MAX_COVERAGE_ENTRIES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: Out of space for test coverage data&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">++</span><span class="n">coverage</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="p">;</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">header</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">coverage_start_registers</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">nesting</span> <span class="o">=</span> <span class="n">coverage</span><span class="o">-&gt;</span><span class="n">nesting</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">matched</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">DECODE_TYPE_TABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">decode_table</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">decode_table</span> <span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
		<span class="o">++</span><span class="n">coverage</span><span class="o">-&gt;</span><span class="n">nesting</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">table_iter</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">table</span><span class="p">,</span> <span class="n">coverage_start_fn</span><span class="p">,</span> <span class="n">coverage</span><span class="p">);</span>
		<span class="o">--</span><span class="n">coverage</span><span class="o">-&gt;</span><span class="n">nesting</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">coverage_start</span><span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">decode_item</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">coverage</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">MAX_COVERAGE_ENTRIES</span> <span class="o">*</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">coverage_entry</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">coverage</span><span class="p">.</span><span class="n">num_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">coverage</span><span class="p">.</span><span class="n">nesting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">table_iter</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">coverage_start_fn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">coverage</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">coverage_add_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">coverage_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="n">kprobe_opcode_t</span> <span class="n">insn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">regs</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">type_regs</span><span class="p">.</span><span class="n">bits</span> <span class="o">&gt;&gt;</span> <span class="n">DECODE_TYPE_BITS</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">decode_reg_type</span> <span class="n">reg_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">regs</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">insn</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reg_type</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="mi">13</span><span class="p">)</span>
			<span class="n">flag</span> <span class="o">=</span> <span class="n">COVERAGE_SP</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span>
			<span class="n">flag</span> <span class="o">=</span> <span class="n">COVERAGE_PC</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">flag</span> <span class="o">=</span> <span class="n">COVERAGE_ANY_REG</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">flag</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">reg_type</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">REG_TYPE_NONE</span>:
		<span class="k">case</span> <span class="n">REG_TYPE_ANY</span>:
		<span class="k">case</span> <span class="n">REG_TYPE_SAMEAS16</span>:
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">REG_TYPE_SP</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">!=</span> <span class="mi">13</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">REG_TYPE_PC</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">!=</span> <span class="mi">15</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">REG_TYPE_NOSP</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="mi">13</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">REG_TYPE_NOSPPC</span>:
		<span class="k">case</span> <span class="n">REG_TYPE_NOSPPCX</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="mi">13</span> <span class="o">||</span> <span class="n">reg</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">REG_TYPE_NOPCWB</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_writeback</span><span class="p">(</span><span class="n">insn</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">entry</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">COVERAGE_PCWB</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">REG_TYPE_NOPC</span>:
		<span class="k">case</span> <span class="n">REG_TYPE_NOPCX</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">coverage_add</span><span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="n">insn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">coverage_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">coverage</span><span class="p">.</span><span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">coverage_entry</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">coverage</span><span class="p">.</span><span class="n">base</span> <span class="o">+</span> <span class="n">coverage</span><span class="p">.</span><span class="n">num_entries</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">matched</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">nesting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">entry</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">decode_header</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
		<span class="k">enum</span> <span class="n">decode_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">type_regs</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">DECODE_TYPE_MASK</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nesting</span> <span class="o">&gt;</span> <span class="n">nesting</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span> <span class="cm">/* Skip sub-table we didn&#39;t match */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nesting</span> <span class="o">&lt;</span> <span class="n">nesting</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span> <span class="cm">/* End of sub-table we were scanning */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">matched</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span> <span class="o">!=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">matched</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">DECODE_TYPE_TABLE</span>:
			<span class="o">++</span><span class="n">nesting</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">DECODE_TYPE_CUSTOM</span>:
		<span class="k">case</span> <span class="n">DECODE_TYPE_SIMULATE</span>:
		<span class="k">case</span> <span class="n">DECODE_TYPE_EMULATE</span>:
			<span class="n">coverage_add_registers</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">insn</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">DECODE_TYPE_OR</span>:
			<span class="n">matched</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">DECODE_TYPE_REJECT</span>:
		<span class="nl">default:</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">coverage_end</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">coverage_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">coverage</span><span class="p">.</span><span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">coverage_entry</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">coverage</span><span class="p">.</span><span class="n">base</span> <span class="o">+</span> <span class="n">coverage</span><span class="p">.</span><span class="n">num_entries</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">entry</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">value</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: Register test coverage missing for %08x %08x (%05x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mask</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
			<span class="n">coverage_fail</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">matched</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: Test coverage entry missing for %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mask</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
			<span class="n">coverage_fail</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">coverage</span><span class="p">.</span><span class="n">base</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Framework for instruction set test cases</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="n">__naked</span> <span class="nf">__kprobes_test_case_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;stmdb	sp!, {r4-r11}				</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;sub	sp, sp, #&quot;</span><span class="n">__stringify</span><span class="p">(</span><span class="n">TEST_MEMORY_SIZE</span><span class="p">)</span><span class="s">&quot;</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bic	r0, lr, #1  @ r0 = inline title string	</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov	r1, sp					</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bl	kprobes_test_case_start			</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bx	r0					</span><span class="se">\n\t</span><span class="s">&quot;</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_THUMB2_KERNEL</span>

<span class="kt">void</span> <span class="n">__naked</span> <span class="nf">__kprobes_test_case_end_32</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;mov	r4, lr					</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bl	kprobes_test_case_end			</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;cmp	r0, #0					</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;movne	pc, r0					</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov	r0, r4					</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;add	sp, sp, #&quot;</span><span class="n">__stringify</span><span class="p">(</span><span class="n">TEST_MEMORY_SIZE</span><span class="p">)</span><span class="s">&quot;</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;ldmia	sp!, {r4-r11}				</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov	pc, r0					</span><span class="se">\n\t</span><span class="s">&quot;</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_THUMB2_KERNEL */</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">__naked</span> <span class="nf">__kprobes_test_case_end_16</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;mov	r4, lr					</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bl	kprobes_test_case_end			</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;cmp	r0, #0					</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bxne	r0					</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;mov	r0, r4					</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;add	sp, sp, #&quot;</span><span class="n">__stringify</span><span class="p">(</span><span class="n">TEST_MEMORY_SIZE</span><span class="p">)</span><span class="s">&quot;</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;ldmia	sp!, {r4-r11}				</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;bx	r0					</span><span class="se">\n\t</span><span class="s">&quot;</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__naked</span> <span class="nf">__kprobes_test_case_end_32</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;.arm						</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;orr	lr, lr, #1  @ will return to Thumb code	</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;ldr	pc, 1f					</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;1:						</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;.word	__kprobes_test_case_end_16		</span><span class="se">\n\t</span><span class="s">&quot;</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>


<span class="kt">int</span> <span class="n">kprobe_test_flags</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">kprobe_test_cc_position</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">test_try_count</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">test_pass_count</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">test_fail_count</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="n">initial_regs</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="n">expected_regs</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="n">result_regs</span><span class="p">;</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">expected_memory</span><span class="p">[</span><span class="n">TEST_MEMORY_SIZE</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)];</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">current_title</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">test_arg</span> <span class="o">*</span><span class="n">current_args</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="o">*</span><span class="n">current_stack</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">uintptr_t</span> <span class="n">current_branch_target</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">uintptr_t</span> <span class="n">current_code_start</span><span class="p">;</span>
<span class="k">static</span> <span class="n">kprobe_opcode_t</span> <span class="n">current_instruction</span><span class="p">;</span>


<span class="cp">#define TEST_CASE_PASSED -1</span>
<span class="cp">#define TEST_CASE_FAILED -2</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">test_case_run_count</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">test_case_is_thumb</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">test_instance</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * We ignore the state of the imprecise abort disable flag (CPSR.A) because this</span>
<span class="cm"> * can change randomly as the kernel doesn&#39;t take care to preserve or initialise</span>
<span class="cm"> * this across context switches. Also, with Security Extentions, the flag may</span>
<span class="cm"> * not be under control of the kernel; for this reason we ignore the state of</span>
<span class="cm"> * the FIQ disable flag CPSR.F as well.</span>
<span class="cm"> */</span>
<span class="cp">#define PSR_IGNORE_BITS (PSR_A_BIT | PSR_F_BIT)</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">test_check_cc</span><span class="p">(</span><span class="kt">int</span> <span class="n">cc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">arm_check_condition</span><span class="p">(</span><span class="n">cc</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">,</span> <span class="n">cpsr</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">ARM_OPCODE_CONDTEST_FAIL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">is_last_scenario</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">probe_should_run</span><span class="p">;</span> <span class="cm">/* 0 = no, 1 = yes, -1 = unknown */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">memory_needs_checking</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">test_context_cpsr</span><span class="p">(</span><span class="kt">int</span> <span class="n">scenario</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">;</span>

	<span class="n">probe_should_run</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Default case is that we cycle through 16 combinations of flags */</span>
	<span class="n">cpsr</span>  <span class="o">=</span> <span class="p">(</span><span class="n">scenario</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">;</span> <span class="cm">/* N,Z,C,V flags */</span>
	<span class="n">cpsr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">scenario</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="cm">/* GE flags */</span>
	<span class="n">cpsr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">scenario</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">;</span> <span class="cm">/* Toggle Q flag */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_case_is_thumb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Testing ARM code */</span>
		<span class="kt">int</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">current_instruction</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">;</span>

		<span class="n">probe_should_run</span> <span class="o">=</span> <span class="n">test_check_cc</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cpsr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scenario</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span>
			<span class="n">is_last_scenario</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">kprobe_test_flags</span> <span class="o">&amp;</span> <span class="n">TEST_FLAG_NO_ITBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Testing Thumb code without setting ITSTATE */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_test_cc_position</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">cc</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_instruction</span> <span class="o">&gt;&gt;</span> <span class="n">kprobe_test_cc_position</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
			<span class="n">probe_should_run</span> <span class="o">=</span> <span class="n">test_check_cc</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">cpsr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">scenario</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span>
			<span class="n">is_last_scenario</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">kprobe_test_flags</span> <span class="o">&amp;</span> <span class="n">TEST_FLAG_FULL_ITBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Testing Thumb code with all combinations of ITSTATE */</span>
		<span class="kt">unsigned</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">scenario</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="n">cond_base</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">7</span><span class="p">;</span> <span class="cm">/* ITSTATE&lt;7:5&gt; */</span>
		<span class="kt">unsigned</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>  <span class="cm">/* ITSTATE&lt;4:0&gt;, bits reversed */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Finish by testing state from instruction &#39;itt al&#39; */</span>
			<span class="n">cond_base</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">scenario</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xf</span><span class="p">)</span>
				<span class="n">is_last_scenario</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cpsr</span> <span class="o">|=</span> <span class="n">cond_base</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">;</span>	<span class="cm">/* ITSTATE&lt;7:5&gt; */</span>
		<span class="n">cpsr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">;</span>	<span class="cm">/* ITSTATE&lt;4&gt; */</span>
		<span class="n">cpsr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">;</span>	<span class="cm">/* ITSTATE&lt;3&gt; */</span>
		<span class="n">cpsr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>	<span class="cm">/* ITSTATE&lt;2&gt; */</span>
		<span class="n">cpsr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">;</span>	<span class="cm">/* ITSTATE&lt;1&gt; */</span>
		<span class="n">cpsr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">;</span>	<span class="cm">/* ITSTATE&lt;0&gt; */</span>

		<span class="n">probe_should_run</span> <span class="o">=</span> <span class="n">test_check_cc</span><span class="p">((</span><span class="n">cpsr</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">,</span> <span class="n">cpsr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Testing Thumb code with several combinations of ITSTATE */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">scenario</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">16</span>: <span class="cm">/* Clear NZCV flags and &#39;it eq&#39; state (false as Z=0) */</span>
			<span class="n">cpsr</span> <span class="o">=</span> <span class="mh">0x00000800</span><span class="p">;</span>
			<span class="n">probe_should_run</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">17</span>: <span class="cm">/* Set NZCV flags and &#39;it vc&#39; state (false as V=1) */</span>
			<span class="n">cpsr</span> <span class="o">=</span> <span class="mh">0xf0007800</span><span class="p">;</span>
			<span class="n">probe_should_run</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">18</span>: <span class="cm">/* Clear NZCV flags and &#39;it ls&#39; state (true as C=0) */</span>
			<span class="n">cpsr</span> <span class="o">=</span> <span class="mh">0x00009800</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">19</span>: <span class="cm">/* Set NZCV flags and &#39;it cs&#39; state (true as C=1) */</span>
			<span class="n">cpsr</span> <span class="o">=</span> <span class="mh">0xf0002800</span><span class="p">;</span>
			<span class="n">is_last_scenario</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cpsr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_test_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">scenario</span> <span class="o">=</span> <span class="n">test_case_run_count</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">test_arg</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">is_last_scenario</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">memory_needs_checking</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Initialise test memory on stack */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">scenario</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">VALM</span> <span class="o">:</span> <span class="o">~</span><span class="n">VALM</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TEST_MEMORY_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">current_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">current_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="cm">/* Put target of branch on stack for tests which load PC from memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_branch_target</span><span class="p">)</span>
		<span class="n">current_stack</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_branch_target</span><span class="p">;</span>
	<span class="cm">/* Put a value for SP on stack for tests which load SP from memory */</span>
	<span class="n">current_stack</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">current_stack</span> <span class="o">+</span> <span class="mi">120</span><span class="p">;</span>

	<span class="cm">/* Initialise register values to their default state */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">scenario</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="n">VALR</span> <span class="o">:</span> <span class="o">~</span><span class="n">VALR</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">13</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">^</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_lr</span> <span class="o">=</span> <span class="n">val</span> <span class="o">^</span> <span class="p">(</span><span class="mi">14</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_cpsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">APSR_MASK</span> <span class="o">|</span> <span class="n">PSR_IT_MASK</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_cpsr</span> <span class="o">|=</span> <span class="n">test_context_cpsr</span><span class="p">(</span><span class="n">scenario</span><span class="p">);</span>

	<span class="cm">/* Perform testcase specific register setup  */</span>
	<span class="n">args</span> <span class="o">=</span> <span class="n">current_args</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARG_TYPE_END</span><span class="p">;</span> <span class="o">++</span><span class="n">args</span><span class="p">)</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ARG_TYPE_REG</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">test_arg_regptr</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">test_arg_regptr</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="p">;</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">ARG_TYPE_PTR</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">test_arg_regptr</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">test_arg_regptr</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="p">;</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">]</span> <span class="o">=</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">current_stack</span> <span class="o">+</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
			<span class="n">memory_needs_checking</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">ARG_TYPE_MEM</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">test_arg_mem</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">test_arg_mem</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="p">;</span>
			<span class="n">current_stack</span><span class="p">[</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">test_probe</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span>	<span class="n">kprobe</span><span class="p">;</span>
	<span class="n">bool</span>		<span class="n">registered</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">hit</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unregister_test_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">test_probe</span> <span class="o">*</span><span class="n">probe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">probe</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unregister_kprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">probe</span><span class="o">-&gt;</span><span class="n">kprobe</span><span class="p">);</span>
		<span class="n">probe</span><span class="o">-&gt;</span><span class="n">kprobe</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Clear disable flag to allow reuse */</span>
	<span class="p">}</span>
	<span class="n">probe</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">register_test_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">test_probe</span> <span class="o">*</span><span class="n">probe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">probe</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_kprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">probe</span><span class="o">-&gt;</span><span class="n">kprobe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">probe</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">probe</span><span class="o">-&gt;</span><span class="n">hit</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span>
<span class="nf">test_before_pre_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">test_probe</span><span class="p">,</span> <span class="n">kprobe</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hit</span> <span class="o">=</span> <span class="n">test_instance</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span>
<span class="nf">test_before_post_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
							<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setup_test_context</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">initial_regs</span> <span class="o">=</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">initial_regs</span><span class="p">.</span><span class="n">ARM_cpsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PSR_IGNORE_BITS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span>
<span class="nf">test_case_pre_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">test_probe</span><span class="p">,</span> <span class="n">kprobe</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hit</span> <span class="o">=</span> <span class="n">test_instance</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span>
<span class="nf">test_after_pre_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">test_probe</span><span class="p">,</span> <span class="n">kprobe</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hit</span> <span class="o">==</span> <span class="n">test_instance</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Already run for this test instance */</span>

	<span class="n">result_regs</span> <span class="o">=</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">result_regs</span><span class="p">.</span><span class="n">ARM_cpsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PSR_IGNORE_BITS</span><span class="p">;</span>

	<span class="cm">/* Undo any changes done to SP by the test case */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_sp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">current_stack</span><span class="p">;</span>

	<span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">test_probe</span><span class="p">,</span> <span class="n">kprobe</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hit</span> <span class="o">=</span> <span class="n">test_instance</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">test_probe</span> <span class="n">test_before_probe</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">kprobe</span><span class="p">.</span><span class="n">pre_handler</span>	<span class="o">=</span> <span class="n">test_before_pre_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kprobe</span><span class="p">.</span><span class="n">post_handler</span>	<span class="o">=</span> <span class="n">test_before_post_handler</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">test_probe</span> <span class="n">test_case_probe</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">kprobe</span><span class="p">.</span><span class="n">pre_handler</span>	<span class="o">=</span> <span class="n">test_case_pre_handler</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">test_probe</span> <span class="n">test_after_probe</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">kprobe</span><span class="p">.</span><span class="n">pre_handler</span>	<span class="o">=</span> <span class="n">test_after_pre_handler</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">test_probe</span> <span class="n">test_after2_probe</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">kprobe</span><span class="p">.</span><span class="n">pre_handler</span>	<span class="o">=</span> <span class="n">test_after_pre_handler</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">test_case_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_test_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_before_probe</span><span class="p">);</span>
	<span class="n">unregister_test_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_case_probe</span><span class="p">);</span>
	<span class="n">unregister_test_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_after_probe</span><span class="p">);</span>
	<span class="n">unregister_test_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_after2_probe</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;r0  %08lx | r1  %08lx | r2  %08lx | r3  %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_r0</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_r1</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_r2</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_r3</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;r4  %08lx | r5  %08lx | r6  %08lx | r7  %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_r4</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_r5</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_r6</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_r7</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;r8  %08lx | r9  %08lx | r10 %08lx | r11 %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_r8</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_r9</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_r10</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_fp</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;r12 %08lx | sp  %08lx | lr  %08lx | pc  %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_ip</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_sp</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_lr</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_pc</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;cpsr %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_cpsr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_memory</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%08x %08x %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mem</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
						<span class="n">mem</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="n">mem</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">expected_memory_size</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">expected_memory</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">sp</span> <span class="o">-</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">current_stack</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">test_case_failed</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">test_case_cleanup</span><span class="p">();</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: Test %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current_title</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: Scenario %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">test_case_run_count</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">next_instruction</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_THUMB2_KERNEL</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pc</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_wide_instruction</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)(</span><span class="n">pc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">pc</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">pc</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uintptr_t</span> <span class="n">__used</span> <span class="nf">kprobes_test_case_start</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">title</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">stack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">test_arg</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">test_arg_end</span> <span class="o">*</span><span class="n">end_arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">test_code</span><span class="p">;</span>

	<span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">test_arg</span> <span class="o">*</span><span class="p">)</span><span class="n">PTR_ALIGN</span><span class="p">(</span><span class="n">title</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">title</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">current_title</span> <span class="o">=</span> <span class="n">title</span><span class="p">;</span>
	<span class="n">current_args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
	<span class="n">current_stack</span> <span class="o">=</span> <span class="n">stack</span><span class="p">;</span>

	<span class="o">++</span><span class="n">test_try_count</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARG_TYPE_END</span><span class="p">)</span>
		<span class="o">++</span><span class="n">args</span><span class="p">;</span>
	<span class="n">end_arg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">test_arg_end</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="p">;</span>

	<span class="n">test_code</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">args</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* Code starts after args */</span>

	<span class="n">test_case_is_thumb</span> <span class="o">=</span> <span class="n">end_arg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ARG_FLAG_THUMB</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_case_is_thumb</span><span class="p">)</span>
		<span class="n">test_code</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">current_code_start</span> <span class="o">=</span> <span class="n">test_code</span><span class="p">;</span>

	<span class="n">current_branch_target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end_arg</span><span class="o">-&gt;</span><span class="n">branch_offset</span> <span class="o">!=</span> <span class="n">end_arg</span><span class="o">-&gt;</span><span class="n">end_offset</span><span class="p">)</span>
		<span class="n">current_branch_target</span> <span class="o">=</span> <span class="n">test_code</span> <span class="o">+</span> <span class="n">end_arg</span><span class="o">-&gt;</span><span class="n">branch_offset</span><span class="p">;</span>

	<span class="n">test_code</span> <span class="o">+=</span> <span class="n">end_arg</span><span class="o">-&gt;</span><span class="n">code_offset</span><span class="p">;</span>
	<span class="n">test_before_probe</span><span class="p">.</span><span class="n">kprobe</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">test_code</span><span class="p">;</span>

	<span class="n">test_code</span> <span class="o">=</span> <span class="n">next_instruction</span><span class="p">(</span><span class="n">test_code</span><span class="p">);</span>
	<span class="n">test_case_probe</span><span class="p">.</span><span class="n">kprobe</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">test_code</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_case_is_thumb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)(</span><span class="n">test_code</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">current_instruction</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_wide_instruction</span><span class="p">(</span><span class="n">current_instruction</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">current_instruction</span> <span class="o">&lt;&lt;=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">current_instruction</span> <span class="o">|=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">current_instruction</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">test_code</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current_title</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span>
		<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current_title</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">verbose</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\t</span><span class="s">@ %0*x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current_title</span><span class="p">,</span>
					<span class="n">test_case_is_thumb</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">8</span><span class="p">,</span>
					<span class="n">current_instruction</span><span class="p">);</span>

	<span class="n">test_code</span> <span class="o">=</span> <span class="n">next_instruction</span><span class="p">(</span><span class="n">test_code</span><span class="p">);</span>
	<span class="n">test_after_probe</span><span class="p">.</span><span class="n">kprobe</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">test_code</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_test_flags</span> <span class="o">&amp;</span> <span class="n">TEST_FLAG_NARROW_INSTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_case_is_thumb</span> <span class="o">||</span>
			<span class="n">is_wide_instruction</span><span class="p">(</span><span class="n">current_instruction</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">test_case_failed</span><span class="p">(</span><span class="s">&quot;expected 16-bit instruction&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_case_is_thumb</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">is_wide_instruction</span><span class="p">(</span><span class="n">current_instruction</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">test_case_failed</span><span class="p">(</span><span class="s">&quot;expected 32-bit instruction&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">coverage_add</span><span class="p">(</span><span class="n">current_instruction</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end_arg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ARG_FLAG_UNSUPPORTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">register_test_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_case_probe</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">pass</span><span class="p">;</span>
		<span class="n">test_case_failed</span><span class="p">(</span><span class="s">&quot;registered probe for unsupported instruction&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end_arg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ARG_FLAG_SUPPORTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">register_test_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_case_probe</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">pass</span><span class="p">;</span>
		<span class="n">test_case_failed</span><span class="p">(</span><span class="s">&quot;couldn&#39;t register probe for supported instruction&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">register_test_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_before_probe</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">test_case_failed</span><span class="p">(</span><span class="s">&quot;register test_before_probe failed&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">register_test_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_after_probe</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">test_case_failed</span><span class="p">(</span><span class="s">&quot;register test_after_probe failed&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_branch_target</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">test_after2_probe</span><span class="p">.</span><span class="n">kprobe</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">current_branch_target</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">register_test_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_after2_probe</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">test_case_failed</span><span class="p">(</span><span class="s">&quot;register test_after2_probe failed&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Start first run of test case */</span>
	<span class="n">test_case_run_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">++</span><span class="n">test_instance</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">current_code_start</span><span class="p">;</span>
<span class="nl">pass:</span>
	<span class="n">test_case_run_count</span> <span class="o">=</span> <span class="n">TEST_CASE_PASSED</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">test_after_probe</span><span class="p">.</span><span class="n">kprobe</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">test_case_run_count</span> <span class="o">=</span> <span class="n">TEST_CASE_FAILED</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">test_after_probe</span><span class="p">.</span><span class="n">kprobe</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">check_test_results</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">mem_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">expected_regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result_regs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">expected_regs</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">test_case_failed</span><span class="p">(</span><span class="s">&quot;registers differ&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memory_needs_checking</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mem</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">result_regs</span><span class="p">.</span><span class="n">ARM_sp</span><span class="p">;</span>
		<span class="n">mem_size</span> <span class="o">=</span> <span class="n">expected_memory_size</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">expected_memory</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">test_case_failed</span><span class="p">(</span><span class="s">&quot;test memory differs&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;initial_regs:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_registers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">initial_regs</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;expected_regs:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_registers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">expected_regs</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;result_regs:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_registers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result_regs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;current_stack=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current_stack</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;expected_memory:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">print_memory</span><span class="p">(</span><span class="n">expected_memory</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;result_memory:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">print_memory</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uintptr_t</span> <span class="n">__used</span> <span class="nf">kprobes_test_case_end</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_case_run_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_case_run_count</span> <span class="o">==</span> <span class="n">TEST_CASE_PASSED</span><span class="p">)</span>
			<span class="cm">/* kprobes_test_case_start did all the needed testing */</span>
			<span class="k">goto</span> <span class="n">pass</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* kprobes_test_case_start failed */</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_before_probe</span><span class="p">.</span><span class="n">hit</span> <span class="o">!=</span> <span class="n">test_instance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">test_case_failed</span><span class="p">(</span><span class="s">&quot;test_before_handler not run&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_after_probe</span><span class="p">.</span><span class="n">hit</span> <span class="o">!=</span> <span class="n">test_instance</span> <span class="o">&amp;&amp;</span>
				<span class="n">test_after2_probe</span><span class="p">.</span><span class="n">hit</span> <span class="o">!=</span> <span class="n">test_instance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">test_case_failed</span><span class="p">(</span><span class="s">&quot;test_after_handler not run&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Even numbered test runs ran without a probe on the test case so</span>
<span class="cm">	 * we can gather reference results. The subsequent odd numbered run</span>
<span class="cm">	 * will have the probe inserted.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">test_case_run_count</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Save results from run without probe */</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">result_regs</span><span class="p">.</span><span class="n">ARM_sp</span><span class="p">;</span>
		<span class="n">expected_regs</span> <span class="o">=</span> <span class="n">result_regs</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">expected_memory</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">expected_memory_size</span><span class="p">(</span><span class="n">mem</span><span class="p">));</span>

		<span class="cm">/* Insert probe onto test case instruction */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">register_test_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_case_probe</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">test_case_failed</span><span class="p">(</span><span class="s">&quot;register test_case_probe failed&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Check probe ran as expected */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">probe_should_run</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_case_probe</span><span class="p">.</span><span class="n">hit</span> <span class="o">!=</span> <span class="n">test_instance</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">test_case_failed</span><span class="p">(</span><span class="s">&quot;test_case_handler not run&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">probe_should_run</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_case_probe</span><span class="p">.</span><span class="n">hit</span> <span class="o">==</span> <span class="n">test_instance</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">test_case_failed</span><span class="p">(</span><span class="s">&quot;test_case_handler ran&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Remove probe for any subsequent reference run */</span>
		<span class="n">unregister_test_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test_case_probe</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_test_results</span><span class="p">())</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_last_scenario</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">pass</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do next test run */</span>
	<span class="o">++</span><span class="n">test_case_run_count</span><span class="p">;</span>
	<span class="o">++</span><span class="n">test_instance</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">current_code_start</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="o">++</span><span class="n">test_fail_count</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
<span class="nl">pass:</span>
	<span class="o">++</span><span class="n">test_pass_count</span><span class="p">;</span>
<span class="nl">end:</span>
	<span class="n">test_case_cleanup</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Top level test functions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">run_test_cases</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">tests</span><span class="p">)(</span><span class="kt">void</span><span class="p">),</span> <span class="k">const</span> <span class="k">union</span> <span class="n">decode_item</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;    Check decoding tables</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">table_test</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;    Run test cases</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">coverage_start</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">tests</span><span class="p">();</span>

	<span class="n">coverage_end</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">run_all_tests</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Begining kprobe tests...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_THUMB2_KERNEL</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Probe ARM code</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">run_api_tests</span><span class="p">(</span><span class="n">arm_func</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ARM instruction simulation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">run_test_cases</span><span class="p">(</span><span class="n">kprobe_arm_test_cases</span><span class="p">,</span> <span class="n">kprobe_decode_arm_table</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_THUMB2_KERNEL */</span><span class="cp"></span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Probe 16-bit Thumb code</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">run_api_tests</span><span class="p">(</span><span class="n">thumb16_func</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Probe 32-bit Thumb code, even halfword</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">run_api_tests</span><span class="p">(</span><span class="n">thumb32even_func</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Probe 32-bit Thumb code, odd halfword</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">run_api_tests</span><span class="p">(</span><span class="n">thumb32odd_func</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;16-bit Thumb instruction simulation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">run_test_cases</span><span class="p">(</span><span class="n">kprobe_thumb16_test_cases</span><span class="p">,</span>
				<span class="n">kprobe_decode_thumb16_table</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;32-bit Thumb instruction simulation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">run_test_cases</span><span class="p">(</span><span class="n">kprobe_thumb32_test_cases</span><span class="p">,</span>
				<span class="n">kprobe_decode_thumb32_table</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Total instruction simulation tests=%d, pass=%d fail=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">test_try_count</span><span class="p">,</span> <span class="n">test_pass_count</span><span class="p">,</span> <span class="n">test_fail_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_fail_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if BENCHMARKING</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Benchmarks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">run_benchmarks</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#if __LINUX_ARM_ARCH__ &gt;= 7</span>
	<span class="cm">/* We are able to run all test cases so coverage should be complete */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">coverage_fail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;FAIL: Test coverage checks failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Finished kprobe tests OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;kprobe tests failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Module setup</span>
<span class="cm"> */</span>

<span class="cp">#ifdef MODULE</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">kprobe_test_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">run_all_tests</span><span class="p">)</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">kprobe_test_exit</span><span class="p">)</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* !MODULE */</span><span class="cp"></span>

<span class="n">late_initcall</span><span class="p">(</span><span class="n">run_all_tests</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
