<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › kernel › kprobes-common.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>kprobes-common.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * arch/arm/kernel/kprobes-common.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2011 Jon Medhurst &lt;tixy@yxit.co.uk&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * Some contents moved here from arch/arm/include/asm/kprobes-arm.c which is</span>
<span class="cm"> * Copyright (C) 2006, 2007 Motorola Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;asm/system_info.h&gt;</span>

<span class="cp">#include &quot;kprobes.h&quot;</span>


<span class="cp">#ifndef find_str_pc_offset</span>

<span class="cm">/*</span>
<span class="cm"> * For STR and STM instructions, an ARM core may choose to use either</span>
<span class="cm"> * a +8 or a +12 displacement from the current instruction&#39;s address.</span>
<span class="cm"> * Whichever value is chosen for a given core, it must be the same for</span>
<span class="cm"> * both instructions and may not change.  This function measures it.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">str_pc_offset</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">find_str_pc_offset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="p">(</span>
		<span class="s">&quot;sub	%[ret], pc, #4		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;str	pc, %[addr]		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;ldr	%[scr], %[addr]		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;sub	%[ret], %[scr], %[ret]	</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="o">:</span> <span class="p">[</span><span class="n">ret</span><span class="p">]</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">ret</span><span class="p">),</span> <span class="p">[</span><span class="n">scr</span><span class="p">]</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">scratch</span><span class="p">),</span> <span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="s">&quot;+m&quot;</span> <span class="p">(</span><span class="n">addr</span><span class="p">));</span>

	<span class="n">str_pc_offset</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !find_str_pc_offset */</span><span class="cp"></span>


<span class="cp">#ifndef test_load_write_pc_interworking</span>

<span class="n">bool</span> <span class="n">load_write_pc_interworks</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">test_load_write_pc_interworking</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">arch</span> <span class="o">=</span> <span class="n">cpu_architecture</span><span class="p">();</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">arch</span> <span class="o">==</span> <span class="n">CPU_ARCH_UNKNOWN</span><span class="p">);</span>
	<span class="n">load_write_pc_interworks</span> <span class="o">=</span> <span class="n">arch</span> <span class="o">&gt;=</span> <span class="n">CPU_ARCH_ARMv5T</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !test_load_write_pc_interworking */</span><span class="cp"></span>


<span class="cp">#ifndef test_alu_write_pc_interworking</span>

<span class="n">bool</span> <span class="n">alu_write_pc_interworks</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">test_alu_write_pc_interworking</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">arch</span> <span class="o">=</span> <span class="n">cpu_architecture</span><span class="p">();</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">arch</span> <span class="o">==</span> <span class="n">CPU_ARCH_UNKNOWN</span><span class="p">);</span>
	<span class="n">alu_write_pc_interworks</span> <span class="o">=</span> <span class="n">arch</span> <span class="o">&gt;=</span> <span class="n">CPU_ARCH_ARMv7</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !test_alu_write_pc_interworking */</span><span class="cp"></span>


<span class="kt">void</span> <span class="n">__init</span> <span class="nf">arm_kprobe_decode_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">find_str_pc_offset</span><span class="p">();</span>
	<span class="n">test_load_write_pc_interworking</span><span class="p">();</span>
	<span class="n">test_alu_write_pc_interworking</span><span class="p">();</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kprobes</span> <span class="nf">__check_eq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpsr</span> <span class="o">&amp;</span> <span class="n">PSR_Z_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kprobes</span> <span class="nf">__check_ne</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">cpsr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PSR_Z_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kprobes</span> <span class="nf">__check_cs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpsr</span> <span class="o">&amp;</span> <span class="n">PSR_C_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kprobes</span> <span class="nf">__check_cc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">cpsr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PSR_C_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kprobes</span> <span class="nf">__check_mi</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpsr</span> <span class="o">&amp;</span> <span class="n">PSR_N_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kprobes</span> <span class="nf">__check_pl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">cpsr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PSR_N_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kprobes</span> <span class="nf">__check_vs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpsr</span> <span class="o">&amp;</span> <span class="n">PSR_V_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kprobes</span> <span class="nf">__check_vc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">cpsr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PSR_V_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kprobes</span> <span class="nf">__check_hi</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">cpsr</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* PSR_C_BIT &amp;= ~PSR_Z_BIT */</span>
	<span class="k">return</span> <span class="n">cpsr</span> <span class="o">&amp;</span> <span class="n">PSR_C_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kprobes</span> <span class="nf">__check_ls</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">cpsr</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* PSR_C_BIT &amp;= ~PSR_Z_BIT */</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">cpsr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PSR_C_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kprobes</span> <span class="nf">__check_ge</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpsr</span> <span class="o">^=</span> <span class="p">(</span><span class="n">cpsr</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span> <span class="cm">/* PSR_N_BIT ^= PSR_V_BIT */</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">cpsr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PSR_N_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kprobes</span> <span class="nf">__check_lt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpsr</span> <span class="o">^=</span> <span class="p">(</span><span class="n">cpsr</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span> <span class="cm">/* PSR_N_BIT ^= PSR_V_BIT */</span>
	<span class="k">return</span> <span class="n">cpsr</span> <span class="o">&amp;</span> <span class="n">PSR_N_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kprobes</span> <span class="nf">__check_gt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">cpsr</span> <span class="o">^</span> <span class="p">(</span><span class="n">cpsr</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span> <span class="cm">/* PSR_N_BIT ^= PSR_V_BIT */</span>
	<span class="n">temp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">cpsr</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>			 <span class="cm">/* PSR_N_BIT |= PSR_Z_BIT */</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">temp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PSR_N_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kprobes</span> <span class="nf">__check_le</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">cpsr</span> <span class="o">^</span> <span class="p">(</span><span class="n">cpsr</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span> <span class="cm">/* PSR_N_BIT ^= PSR_V_BIT */</span>
	<span class="n">temp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">cpsr</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>			 <span class="cm">/* PSR_N_BIT |= PSR_Z_BIT */</span>
	<span class="k">return</span> <span class="n">temp</span> <span class="o">&amp;</span> <span class="n">PSR_N_BIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__kprobes</span> <span class="nf">__check_al</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">kprobe_check_cc</span> <span class="o">*</span> <span class="k">const</span> <span class="n">kprobe_condition_checks</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">__check_eq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__check_ne</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__check_cs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__check_cc</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">__check_mi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__check_pl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__check_vs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__check_vc</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">__check_hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__check_ls</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__check_ge</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__check_lt</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">__check_gt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__check_le</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__check_al</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__check_al</span>
<span class="p">};</span>


<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">kprobe_simulate_nop</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">kprobe_emulate_none</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn_fn</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">simulate_ldm1stm1</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kprobe_opcode_t</span> <span class="n">insn</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rn</span> <span class="o">=</span> <span class="p">(</span><span class="n">insn</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lbit</span> <span class="o">=</span> <span class="n">insn</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">wbit</span> <span class="o">=</span> <span class="n">insn</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ubit</span> <span class="o">=</span> <span class="n">insn</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">pbit</span> <span class="o">=</span> <span class="n">insn</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="kt">long</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rn</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">reg_bit_vector</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reg_count</span><span class="p">;</span>

	<span class="n">reg_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">reg_bit_vector</span> <span class="o">=</span> <span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">reg_bit_vector</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_bit_vector</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">reg_bit_vector</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="o">++</span><span class="n">reg_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubit</span><span class="p">)</span>
		<span class="n">addr</span> <span class="o">-=</span> <span class="n">reg_count</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="p">(</span><span class="o">!</span><span class="n">pbit</span> <span class="o">==</span> <span class="o">!</span><span class="n">ubit</span><span class="p">);</span>

	<span class="n">reg_bit_vector</span> <span class="o">=</span> <span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">reg_bit_vector</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">reg_bit_vector</span><span class="p">);</span>
		<span class="n">reg_bit_vector</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">reg_bit_vector</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lbit</span><span class="p">)</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">reg</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">addr</span><span class="o">++</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">reg</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubit</span><span class="p">)</span>
			<span class="n">addr</span> <span class="o">-=</span> <span class="n">reg_count</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">-=</span> <span class="p">(</span><span class="o">!</span><span class="n">pbit</span> <span class="o">==</span> <span class="o">!</span><span class="n">ubit</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="p">[</span><span class="n">rn</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">simulate_stm1_pc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_pc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">str_pc_offset</span><span class="p">;</span>
	<span class="n">simulate_ldm1stm1</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_pc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">simulate_ldm1_pc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">simulate_ldm1stm1</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">load_write_pc</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_pc</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span>
<span class="nf">emulate_generic_r0_12_noflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">void</span> <span class="o">*</span><span class="n">rregs</span> <span class="n">asm</span><span class="p">(</span><span class="s">&quot;r1&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">regs</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">void</span> <span class="o">*</span><span class="n">rfn</span> <span class="n">asm</span><span class="p">(</span><span class="s">&quot;lr&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn_fn</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
		<span class="s">&quot;stmdb	sp!, {%[regs], r11}	</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;ldmia	%[regs], {r0-r12}	</span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="cp">#if __LINUX_ARM_ARCH__ &gt;= 6</span>
		<span class="s">&quot;blx	%[fn]			</span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="cp">#else</span>
		<span class="s">&quot;str	%[fn], [sp, #-4]!	</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;adr	lr, 1f			</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;ldr	pc, [sp], #4		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;1:				</span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="cp">#endif</span>
		<span class="s">&quot;ldr	lr, [sp], #4		</span><span class="se">\n\t</span><span class="s">&quot;</span> <span class="cm">/* lr = regs */</span>
		<span class="s">&quot;stmia	lr, {r0-r12}		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;ldr	r11, [sp], #4		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="o">:</span> <span class="p">[</span><span class="n">regs</span><span class="p">]</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">rregs</span><span class="p">),</span> <span class="p">[</span><span class="n">fn</span><span class="p">]</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">rfn</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">rregs</span><span class="p">),</span> <span class="s">&quot;1&quot;</span> <span class="p">(</span><span class="n">rfn</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;r0&quot;</span><span class="p">,</span> <span class="s">&quot;r2&quot;</span><span class="p">,</span> <span class="s">&quot;r3&quot;</span><span class="p">,</span> <span class="s">&quot;r4&quot;</span><span class="p">,</span> <span class="s">&quot;r5&quot;</span><span class="p">,</span> <span class="s">&quot;r6&quot;</span><span class="p">,</span> <span class="s">&quot;r7&quot;</span><span class="p">,</span>
		  <span class="s">&quot;r8&quot;</span><span class="p">,</span> <span class="s">&quot;r9&quot;</span><span class="p">,</span> <span class="s">&quot;r10&quot;</span><span class="p">,</span> <span class="s">&quot;r12&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">,</span> <span class="s">&quot;cc&quot;</span>
		<span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span>
<span class="nf">emulate_generic_r2_14_noflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">emulate_generic_r0_12_noflags</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="o">+</span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span>
<span class="nf">emulate_ldm_r3_15</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">emulate_generic_r0_12_noflags</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">uregs</span><span class="o">+</span><span class="mi">3</span><span class="p">));</span>
	<span class="n">load_write_pc</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ARM_pc</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">kprobe_insn</span> <span class="n">__kprobes</span>
<span class="nf">kprobe_decode_ldmstm</span><span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="n">insn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">arch_specific_insn</span> <span class="o">*</span><span class="n">asi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kprobe_insn_handler_t</span> <span class="o">*</span><span class="n">handler</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">reglist</span> <span class="o">=</span> <span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_ldm</span> <span class="o">=</span> <span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0x100000</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rn</span> <span class="o">=</span> <span class="p">(</span><span class="n">insn</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rn</span> <span class="o">&lt;=</span> <span class="mi">12</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">reglist</span> <span class="o">&amp;</span> <span class="mh">0xe000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Instruction only uses registers in the range R0..R12 */</span>
		<span class="n">handler</span> <span class="o">=</span> <span class="n">emulate_generic_r0_12_noflags</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rn</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">reglist</span> <span class="o">&amp;</span> <span class="mh">0x8003</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Instruction only uses registers in the range R2..R14 */</span>
		<span class="n">rn</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">reglist</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">handler</span> <span class="o">=</span> <span class="n">emulate_generic_r2_14_noflags</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rn</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">reglist</span> <span class="o">&amp;</span> <span class="mh">0x0007</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Instruction only uses registers in the range R3..R15 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_ldm</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">reglist</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rn</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">reglist</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">handler</span> <span class="o">=</span> <span class="n">emulate_ldm_r3_15</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We can emulate the instruction in (possibly) modified form */</span>
		<span class="n">asi</span><span class="o">-&gt;</span><span class="n">insn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0xfff00000</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">rn</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">reglist</span><span class="p">;</span>
		<span class="n">asi</span><span class="o">-&gt;</span><span class="n">insn_handler</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">INSN_GOOD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fallback to slower simulation... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reglist</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">)</span>
		<span class="n">handler</span> <span class="o">=</span> <span class="n">is_ldm</span> <span class="o">?</span> <span class="n">simulate_ldm1_pc</span> <span class="o">:</span> <span class="n">simulate_stm1_pc</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">handler</span> <span class="o">=</span> <span class="n">simulate_ldm1stm1</span><span class="p">;</span>
	<span class="n">asi</span><span class="o">-&gt;</span><span class="n">insn_handler</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">INSN_GOOD_NO_SLOT</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Prepare an instruction slot to receive an instruction for emulating.</span>
<span class="cm"> * This is done by placing a subroutine return after the location where the</span>
<span class="cm"> * instruction will be placed. We also modify ARM instructions to be</span>
<span class="cm"> * unconditional as the condition code will already be checked before any</span>
<span class="cm"> * emulation handler is called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">kprobe_opcode_t</span> <span class="n">__kprobes</span>
<span class="nf">prepare_emulated_insn</span><span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="n">insn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">arch_specific_insn</span> <span class="o">*</span><span class="n">asi</span><span class="p">,</span>
								<span class="n">bool</span> <span class="n">thumb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_THUMB2_KERNEL</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thumb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="o">*</span><span class="n">thumb_insn</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">asi</span><span class="o">-&gt;</span><span class="n">insn</span><span class="p">;</span>
		<span class="n">thumb_insn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x4770</span><span class="p">;</span> <span class="cm">/* Thumb bx lr */</span>
		<span class="n">thumb_insn</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x4770</span><span class="p">;</span> <span class="cm">/* Thumb bx lr */</span>
		<span class="k">return</span> <span class="n">insn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">asi</span><span class="o">-&gt;</span><span class="n">insn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xe12fff1e</span><span class="p">;</span> <span class="cm">/* ARM bx lr */</span>
<span class="cp">#else</span>
	<span class="n">asi</span><span class="o">-&gt;</span><span class="n">insn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xe1a0f00e</span><span class="p">;</span> <span class="cm">/* mov pc, lr */</span>
<span class="cp">#endif</span>
	<span class="cm">/* Make an ARM instruction unconditional */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span> <span class="o">&lt;</span> <span class="mh">0xe0000000</span><span class="p">)</span>
		<span class="n">insn</span> <span class="o">=</span> <span class="p">(</span><span class="n">insn</span> <span class="o">|</span> <span class="mh">0xe0000000</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x10000000</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">insn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write a (probably modified) instruction into the slot previously prepared by</span>
<span class="cm"> * prepare_emulated_insn</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>  <span class="n">__kprobes</span>
<span class="nf">set_emulated_insn</span><span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="n">insn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">arch_specific_insn</span> <span class="o">*</span><span class="n">asi</span><span class="p">,</span>
								<span class="n">bool</span> <span class="n">thumb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_THUMB2_KERNEL</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thumb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">asi</span><span class="o">-&gt;</span><span class="n">insn</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_wide_instruction</span><span class="p">(</span><span class="n">insn</span><span class="p">))</span>
			<span class="o">*</span><span class="n">ip</span><span class="o">++</span> <span class="o">=</span> <span class="n">insn</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ip</span><span class="o">++</span> <span class="o">=</span> <span class="n">insn</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">asi</span><span class="o">-&gt;</span><span class="n">insn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">insn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When we modify the register numbers encoded in an instruction to be emulated,</span>
<span class="cm"> * the new values come from this define. For ARM and 32-bit Thumb instructions</span>
<span class="cm"> * this gives...</span>
<span class="cm"> *</span>
<span class="cm"> *	bit position	  16  12   8   4   0</span>
<span class="cm"> *	---------------+---+---+---+---+---+</span>
<span class="cm"> *	register	 r2  r0  r1  --  r3</span>
<span class="cm"> */</span>
<span class="cp">#define INSN_NEW_BITS		0x00020103</span>

<span class="cm">/* Each nibble has same value as that at INSN_NEW_BITS bit 16 */</span>
<span class="cp">#define INSN_SAMEAS16_BITS	0x22222222</span>

<span class="cm">/*</span>
<span class="cm"> * Validate and modify each of the registers encoded in an instruction.</span>
<span class="cm"> *</span>
<span class="cm"> * Each nibble in regs contains a value from enum decode_reg_type. For each</span>
<span class="cm"> * non-zero value, the corresponding nibble in pinsn is validated and modified</span>
<span class="cm"> * according to the type.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">__kprobes</span> <span class="nf">decode_regs</span><span class="p">(</span><span class="n">kprobe_opcode_t</span><span class="o">*</span> <span class="n">pinsn</span><span class="p">,</span> <span class="n">u32</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kprobe_opcode_t</span> <span class="n">insn</span> <span class="o">=</span> <span class="o">*</span><span class="n">pinsn</span><span class="p">;</span>
	<span class="n">kprobe_opcode_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0xf</span><span class="p">;</span> <span class="cm">/* Start at least significant nibble */</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">regs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">regs</span> <span class="o">&gt;&gt;=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&lt;&lt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">kprobe_opcode_t</span> <span class="n">new_bits</span> <span class="o">=</span> <span class="n">INSN_NEW_BITS</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">regs</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">REG_TYPE_NONE</span>:
			<span class="cm">/* Nibble not a register, skip to next */</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">REG_TYPE_ANY</span>:
			<span class="cm">/* Any register is allowed */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">REG_TYPE_SAMEAS16</span>:
			<span class="cm">/* Replace register with same as at bit position 16 */</span>
			<span class="n">new_bits</span> <span class="o">=</span> <span class="n">INSN_SAMEAS16_BITS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">REG_TYPE_SP</span>:
			<span class="cm">/* Only allow SP (R13) */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">insn</span> <span class="o">^</span> <span class="mh">0xdddddddd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">reject</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">REG_TYPE_PC</span>:
			<span class="cm">/* Only allow PC (R15) */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">insn</span> <span class="o">^</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">reject</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">REG_TYPE_NOSP</span>:
			<span class="cm">/* Reject SP (R13) */</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">insn</span> <span class="o">^</span> <span class="mh">0xdddddddd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">reject</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">REG_TYPE_NOSPPC</span>:
		<span class="k">case</span> <span class="n">REG_TYPE_NOSPPCX</span>:
			<span class="cm">/* Reject SP and PC (R13 and R15) */</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">insn</span> <span class="o">^</span> <span class="mh">0xdddddddd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xdddddddd</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">reject</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">REG_TYPE_NOPCWB</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_writeback</span><span class="p">(</span><span class="n">insn</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span> <span class="cm">/* No writeback, so any register is OK */</span>
			<span class="cm">/* fall through... */</span>
		<span class="k">case</span> <span class="n">REG_TYPE_NOPC</span>:
		<span class="k">case</span> <span class="n">REG_TYPE_NOPCX</span>:
			<span class="cm">/* Reject PC (R15) */</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">insn</span> <span class="o">^</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">reject</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Replace value of nibble with new register number... */</span>
		<span class="n">insn</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">insn</span> <span class="o">|=</span> <span class="n">new_bits</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">pinsn</span> <span class="o">=</span> <span class="n">insn</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

<span class="nl">reject:</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">decode_struct_sizes</span><span class="p">[</span><span class="n">NUM_DECODE_TYPES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">DECODE_TYPE_TABLE</span><span class="p">]</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">decode_table</span><span class="p">),</span>
	<span class="p">[</span><span class="n">DECODE_TYPE_CUSTOM</span><span class="p">]</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">decode_custom</span><span class="p">),</span>
	<span class="p">[</span><span class="n">DECODE_TYPE_SIMULATE</span><span class="p">]</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">decode_simulate</span><span class="p">),</span>
	<span class="p">[</span><span class="n">DECODE_TYPE_EMULATE</span><span class="p">]</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">decode_emulate</span><span class="p">),</span>
	<span class="p">[</span><span class="n">DECODE_TYPE_OR</span><span class="p">]</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">decode_or</span><span class="p">),</span>
	<span class="p">[</span><span class="n">DECODE_TYPE_REJECT</span><span class="p">]</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">decode_reject</span><span class="p">)</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * kprobe_decode_insn operates on data tables in order to decode an ARM</span>
<span class="cm"> * architecture instruction onto which a kprobe has been placed.</span>
<span class="cm"> *</span>
<span class="cm"> * These instruction decoding tables are a concatenation of entries each</span>
<span class="cm"> * of which consist of one of the following structs:</span>
<span class="cm"> *</span>
<span class="cm"> *	decode_table</span>
<span class="cm"> *	decode_custom</span>
<span class="cm"> *	decode_simulate</span>
<span class="cm"> *	decode_emulate</span>
<span class="cm"> *	decode_or</span>
<span class="cm"> *	decode_reject</span>
<span class="cm"> *</span>
<span class="cm"> * Each of these starts with a struct decode_header which has the following</span>
<span class="cm"> * fields:</span>
<span class="cm"> *</span>
<span class="cm"> *	type_regs</span>
<span class="cm"> *	mask</span>
<span class="cm"> *	value</span>
<span class="cm"> *</span>
<span class="cm"> * The least significant DECODE_TYPE_BITS of type_regs contains a value</span>
<span class="cm"> * from enum decode_type, this indicates which of the decode_* structs</span>
<span class="cm"> * the entry contains. The value DECODE_TYPE_END indicates the end of the</span>
<span class="cm"> * table.</span>
<span class="cm"> *</span>
<span class="cm"> * When the table is parsed, each entry is checked in turn to see if it</span>
<span class="cm"> * matches the instruction to be decoded using the test:</span>
<span class="cm"> *</span>
<span class="cm"> *	(insn &amp; mask) == value</span>
<span class="cm"> *</span>
<span class="cm"> * If no match is found before the end of the table is reached then decoding</span>
<span class="cm"> * fails with INSN_REJECTED.</span>
<span class="cm"> *</span>
<span class="cm"> * When a match is found, decode_regs() is called to validate and modify each</span>
<span class="cm"> * of the registers encoded in the instruction; the data it uses to do this</span>
<span class="cm"> * is (type_regs &gt;&gt; DECODE_TYPE_BITS). A validation failure will cause decoding</span>
<span class="cm"> * to fail with INSN_REJECTED.</span>
<span class="cm"> *</span>
<span class="cm"> * Once the instruction has passed the above tests, further processing</span>
<span class="cm"> * depends on the type of the table entry&#39;s decode struct.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__kprobes</span>
<span class="nf">kprobe_decode_insn</span><span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="n">insn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">arch_specific_insn</span> <span class="o">*</span><span class="n">asi</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">union</span> <span class="n">decode_item</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="n">bool</span> <span class="n">thumb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">decode_header</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">decode_header</span> <span class="o">*</span><span class="p">)</span><span class="n">table</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">decode_header</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">matched</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">insn</span> <span class="o">=</span> <span class="n">prepare_emulated_insn</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="n">asi</span><span class="p">,</span> <span class="n">thumb</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;</span> <span class="n">h</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">decode_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">type_regs</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">DECODE_TYPE_MASK</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">regs</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">type_regs</span><span class="p">.</span><span class="n">bits</span> <span class="o">&gt;&gt;</span> <span class="n">DECODE_TYPE_BITS</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">DECODE_TYPE_END</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">INSN_REJECTED</span><span class="p">;</span>

		<span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">decode_header</span> <span class="o">*</span><span class="p">)</span>
				<span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">h</span> <span class="o">+</span> <span class="n">decode_struct_sizes</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">matched</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span> <span class="o">!=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">decode_regs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">insn</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">INSN_REJECTED</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">DECODE_TYPE_TABLE</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">decode_table</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">decode_table</span> <span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="p">;</span>
			<span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">decode_header</span> <span class="o">*</span><span class="p">)</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">table</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">case</span> <span class="n">DECODE_TYPE_CUSTOM</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">decode_custom</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">decode_custom</span> <span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="p">;</span>
			<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">decoder</span><span class="p">.</span><span class="n">decoder</span><span class="p">)(</span><span class="n">insn</span><span class="p">,</span> <span class="n">asi</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">case</span> <span class="n">DECODE_TYPE_SIMULATE</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">decode_simulate</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">decode_simulate</span> <span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="p">;</span>
			<span class="n">asi</span><span class="o">-&gt;</span><span class="n">insn_handler</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">.</span><span class="n">handler</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">INSN_GOOD_NO_SLOT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">case</span> <span class="n">DECODE_TYPE_EMULATE</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">decode_emulate</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">decode_emulate</span> <span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="p">;</span>
			<span class="n">asi</span><span class="o">-&gt;</span><span class="n">insn_handler</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">.</span><span class="n">handler</span><span class="p">;</span>
			<span class="n">set_emulated_insn</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="n">asi</span><span class="p">,</span> <span class="n">thumb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">INSN_GOOD</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">case</span> <span class="n">DECODE_TYPE_OR</span>:
			<span class="n">matched</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">DECODE_TYPE_REJECT</span>:
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="n">INSN_REJECTED</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
