<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › plat-omap › omap_device.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>omap_device.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * omap_device implementation</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009-2010 Nokia Corporation</span>
<span class="cm"> * Paul Walmsley, Kevin Hilman</span>
<span class="cm"> *</span>
<span class="cm"> * Developed in collaboration with (alphabetical order): Benoit</span>
<span class="cm"> * Cousson, Thara Gopinath, Tony Lindgren, Rajendra Nayak, Vikram</span>
<span class="cm"> * Pandita, Sakari Poussa, Anand Sawant, Santosh Shilimkar, Richard</span>
<span class="cm"> * Woodruff</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This code provides a consistent interface for OMAP device drivers</span>
<span class="cm"> * to control power management and interconnect properties of their</span>
<span class="cm"> * devices.</span>
<span class="cm"> *</span>
<span class="cm"> * In the medium- to long-term, this code should either be</span>
<span class="cm"> * a) implemented via arch-specific pointers in platform_data</span>
<span class="cm"> * or</span>
<span class="cm"> * b) implemented as a proper omap_bus/omap_device in Linux, no more</span>
<span class="cm"> *    platform_data func pointers</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Guidelines for usage by driver authors:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. These functions are intended to be used by device drivers via</span>
<span class="cm"> * function pointers in struct platform_data.  As an example,</span>
<span class="cm"> * omap_device_enable() should be passed to the driver as</span>
<span class="cm"> *</span>
<span class="cm"> * struct foo_driver_platform_data {</span>
<span class="cm"> * ...</span>
<span class="cm"> *      int (*device_enable)(struct platform_device *pdev);</span>
<span class="cm"> * ...</span>
<span class="cm"> * }</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the generic &quot;device_enable&quot; name is used, rather than</span>
<span class="cm"> * &quot;omap_device_enable&quot;.  This is so other architectures can pass in their</span>
<span class="cm"> * own enable/disable functions here.</span>
<span class="cm"> *</span>
<span class="cm"> * This should be populated during device setup:</span>
<span class="cm"> *</span>
<span class="cm"> * ...</span>
<span class="cm"> * pdata-&gt;device_enable = omap_device_enable;</span>
<span class="cm"> * ...</span>
<span class="cm"> *</span>
<span class="cm"> * 2. Drivers should first check to ensure the function pointer is not null</span>
<span class="cm"> * before calling it, as in:</span>
<span class="cm"> *</span>
<span class="cm"> * if (pdata-&gt;device_enable)</span>
<span class="cm"> *     pdata-&gt;device_enable(pdev);</span>
<span class="cm"> *</span>
<span class="cm"> * This allows other architectures that don&#39;t use similar device_enable()/</span>
<span class="cm"> * device_shutdown() functions to execute normally.</span>
<span class="cm"> *</span>
<span class="cm"> * ...</span>
<span class="cm"> *</span>
<span class="cm"> * Suggested usage by device drivers:</span>
<span class="cm"> *</span>
<span class="cm"> * During device initialization:</span>
<span class="cm"> * device_enable()</span>
<span class="cm"> *</span>
<span class="cm"> * During device idle:</span>
<span class="cm"> * (save remaining device context if necessary)</span>
<span class="cm"> * device_idle();</span>
<span class="cm"> *</span>
<span class="cm"> * During device resume:</span>
<span class="cm"> * device_enable();</span>
<span class="cm"> * (restore context if necessary)</span>
<span class="cm"> *</span>
<span class="cm"> * During device shutdown:</span>
<span class="cm"> * device_shutdown()</span>
<span class="cm"> * (device must be reinitialized at this point to use it again)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#undef DEBUG</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/clkdev.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>

<span class="cp">#include &lt;plat/omap_device.h&gt;</span>
<span class="cp">#include &lt;plat/omap_hwmod.h&gt;</span>
<span class="cp">#include &lt;plat/clock.h&gt;</span>

<span class="cm">/* These parameters are passed to _omap_device_{de,}activate() */</span>
<span class="cp">#define USE_WAKEUP_LAT			0</span>
<span class="cp">#define IGNORE_WAKEUP_LAT		1</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">omap_early_device_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">omap_device_pm_latency</span> <span class="n">omap_default_latency</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">deactivate_func</span> <span class="o">=</span> <span class="n">omap_device_idle_hwmods</span><span class="p">,</span>
		<span class="p">.</span><span class="n">activate_func</span>   <span class="o">=</span> <span class="n">omap_device_enable_hwmods</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">OMAP_DEVICE_LATENCY_AUTO_ADJUST</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* Private functions */</span>

<span class="cm">/**</span>
<span class="cm"> * _omap_device_activate - increase device readiness</span>
<span class="cm"> * @od: struct omap_device *</span>
<span class="cm"> * @ignore_lat: increase to latency target (0) or full readiness (1)?</span>
<span class="cm"> *</span>
<span class="cm"> * Increase readiness of omap_device @od (thus decreasing device</span>
<span class="cm"> * wakeup latency, but consuming more power).  If @ignore_lat is</span>
<span class="cm"> * IGNORE_WAKEUP_LAT, make the omap_device fully active.  Otherwise,</span>
<span class="cm"> * if @ignore_lat is USE_WAKEUP_LAT, and the device&#39;s maximum wakeup</span>
<span class="cm"> * latency is greater than the requested maximum wakeup latency, step</span>
<span class="cm"> * backwards in the omap_device_pm_latency table to ensure the</span>
<span class="cm"> * device&#39;s maximum wakeup latency is less than or equal to the</span>
<span class="cm"> * requested maximum wakeup latency.  Returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_omap_device_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ignore_lat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;omap_device: activating</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lat_level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">omap_device_pm_latency</span> <span class="o">*</span><span class="n">odpl</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">act_lat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lat_level</span><span class="o">--</span><span class="p">;</span>

		<span class="n">odpl</span> <span class="o">=</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lats</span> <span class="o">+</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lat_level</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ignore_lat</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">dev_wakeup_lat</span> <span class="o">&lt;=</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">_dev_wakeup_lat_limit</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">read_persistent_clock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>

		<span class="cm">/* XXX check return code */</span>
		<span class="n">odpl</span><span class="o">-&gt;</span><span class="n">activate_func</span><span class="p">(</span><span class="n">od</span><span class="p">);</span>

		<span class="n">read_persistent_clock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>

		<span class="n">c</span> <span class="o">=</span> <span class="n">timespec_sub</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
		<span class="n">act_lat</span> <span class="o">=</span> <span class="n">timespec_to_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;omap_device: pm_lat %d: activate: elapsed time &quot;</span>
			<span class="s">&quot;%llu nsec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lat_level</span><span class="p">,</span> <span class="n">act_lat</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">act_lat</span> <span class="o">&gt;</span> <span class="n">odpl</span><span class="o">-&gt;</span><span class="n">activate_lat</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">odpl</span><span class="o">-&gt;</span><span class="n">activate_lat_worst</span> <span class="o">=</span> <span class="n">act_lat</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">odpl</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_DEVICE_LATENCY_AUTO_ADJUST</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">odpl</span><span class="o">-&gt;</span><span class="n">activate_lat</span> <span class="o">=</span> <span class="n">act_lat</span><span class="p">;</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;new worst case activate latency &quot;</span>
					<span class="s">&quot;%d: %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lat_level</span><span class="p">,</span> <span class="n">act_lat</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					 <span class="s">&quot;activate latency %d &quot;</span>
					 <span class="s">&quot;higher than exptected. (%llu &gt; %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lat_level</span><span class="p">,</span> <span class="n">act_lat</span><span class="p">,</span>
					 <span class="n">odpl</span><span class="o">-&gt;</span><span class="n">activate_lat</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">od</span><span class="o">-&gt;</span><span class="n">dev_wakeup_lat</span> <span class="o">-=</span> <span class="n">odpl</span><span class="o">-&gt;</span><span class="n">activate_lat</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _omap_device_deactivate - decrease device readiness</span>
<span class="cm"> * @od: struct omap_device *</span>
<span class="cm"> * @ignore_lat: decrease to latency target (0) or full inactivity (1)?</span>
<span class="cm"> *</span>
<span class="cm"> * Decrease readiness of omap_device @od (thus increasing device</span>
<span class="cm"> * wakeup latency, but conserving power).  If @ignore_lat is</span>
<span class="cm"> * IGNORE_WAKEUP_LAT, make the omap_device fully inactive.  Otherwise,</span>
<span class="cm"> * if @ignore_lat is USE_WAKEUP_LAT, and the device&#39;s maximum wakeup</span>
<span class="cm"> * latency is less than the requested maximum wakeup latency, step</span>
<span class="cm"> * forwards in the omap_device_pm_latency table to ensure the device&#39;s</span>
<span class="cm"> * maximum wakeup latency is less than or equal to the requested</span>
<span class="cm"> * maximum wakeup latency.  Returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_omap_device_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ignore_lat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;omap_device: deactivating</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lat_level</span> <span class="o">&lt;</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lats_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">omap_device_pm_latency</span> <span class="o">*</span><span class="n">odpl</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">deact_lat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">odpl</span> <span class="o">=</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lats</span> <span class="o">+</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lat_level</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ignore_lat</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">dev_wakeup_lat</span> <span class="o">+</span> <span class="n">odpl</span><span class="o">-&gt;</span><span class="n">activate_lat</span><span class="p">)</span> <span class="o">&gt;</span>
		     <span class="n">od</span><span class="o">-&gt;</span><span class="n">_dev_wakeup_lat_limit</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">read_persistent_clock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>

		<span class="cm">/* XXX check return code */</span>
		<span class="n">odpl</span><span class="o">-&gt;</span><span class="n">deactivate_func</span><span class="p">(</span><span class="n">od</span><span class="p">);</span>

		<span class="n">read_persistent_clock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>

		<span class="n">c</span> <span class="o">=</span> <span class="n">timespec_sub</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
		<span class="n">deact_lat</span> <span class="o">=</span> <span class="n">timespec_to_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;omap_device: pm_lat %d: deactivate: elapsed time &quot;</span>
			<span class="s">&quot;%llu nsec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lat_level</span><span class="p">,</span> <span class="n">deact_lat</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">deact_lat</span> <span class="o">&gt;</span> <span class="n">odpl</span><span class="o">-&gt;</span><span class="n">deactivate_lat</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">odpl</span><span class="o">-&gt;</span><span class="n">deactivate_lat_worst</span> <span class="o">=</span> <span class="n">deact_lat</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">odpl</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_DEVICE_LATENCY_AUTO_ADJUST</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">odpl</span><span class="o">-&gt;</span><span class="n">deactivate_lat</span> <span class="o">=</span> <span class="n">deact_lat</span><span class="p">;</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;new worst case deactivate latency &quot;</span>
					<span class="s">&quot;%d: %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lat_level</span><span class="p">,</span> <span class="n">deact_lat</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					 <span class="s">&quot;deactivate latency %d &quot;</span>
					 <span class="s">&quot;higher than exptected. (%llu &gt; %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lat_level</span><span class="p">,</span> <span class="n">deact_lat</span><span class="p">,</span>
					 <span class="n">odpl</span><span class="o">-&gt;</span><span class="n">deactivate_lat</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">od</span><span class="o">-&gt;</span><span class="n">dev_wakeup_lat</span> <span class="o">+=</span> <span class="n">odpl</span><span class="o">-&gt;</span><span class="n">activate_lat</span><span class="p">;</span>

		<span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lat_level</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_add_clkdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">clk_alias</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">clk_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk_lookup</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk_alias</span> <span class="o">||</span> <span class="o">!</span><span class="n">clk_name</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Creating %s -&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk_alias</span><span class="p">,</span> <span class="n">clk_name</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">clk_get_sys</span><span class="p">(</span><span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">clk_alias</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;alias %s already exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk_alias</span><span class="p">);</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">omap_clk_get_by_name</span><span class="p">(</span><span class="n">clk_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;omap_clk_get_by_name for %s failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk_name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">l</span> <span class="o">=</span> <span class="n">clkdev_alloc</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">clk_alias</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;clkdev_alloc for %s failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk_alias</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">clkdev_add</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _add_hwmod_clocks_clkdev - Add clkdev entry for hwmod optional clocks</span>
<span class="cm"> * and main clock</span>
<span class="cm"> * @od: struct omap_device *od</span>
<span class="cm"> * @oh: struct omap_hwmod *oh</span>
<span class="cm"> *</span>
<span class="cm"> * For the main clock and every optional clock present per hwmod per</span>
<span class="cm"> * omap_device, this function adds an entry in the clkdev table of the</span>
<span class="cm"> * form &lt;dev-id=dev_name, con-id=role&gt; if it does not exist already.</span>
<span class="cm"> *</span>
<span class="cm"> * The function is called from inside omap_device_build_ss(), after</span>
<span class="cm"> * omap_device_register.</span>
<span class="cm"> *</span>
<span class="cm"> * This allows drivers to get a pointer to its optional clocks based on its role</span>
<span class="cm"> * by calling clk_get(&lt;dev*&gt;, &lt;role&gt;).</span>
<span class="cm"> * In the case of the main clock, a &quot;fck&quot; alias is used.</span>
<span class="cm"> *</span>
<span class="cm"> * No return value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_add_hwmod_clocks_clkdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">_add_clkdev</span><span class="p">(</span><span class="n">od</span><span class="p">,</span> <span class="s">&quot;fck&quot;</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">main_clk</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">opt_clks_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">_add_clkdev</span><span class="p">(</span><span class="n">od</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">opt_clks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">role</span><span class="p">,</span> <span class="n">oh</span><span class="o">-&gt;</span><span class="n">opt_clks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clk</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * omap_device_build_from_dt - build an omap_device with multiple hwmods</span>
<span class="cm"> * @pdev_name: name of the platform_device driver to use</span>
<span class="cm"> * @pdev_id: this platform_device&#39;s connection ID</span>
<span class="cm"> * @oh: ptr to the single omap_hwmod that backs this omap_device</span>
<span class="cm"> * @pdata: platform_data ptr to associate with the platform_device</span>
<span class="cm"> * @pdata_len: amount of memory pointed to by @pdata</span>
<span class="cm"> * @pm_lats: pointer to a omap_device_pm_latency array for this device</span>
<span class="cm"> * @pm_lats_cnt: ARRAY_SIZE() of @pm_lats</span>
<span class="cm"> * @is_early_device: should the device be registered as an early device or not</span>
<span class="cm"> *</span>
<span class="cm"> * Function for building an omap_device already registered from device-tree</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 or PTR_ERR() on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap_device_build_from_dt</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">**</span><span class="n">hwmods</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oh_name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oh_cnt</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">oh_cnt</span> <span class="o">=</span> <span class="n">of_property_count_strings</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ti,hwmods&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh_cnt</span> <span class="o">||</span> <span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">oh_cnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No &#39;hwmods&#39; to build omap_device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hwmods</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">oh_cnt</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hwmods</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">odbfd_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oh_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">of_property_read_string_index</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ti,hwmods&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oh_name</span><span class="p">);</span>
		<span class="n">oh</span> <span class="o">=</span> <span class="n">omap_hwmod_lookup</span><span class="p">(</span><span class="n">oh_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot lookup hwmod &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">oh_name</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">odbfd_exit1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hwmods</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">oh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">od</span> <span class="o">=</span> <span class="n">omap_device_alloc</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">hwmods</span><span class="p">,</span> <span class="n">oh_cnt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">od</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot allocate omap_device for :%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">oh_name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">od</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">odbfd_exit1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">of_get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ti,no_idle_on_suspend&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">omap_device_disable_idle_on_suspend</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">pm_domain</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">omap_device_pm_domain</span><span class="p">;</span>

<span class="nl">odbfd_exit1:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hwmods</span><span class="p">);</span>
<span class="nl">odbfd_exit:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_omap_device_notifier_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BUS_NOTIFY_ADD_DEVICE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">)</span>
			<span class="n">omap_device_build_from_dt</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">BUS_NOTIFY_DEL_DEVICE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">archdata</span><span class="p">.</span><span class="n">od</span><span class="p">)</span>
			<span class="n">omap_device_delete</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">archdata</span><span class="p">.</span><span class="n">od</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Public functions for use by core code */</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_get_context_loss_count - get lost context count</span>
<span class="cm"> * @od: struct omap_device *</span>
<span class="cm"> *</span>
<span class="cm"> * Using the primary hwmod, query the context loss count for this</span>
<span class="cm"> * device.</span>
<span class="cm"> *</span>
<span class="cm"> * Callers should consider context for this device lost any time this</span>
<span class="cm"> * function returns a value different than the value the caller got</span>
<span class="cm"> * the last time it called this function.</span>
<span class="cm"> *</span>
<span class="cm"> * If any hwmods exist for the omap_device assoiated with @pdev,</span>
<span class="cm"> * return the context loss counter for that hwmod, otherwise return</span>
<span class="cm"> * zero.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_device_get_context_loss_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">od</span> <span class="o">=</span> <span class="n">to_omap_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods_cnt</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">omap_hwmod_get_context_loss_count</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_count_resources - count number of struct resource entries needed</span>
<span class="cm"> * @od: struct omap_device *</span>
<span class="cm"> *</span>
<span class="cm"> * Count the number of struct resource entries needed for this</span>
<span class="cm"> * omap_device @od.  Used by omap_device_build_ss() to determine how</span>
<span class="cm"> * much memory to allocate before calling</span>
<span class="cm"> * omap_device_fill_resources().  Returns the count.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap_device_count_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">c</span> <span class="o">+=</span> <span class="n">omap_hwmod_count_resources</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_device: %s: counted %d total resources across %d &quot;</span>
		 <span class="s">&quot;hwmods</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods_cnt</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_fill_resources - fill in array of struct resource</span>
<span class="cm"> * @od: struct omap_device *</span>
<span class="cm"> * @res: pointer to an array of struct resource to be filled in</span>
<span class="cm"> *</span>
<span class="cm"> * Populate one or more empty struct resource pointed to by @res with</span>
<span class="cm"> * the resource data for this omap_device @od.  Used by</span>
<span class="cm"> * omap_device_build_ss() after calling omap_device_count_resources().</span>
<span class="cm"> * Ideally this function would not be needed at all.  If omap_device</span>
<span class="cm"> * replaces platform_device, then we can specify our own</span>
<span class="cm"> * get_resource()/ get_irq()/etc functions that use the underlying</span>
<span class="cm"> * omap_hwmod information.  Or if platform_device is extended to use</span>
<span class="cm"> * subarchitecture-specific function pointers, the various</span>
<span class="cm"> * platform_device functions can simply call omap_device internal</span>
<span class="cm"> * functions to get device resources.  Hacking around the existing</span>
<span class="cm"> * platform_device code wastes memory.  Returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap_device_fill_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">omap_hwmod_fill_resources</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">res</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_alloc - allocate an omap_device</span>
<span class="cm"> * @pdev: platform_device that will be included in this omap_device</span>
<span class="cm"> * @oh: ptr to the single omap_hwmod that backs this omap_device</span>
<span class="cm"> * @pdata: platform_data ptr to associate with the platform_device</span>
<span class="cm"> * @pdata_len: amount of memory pointed to by @pdata</span>
<span class="cm"> * @pm_lats: pointer to a omap_device_pm_latency array for this device</span>
<span class="cm"> * @pm_lats_cnt: ARRAY_SIZE() of @pm_lats</span>
<span class="cm"> *</span>
<span class="cm"> * Convenience function for allocating an omap_device structure and filling</span>
<span class="cm"> * hwmods, resources and pm_latency attributes.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns an struct omap_device pointer or ERR_PTR() on error;</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="nf">omap_device_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">**</span><span class="n">ohs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oh_cnt</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">omap_device_pm_latency</span> <span class="o">*</span><span class="n">pm_lats</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">pm_lats_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">res_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">**</span><span class="n">hwmods</span><span class="p">;</span>

	<span class="n">od</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">od</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">oda_exit1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods_cnt</span> <span class="o">=</span> <span class="n">oh_cnt</span><span class="p">;</span>

	<span class="n">hwmods</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">ohs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">oh_cnt</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hwmods</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">oda_exit2</span><span class="p">;</span>

	<span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span> <span class="o">=</span> <span class="n">hwmods</span><span class="p">;</span>
	<span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * HACK: Ideally the resources from DT should match, and hwmod</span>
<span class="cm">	 * should just add the missing ones. Since the name is not</span>
<span class="cm">	 * properly populated by DT, stick to hwmod resources only.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">num_resources</span> <span class="o">&amp;&amp;</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s(): resources already allocated %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">num_resources</span><span class="p">);</span>

	<span class="n">res_count</span> <span class="o">=</span> <span class="n">omap_device_count_resources</span><span class="p">(</span><span class="n">od</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s(): resources allocated from hwmod %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">res_count</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource</span><span class="p">)</span> <span class="o">*</span> <span class="n">res_count</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">oda_exit3</span><span class="p">;</span>

		<span class="n">omap_device_fill_resources</span><span class="p">(</span><span class="n">od</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">platform_device_add_resources</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">res_count</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">oda_exit3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm_lats</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm_lats</span> <span class="o">=</span> <span class="n">omap_default_latency</span><span class="p">;</span>
		<span class="n">pm_lats_cnt</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">omap_default_latency</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lats_cnt</span> <span class="o">=</span> <span class="n">pm_lats_cnt</span><span class="p">;</span>
	<span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lats</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">pm_lats</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_device_pm_latency</span><span class="p">)</span> <span class="o">*</span> <span class="n">pm_lats_cnt</span><span class="p">,</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lats</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">oda_exit3</span><span class="p">;</span>

	<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">archdata</span><span class="p">.</span><span class="n">od</span> <span class="o">=</span> <span class="n">od</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oh_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hwmods</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">od</span> <span class="o">=</span> <span class="n">od</span><span class="p">;</span>
		<span class="n">_add_hwmod_clocks_clkdev</span><span class="p">(</span><span class="n">od</span><span class="p">,</span> <span class="n">hwmods</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">od</span><span class="p">;</span>

<span class="nl">oda_exit3:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hwmods</span><span class="p">);</span>
<span class="nl">oda_exit2:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">od</span><span class="p">);</span>
<span class="nl">oda_exit1:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;omap_device: build failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">omap_device_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">od</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">archdata</span><span class="p">.</span><span class="n">od</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lats</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">od</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_build - build and register an omap_device with one omap_hwmod</span>
<span class="cm"> * @pdev_name: name of the platform_device driver to use</span>
<span class="cm"> * @pdev_id: this platform_device&#39;s connection ID</span>
<span class="cm"> * @oh: ptr to the single omap_hwmod that backs this omap_device</span>
<span class="cm"> * @pdata: platform_data ptr to associate with the platform_device</span>
<span class="cm"> * @pdata_len: amount of memory pointed to by @pdata</span>
<span class="cm"> * @pm_lats: pointer to a omap_device_pm_latency array for this device</span>
<span class="cm"> * @pm_lats_cnt: ARRAY_SIZE() of @pm_lats</span>
<span class="cm"> * @is_early_device: should the device be registered as an early device or not</span>
<span class="cm"> *</span>
<span class="cm"> * Convenience function for building and registering a single</span>
<span class="cm"> * omap_device record, which in turn builds and registers a</span>
<span class="cm"> * platform_device record.  See omap_device_build_ss() for more</span>
<span class="cm"> * information.  Returns ERR_PTR(-EINVAL) if @oh is NULL; otherwise,</span>
<span class="cm"> * passes along the return value of omap_device_build_ss().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">platform_device</span> <span class="n">__init</span> <span class="o">*</span><span class="nf">omap_device_build</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pdev_name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pdev_id</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pdata</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">pdata_len</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">omap_device_pm_latency</span> <span class="o">*</span><span class="n">pm_lats</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">pm_lats_cnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_early_device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">ohs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">oh</span> <span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">omap_device_build_ss</span><span class="p">(</span><span class="n">pdev_name</span><span class="p">,</span> <span class="n">pdev_id</span><span class="p">,</span> <span class="n">ohs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pdata</span><span class="p">,</span>
				    <span class="n">pdata_len</span><span class="p">,</span> <span class="n">pm_lats</span><span class="p">,</span> <span class="n">pm_lats_cnt</span><span class="p">,</span>
				    <span class="n">is_early_device</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_build_ss - build and register an omap_device with multiple hwmods</span>
<span class="cm"> * @pdev_name: name of the platform_device driver to use</span>
<span class="cm"> * @pdev_id: this platform_device&#39;s connection ID</span>
<span class="cm"> * @oh: ptr to the single omap_hwmod that backs this omap_device</span>
<span class="cm"> * @pdata: platform_data ptr to associate with the platform_device</span>
<span class="cm"> * @pdata_len: amount of memory pointed to by @pdata</span>
<span class="cm"> * @pm_lats: pointer to a omap_device_pm_latency array for this device</span>
<span class="cm"> * @pm_lats_cnt: ARRAY_SIZE() of @pm_lats</span>
<span class="cm"> * @is_early_device: should the device be registered as an early device or not</span>
<span class="cm"> *</span>
<span class="cm"> * Convenience function for building and registering an omap_device</span>
<span class="cm"> * subsystem record.  Subsystem records consist of multiple</span>
<span class="cm"> * omap_hwmods.  This function in turn builds and registers a</span>
<span class="cm"> * platform_device record.  Returns an ERR_PTR() on error, or passes</span>
<span class="cm"> * along the return value of omap_device_register().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">platform_device</span> <span class="n">__init</span> <span class="o">*</span><span class="nf">omap_device_build_ss</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pdev_name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pdev_id</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">**</span><span class="n">ohs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oh_cnt</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="o">*</span><span class="n">pdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pdata_len</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">omap_device_pm_latency</span> <span class="o">*</span><span class="n">pm_lats</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">pm_lats_cnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_early_device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ohs</span> <span class="o">||</span> <span class="n">oh_cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">pdev_name</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdata</span> <span class="o">&amp;&amp;</span> <span class="n">pdata_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">pdev</span> <span class="o">=</span> <span class="n">platform_device_alloc</span><span class="p">(</span><span class="n">pdev_name</span><span class="p">,</span> <span class="n">pdev_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">odbs_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the dev_name early to allow dev_xxx in omap_device_alloc */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s.%d&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>  <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">od</span> <span class="o">=</span> <span class="n">omap_device_alloc</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ohs</span><span class="p">,</span> <span class="n">oh_cnt</span><span class="p">,</span> <span class="n">pm_lats</span><span class="p">,</span> <span class="n">pm_lats_cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">od</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">odbs_exit1</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">platform_device_add_data</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pdata</span><span class="p">,</span> <span class="n">pdata_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">odbs_exit2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_early_device</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">omap_early_device_register</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">omap_device_register</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">odbs_exit2</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pdev</span><span class="p">;</span>

<span class="nl">odbs_exit2:</span>
	<span class="n">omap_device_delete</span><span class="p">(</span><span class="n">od</span><span class="p">);</span>
<span class="nl">odbs_exit1:</span>
	<span class="n">platform_device_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">odbs_exit:</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;omap_device: %s: build failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdev_name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_early_device_register - register an omap_device as an early platform</span>
<span class="cm"> * device.</span>
<span class="cm"> * @od: struct omap_device * to register</span>
<span class="cm"> *</span>
<span class="cm"> * Register the omap_device structure.  This currently just calls</span>
<span class="cm"> * platform_early_add_device() on the underlying platform_device.</span>
<span class="cm"> * Returns 0 by default.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">omap_early_device_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">devices</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">devices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">early_platform_add_devices</span><span class="p">(</span><span class="n">devices</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM_RUNTIME</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_od_runtime_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pm_generic_runtime_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">omap_device_idle</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_od_runtime_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pm_generic_runtime_idle</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_od_runtime_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">omap_device_enable</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pm_generic_runtime_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SUSPEND</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_od_suspend_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span> <span class="o">=</span> <span class="n">to_omap_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pm_generic_suspend_noirq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pm_runtime_status_suspended</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pm_generic_runtime_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_DEVICE_NO_IDLE_ON_SUSPEND</span><span class="p">))</span>
				<span class="n">omap_device_idle</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
			<span class="n">od</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">OMAP_DEVICE_SUSPENDED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_od_resume_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span> <span class="o">=</span> <span class="n">to_omap_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_DEVICE_SUSPENDED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">pm_runtime_status_suspended</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">od</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">OMAP_DEVICE_SUSPENDED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP_DEVICE_NO_IDLE_ON_SUSPEND</span><span class="p">))</span>
			<span class="n">omap_device_enable</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">pm_generic_runtime_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pm_generic_resume_noirq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define _od_suspend_noirq NULL</span>
<span class="cp">#define _od_resume_noirq NULL</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">dev_pm_domain</span> <span class="n">omap_device_pm_domain</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">SET_RUNTIME_PM_OPS</span><span class="p">(</span><span class="n">_od_runtime_suspend</span><span class="p">,</span> <span class="n">_od_runtime_resume</span><span class="p">,</span>
				   <span class="n">_od_runtime_idle</span><span class="p">)</span>
		<span class="n">USE_PLATFORM_PM_SLEEP_OPS</span>
		<span class="p">.</span><span class="n">suspend_noirq</span> <span class="o">=</span> <span class="n">_od_suspend_noirq</span><span class="p">,</span>
		<span class="p">.</span><span class="n">resume_noirq</span> <span class="o">=</span> <span class="n">_od_resume_noirq</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_register - register an omap_device with one omap_hwmod</span>
<span class="cm"> * @od: struct omap_device * to register</span>
<span class="cm"> *</span>
<span class="cm"> * Register the omap_device structure.  This currently just calls</span>
<span class="cm"> * platform_device_register() on the underlying platform_device.</span>
<span class="cm"> * Returns the return value of platform_device_register().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_device_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;omap_device: %s: registering</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">pm_domain</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">omap_device_pm_domain</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">platform_device_add</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Public functions for use by device drivers through struct platform_data */</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_enable - fully activate an omap_device</span>
<span class="cm"> * @od: struct omap_device * to activate</span>
<span class="cm"> *</span>
<span class="cm"> * Do whatever is necessary for the hwmods underlying omap_device @od</span>
<span class="cm"> * to be accessible and ready to operate.  This generally involves</span>
<span class="cm"> * enabling clocks, setting SYSCONFIG registers; and in the future may</span>
<span class="cm"> * involve remuxing pins.  Device drivers should call this function</span>
<span class="cm"> * (through platform_data function pointers) where they would normally</span>
<span class="cm"> * enable clocks, etc.  Returns -EINVAL if called when the omap_device</span>
<span class="cm"> * is already enabled, or passes along the return value of</span>
<span class="cm"> * _omap_device_activate().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_device_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">;</span>

	<span class="n">od</span> <span class="o">=</span> <span class="n">to_omap_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">==</span> <span class="n">OMAP_DEVICE_STATE_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;omap_device: %s() called from invalid state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">_state</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable everything if we&#39;re enabling this device from scratch */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">==</span> <span class="n">OMAP_DEVICE_STATE_UNKNOWN</span><span class="p">)</span>
		<span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lat_level</span> <span class="o">=</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">pm_lats_cnt</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">_omap_device_activate</span><span class="p">(</span><span class="n">od</span><span class="p">,</span> <span class="n">IGNORE_WAKEUP_LAT</span><span class="p">);</span>

	<span class="n">od</span><span class="o">-&gt;</span><span class="n">dev_wakeup_lat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">od</span><span class="o">-&gt;</span><span class="n">_dev_wakeup_lat_limit</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
	<span class="n">od</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">=</span> <span class="n">OMAP_DEVICE_STATE_ENABLED</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_idle - idle an omap_device</span>
<span class="cm"> * @od: struct omap_device * to idle</span>
<span class="cm"> *</span>
<span class="cm"> * Idle omap_device @od by calling as many .deactivate_func() entries</span>
<span class="cm"> * in the omap_device&#39;s pm_lats table as is possible without exceeding</span>
<span class="cm"> * the device&#39;s maximum wakeup latency limit, pm_lat_limit.  Device</span>
<span class="cm"> * drivers should call this function (through platform_data function</span>
<span class="cm"> * pointers) where they would normally disable clocks after operations</span>
<span class="cm"> * complete, etc..  Returns -EINVAL if the omap_device is not</span>
<span class="cm"> * currently enabled, or passes along the return value of</span>
<span class="cm"> * _omap_device_deactivate().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_device_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">;</span>

	<span class="n">od</span> <span class="o">=</span> <span class="n">to_omap_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">OMAP_DEVICE_STATE_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;omap_device: %s() called from invalid state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">_state</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">_omap_device_deactivate</span><span class="p">(</span><span class="n">od</span><span class="p">,</span> <span class="n">USE_WAKEUP_LAT</span><span class="p">);</span>

	<span class="n">od</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">=</span> <span class="n">OMAP_DEVICE_STATE_IDLE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_shutdown - shut down an omap_device</span>
<span class="cm"> * @od: struct omap_device * to shut down</span>
<span class="cm"> *</span>
<span class="cm"> * Shut down omap_device @od by calling all .deactivate_func() entries</span>
<span class="cm"> * in the omap_device&#39;s pm_lats table and then shutting down all of</span>
<span class="cm"> * the underlying omap_hwmods.  Used when a device is being &quot;removed&quot;</span>
<span class="cm"> * or a device driver is being unloaded.  Returns -EINVAL if the</span>
<span class="cm"> * omap_device is not currently enabled or idle, or passes along the</span>
<span class="cm"> * return value of _omap_device_deactivate().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_device_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">;</span>

	<span class="n">od</span> <span class="o">=</span> <span class="n">to_omap_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">OMAP_DEVICE_STATE_ENABLED</span> <span class="o">&amp;&amp;</span>
	    <span class="n">od</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">OMAP_DEVICE_STATE_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;omap_device: %s() called from invalid state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">_state</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">_omap_device_deactivate</span><span class="p">(</span><span class="n">od</span><span class="p">,</span> <span class="n">IGNORE_WAKEUP_LAT</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">omap_hwmod_shutdown</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">od</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">=</span> <span class="n">OMAP_DEVICE_STATE_SHUTDOWN</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_align_pm_lat - activate/deactivate device to match wakeup lat lim</span>
<span class="cm"> * @od: struct omap_device *</span>
<span class="cm"> *</span>
<span class="cm"> * When a device&#39;s maximum wakeup latency limit changes, call some of</span>
<span class="cm"> * the .activate_func or .deactivate_func function pointers in the</span>
<span class="cm"> * omap_device&#39;s pm_lats array to ensure that the device&#39;s maximum</span>
<span class="cm"> * wakeup latency is less than or equal to the new latency limit.</span>
<span class="cm"> * Intended to be called by OMAP PM code whenever a device&#39;s maximum</span>
<span class="cm"> * wakeup latency limit changes (e.g., via</span>
<span class="cm"> * omap_pm_set_dev_wakeup_lat()).  Returns 0 if nothing needs to be</span>
<span class="cm"> * done (e.g., if the omap_device is not currently idle, or if the</span>
<span class="cm"> * wakeup latency is already current with the new limit) or passes</span>
<span class="cm"> * along the return value of _omap_device_deactivate() or</span>
<span class="cm"> * _omap_device_activate().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_device_align_pm_lat</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">new_wakeup_lat_limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">;</span>

	<span class="n">od</span> <span class="o">=</span> <span class="n">to_omap_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_wakeup_lat_limit</span> <span class="o">==</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">dev_wakeup_lat</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">od</span><span class="o">-&gt;</span><span class="n">_dev_wakeup_lat_limit</span> <span class="o">=</span> <span class="n">new_wakeup_lat_limit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">OMAP_DEVICE_STATE_IDLE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_wakeup_lat_limit</span> <span class="o">&gt;</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">dev_wakeup_lat</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">_omap_device_deactivate</span><span class="p">(</span><span class="n">od</span><span class="p">,</span> <span class="n">USE_WAKEUP_LAT</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_wakeup_lat_limit</span> <span class="o">&lt;</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">dev_wakeup_lat</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">_omap_device_activate</span><span class="p">(</span><span class="n">od</span><span class="p">,</span> <span class="n">USE_WAKEUP_LAT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_get_pwrdm - return the powerdomain * associated with @od</span>
<span class="cm"> * @od: struct omap_device *</span>
<span class="cm"> *</span>
<span class="cm"> * Return the powerdomain associated with the first underlying</span>
<span class="cm"> * omap_hwmod for this omap_device.  Intended for use by core OMAP PM</span>
<span class="cm"> * code.  Returns NULL on error or a struct powerdomain * upon</span>
<span class="cm"> * success.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="nf">omap_device_get_pwrdm</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * XXX Assumes that all omap_hwmod powerdomains are identical.</span>
<span class="cm">	 * This may not necessarily be true.  There should be a sanity</span>
<span class="cm">	 * check in here to WARN() if any difference appears.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods_cnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">omap_hwmod_get_pwrdm</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_get_mpu_rt_va - return the MPU&#39;s virtual addr for the hwmod base</span>
<span class="cm"> * @od: struct omap_device *</span>
<span class="cm"> *</span>
<span class="cm"> * Return the MPU&#39;s virtual address for the base of the hwmod, from</span>
<span class="cm"> * the ioremap() that the hwmod code does.  Only valid if there is one</span>
<span class="cm"> * hwmod associated with this device.  Returns NULL if there are zero</span>
<span class="cm"> * or more than one hwmods associated with this omap_device;</span>
<span class="cm"> * otherwise, passes along the return value from</span>
<span class="cm"> * omap_hwmod_get_mpu_rt_va().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">omap_device_get_rt_va</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods_cnt</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">omap_hwmod_get_mpu_rt_va</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_get_by_hwmod_name() - convert a hwmod name to</span>
<span class="cm"> * device pointer.</span>
<span class="cm"> * @oh_name: name of the hwmod device</span>
<span class="cm"> *</span>
<span class="cm"> * Returns back a struct device * pointer associated with a hwmod</span>
<span class="cm"> * device represented by a hwmod_name</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">omap_device_get_by_hwmod_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oh_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oh_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s: no hwmod name!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">oh</span> <span class="o">=</span> <span class="n">omap_hwmod_lookup</span><span class="p">(</span><span class="n">oh_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">oh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s: no hwmod for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">oh_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">oh</span> <span class="o">?</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">oh</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">od</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s: no omap_device for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">oh_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">od</span> <span class="o">?</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">od</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">?</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">oh</span><span class="o">-&gt;</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">omap_device_get_by_hwmod_name</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Public functions intended for use in omap_device_pm_latency</span>
<span class="cm"> * .activate_func and .deactivate_func function pointers</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_enable_hwmods - call omap_hwmod_enable() on all hwmods</span>
<span class="cm"> * @od: struct omap_device *od</span>
<span class="cm"> *</span>
<span class="cm"> * Enable all underlying hwmods.  Returns 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_device_enable_hwmods</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">omap_hwmod_enable</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* XXX pass along return value here? */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_idle_hwmods - call omap_hwmod_idle() on all hwmods</span>
<span class="cm"> * @od: struct omap_device *od</span>
<span class="cm"> *</span>
<span class="cm"> * Idle all underlying hwmods.  Returns 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_device_idle_hwmods</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">omap_hwmod_idle</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* XXX pass along return value here? */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_disable_clocks - disable all main and interface clocks</span>
<span class="cm"> * @od: struct omap_device *od</span>
<span class="cm"> *</span>
<span class="cm"> * Disable the main functional clock and interface clock for all of the</span>
<span class="cm"> * omap_hwmods associated with the omap_device.  Returns 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_device_disable_clocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">omap_hwmod_disable_clocks</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* XXX pass along return value here? */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * omap_device_enable_clocks - enable all main and interface clocks</span>
<span class="cm"> * @od: struct omap_device *od</span>
<span class="cm"> *</span>
<span class="cm"> * Enable the main functional clock and interface clock for all of the</span>
<span class="cm"> * omap_hwmods associated with the omap_device.  Returns 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">omap_device_enable_clocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_device</span> <span class="o">*</span><span class="n">od</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">omap_hwmod_enable_clocks</span><span class="p">(</span><span class="n">od</span><span class="o">-&gt;</span><span class="n">hwmods</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* XXX pass along return value here? */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">platform_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">_omap_device_notifier_call</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">omap_device_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bus_register_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">platform_nb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">core_initcall</span><span class="p">(</span><span class="n">omap_device_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
