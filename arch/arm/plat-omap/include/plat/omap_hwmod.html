<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › plat-omap › include › plat › omap_hwmod.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>omap_hwmod.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * omap_hwmod macros, structures</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009-2011 Nokia Corporation</span>
<span class="cm"> * Copyright (C) 2011 Texas Instruments, Inc.</span>
<span class="cm"> * Paul Walmsley</span>
<span class="cm"> *</span>
<span class="cm"> * Created in collaboration with (alphabetical order): Benoît Cousson,</span>
<span class="cm"> * Kevin Hilman, Tony Lindgren, Rajendra Nayak, Vikram Pandita, Sakari</span>
<span class="cm"> * Poussa, Anand Sawant, Santosh Shilimkar, Richard Woodruff</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * These headers and macros are used to define OMAP on-chip module</span>
<span class="cm"> * data and their integration with other OMAP modules and Linux.</span>
<span class="cm"> * Copious documentation and references can also be found in the</span>
<span class="cm"> * omap_hwmod code, in arch/arm/mach-omap2/omap_hwmod.c (as of this</span>
<span class="cm"> * writing).</span>
<span class="cm"> *</span>
<span class="cm"> * To do:</span>
<span class="cm"> * - add interconnect error log structures</span>
<span class="cm"> * - add pinmuxing</span>
<span class="cm"> * - init_conn_id_bit (CONNID_BIT_VECTOR)</span>
<span class="cm"> * - implement default hwmod SMS/SDRC flags?</span>
<span class="cm"> * - move Linux-specific data (&quot;non-ROM data&quot;) out</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __ARCH_ARM_PLAT_OMAP_INCLUDE_MACH_OMAP_HWMOD_H</span>
<span class="cp">#define __ARCH_ARM_PLAT_OMAP_INCLUDE_MACH_OMAP_HWMOD_H</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;plat/cpu.h&gt;</span>

<span class="k">struct</span> <span class="n">omap_device</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">omap_hwmod_sysc_fields</span> <span class="n">omap_hwmod_sysc_type1</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">omap_hwmod_sysc_fields</span> <span class="n">omap_hwmod_sysc_type2</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * OCP SYSCONFIG bit shifts/masks TYPE1. These are for IPs compliant</span>
<span class="cm"> * with the original PRCM protocol defined for OMAP2420</span>
<span class="cm"> */</span>
<span class="cp">#define SYSC_TYPE1_MIDLEMODE_SHIFT	12</span>
<span class="cp">#define SYSC_TYPE1_MIDLEMODE_MASK	(0x3 &lt;&lt; SYSC_TYPE1_MIDLEMODE_SHIFT)</span>
<span class="cp">#define SYSC_TYPE1_CLOCKACTIVITY_SHIFT	8</span>
<span class="cp">#define SYSC_TYPE1_CLOCKACTIVITY_MASK	(0x3 &lt;&lt; SYSC_TYPE1_CLOCKACTIVITY_SHIFT)</span>
<span class="cp">#define SYSC_TYPE1_SIDLEMODE_SHIFT	3</span>
<span class="cp">#define SYSC_TYPE1_SIDLEMODE_MASK	(0x3 &lt;&lt; SYSC_TYPE1_SIDLEMODE_SHIFT)</span>
<span class="cp">#define SYSC_TYPE1_ENAWAKEUP_SHIFT	2</span>
<span class="cp">#define SYSC_TYPE1_ENAWAKEUP_MASK	(1 &lt;&lt; SYSC_TYPE1_ENAWAKEUP_SHIFT)</span>
<span class="cp">#define SYSC_TYPE1_SOFTRESET_SHIFT	1</span>
<span class="cp">#define SYSC_TYPE1_SOFTRESET_MASK	(1 &lt;&lt; SYSC_TYPE1_SOFTRESET_SHIFT)</span>
<span class="cp">#define SYSC_TYPE1_AUTOIDLE_SHIFT	0</span>
<span class="cp">#define SYSC_TYPE1_AUTOIDLE_MASK	(1 &lt;&lt; SYSC_TYPE1_AUTOIDLE_SHIFT)</span>

<span class="cm">/*</span>
<span class="cm"> * OCP SYSCONFIG bit shifts/masks TYPE2. These are for IPs compliant</span>
<span class="cm"> * with the new PRCM protocol defined for new OMAP4 IPs.</span>
<span class="cm"> */</span>
<span class="cp">#define SYSC_TYPE2_SOFTRESET_SHIFT	0</span>
<span class="cp">#define SYSC_TYPE2_SOFTRESET_MASK	(1 &lt;&lt; SYSC_TYPE2_SOFTRESET_SHIFT)</span>
<span class="cp">#define SYSC_TYPE2_SIDLEMODE_SHIFT	2</span>
<span class="cp">#define SYSC_TYPE2_SIDLEMODE_MASK	(0x3 &lt;&lt; SYSC_TYPE2_SIDLEMODE_SHIFT)</span>
<span class="cp">#define SYSC_TYPE2_MIDLEMODE_SHIFT	4</span>
<span class="cp">#define SYSC_TYPE2_MIDLEMODE_MASK	(0x3 &lt;&lt; SYSC_TYPE2_MIDLEMODE_SHIFT)</span>

<span class="cm">/* OCP SYSSTATUS bit shifts/masks */</span>
<span class="cp">#define SYSS_RESETDONE_SHIFT		0</span>
<span class="cp">#define SYSS_RESETDONE_MASK		(1 &lt;&lt; SYSS_RESETDONE_SHIFT)</span>

<span class="cm">/* Master standby/slave idle mode flags */</span>
<span class="cp">#define HWMOD_IDLEMODE_FORCE		(1 &lt;&lt; 0)</span>
<span class="cp">#define HWMOD_IDLEMODE_NO		(1 &lt;&lt; 1)</span>
<span class="cp">#define HWMOD_IDLEMODE_SMART		(1 &lt;&lt; 2)</span>
<span class="cp">#define HWMOD_IDLEMODE_SMART_WKUP	(1 &lt;&lt; 3)</span>

<span class="cm">/* modulemode control type (SW or HW) */</span>
<span class="cp">#define MODULEMODE_HWCTRL		1</span>
<span class="cp">#define MODULEMODE_SWCTRL		2</span>


<span class="cm">/**</span>
<span class="cm"> * struct omap_hwmod_mux_info - hwmod specific mux configuration</span>
<span class="cm"> * @pads:              array of omap_device_pad entries</span>
<span class="cm"> * @nr_pads:           number of omap_device_pad entries</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this is currently built during init as needed.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod_mux_info</span> <span class="p">{</span>
	<span class="kt">int</span>				<span class="n">nr_pads</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_device_pad</span>		<span class="o">*</span><span class="n">pads</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">nr_pads_dynamic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_device_pad</span>		<span class="o">**</span><span class="n">pads_dynamic</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="o">*</span><span class="n">irqs</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">enabled</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct omap_hwmod_irq_info - MPU IRQs used by the hwmod</span>
<span class="cm"> * @name: name of the IRQ channel (module local name)</span>
<span class="cm"> * @irq: IRQ channel ID (should be non-negative except -1 = terminator)</span>
<span class="cm"> *</span>
<span class="cm"> * @name should be something short, e.g., &quot;tx&quot; or &quot;rx&quot;.  It is for use</span>
<span class="cm"> * by platform_get_resource_byname().  It is defined locally to the</span>
<span class="cm"> * hwmod.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod_irq_info</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">s16</span>		<span class="n">irq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct omap_hwmod_dma_info - DMA channels used by the hwmod</span>
<span class="cm"> * @name: name of the DMA channel (module local name)</span>
<span class="cm"> * @dma_req: DMA request ID (should be non-negative except -1 = terminator)</span>
<span class="cm"> *</span>
<span class="cm"> * @name should be something short, e.g., &quot;tx&quot; or &quot;rx&quot;.  It is for use</span>
<span class="cm"> * by platform_get_resource_byname().  It is defined locally to the</span>
<span class="cm"> * hwmod.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod_dma_info</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">s16</span>		<span class="n">dma_req</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct omap_hwmod_rst_info - IPs reset lines use by hwmod</span>
<span class="cm"> * @name: name of the reset line (module local name)</span>
<span class="cm"> * @rst_shift: Offset of the reset bit</span>
<span class="cm"> * @st_shift: Offset of the reset status bit (OMAP2/3 only)</span>
<span class="cm"> *</span>
<span class="cm"> * @name should be something short, e.g., &quot;cpu0&quot; or &quot;rst&quot;. It is defined</span>
<span class="cm"> * locally to the hwmod.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod_rst_info</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">rst_shift</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">st_shift</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct omap_hwmod_opt_clk - optional clocks used by this hwmod</span>
<span class="cm"> * @role: &quot;sys&quot;, &quot;32k&quot;, &quot;tv&quot;, etc -- for use in clk_get()</span>
<span class="cm"> * @clk: opt clock: OMAP clock name</span>
<span class="cm"> * @_clk: pointer to the struct clk (filled in at runtime)</span>
<span class="cm"> *</span>
<span class="cm"> * The module&#39;s interface clock and main functional clock should not</span>
<span class="cm"> * be added as optional clocks.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod_opt_clk</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">role</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>	<span class="o">*</span><span class="n">_clk</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* omap_hwmod_omap2_firewall.flags bits */</span>
<span class="cp">#define OMAP_FIREWALL_L3		(1 &lt;&lt; 0)</span>
<span class="cp">#define OMAP_FIREWALL_L4		(1 &lt;&lt; 1)</span>

<span class="cm">/**</span>
<span class="cm"> * struct omap_hwmod_omap2_firewall - OMAP2/3 device firewall data</span>
<span class="cm"> * @l3_perm_bit: bit shift for L3_PM_*_PERMISSION_*</span>
<span class="cm"> * @l4_fw_region: L4 firewall region ID</span>
<span class="cm"> * @l4_prot_group: L4 protection group ID</span>
<span class="cm"> * @flags: (see omap_hwmod_omap2_firewall.flags macros above)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod_omap2_firewall</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">l3_perm_bit</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">l4_fw_region</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">l4_prot_group</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * omap_hwmod_addr_space.flags bits</span>
<span class="cm"> *</span>
<span class="cm"> * ADDR_MAP_ON_INIT: Map this address space during omap_hwmod init.</span>
<span class="cm"> * ADDR_TYPE_RT: Address space contains module register target data.</span>
<span class="cm"> */</span>
<span class="cp">#define ADDR_MAP_ON_INIT	(1 &lt;&lt; 0)	</span><span class="cm">/* XXX does not belong */</span><span class="cp"></span>
<span class="cp">#define ADDR_TYPE_RT		(1 &lt;&lt; 1)</span>

<span class="cm">/**</span>
<span class="cm"> * struct omap_hwmod_addr_space - address space handled by the hwmod</span>
<span class="cm"> * @name: name of the address space</span>
<span class="cm"> * @pa_start: starting physical address</span>
<span class="cm"> * @pa_end: ending physical address</span>
<span class="cm"> * @flags: (see omap_hwmod_addr_space.flags macros above)</span>
<span class="cm"> *</span>
<span class="cm"> * Address space doesn&#39;t necessarily follow physical interconnect</span>
<span class="cm"> * structure.  GPMC is one example.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod_addr_space</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pa_start</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pa_end</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * omap_hwmod_ocp_if.user bits: these indicate the initiators that use this</span>
<span class="cm"> * interface to interact with the hwmod.  Used to add sleep dependencies</span>
<span class="cm"> * when the module is enabled or disabled.</span>
<span class="cm"> */</span>
<span class="cp">#define OCP_USER_MPU			(1 &lt;&lt; 0)</span>
<span class="cp">#define OCP_USER_SDMA			(1 &lt;&lt; 1)</span>
<span class="cp">#define OCP_USER_DSP			(1 &lt;&lt; 2)</span>
<span class="cp">#define OCP_USER_IVA			(1 &lt;&lt; 3)</span>

<span class="cm">/* omap_hwmod_ocp_if.flags bits */</span>
<span class="cp">#define OCPIF_SWSUP_IDLE		(1 &lt;&lt; 0)</span>
<span class="cp">#define OCPIF_CAN_BURST			(1 &lt;&lt; 1)</span>

<span class="cm">/* omap_hwmod_ocp_if._int_flags possibilities */</span>
<span class="cp">#define _OCPIF_INT_FLAGS_REGISTERED	(1 &lt;&lt; 0)</span>


<span class="cm">/**</span>
<span class="cm"> * struct omap_hwmod_ocp_if - OCP interface data</span>
<span class="cm"> * @master: struct omap_hwmod that initiates OCP transactions on this link</span>
<span class="cm"> * @slave: struct omap_hwmod that responds to OCP transactions on this link</span>
<span class="cm"> * @addr: address space associated with this link</span>
<span class="cm"> * @clk: interface clock: OMAP clock name</span>
<span class="cm"> * @_clk: pointer to the interface struct clk (filled in at runtime)</span>
<span class="cm"> * @fw: interface firewall data</span>
<span class="cm"> * @width: OCP data width</span>
<span class="cm"> * @user: initiators using this interface (see OCP_USER_* macros above)</span>
<span class="cm"> * @flags: OCP interface flags (see OCPIF_* macros above)</span>
<span class="cm"> * @_int_flags: internal flags (see _OCPIF_INT_FLAGS* macros above)</span>
<span class="cm"> *</span>
<span class="cm"> * It may also be useful to add a tag_cnt field for OCP2.x devices.</span>
<span class="cm"> *</span>
<span class="cm"> * Parameter names beginning with an underscore are managed internally by</span>
<span class="cm"> * the omap_hwmod code and should not be set during initialization.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span>		<span class="o">*</span><span class="n">master</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod</span>		<span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_addr_space</span>	<span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>			<span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>			<span class="o">*</span><span class="n">_clk</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">omap_hwmod_omap2_firewall</span> <span class="n">omap2</span><span class="p">;</span>
	<span class="p">}</span>				<span class="n">fw</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">width</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">user</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">_int_flags</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* Macros for use in struct omap_hwmod_sysconfig */</span>

<span class="cm">/* Flags for use in omap_hwmod_sysconfig.idlemodes */</span>
<span class="cp">#define MASTER_STANDBY_SHIFT	4</span>
<span class="cp">#define SLAVE_IDLE_SHIFT	0</span>
<span class="cp">#define SIDLE_FORCE		(HWMOD_IDLEMODE_FORCE &lt;&lt; SLAVE_IDLE_SHIFT)</span>
<span class="cp">#define SIDLE_NO		(HWMOD_IDLEMODE_NO &lt;&lt; SLAVE_IDLE_SHIFT)</span>
<span class="cp">#define SIDLE_SMART		(HWMOD_IDLEMODE_SMART &lt;&lt; SLAVE_IDLE_SHIFT)</span>
<span class="cp">#define SIDLE_SMART_WKUP	(HWMOD_IDLEMODE_SMART_WKUP &lt;&lt; SLAVE_IDLE_SHIFT)</span>
<span class="cp">#define MSTANDBY_FORCE		(HWMOD_IDLEMODE_FORCE &lt;&lt; MASTER_STANDBY_SHIFT)</span>
<span class="cp">#define MSTANDBY_NO		(HWMOD_IDLEMODE_NO &lt;&lt; MASTER_STANDBY_SHIFT)</span>
<span class="cp">#define MSTANDBY_SMART		(HWMOD_IDLEMODE_SMART &lt;&lt; MASTER_STANDBY_SHIFT)</span>
<span class="cp">#define MSTANDBY_SMART_WKUP	(HWMOD_IDLEMODE_SMART_WKUP &lt;&lt; MASTER_STANDBY_SHIFT)</span>

<span class="cm">/* omap_hwmod_sysconfig.sysc_flags capability flags */</span>
<span class="cp">#define SYSC_HAS_AUTOIDLE	(1 &lt;&lt; 0)</span>
<span class="cp">#define SYSC_HAS_SOFTRESET	(1 &lt;&lt; 1)</span>
<span class="cp">#define SYSC_HAS_ENAWAKEUP	(1 &lt;&lt; 2)</span>
<span class="cp">#define SYSC_HAS_EMUFREE	(1 &lt;&lt; 3)</span>
<span class="cp">#define SYSC_HAS_CLOCKACTIVITY	(1 &lt;&lt; 4)</span>
<span class="cp">#define SYSC_HAS_SIDLEMODE	(1 &lt;&lt; 5)</span>
<span class="cp">#define SYSC_HAS_MIDLEMODE	(1 &lt;&lt; 6)</span>
<span class="cp">#define SYSS_HAS_RESET_STATUS	(1 &lt;&lt; 7)</span>
<span class="cp">#define SYSC_NO_CACHE		(1 &lt;&lt; 8)  </span><span class="cm">/* XXX SW flag, belongs elsewhere */</span><span class="cp"></span>
<span class="cp">#define SYSC_HAS_RESET_STATUS	(1 &lt;&lt; 9)</span>

<span class="cm">/* omap_hwmod_sysconfig.clockact flags */</span>
<span class="cp">#define CLOCKACT_TEST_BOTH	0x0</span>
<span class="cp">#define CLOCKACT_TEST_MAIN	0x1</span>
<span class="cp">#define CLOCKACT_TEST_ICLK	0x2</span>
<span class="cp">#define CLOCKACT_TEST_NONE	0x3</span>

<span class="cm">/**</span>
<span class="cm"> * struct omap_hwmod_sysc_fields - hwmod OCP_SYSCONFIG register field offsets.</span>
<span class="cm"> * @midle_shift: Offset of the midle bit</span>
<span class="cm"> * @clkact_shift: Offset of the clockactivity bit</span>
<span class="cm"> * @sidle_shift: Offset of the sidle bit</span>
<span class="cm"> * @enwkup_shift: Offset of the enawakeup bit</span>
<span class="cm"> * @srst_shift: Offset of the softreset bit</span>
<span class="cm"> * @autoidle_shift: Offset of the autoidle bit</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod_sysc_fields</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">midle_shift</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">clkact_shift</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sidle_shift</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">enwkup_shift</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">srst_shift</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">autoidle_shift</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct omap_hwmod_class_sysconfig - hwmod class OCP_SYS* data</span>
<span class="cm"> * @rev_offs: IP block revision register offset (from module base addr)</span>
<span class="cm"> * @sysc_offs: OCP_SYSCONFIG register offset (from module base addr)</span>
<span class="cm"> * @syss_offs: OCP_SYSSTATUS register offset (from module base addr)</span>
<span class="cm"> * @srst_udelay: Delay needed after doing a softreset in usecs</span>
<span class="cm"> * @idlemodes: One or more of {SIDLE,MSTANDBY}_{OFF,FORCE,SMART}</span>
<span class="cm"> * @sysc_flags: SYS{C,S}_HAS* flags indicating SYSCONFIG bits supported</span>
<span class="cm"> * @clockact: the default value of the module CLOCKACTIVITY bits</span>
<span class="cm"> *</span>
<span class="cm"> * @clockact describes to the module which clocks are likely to be</span>
<span class="cm"> * disabled when the PRCM issues its idle request to the module.  Some</span>
<span class="cm"> * modules have separate clockdomains for the interface clock and main</span>
<span class="cm"> * functional clock, and can check whether they should acknowledge the</span>
<span class="cm"> * idle request based on the internal module functionality that has</span>
<span class="cm"> * been associated with the clocks marked in @clockact.  This field is</span>
<span class="cm"> * only used if HWMOD_SET_DEFAULT_CLOCKACT is set (see below)</span>
<span class="cm"> *</span>
<span class="cm"> * @sysc_fields: structure containing the offset positions of various bits in</span>
<span class="cm"> * SYSCONFIG register. This can be populated using omap_hwmod_sysc_type1 or</span>
<span class="cm"> * omap_hwmod_sysc_type2 defined in omap_hwmod_common_data.c depending on</span>
<span class="cm"> * whether the device ip is compliant with the original PRCM protocol</span>
<span class="cm"> * defined for OMAP2420 or the new PRCM protocol for new OMAP4 IPs.</span>
<span class="cm"> * If the device follows a different scheme for the sysconfig register ,</span>
<span class="cm"> * then this field has to be populated with the correct offset structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod_class_sysconfig</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">rev_offs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sysc_offs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">syss_offs</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">sysc_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_sysc_fields</span> <span class="o">*</span><span class="n">sysc_fields</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">srst_udelay</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">idlemodes</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">clockact</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct omap_hwmod_omap2_prcm - OMAP2/3-specific PRCM data</span>
<span class="cm"> * @module_offs: PRCM submodule offset from the start of the PRM/CM</span>
<span class="cm"> * @prcm_reg_id: PRCM register ID (e.g., 3 for CM_AUTOIDLE3)</span>
<span class="cm"> * @module_bit: register bit shift for AUTOIDLE, WKST, WKEN, GRPSEL regs</span>
<span class="cm"> * @idlest_reg_id: IDLEST register ID (e.g., 3 for CM_IDLEST3)</span>
<span class="cm"> * @idlest_idle_bit: register bit shift for CM_IDLEST slave idle bit</span>
<span class="cm"> * @idlest_stdby_bit: register bit shift for CM_IDLEST master standby bit</span>
<span class="cm"> *</span>
<span class="cm"> * @prcm_reg_id and @module_bit are specific to the AUTOIDLE, WKST,</span>
<span class="cm"> * WKEN, GRPSEL registers.  In an ideal world, no extra information</span>
<span class="cm"> * would be needed for IDLEST information, but alas, there are some</span>
<span class="cm"> * exceptions, so @idlest_reg_id, @idlest_idle_bit, @idlest_stdby_bit</span>
<span class="cm"> * are needed for the IDLEST registers (c.f. 2430 I2CHS, 3430 USBHOST)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod_omap2_prcm</span> <span class="p">{</span>
	<span class="n">s16</span> <span class="n">module_offs</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">prcm_reg_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">module_bit</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">idlest_reg_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">idlest_idle_bit</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">idlest_stdby_bit</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * struct omap_hwmod_omap4_prcm - OMAP4-specific PRCM data</span>
<span class="cm"> * @clkctrl_reg: PRCM address of the clock control register</span>
<span class="cm"> * @rstctrl_reg: address of the XXX_RSTCTRL register located in the PRM</span>
<span class="cm"> * @submodule_wkdep_bit: bit shift of the WKDEP range</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod_omap4_prcm</span> <span class="p">{</span>
	<span class="n">u16</span>		<span class="n">clkctrl_offs</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">rstctrl_offs</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">context_offs</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">submodule_wkdep_bit</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">modulemode</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * omap_hwmod.flags definitions</span>
<span class="cm"> *</span>
<span class="cm"> * HWMOD_SWSUP_SIDLE: omap_hwmod code should manually bring module in and out</span>
<span class="cm"> *     of idle, rather than relying on module smart-idle</span>
<span class="cm"> * HWMOD_SWSUP_MSTDBY: omap_hwmod code should manually bring module in and out</span>
<span class="cm"> *     of standby, rather than relying on module smart-standby</span>
<span class="cm"> * HWMOD_INIT_NO_RESET: don&#39;t reset this module at boot - important for</span>
<span class="cm"> *     SDRAM controller, etc. XXX probably belongs outside the main hwmod file</span>
<span class="cm"> *     XXX Should be HWMOD_SETUP_NO_RESET</span>
<span class="cm"> * HWMOD_INIT_NO_IDLE: don&#39;t idle this module at boot - important for SDRAM</span>
<span class="cm"> *     controller, etc. XXX probably belongs outside the main hwmod file</span>
<span class="cm"> *     XXX Should be HWMOD_SETUP_NO_IDLE</span>
<span class="cm"> * HWMOD_NO_OCP_AUTOIDLE: disable module autoidle (OCP_SYSCONFIG.AUTOIDLE)</span>
<span class="cm"> *     when module is enabled, rather than the default, which is to</span>
<span class="cm"> *     enable autoidle</span>
<span class="cm"> * HWMOD_SET_DEFAULT_CLOCKACT: program CLOCKACTIVITY bits at startup</span>
<span class="cm"> * HWMOD_NO_IDLEST: this module does not have idle status - this is the case</span>
<span class="cm"> *     only for few initiator modules on OMAP2 &amp; 3.</span>
<span class="cm"> * HWMOD_CONTROL_OPT_CLKS_IN_RESET: Enable all optional clocks during reset.</span>
<span class="cm"> *     This is needed for devices like DSS that require optional clocks enabled</span>
<span class="cm"> *     in order to complete the reset. Optional clocks will be disabled</span>
<span class="cm"> *     again after the reset.</span>
<span class="cm"> * HWMOD_16BIT_REG: Module has 16bit registers</span>
<span class="cm"> */</span>
<span class="cp">#define HWMOD_SWSUP_SIDLE			(1 &lt;&lt; 0)</span>
<span class="cp">#define HWMOD_SWSUP_MSTANDBY			(1 &lt;&lt; 1)</span>
<span class="cp">#define HWMOD_INIT_NO_RESET			(1 &lt;&lt; 2)</span>
<span class="cp">#define HWMOD_INIT_NO_IDLE			(1 &lt;&lt; 3)</span>
<span class="cp">#define HWMOD_NO_OCP_AUTOIDLE			(1 &lt;&lt; 4)</span>
<span class="cp">#define HWMOD_SET_DEFAULT_CLOCKACT		(1 &lt;&lt; 5)</span>
<span class="cp">#define HWMOD_NO_IDLEST				(1 &lt;&lt; 6)</span>
<span class="cp">#define HWMOD_CONTROL_OPT_CLKS_IN_RESET		(1 &lt;&lt; 7)</span>
<span class="cp">#define HWMOD_16BIT_REG				(1 &lt;&lt; 8)</span>

<span class="cm">/*</span>
<span class="cm"> * omap_hwmod._int_flags definitions</span>
<span class="cm"> * These are for internal use only and are managed by the omap_hwmod code.</span>
<span class="cm"> *</span>
<span class="cm"> * _HWMOD_NO_MPU_PORT: no path exists for the MPU to write to this module</span>
<span class="cm"> * _HWMOD_WAKEUP_ENABLED: set when the omap_hwmod code has enabled ENAWAKEUP</span>
<span class="cm"> * _HWMOD_SYSCONFIG_LOADED: set when the OCP_SYSCONFIG value has been cached</span>
<span class="cm"> * _HWMOD_SKIP_ENABLE: set if hwmod enabled during init (HWMOD_INIT_NO_IDLE) -</span>
<span class="cm"> *     causes the first call to _enable() to only update the pinmux</span>
<span class="cm"> */</span>
<span class="cp">#define _HWMOD_NO_MPU_PORT			(1 &lt;&lt; 0)</span>
<span class="cp">#define _HWMOD_WAKEUP_ENABLED			(1 &lt;&lt; 1)</span>
<span class="cp">#define _HWMOD_SYSCONFIG_LOADED			(1 &lt;&lt; 2)</span>
<span class="cp">#define _HWMOD_SKIP_ENABLE			(1 &lt;&lt; 3)</span>

<span class="cm">/*</span>
<span class="cm"> * omap_hwmod._state definitions</span>
<span class="cm"> *</span>
<span class="cm"> * INITIALIZED: reset (optionally), initialized, enabled, disabled</span>
<span class="cm"> *              (optionally)</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define _HWMOD_STATE_UNKNOWN			0</span>
<span class="cp">#define _HWMOD_STATE_REGISTERED			1</span>
<span class="cp">#define _HWMOD_STATE_CLKS_INITED		2</span>
<span class="cp">#define _HWMOD_STATE_INITIALIZED		3</span>
<span class="cp">#define _HWMOD_STATE_ENABLED			4</span>
<span class="cp">#define _HWMOD_STATE_IDLE			5</span>
<span class="cp">#define _HWMOD_STATE_DISABLED			6</span>

<span class="cm">/**</span>
<span class="cm"> * struct omap_hwmod_class - the type of an IP block</span>
<span class="cm"> * @name: name of the hwmod_class</span>
<span class="cm"> * @sysc: device SYSCONFIG/SYSSTATUS register data</span>
<span class="cm"> * @rev: revision of the IP class</span>
<span class="cm"> * @pre_shutdown: ptr to fn to be executed immediately prior to device shutdown</span>
<span class="cm"> * @reset: ptr to fn to be executed in place of the standard hwmod reset fn</span>
<span class="cm"> *</span>
<span class="cm"> * Represent the class of a OMAP hardware &quot;modules&quot; (e.g. timer,</span>
<span class="cm"> * smartreflex, gpio, uart...)</span>
<span class="cm"> *</span>
<span class="cm"> * @pre_shutdown is a function that will be run immediately before</span>
<span class="cm"> * hwmod clocks are disabled, etc.  It is intended for use for hwmods</span>
<span class="cm"> * like the MPU watchdog, which cannot be disabled with the standard</span>
<span class="cm"> * omap_hwmod_shutdown().  The function should return 0 upon success,</span>
<span class="cm"> * or some negative error upon failure.  Returning an error will cause</span>
<span class="cm"> * omap_hwmod_shutdown() to abort the device shutdown and return an</span>
<span class="cm"> * error.</span>
<span class="cm"> *</span>
<span class="cm"> * If @reset is defined, then the function it points to will be</span>
<span class="cm"> * executed in place of the standard hwmod _reset() code in</span>
<span class="cm"> * mach-omap2/omap_hwmod.c.  This is needed for IP blocks which have</span>
<span class="cm"> * unusual reset sequences - usually processor IP blocks like the IVA.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod_class</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>				<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_class_sysconfig</span>	<span class="o">*</span><span class="n">sysc</span><span class="p">;</span>
	<span class="n">u32</span>					<span class="n">rev</span><span class="p">;</span>
	<span class="kt">int</span>					<span class="p">(</span><span class="o">*</span><span class="n">pre_shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>
	<span class="kt">int</span>					<span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct omap_hwmod_link - internal structure linking hwmods with ocp_ifs</span>
<span class="cm"> * @ocp_if: OCP interface structure record pointer</span>
<span class="cm"> * @node: list_head pointing to next struct omap_hwmod_link in a list</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod_link</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span>	<span class="o">*</span><span class="n">ocp_if</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">node</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct omap_hwmod - integration data for OMAP hardware &quot;modules&quot; (IP blocks)</span>
<span class="cm"> * @name: name of the hwmod</span>
<span class="cm"> * @class: struct omap_hwmod_class * to the class of this hwmod</span>
<span class="cm"> * @od: struct omap_device currently associated with this hwmod (internal use)</span>
<span class="cm"> * @mpu_irqs: ptr to an array of MPU IRQs</span>
<span class="cm"> * @sdma_reqs: ptr to an array of System DMA request IDs</span>
<span class="cm"> * @prcm: PRCM data pertaining to this hwmod</span>
<span class="cm"> * @main_clk: main clock: OMAP clock name</span>
<span class="cm"> * @_clk: pointer to the main struct clk (filled in at runtime)</span>
<span class="cm"> * @opt_clks: other device clocks that drivers can request (0..*)</span>
<span class="cm"> * @voltdm: pointer to voltage domain (filled in at runtime)</span>
<span class="cm"> * @dev_attr: arbitrary device attributes that can be passed to the driver</span>
<span class="cm"> * @_sysc_cache: internal-use hwmod flags</span>
<span class="cm"> * @_mpu_rt_va: cached register target start address (internal use)</span>
<span class="cm"> * @_mpu_port: cached MPU register target slave (internal use)</span>
<span class="cm"> * @opt_clks_cnt: number of @opt_clks</span>
<span class="cm"> * @master_cnt: number of @master entries</span>
<span class="cm"> * @slaves_cnt: number of @slave entries</span>
<span class="cm"> * @response_lat: device OCP response latency (in interface clock cycles)</span>
<span class="cm"> * @_int_flags: internal-use hwmod flags</span>
<span class="cm"> * @_state: internal-use hwmod state</span>
<span class="cm"> * @_postsetup_state: internal-use state to leave the hwmod in after _setup()</span>
<span class="cm"> * @flags: hwmod flags (documented below)</span>
<span class="cm"> * @_lock: spinlock serializing operations on this hwmod</span>
<span class="cm"> * @node: list node for hwmod list (internal use)</span>
<span class="cm"> *</span>
<span class="cm"> * @main_clk refers to this module&#39;s &quot;main clock,&quot; which for our</span>
<span class="cm"> * purposes is defined as &quot;the functional clock needed for register</span>
<span class="cm"> * accesses to complete.&quot;  Modules may not have a main clock if the</span>
<span class="cm"> * interface clock also serves as a main clock.</span>
<span class="cm"> *</span>
<span class="cm"> * Parameter names beginning with an underscore are managed internally by</span>
<span class="cm"> * the omap_hwmod code and should not be set during initialization.</span>
<span class="cm"> *</span>
<span class="cm"> * @masters and @slaves are now deprecated.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_class</span>		<span class="o">*</span><span class="n">class</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_device</span>		<span class="o">*</span><span class="n">od</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_mux_info</span>	<span class="o">*</span><span class="n">mux</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_irq_info</span>	<span class="o">*</span><span class="n">mpu_irqs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_dma_info</span>	<span class="o">*</span><span class="n">sdma_reqs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_rst_info</span>	<span class="o">*</span><span class="n">rst_lines</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">omap_hwmod_omap2_prcm</span> <span class="n">omap2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">omap_hwmod_omap4_prcm</span> <span class="n">omap4</span><span class="p">;</span>
	<span class="p">}</span>				<span class="n">prcm</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>			<span class="o">*</span><span class="n">main_clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>			<span class="o">*</span><span class="n">_clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_opt_clk</span>	<span class="o">*</span><span class="n">opt_clks</span><span class="p">;</span>
	<span class="kt">char</span>				<span class="o">*</span><span class="n">clkdm_name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clockdomain</span>		<span class="o">*</span><span class="n">clkdm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">master_ports</span><span class="p">;</span> <span class="cm">/* connect to *_IA */</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">slave_ports</span><span class="p">;</span> <span class="cm">/* connect to *_TA */</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">dev_attr</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">_sysc_cache</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>			<span class="o">*</span><span class="n">_mpu_rt_va</span><span class="p">;</span>
	<span class="n">spinlock_t</span>			<span class="n">_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span>	<span class="o">*</span><span class="n">_mpu_port</span><span class="p">;</span>
	<span class="n">u16</span>				<span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">response_lat</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">rst_lines_cnt</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">opt_clks_cnt</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">masters_cnt</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">slaves_cnt</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">hwmods_cnt</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">_int_flags</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">_state</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">_postsetup_state</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">omap_hwmod_lookup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_for_each</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="n">omap_hwmod_setup_one</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">omap_hwmod_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">_omap_hwmod_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">_omap_hwmod_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">omap_hwmod_assert_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_deassert_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_read_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">omap_hwmod_enable_clocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_disable_clocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">omap_hwmod_set_slave_idlemode</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u8</span> <span class="n">idlemode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_set_ocp_autoidle</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u8</span> <span class="n">autoidle</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">omap_hwmod_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">omap_hwmod_ocp_barrier</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">omap_hwmod_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">v</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg_offs</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">omap_hwmod_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg_offs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_softreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">omap_hwmod_count_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_fill_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_get_resource_byname</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">powerdomain</span> <span class="o">*</span><span class="n">omap_hwmod_get_pwrdm</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">omap_hwmod_get_mpu_rt_va</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">omap_hwmod_add_initiator_dep</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">init_oh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_del_initiator_dep</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">init_oh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">omap_hwmod_set_clockact_both</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_set_clockact_main</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_set_clockact_iclk</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_set_clockact_none</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">omap_hwmod_enable_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_disable_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">omap_hwmod_for_each_by_class</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">classname</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="o">*</span><span class="n">user</span><span class="p">),</span>
				 <span class="kt">void</span> <span class="o">*</span><span class="n">user</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">omap_hwmod_set_postsetup_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="n">u8</span> <span class="n">state</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">omap_hwmod_get_context_loss_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">omap_hwmod_no_setup_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">omap_hwmod_pad_route_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod</span> <span class="o">*</span><span class="n">oh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad_idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq_idx</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Chip variant-specific hwmod init routines - XXX should be converted</span>
<span class="cm"> * to use initcalls once the initial boot ordering is straightened out</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">omap2420_hwmod_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">omap2430_hwmod_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">omap3xxx_hwmod_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">omap44xx_hwmod_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">omap_hwmod_register_links</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_hwmod_ocp_if</span> <span class="o">**</span><span class="n">ois</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
