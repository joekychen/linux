<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › plat-omap › include › plat › omap-pm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>omap-pm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * omap-pm.h - OMAP power management interface</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008-2010 Texas Instruments, Inc.</span>
<span class="cm"> * Copyright (C) 2008-2010 Nokia Corporation</span>
<span class="cm"> * Paul Walmsley</span>
<span class="cm"> *</span>
<span class="cm"> * Interface developed by (in alphabetical order): Karthik Dasu, Jouni</span>
<span class="cm"> * Högander, Tony Lindgren, Rajendra Nayak, Sakari Poussa,</span>
<span class="cm"> * Veeramanikandan Raju, Anand Sawant, Igor Stoppa, Paul Walmsley,</span>
<span class="cm"> * Richard Woodruff</span>
<span class="cm"> */</span>

<span class="cp">#ifndef ASM_ARM_ARCH_OMAP_OMAP_PM_H</span>
<span class="cp">#define ASM_ARM_ARCH_OMAP_OMAP_PM_H</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/cpufreq.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/opp.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * agent_id values for use with omap_pm_set_min_bus_tput():</span>
<span class="cm"> *</span>
<span class="cm"> * OCP_INITIATOR_AGENT is only valid for devices that can act as</span>
<span class="cm"> * initiators -- it represents the device&#39;s L3 interconnect</span>
<span class="cm"> * connection.  OCP_TARGET_AGENT represents the device&#39;s L4</span>
<span class="cm"> * interconnect connection.</span>
<span class="cm"> */</span>
<span class="cp">#define OCP_TARGET_AGENT		1</span>
<span class="cp">#define OCP_INITIATOR_AGENT		2</span>

<span class="cm">/**</span>
<span class="cm"> * omap_pm_if_early_init - OMAP PM init code called before clock fw init</span>
<span class="cm"> * @mpu_opp_table: array ptr to struct omap_opp for MPU</span>
<span class="cm"> * @dsp_opp_table: array ptr to struct omap_opp for DSP</span>
<span class="cm"> * @l3_opp_table : array ptr to struct omap_opp for CORE</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize anything that must be configured before the clock</span>
<span class="cm"> * framework starts.  The &quot;_if_&quot; is to avoid name collisions with the</span>
<span class="cm"> * PM idle-loop code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="n">omap_pm_if_early_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * omap_pm_if_init - OMAP PM init code called after clock fw init</span>
<span class="cm"> *</span>
<span class="cm"> * The main initialization code.  OPP tables are passed in here.  The</span>
<span class="cm"> * &quot;_if_&quot; is to avoid name collisions with the PM idle-loop code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="n">omap_pm_if_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * omap_pm_if_exit - OMAP PM exit code</span>
<span class="cm"> *</span>
<span class="cm"> * Exit code; currently unused.  The &quot;_if_&quot; is to avoid name</span>
<span class="cm"> * collisions with the PM idle-loop code.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">omap_pm_if_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Device-driver-originated constraints (via board-*.c files, platform_data)</span>
<span class="cm"> */</span>


<span class="cm">/**</span>
<span class="cm"> * omap_pm_set_max_mpu_wakeup_lat - set the maximum MPU wakeup latency</span>
<span class="cm"> * @dev: struct device * requesting the constraint</span>
<span class="cm"> * @t: maximum MPU wakeup latency in microseconds</span>
<span class="cm"> *</span>
<span class="cm"> * Request that the maximum interrupt latency for the MPU to be no</span>
<span class="cm"> * greater than @t microseconds. &quot;Interrupt latency&quot; in this case is</span>
<span class="cm"> * defined as the elapsed time from the occurrence of a hardware or</span>
<span class="cm"> * timer interrupt to the time when the device driver&#39;s interrupt</span>
<span class="cm"> * service routine has been entered by the MPU.</span>
<span class="cm"> *</span>
<span class="cm"> * It is intended that underlying PM code will use this information to</span>
<span class="cm"> * determine what power state to put the MPU powerdomain into, and</span>
<span class="cm"> * possibly the CORE powerdomain as well, since interrupt handling</span>
<span class="cm"> * code currently runs from SDRAM.  Advanced PM or board*.c code may</span>
<span class="cm"> * also configure interrupt controller priorities, OCP bus priorities,</span>
<span class="cm"> * CPU speed(s), etc.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will not affect device wakeup latency, e.g., time</span>
<span class="cm"> * elapsed from when a device driver enables a hardware device with</span>
<span class="cm"> * clk_enable(), to when the device is ready for register access or</span>
<span class="cm"> * other use.  To control this device wakeup latency, use</span>
<span class="cm"> * omap_pm_set_max_dev_wakeup_lat()</span>
<span class="cm"> *</span>
<span class="cm"> * Multiple calls to omap_pm_set_max_mpu_wakeup_lat() will replace the</span>
<span class="cm"> * previous t value.  To remove the latency target for the MPU, call</span>
<span class="cm"> * with t = -1.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX This constraint will be deprecated soon in favor of the more</span>
<span class="cm"> * general omap_pm_set_max_dev_wakeup_lat()</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EINVAL for an invalid argument, -ERANGE if the constraint</span>
<span class="cm"> * is not satisfiable, or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">omap_pm_set_max_mpu_wakeup_lat</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">long</span> <span class="n">t</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * omap_pm_set_min_bus_tput - set minimum bus throughput needed by device</span>
<span class="cm"> * @dev: struct device * requesting the constraint</span>
<span class="cm"> * @tbus_id: interconnect to operate on (OCP_{INITIATOR,TARGET}_AGENT)</span>
<span class="cm"> * @r: minimum throughput (in KiB/s)</span>
<span class="cm"> *</span>
<span class="cm"> * Request that the minimum data throughput on the OCP interconnect</span>
<span class="cm"> * attached to device @dev interconnect agent @tbus_id be no less</span>
<span class="cm"> * than @r KiB/s.</span>
<span class="cm"> *</span>
<span class="cm"> * It is expected that the OMAP PM or bus code will use this</span>
<span class="cm"> * information to set the interconnect clock to run at the lowest</span>
<span class="cm"> * possible speed that satisfies all current system users.  The PM or</span>
<span class="cm"> * bus code will adjust the estimate based on its model of the bus, so</span>
<span class="cm"> * device driver authors should attempt to specify an accurate</span>
<span class="cm"> * quantity for their device use case, and let the PM or bus code</span>
<span class="cm"> * overestimate the numbers as necessary to handle request/response</span>
<span class="cm"> * latency, other competing users on the system, etc.  On OMAP2/3, if</span>
<span class="cm"> * a driver requests a minimum L4 interconnect speed constraint, the</span>
<span class="cm"> * code will also need to add an minimum L3 interconnect speed</span>
<span class="cm"> * constraint,</span>
<span class="cm"> *</span>
<span class="cm"> * Multiple calls to omap_pm_set_min_bus_tput() will replace the</span>
<span class="cm"> * previous rate value for this device.  To remove the interconnect</span>
<span class="cm"> * throughput restriction for this device, call with r = 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EINVAL for an invalid argument, -ERANGE if the constraint</span>
<span class="cm"> * is not satisfiable, or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">omap_pm_set_min_bus_tput</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">agent_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * omap_pm_set_max_dev_wakeup_lat - set the maximum device enable latency</span>
<span class="cm"> * @req_dev: struct device * requesting the constraint, or NULL if none</span>
<span class="cm"> * @dev: struct device * to set the constraint one</span>
<span class="cm"> * @t: maximum device wakeup latency in microseconds</span>
<span class="cm"> *</span>
<span class="cm"> * Request that the maximum amount of time necessary for a device @dev</span>
<span class="cm"> * to become accessible after its clocks are enabled should be no</span>
<span class="cm"> * greater than @t microseconds.  Specifically, this represents the</span>
<span class="cm"> * time from when a device driver enables device clocks with</span>
<span class="cm"> * clk_enable(), to when the register reads and writes on the device</span>
<span class="cm"> * will succeed.  This function should be called before clk_disable()</span>
<span class="cm"> * is called, since the power state transition decision may be made</span>
<span class="cm"> * during clk_disable().</span>
<span class="cm"> *</span>
<span class="cm"> * It is intended that underlying PM code will use this information to</span>
<span class="cm"> * determine what power state to put the powerdomain enclosing this</span>
<span class="cm"> * device into.</span>
<span class="cm"> *</span>
<span class="cm"> * Multiple calls to omap_pm_set_max_dev_wakeup_lat() will replace the</span>
<span class="cm"> * previous wakeup latency values for this device.  To remove the</span>
<span class="cm"> * wakeup latency restriction for this device, call with t = -1.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EINVAL for an invalid argument, -ERANGE if the constraint</span>
<span class="cm"> * is not satisfiable, or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">omap_pm_set_max_dev_wakeup_lat</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">req_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="kt">long</span> <span class="n">t</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * omap_pm_set_max_sdma_lat - set the maximum system DMA transfer start latency</span>
<span class="cm"> * @dev: struct device *</span>
<span class="cm"> * @t: maximum DMA transfer start latency in microseconds</span>
<span class="cm"> *</span>
<span class="cm"> * Request that the maximum system DMA transfer start latency for this</span>
<span class="cm"> * device &#39;dev&#39; should be no greater than &#39;t&#39; microseconds.  &quot;DMA</span>
<span class="cm"> * transfer start latency&quot; here is defined as the elapsed time from</span>
<span class="cm"> * when a device (e.g., McBSP) requests that a system DMA transfer</span>
<span class="cm"> * start or continue, to the time at which data starts to flow into</span>
<span class="cm"> * that device from the system DMA controller.</span>
<span class="cm"> *</span>
<span class="cm"> * It is intended that underlying PM code will use this information to</span>
<span class="cm"> * determine what power state to put the CORE powerdomain into.</span>
<span class="cm"> *</span>
<span class="cm"> * Since system DMA transfers may not involve the MPU, this function</span>
<span class="cm"> * will not affect MPU wakeup latency.  Use set_max_cpu_lat() to do</span>
<span class="cm"> * so.  Similarly, this function will not affect device wakeup latency</span>
<span class="cm"> * -- use set_max_dev_wakeup_lat() to affect that.</span>
<span class="cm"> *</span>
<span class="cm"> * Multiple calls to set_max_sdma_lat() will replace the previous t</span>
<span class="cm"> * value for this device.  To remove the maximum DMA latency for this</span>
<span class="cm"> * device, call with t = -1.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EINVAL for an invalid argument, -ERANGE if the constraint</span>
<span class="cm"> * is not satisfiable, or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">omap_pm_set_max_sdma_lat</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">long</span> <span class="n">t</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * omap_pm_set_min_clk_rate - set minimum clock rate requested by @dev</span>
<span class="cm"> * @dev: struct device * requesting the constraint</span>
<span class="cm"> * @clk: struct clk * to set the minimum rate constraint on</span>
<span class="cm"> * @r: minimum rate in Hz</span>
<span class="cm"> *</span>
<span class="cm"> * Request that the minimum clock rate on the device @dev&#39;s clk @clk</span>
<span class="cm"> * be no less than @r Hz.</span>
<span class="cm"> *</span>
<span class="cm"> * It is expected that the OMAP PM code will use this information to</span>
<span class="cm"> * find an OPP or clock setting that will satisfy this clock rate</span>
<span class="cm"> * constraint, along with any other applicable system constraints on</span>
<span class="cm"> * the clock rate or corresponding voltage, etc.</span>
<span class="cm"> *</span>
<span class="cm"> * omap_pm_set_min_clk_rate() differs from the clock code&#39;s</span>
<span class="cm"> * clk_set_rate() in that it considers other constraints before taking</span>
<span class="cm"> * any hardware action, and may change a system OPP rather than just a</span>
<span class="cm"> * clock rate.  clk_set_rate() is intended to be a low-level</span>
<span class="cm"> * interface.</span>
<span class="cm"> *</span>
<span class="cm"> * omap_pm_set_min_clk_rate() is easily open to abuse.  A better API</span>
<span class="cm"> * would be something like &quot;omap_pm_set_min_dev_performance()&quot;;</span>
<span class="cm"> * however, there is no easily-generalizable concept of performance</span>
<span class="cm"> * that applies to all devices.  Only a device (and possibly the</span>
<span class="cm"> * device subsystem) has both the subsystem-specific knowledge, and</span>
<span class="cm"> * the hardware IP block-specific knowledge, to translate a constraint</span>
<span class="cm"> * on &quot;touchscreen sampling accuracy&quot; or &quot;number of pixels or polygons</span>
<span class="cm"> * rendered per second&quot; to a clock rate.  This translation can be</span>
<span class="cm"> * dependent on the hardware IP block&#39;s revision, or firmware version,</span>
<span class="cm"> * and the driver is the only code on the system that has this</span>
<span class="cm"> * information and can know how to translate that into a clock rate.</span>
<span class="cm"> *</span>
<span class="cm"> * The intended use-case for this function is for userspace or other</span>
<span class="cm"> * kernel code to communicate a particular performance requirement to</span>
<span class="cm"> * a subsystem; then for the subsystem to communicate that requirement</span>
<span class="cm"> * to something that is meaningful to the device driver; then for the</span>
<span class="cm"> * device driver to convert that requirement to a clock rate, and to</span>
<span class="cm"> * then call omap_pm_set_min_clk_rate().</span>
<span class="cm"> *</span>
<span class="cm"> * Users of this function (such as device drivers) should not simply</span>
<span class="cm"> * call this function with some high clock rate to ensure &quot;high</span>
<span class="cm"> * performance.&quot;  Rather, the device driver should take a performance</span>
<span class="cm"> * constraint from its subsystem, such as &quot;render at least X polygons</span>
<span class="cm"> * per second,&quot; and use some formula or table to convert that into a</span>
<span class="cm"> * clock rate constraint given the hardware type and hardware</span>
<span class="cm"> * revision.  Device drivers or subsystems should not assume that they</span>
<span class="cm"> * know how to make a power/performance tradeoff - some device use</span>
<span class="cm"> * cases may tolerate a lower-fidelity device function for lower power</span>
<span class="cm"> * consumption; others may demand a higher-fidelity device function,</span>
<span class="cm"> * no matter what the power consumption.</span>
<span class="cm"> *</span>
<span class="cm"> * Multiple calls to omap_pm_set_min_clk_rate() will replace the</span>
<span class="cm"> * previous rate value for the device @dev.  To remove the minimum clock</span>
<span class="cm"> * rate constraint for the device, call with r = 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EINVAL for an invalid argument, -ERANGE if the constraint</span>
<span class="cm"> * is not satisfiable, or 0 upon success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">omap_pm_set_min_clk_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">long</span> <span class="n">r</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * DSP Bridge-specific constraints</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * omap_pm_dsp_get_opp_table - get OPP-&gt;DSP clock frequency table</span>
<span class="cm"> *</span>
<span class="cm"> * Intended for use by DSPBridge.  Returns an array of OPP-&gt;DSP clock</span>
<span class="cm"> * frequency entries.  The final item in the array should have .rate =</span>
<span class="cm"> * .opp_id = 0.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">omap_opp</span> <span class="o">*</span><span class="n">omap_pm_dsp_get_opp_table</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * omap_pm_dsp_set_min_opp - receive desired OPP target ID from DSP Bridge</span>
<span class="cm"> * @opp_id: target DSP OPP ID</span>
<span class="cm"> *</span>
<span class="cm"> * Set a minimum OPP ID for the DSP.  This is intended to be called</span>
<span class="cm"> * only from the DSP Bridge MPU-side driver.  Unfortunately, the only</span>
<span class="cm"> * information that code receives from the DSP/BIOS load estimator is the</span>
<span class="cm"> * target OPP ID; hence, this interface.  No return value.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">omap_pm_dsp_set_min_opp</span><span class="p">(</span><span class="n">u8</span> <span class="n">opp_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * omap_pm_dsp_get_opp - report the current DSP OPP ID</span>
<span class="cm"> *</span>
<span class="cm"> * Report the current OPP for the DSP.  Since on OMAP3, the DSP and</span>
<span class="cm"> * MPU share a single voltage domain, the OPP ID returned back may</span>
<span class="cm"> * represent a higher DSP speed than the OPP requested via</span>
<span class="cm"> * omap_pm_dsp_set_min_opp().</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the current VDD1 OPP ID, or 0 upon error.</span>
<span class="cm"> */</span>
<span class="n">u8</span> <span class="n">omap_pm_dsp_get_opp</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * CPUFreq-originated constraint</span>
<span class="cm"> *</span>
<span class="cm"> * In the future, this should be handled by custom OPP clocktype</span>
<span class="cm"> * functions.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * omap_pm_cpu_get_freq_table - return a cpufreq_frequency_table array ptr</span>
<span class="cm"> *</span>
<span class="cm"> * Provide a frequency table usable by CPUFreq for the current chip/board.</span>
<span class="cm"> * Returns a pointer to a struct cpufreq_frequency_table array or NULL</span>
<span class="cm"> * upon error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cpufreq_frequency_table</span> <span class="o">**</span><span class="n">omap_pm_cpu_get_freq_table</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * omap_pm_cpu_set_freq - set the current minimum MPU frequency</span>
<span class="cm"> * @f: MPU frequency in Hz</span>
<span class="cm"> *</span>
<span class="cm"> * Set the current minimum CPU frequency.  The actual CPU frequency</span>
<span class="cm"> * used could end up higher if the DSP requested a higher OPP.</span>
<span class="cm"> * Intended to be called by plat-omap/cpu_omap.c:omap_target().  No</span>
<span class="cm"> * return value.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">omap_pm_cpu_set_freq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">f</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * omap_pm_cpu_get_freq - report the current CPU frequency</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the current MPU frequency, or 0 upon error.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">omap_pm_cpu_get_freq</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Device context loss tracking</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * omap_pm_get_dev_context_loss_count - return count of times dev has lost ctx</span>
<span class="cm"> * @dev: struct device *</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of times that the device @dev has</span>
<span class="cm"> * lost its internal context.  This generally occurs on a powerdomain</span>
<span class="cm"> * transition to OFF.  Drivers use this as an optimization to avoid restoring</span>
<span class="cm"> * context if the device hasn&#39;t lost it.  To use, drivers should initially</span>
<span class="cm"> * call this in their context save functions and store the result.  Early in</span>
<span class="cm"> * the driver&#39;s context restore function, the driver should call this function</span>
<span class="cm"> * again, and compare the result to the stored counter.  If they differ, the</span>
<span class="cm"> * driver must restore device context.   If the number of context losses</span>
<span class="cm"> * exceeds the maximum positive integer, the function will wrap to 0 and</span>
<span class="cm"> * continue counting.  Returns the number of context losses for this device,</span>
<span class="cm"> * or negative value upon error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">omap_pm_get_dev_context_loss_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">omap_pm_enable_off_mode</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">omap_pm_disable_off_mode</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
