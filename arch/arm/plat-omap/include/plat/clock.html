<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › plat-omap › include › plat › clock.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>clock.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * OMAP clock: data structure definitions, function prototypes, shared macros</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004-2005, 2008-2010 Nokia Corporation</span>
<span class="cm"> * Written by Tuukka Tikkanen &lt;tuukka.tikkanen@elektrobit.com&gt;</span>
<span class="cm"> * Based on clocks.h by Tony Lindgren, Gordon McNutt and RidgeRun, Inc</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __ARCH_ARM_OMAP_CLOCK_H</span>
<span class="cp">#define __ARCH_ARM_OMAP_CLOCK_H</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>

<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">clk</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">clockdomain</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct clkops - some clock function pointers</span>
<span class="cm"> * @enable: fn ptr that enables the current clock in hardware</span>
<span class="cm"> * @disable: fn ptr that enables the current clock in hardware</span>
<span class="cm"> * @find_idlest: function returning the IDLEST register for the clock&#39;s IP blk</span>
<span class="cm"> * @find_companion: function returning the &quot;companion&quot; clk reg for the clock</span>
<span class="cm"> * @allow_idle: fn ptr that enables autoidle for the current clock in hardware</span>
<span class="cm"> * @deny_idle: fn ptr that disables autoidle for the current clock in hardware</span>
<span class="cm"> *</span>
<span class="cm"> * A &quot;companion&quot; clk is an accompanying clock to the one being queried</span>
<span class="cm"> * that must be enabled for the IP module connected to the clock to</span>
<span class="cm"> * become accessible by the hardware.  Neither @find_idlest nor</span>
<span class="cm"> * @find_companion should be needed; that information is IP</span>
<span class="cm"> * block-specific; the hwmod code has been created to handle this, but</span>
<span class="cm"> * until hwmod data is ready and drivers have been converted to use PM</span>
<span class="cm"> * runtime calls in place of clk_enable()/clk_disable(), @find_idlest and</span>
<span class="cm"> * @find_companion must, unfortunately, remain.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">clkops</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">enable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">disable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">find_idlest</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">**</span><span class="p">,</span>
					       <span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">find_companion</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">**</span><span class="p">,</span>
						  <span class="n">u8</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">allow_idle</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">deny_idle</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_ARCH_OMAP2PLUS</span>

<span class="cm">/* struct clksel_rate.flags possibilities */</span>
<span class="cp">#define RATE_IN_242X		(1 &lt;&lt; 0)</span>
<span class="cp">#define RATE_IN_243X		(1 &lt;&lt; 1)</span>
<span class="cp">#define RATE_IN_3430ES1		(1 &lt;&lt; 2)	</span><span class="cm">/* 3430ES1 rates only */</span><span class="cp"></span>
<span class="cp">#define RATE_IN_3430ES2PLUS	(1 &lt;&lt; 3)	</span><span class="cm">/* 3430 ES &gt;= 2 rates only */</span><span class="cp"></span>
<span class="cp">#define RATE_IN_36XX		(1 &lt;&lt; 4)</span>
<span class="cp">#define RATE_IN_4430		(1 &lt;&lt; 5)</span>
<span class="cp">#define RATE_IN_TI816X		(1 &lt;&lt; 6)</span>
<span class="cp">#define RATE_IN_4460		(1 &lt;&lt; 7)</span>
<span class="cp">#define RATE_IN_AM33XX		(1 &lt;&lt; 8)</span>
<span class="cp">#define RATE_IN_TI814X		(1 &lt;&lt; 9)</span>

<span class="cp">#define RATE_IN_24XX		(RATE_IN_242X | RATE_IN_243X)</span>
<span class="cp">#define RATE_IN_34XX		(RATE_IN_3430ES1 | RATE_IN_3430ES2PLUS)</span>
<span class="cp">#define RATE_IN_3XXX		(RATE_IN_34XX | RATE_IN_36XX)</span>
<span class="cp">#define RATE_IN_44XX		(RATE_IN_4430 | RATE_IN_4460)</span>

<span class="cm">/* RATE_IN_3430ES2PLUS_36XX includes 34xx/35xx with ES &gt;=2, and all 36xx/37xx */</span>
<span class="cp">#define RATE_IN_3430ES2PLUS_36XX	(RATE_IN_3430ES2PLUS | RATE_IN_36XX)</span>


<span class="cm">/**</span>
<span class="cm"> * struct clksel_rate - register bitfield values corresponding to clk divisors</span>
<span class="cm"> * @val: register bitfield value (shifted to bit 0)</span>
<span class="cm"> * @div: clock divisor corresponding to @val</span>
<span class="cm"> * @flags: (see &quot;struct clksel_rate.flags possibilities&quot; above)</span>
<span class="cm"> *</span>
<span class="cm"> * @val should match the value of a read from struct clk.clksel_reg</span>
<span class="cm"> * AND&#39;ed with struct clk.clksel_mask, shifted right to bit 0.</span>
<span class="cm"> *</span>
<span class="cm"> * @div is the divisor that should be applied to the parent clock&#39;s rate</span>
<span class="cm"> * to produce the current clock&#39;s rate.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">clksel_rate</span> <span class="p">{</span>
	<span class="n">u32</span>			<span class="n">val</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">div</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct clksel - available parent clocks, and a pointer to their divisors</span>
<span class="cm"> * @parent: struct clk * to a possible parent clock</span>
<span class="cm"> * @rates: available divisors for this parent clock</span>
<span class="cm"> *</span>
<span class="cm"> * A struct clksel is always associated with one or more struct clks</span>
<span class="cm"> * and one or more struct clksel_rates.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">clksel</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">clk</span>		 <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">clksel_rate</span> <span class="o">*</span><span class="n">rates</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct dpll_data - DPLL registers and integration data</span>
<span class="cm"> * @mult_div1_reg: register containing the DPLL M and N bitfields</span>
<span class="cm"> * @mult_mask: mask of the DPLL M bitfield in @mult_div1_reg</span>
<span class="cm"> * @div1_mask: mask of the DPLL N bitfield in @mult_div1_reg</span>
<span class="cm"> * @clk_bypass: struct clk pointer to the clock&#39;s bypass clock input</span>
<span class="cm"> * @clk_ref: struct clk pointer to the clock&#39;s reference clock input</span>
<span class="cm"> * @control_reg: register containing the DPLL mode bitfield</span>
<span class="cm"> * @enable_mask: mask of the DPLL mode bitfield in @control_reg</span>
<span class="cm"> * @last_rounded_rate: cache of the last rate result of omap2_dpll_round_rate()</span>
<span class="cm"> * @last_rounded_m: cache of the last M result of omap2_dpll_round_rate()</span>
<span class="cm"> * @max_multiplier: maximum valid non-bypass multiplier value (actual)</span>
<span class="cm"> * @last_rounded_n: cache of the last N result of omap2_dpll_round_rate()</span>
<span class="cm"> * @min_divider: minimum valid non-bypass divider value (actual)</span>
<span class="cm"> * @max_divider: maximum valid non-bypass divider value (actual)</span>
<span class="cm"> * @modes: possible values of @enable_mask</span>
<span class="cm"> * @autoidle_reg: register containing the DPLL autoidle mode bitfield</span>
<span class="cm"> * @idlest_reg: register containing the DPLL idle status bitfield</span>
<span class="cm"> * @autoidle_mask: mask of the DPLL autoidle mode bitfield in @autoidle_reg</span>
<span class="cm"> * @freqsel_mask: mask of the DPLL jitter correction bitfield in @control_reg</span>
<span class="cm"> * @idlest_mask: mask of the DPLL idle status bitfield in @idlest_reg</span>
<span class="cm"> * @auto_recal_bit: bitshift of the driftguard enable bit in @control_reg</span>
<span class="cm"> * @recal_en_bit: bitshift of the PRM_IRQENABLE_* bit for recalibration IRQs</span>
<span class="cm"> * @recal_st_bit: bitshift of the PRM_IRQSTATUS_* bit for recalibration IRQs</span>
<span class="cm"> * @flags: DPLL type/features (see below)</span>
<span class="cm"> *</span>
<span class="cm"> * Possible values for @flags:</span>
<span class="cm"> * DPLL_J_TYPE: &quot;J-type DPLL&quot; (only some 36xx, 4xxx DPLLs)</span>
<span class="cm"> *</span>
<span class="cm"> * @freqsel_mask is only used on the OMAP34xx family and AM35xx.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX Some DPLLs have multiple bypass inputs, so it&#39;s not technically</span>
<span class="cm"> * correct to only have one @clk_bypass pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX The runtime-variable fields (@last_rounded_rate, @last_rounded_m,</span>
<span class="cm"> * @last_rounded_n) should be separated from the runtime-fixed fields</span>
<span class="cm"> * and placed into a different structure, so that the runtime-fixed data</span>
<span class="cm"> * can be placed into read-only space.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dpll_data</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">mult_div1_reg</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">mult_mask</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">div1_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>		<span class="o">*</span><span class="n">clk_bypass</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>		<span class="o">*</span><span class="n">clk_ref</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">control_reg</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">enable_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">last_rounded_rate</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">last_rounded_m</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">max_multiplier</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">last_rounded_n</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">min_divider</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">max_divider</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">modes</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_ARCH_OMAP4)</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">autoidle_reg</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">idlest_reg</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">autoidle_mask</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">freqsel_mask</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">idlest_mask</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">dco_mask</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">sddiv_mask</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">auto_recal_bit</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">recal_en_bit</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">recal_st_bit</span><span class="p">;</span>
<span class="cp">#  endif</span>
	<span class="n">u8</span>			<span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * struct clk.flags possibilities</span>
<span class="cm"> *</span>
<span class="cm"> * XXX document the rest of the clock flags here</span>
<span class="cm"> *</span>
<span class="cm"> * CLOCK_CLKOUTX2: (OMAP4 only) DPLL CLKOUT and CLKOUTX2 GATE_CTRL</span>
<span class="cm"> *     bits share the same register.  This flag allows the</span>
<span class="cm"> *     omap4_dpllmx*() code to determine which GATE_CTRL bit field</span>
<span class="cm"> *     should be used.  This is a temporary solution - a better approach</span>
<span class="cm"> *     would be to associate clock type-specific data with the clock,</span>
<span class="cm"> *     similar to the struct dpll_data approach.</span>
<span class="cm"> */</span>
<span class="cp">#define ENABLE_REG_32BIT	(1 &lt;&lt; 0)	</span><span class="cm">/* Use 32-bit access */</span><span class="cp"></span>
<span class="cp">#define CLOCK_IDLE_CONTROL	(1 &lt;&lt; 1)</span>
<span class="cp">#define CLOCK_NO_IDLE_PARENT	(1 &lt;&lt; 2)</span>
<span class="cp">#define ENABLE_ON_INIT		(1 &lt;&lt; 3)	</span><span class="cm">/* Enable upon framework init */</span><span class="cp"></span>
<span class="cp">#define INVERT_ENABLE		(1 &lt;&lt; 4)	</span><span class="cm">/* 0 enables, 1 disables */</span><span class="cp"></span>
<span class="cp">#define CLOCK_CLKOUTX2		(1 &lt;&lt; 5)</span>

<span class="cm">/**</span>
<span class="cm"> * struct clk - OMAP struct clk</span>
<span class="cm"> * @node: list_head connecting this clock into the full clock list</span>
<span class="cm"> * @ops: struct clkops * for this clock</span>
<span class="cm"> * @name: the name of the clock in the hardware (used in hwmod data and debug)</span>
<span class="cm"> * @parent: pointer to this clock&#39;s parent struct clk</span>
<span class="cm"> * @children: list_head connecting to the child clks&#39; @sibling list_heads</span>
<span class="cm"> * @sibling: list_head connecting this clk to its parent clk&#39;s @children</span>
<span class="cm"> * @rate: current clock rate</span>
<span class="cm"> * @enable_reg: register to write to enable the clock (see @enable_bit)</span>
<span class="cm"> * @recalc: fn ptr that returns the clock&#39;s current rate</span>
<span class="cm"> * @set_rate: fn ptr that can change the clock&#39;s current rate</span>
<span class="cm"> * @round_rate: fn ptr that can round the clock&#39;s current rate</span>
<span class="cm"> * @init: fn ptr to do clock-specific initialization</span>
<span class="cm"> * @enable_bit: bitshift to write to enable/disable the clock (see @enable_reg)</span>
<span class="cm"> * @usecount: number of users that have requested this clock to be enabled</span>
<span class="cm"> * @fixed_div: when &gt; 0, this clock&#39;s rate is its parent&#39;s rate / @fixed_div</span>
<span class="cm"> * @flags: see &quot;struct clk.flags possibilities&quot; above</span>
<span class="cm"> * @clksel_reg: for clksel clks, register va containing src/divisor select</span>
<span class="cm"> * @clksel_mask: bitmask in @clksel_reg for the src/divisor selector</span>
<span class="cm"> * @clksel: for clksel clks, pointer to struct clksel for this clock</span>
<span class="cm"> * @dpll_data: for DPLLs, pointer to struct dpll_data for this clock</span>
<span class="cm"> * @clkdm_name: clockdomain name that this clock is contained in</span>
<span class="cm"> * @clkdm: pointer to struct clockdomain, resolved from @clkdm_name at runtime</span>
<span class="cm"> * @rate_offset: bitshift for rate selection bitfield (OMAP1 only)</span>
<span class="cm"> * @src_offset: bitshift for source selection bitfield (OMAP1 only)</span>
<span class="cm"> *</span>
<span class="cm"> * XXX @rate_offset, @src_offset should probably be removed and OMAP1</span>
<span class="cm"> * clock code converted to use clksel.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX @usecount is poorly named.  It should be &quot;enable_count&quot; or</span>
<span class="cm"> * something similar.  &quot;users&quot; in the description refers to kernel</span>
<span class="cm"> * code (core code or drivers) that have called clk_enable() and not</span>
<span class="cm"> * yet called clk_disable(); the usecount of parent clocks is also</span>
<span class="cm"> * incremented by the clock code when clk_enable() is called on child</span>
<span class="cm"> * clocks and decremented by the clock code when clk_disable() is</span>
<span class="cm"> * called on child clocks.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX @clkdm, @usecount, @children, @sibling should be marked for</span>
<span class="cm"> * internal use only.</span>
<span class="cm"> *</span>
<span class="cm"> * @children and @sibling are used to optimize parent-to-child clock</span>
<span class="cm"> * tree traversals.  (child-to-parent traversals use @parent.)</span>
<span class="cm"> *</span>
<span class="cm"> * XXX The notion of the clock&#39;s current rate probably needs to be</span>
<span class="cm"> * separated from the clock&#39;s target rate.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">clk</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">node</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">clkops</span>	<span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>		<span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">children</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">sibling</span><span class="p">;</span>	<span class="cm">/* node for children */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">rate</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">enable_reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="p">(</span><span class="o">*</span><span class="n">recalc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">set_rate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">long</span>			<span class="p">(</span><span class="o">*</span><span class="n">round_rate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">u8</span>			<span class="n">enable_bit</span><span class="p">;</span>
	<span class="n">s8</span>			<span class="n">usecount</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">fixed_div</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">flags</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ARCH_OMAP2PLUS</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">clksel_reg</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">clksel_mask</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">clksel</span>	<span class="o">*</span><span class="n">clksel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dpll_data</span>	<span class="o">*</span><span class="n">dpll_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">clkdm_name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clockdomain</span>	<span class="o">*</span><span class="n">clkdm</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">u8</span>			<span class="n">rate_offset</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">src_offset</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(CONFIG_PM_DEBUG) &amp;&amp; defined(CONFIG_DEBUG_FS)</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">dent</span><span class="p">;</span>	<span class="cm">/* For visible tree hierarchy */</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">clk_functions</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">clk_enable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">clk_disable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>
	<span class="kt">long</span>		<span class="p">(</span><span class="o">*</span><span class="n">clk_round_rate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">clk_set_rate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">clk_set_parent</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">clk_allow_idle</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">clk_deny_idle</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">clk_disable_unused</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">mpurate</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">clk_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk_functions</span> <span class="o">*</span><span class="n">custom_clocks</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">clk_preinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">clk_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">clk_reparent</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">clk_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">propagate_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">recalculate_root_clocks</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">followparent_recalc</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">clk_enable_init_clocks</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">omap_fixed_divisor_recalc</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">omap_clk_get_by_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">omap_clk_enable_autoidle_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">omap_clk_disable_autoidle_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">clkops</span> <span class="n">clkops_null</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">clk</span> <span class="n">dummy_ck</span><span class="p">;</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
