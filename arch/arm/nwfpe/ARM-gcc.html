<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › nwfpe › ARM-gcc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ARM-gcc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">The macro `BITS64&#39; can be defined to indicate that 64-bit integer types are</span>
<span class="cm">supported by the compiler.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="cp">#define BITS64</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Each of the following `typedef&#39;s defines the most convenient type that holds</span>
<span class="cm">integers of at least as many bits as specified.  For example, `uint8&#39; should</span>
<span class="cm">be the most convenient type that can hold unsigned integers of as many as</span>
<span class="cm">8 bits.  The `flag&#39; type must be able to hold either a 0 or 1.  For most</span>
<span class="cm">implementations of C, `flag&#39;, `uint8&#39;, and `int8&#39; should all be `typedef&#39;ed</span>
<span class="cm">to the same as `int&#39;.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">typedef</span> <span class="kt">char</span> <span class="n">flag</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">uint8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">char</span> <span class="n">int8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">uint16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">int16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uint32</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">int</span> <span class="n">int32</span><span class="p">;</span>
<span class="cp">#ifdef BITS64</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">bits64</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">sbits64</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Each of the following `typedef&#39;s defines a type that holds integers</span>
<span class="cm">of _exactly_ the number of bits specified.  For instance, for most</span>
<span class="cm">implementation of C, `bits16&#39; and `sbits16&#39; should be `typedef&#39;ed to</span>
<span class="cm">`unsigned short int&#39; and `signed short int&#39; (or `short int&#39;), respectively.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bits8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">char</span> <span class="n">sbits8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">bits16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">sbits16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits32</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">int</span> <span class="n">sbits32</span><span class="p">;</span>
<span class="cp">#ifdef BITS64</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">uint64</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">signed</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">int64</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef BITS64</span>
<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">The `LIT64&#39; macro takes as its argument a textual integer literal and if</span>
<span class="cm">necessary ``marks&#39;&#39; the literal as having a 64-bit integer type.  For</span>
<span class="cm">example, the Gnu C Compiler (`gcc&#39;) requires that 64-bit literals be</span>
<span class="cm">appended with the letters `LL&#39; standing for `long long&#39;, which is `gcc&#39;s</span>
<span class="cm">name for the 64-bit integer type.  Some compilers may allow `LIT64&#39; to be</span>
<span class="cm">defined as the identity macro:  `#define LIT64( a ) a&#39;.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="cp">#define LIT64( a ) a##LL</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">The macro `INLINE&#39; can be used before functions that should be inlined.  If</span>
<span class="cm">a compiler does not support explicit inlining, this macro should be defined</span>
<span class="cm">to be `static&#39;.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="cp">#define INLINE static inline</span>


<span class="cm">/* For use as a GCC soft-float library we need some special function names. */</span>

<span class="cp">#ifdef __LIBFLOAT__</span>

<span class="cm">/* Some 32-bit ops can be mapped straight across by just changing the name. */</span>
<span class="cp">#define float32_add			__addsf3</span>
<span class="cp">#define float32_sub			__subsf3</span>
<span class="cp">#define float32_mul			__mulsf3</span>
<span class="cp">#define float32_div			__divsf3</span>
<span class="cp">#define int32_to_float32		__floatsisf</span>
<span class="cp">#define float32_to_int32_round_to_zero	__fixsfsi</span>
<span class="cp">#define float32_to_uint32_round_to_zero	__fixunssfsi</span>

<span class="cm">/* These ones go through the glue code.  To avoid namespace pollution</span>
<span class="cm">   we rename the internal functions too.  */</span>
<span class="cp">#define float32_eq			___float32_eq</span>
<span class="cp">#define float32_le			___float32_le</span>
<span class="cp">#define float32_lt			___float32_lt</span>

<span class="cm">/* All the 64-bit ops have to go through the glue, so we pull the same</span>
<span class="cm">   trick.  */</span>
<span class="cp">#define float64_add			___float64_add</span>
<span class="cp">#define float64_sub			___float64_sub</span>
<span class="cp">#define float64_mul			___float64_mul</span>
<span class="cp">#define float64_div			___float64_div</span>
<span class="cp">#define int32_to_float64		___int32_to_float64</span>
<span class="cp">#define float64_to_int32_round_to_zero	___float64_to_int32_round_to_zero</span>
<span class="cp">#define float64_to_uint32_round_to_zero	___float64_to_uint32_round_to_zero</span>
<span class="cp">#define float64_to_float32		___float64_to_float32</span>
<span class="cp">#define float32_to_float64		___float32_to_float64</span>
<span class="cp">#define float64_eq			___float64_eq</span>
<span class="cp">#define float64_le			___float64_le</span>
<span class="cp">#define float64_lt			___float64_lt</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define float64_add			__adddf3</span>
<span class="c">#define float64_sub			__subdf3</span>
<span class="c">#define float64_mul			__muldf3</span>
<span class="c">#define float64_div			__divdf3</span>
<span class="c">#define int32_to_float64		__floatsidf</span>
<span class="c">#define float64_to_int32_round_to_zero	__fixdfsi</span>
<span class="c">#define float64_to_uint32_round_to_zero	__fixunsdfsi</span>
<span class="c">#define float64_to_float32		__truncdfsf2</span>
<span class="c">#define float32_to_float64		__extendsfdf2</span>
<span class="cp">#endif</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
