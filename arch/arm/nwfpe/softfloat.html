<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › nwfpe › softfloat.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>softfloat.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">===============================================================================</span>

<span class="cm">This C source file is part of the SoftFloat IEC/IEEE Floating-point</span>
<span class="cm">Arithmetic Package, Release 2.</span>

<span class="cm">Written by John R. Hauser.  This work was made possible in part by the</span>
<span class="cm">International Computer Science Institute, located at Suite 600, 1947 Center</span>
<span class="cm">Street, Berkeley, California 94704.  Funding was partially provided by the</span>
<span class="cm">National Science Foundation under grant MIP-9311980.  The original version</span>
<span class="cm">of this code was written as part of a project to build a fixed-point vector</span>
<span class="cm">processor in collaboration with the University of California at Berkeley,</span>
<span class="cm">overseen by Profs. Nelson Morgan and John Wawrzynek.  More information</span>
<span class="cm">is available through the web page</span>
<span class="cm">http://www.jhauser.us/arithmetic/SoftFloat-2b/SoftFloat-source.txt</span>

<span class="cm">THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort</span>
<span class="cm">has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT</span>
<span class="cm">TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO</span>
<span class="cm">PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY</span>
<span class="cm">AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.</span>

<span class="cm">Derivative works are acceptable, even for commercial purposes, so long as</span>
<span class="cm">(1) they include prominent notice that the work is derivative, and (2) they</span>
<span class="cm">include prominent notice akin to these three paragraphs for those parts of</span>
<span class="cm">this code that are retained.</span>

<span class="cm">===============================================================================</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;asm/div64.h&gt;</span>

<span class="cp">#include &quot;fpa11.h&quot;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><h1>include "milieu.h"</h1>

<h1>include "softfloat.h"</h1></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Primitive arithmetic functions, including multi-word arithmetic, and</span>
<span class="cm">division and square root approximations.  (Can be specialized to target if</span>
<span class="cm">desired.)</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="cp">#include &quot;softfloat-macros&quot;</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Functions and definitions to determine:  (1) whether tininess for underflow</span>
<span class="cm">is detected before or after rounding by default, (2) what (if anything)</span>
<span class="cm">happens when exceptions are raised, (3) how signaling NaNs are distinguished</span>
<span class="cm">from quiet NaNs, (4) the default generated quiet NaNs, and (5) how NaNs</span>
<span class="cm">are propagated from function inputs to output.  These details are target-</span>
<span class="cm">specific.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="cp">#include &quot;softfloat-specialize&quot;</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Takes a 64-bit fixed-point value `absZ&#39; with binary point between bits 6</span>
<span class="cm">and 7, and returns the properly rounded 32-bit integer corresponding to the</span>
<span class="cm">input.  If `zSign&#39; is nonzero, the input is negated before being converted</span>
<span class="cm">to an integer.  Bit 63 of `absZ&#39; must be zero.  Ordinarily, the fixed-point</span>
<span class="cm">input is simply rounded to an integer, with the inexact exception raised if</span>
<span class="cm">the input cannot be represented exactly as an integer.  If the fixed-point</span>
<span class="cm">input is too large, however, the invalid exception is raised and the largest</span>
<span class="cm">positive or negative integer is returned.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">int32</span> <span class="nf">roundAndPackInt32</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">flag</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">bits64</span> <span class="n">absZ</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int8</span> <span class="n">roundingMode</span><span class="p">;</span>
    <span class="n">flag</span> <span class="n">roundNearestEven</span><span class="p">;</span>
    <span class="n">int8</span> <span class="n">roundIncrement</span><span class="p">,</span> <span class="n">roundBits</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">roundingMode</span> <span class="o">=</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
    <span class="n">roundNearestEven</span> <span class="o">=</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_nearest_even</span> <span class="p">);</span>
    <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">roundNearestEven</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_to_zero</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mh">0x7F</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">zSign</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_up</span> <span class="p">)</span> <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_down</span> <span class="p">)</span> <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">roundBits</span> <span class="o">=</span> <span class="n">absZ</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">;</span>
    <span class="n">absZ</span> <span class="o">=</span> <span class="p">(</span> <span class="n">absZ</span> <span class="o">+</span> <span class="n">roundIncrement</span> <span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">absZ</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span> <span class="n">roundBits</span> <span class="o">^</span> <span class="mh">0x40</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">roundNearestEven</span> <span class="p">);</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">absZ</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">zSign</span> <span class="p">)</span> <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">z</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">absZ</span><span class="o">&gt;&gt;</span><span class="mi">32</span> <span class="p">)</span> <span class="o">||</span> <span class="p">(</span> <span class="n">z</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="p">(</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">^</span> <span class="n">zSign</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">zSign</span> <span class="o">?</span> <span class="mh">0x80000000</span> <span class="o">:</span> <span class="mh">0x7FFFFFFF</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">roundBits</span> <span class="p">)</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the fraction bits of the single-precision floating-point value `a&#39;.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">INLINE</span> <span class="n">bits32</span> <span class="nf">extractFloat32Frac</span><span class="p">(</span> <span class="n">float32</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>

    <span class="k">return</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="mh">0x007FFFFF</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the exponent bits of the single-precision floating-point value `a&#39;.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">INLINE</span> <span class="n">int16</span> <span class="nf">extractFloat32Exp</span><span class="p">(</span> <span class="n">float32</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>

    <span class="k">return</span> <span class="p">(</span> <span class="n">a</span><span class="o">&gt;&gt;</span><span class="mi">23</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the sign bit of the single-precision floating-point value `a&#39;.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="cp">#if 0</span><span class="c">	/* in softfloat.h */</span>
<span class="c">INLINE flag extractFloat32Sign( float32 a )</span>
<span class="c">{</span>

<span class="c">    return a&gt;&gt;31;</span>

<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Normalizes the subnormal single-precision floating-point value represented</span>
<span class="cm">by the denormalized significand `aSig&#39;.  The normalized exponent and</span>
<span class="cm">significand are stored at the locations pointed to by `zExpPtr&#39; and</span>
<span class="cm">`zSigPtr&#39;, respectively.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span>
 <span class="nf">normalizeFloat32Subnormal</span><span class="p">(</span> <span class="n">bits32</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">int16</span> <span class="o">*</span><span class="n">zExpPtr</span><span class="p">,</span> <span class="n">bits32</span> <span class="o">*</span><span class="n">zSigPtr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int8</span> <span class="n">shiftCount</span><span class="p">;</span>

    <span class="n">shiftCount</span> <span class="o">=</span> <span class="n">countLeadingZeros32</span><span class="p">(</span> <span class="n">aSig</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
    <span class="o">*</span><span class="n">zSigPtr</span> <span class="o">=</span> <span class="n">aSig</span><span class="o">&lt;&lt;</span><span class="n">shiftCount</span><span class="p">;</span>
    <span class="o">*</span><span class="n">zExpPtr</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">shiftCount</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Packs the sign `zSign&#39;, exponent `zExp&#39;, and significand `zSig&#39; into a</span>
<span class="cm">single-precision floating-point value, returning the result.  After being</span>
<span class="cm">shifted into the proper positions, the three fields are simply added</span>
<span class="cm">together to form the result.  This means that any integer portion of `zSig&#39;</span>
<span class="cm">will be added into the exponent.  Since a properly normalized significand</span>
<span class="cm">will have an integer portion equal to 1, the `zExp&#39; input should be 1 less</span>
<span class="cm">than the desired result exponent whenever `zSig&#39; is a complete, normalized</span>
<span class="cm">significand.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">INLINE</span> <span class="n">float32</span> <span class="nf">packFloat32</span><span class="p">(</span> <span class="n">flag</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">int16</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">bits32</span> <span class="n">zSig</span> <span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">   float32 f;</span>
<span class="c">   __asm__(&quot;@ packFloat32				\n\</span>
<span class="c">   	    mov %0, %1, asl #31				\n\</span>
<span class="c">   	    orr %0, %2, asl #23				\n\</span>
<span class="c">   	    orr %0, %3&quot;</span>
<span class="c">   	    : /* no outputs */</span>
<span class="c">   	    : &quot;g&quot; (f), &quot;g&quot; (zSign), &quot;g&quot; (zExp), &quot;g&quot; (zSig)</span>
<span class="c">   	    : &quot;cc&quot;);</span>
<span class="c">   return f;</span>
<span class="cp">#else</span>
    <span class="k">return</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits32</span><span class="p">)</span> <span class="n">zSign</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">31</span> <span class="p">)</span> <span class="o">+</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits32</span><span class="p">)</span> <span class="n">zExp</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">23</span> <span class="p">)</span> <span class="o">+</span> <span class="n">zSig</span><span class="p">;</span>
<span class="cp">#endif </span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Takes an abstract floating-point value having sign `zSign&#39;, exponent `zExp&#39;,</span>
<span class="cm">and significand `zSig&#39;, and returns the proper single-precision floating-</span>
<span class="cm">point value corresponding to the abstract input.  Ordinarily, the abstract</span>
<span class="cm">value is simply rounded and packed into the single-precision format, with</span>
<span class="cm">the inexact exception raised if the abstract input cannot be represented</span>
<span class="cm">exactly.  If the abstract value is too large, however, the overflow and</span>
<span class="cm">inexact exceptions are raised and an infinity or maximal finite value is</span>
<span class="cm">returned.  If the abstract value is too small, the input value is rounded to</span>
<span class="cm">a subnormal number, and the underflow and inexact exceptions are raised if</span>
<span class="cm">the abstract input cannot be represented exactly as a subnormal single-</span>
<span class="cm">precision floating-point number.</span>
<span class="cm">    The input significand `zSig&#39; has its binary point between bits 30</span>
<span class="cm">and 29, which is 7 bits to the left of the usual location.  This shifted</span>
<span class="cm">significand must be normalized or smaller.  If `zSig&#39; is not normalized,</span>
<span class="cm">`zExp&#39; must be 0; in that case, the result returned is a subnormal number,</span>
<span class="cm">and it must not require rounding.  In the usual case that `zSig&#39; is</span>
<span class="cm">normalized, `zExp&#39; must be 1 less than the ``true&#39;&#39; floating-point exponent.</span>
<span class="cm">The handling of underflow and overflow follows the IEC/IEEE Standard for</span>
<span class="cm">Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">float32</span> <span class="nf">roundAndPackFloat32</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">flag</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">int16</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">bits32</span> <span class="n">zSig</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int8</span> <span class="n">roundingMode</span><span class="p">;</span>
    <span class="n">flag</span> <span class="n">roundNearestEven</span><span class="p">;</span>
    <span class="n">int8</span> <span class="n">roundIncrement</span><span class="p">,</span> <span class="n">roundBits</span><span class="p">;</span>
    <span class="n">flag</span> <span class="n">isTiny</span><span class="p">;</span>

    <span class="n">roundingMode</span> <span class="o">=</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
    <span class="n">roundNearestEven</span> <span class="o">=</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_nearest_even</span> <span class="p">);</span>
    <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">roundNearestEven</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_to_zero</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mh">0x7F</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">zSign</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_up</span> <span class="p">)</span> <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_down</span> <span class="p">)</span> <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">roundBits</span> <span class="o">=</span> <span class="n">zSig</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mh">0xFD</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">bits16</span><span class="p">)</span> <span class="n">zExp</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="mh">0xFD</span> <span class="o">&lt;</span> <span class="n">zExp</span> <span class="p">)</span>
             <span class="o">||</span> <span class="p">(</span>    <span class="p">(</span> <span class="n">zExp</span> <span class="o">==</span> <span class="mh">0xFD</span> <span class="p">)</span>
                  <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits32</span><span class="p">)</span> <span class="p">(</span> <span class="n">zSig</span> <span class="o">+</span> <span class="n">roundIncrement</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">)</span>
           <span class="p">)</span> <span class="p">{</span>
            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_overflow</span> <span class="o">|</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">-</span> <span class="p">(</span> <span class="n">roundIncrement</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">zExp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">isTiny</span> <span class="o">=</span>
                   <span class="p">(</span> <span class="n">float_detect_tininess</span> <span class="o">==</span> <span class="n">float_tininess_before_rounding</span> <span class="p">)</span>
                <span class="o">||</span> <span class="p">(</span> <span class="n">zExp</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
                <span class="o">||</span> <span class="p">(</span> <span class="n">zSig</span> <span class="o">+</span> <span class="n">roundIncrement</span> <span class="o">&lt;</span> <span class="mh">0x80000000</span> <span class="p">);</span>
            <span class="n">shift32RightJamming</span><span class="p">(</span> <span class="n">zSig</span><span class="p">,</span> <span class="o">-</span> <span class="n">zExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig</span> <span class="p">);</span>
            <span class="n">zExp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">roundBits</span> <span class="o">=</span> <span class="n">zSig</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">isTiny</span> <span class="o">&amp;&amp;</span> <span class="n">roundBits</span> <span class="p">)</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_underflow</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">roundBits</span> <span class="p">)</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">zSig</span> <span class="o">+</span> <span class="n">roundIncrement</span> <span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">zSig</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span> <span class="n">roundBits</span> <span class="o">^</span> <span class="mh">0x40</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">roundNearestEven</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">zSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">zExp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Takes an abstract floating-point value having sign `zSign&#39;, exponent `zExp&#39;,</span>
<span class="cm">and significand `zSig&#39;, and returns the proper single-precision floating-</span>
<span class="cm">point value corresponding to the abstract input.  This routine is just like</span>
<span class="cm">`roundAndPackFloat32&#39; except that `zSig&#39; does not have to be normalized in</span>
<span class="cm">any way.  In all cases, `zExp&#39; must be 1 less than the ``true&#39;&#39; floating-</span>
<span class="cm">point exponent.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">float32</span>
 <span class="nf">normalizeRoundAndPackFloat32</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">flag</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">int16</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">bits32</span> <span class="n">zSig</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int8</span> <span class="n">shiftCount</span><span class="p">;</span>

    <span class="n">shiftCount</span> <span class="o">=</span> <span class="n">countLeadingZeros32</span><span class="p">(</span> <span class="n">zSig</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">roundAndPackFloat32</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span> <span class="o">-</span> <span class="n">shiftCount</span><span class="p">,</span> <span class="n">zSig</span><span class="o">&lt;&lt;</span><span class="n">shiftCount</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the fraction bits of the double-precision floating-point value `a&#39;.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">INLINE</span> <span class="n">bits64</span> <span class="nf">extractFloat64Frac</span><span class="p">(</span> <span class="n">float64</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>

    <span class="k">return</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x000FFFFFFFFFFFFF</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the exponent bits of the double-precision floating-point value `a&#39;.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">INLINE</span> <span class="n">int16</span> <span class="nf">extractFloat64Exp</span><span class="p">(</span> <span class="n">float64</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>

    <span class="k">return</span> <span class="p">(</span> <span class="n">a</span><span class="o">&gt;&gt;</span><span class="mi">52</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7FF</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the sign bit of the double-precision floating-point value `a&#39;.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="cp">#if 0</span><span class="c">	/* in softfloat.h */</span>
<span class="c">INLINE flag extractFloat64Sign( float64 a )</span>
<span class="c">{</span>

<span class="c">    return a&gt;&gt;63;</span>

<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Normalizes the subnormal double-precision floating-point value represented</span>
<span class="cm">by the denormalized significand `aSig&#39;.  The normalized exponent and</span>
<span class="cm">significand are stored at the locations pointed to by `zExpPtr&#39; and</span>
<span class="cm">`zSigPtr&#39;, respectively.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span>
 <span class="nf">normalizeFloat64Subnormal</span><span class="p">(</span> <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">int16</span> <span class="o">*</span><span class="n">zExpPtr</span><span class="p">,</span> <span class="n">bits64</span> <span class="o">*</span><span class="n">zSigPtr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int8</span> <span class="n">shiftCount</span><span class="p">;</span>

    <span class="n">shiftCount</span> <span class="o">=</span> <span class="n">countLeadingZeros64</span><span class="p">(</span> <span class="n">aSig</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">11</span><span class="p">;</span>
    <span class="o">*</span><span class="n">zSigPtr</span> <span class="o">=</span> <span class="n">aSig</span><span class="o">&lt;&lt;</span><span class="n">shiftCount</span><span class="p">;</span>
    <span class="o">*</span><span class="n">zExpPtr</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">shiftCount</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Packs the sign `zSign&#39;, exponent `zExp&#39;, and significand `zSig&#39; into a</span>
<span class="cm">double-precision floating-point value, returning the result.  After being</span>
<span class="cm">shifted into the proper positions, the three fields are simply added</span>
<span class="cm">together to form the result.  This means that any integer portion of `zSig&#39;</span>
<span class="cm">will be added into the exponent.  Since a properly normalized significand</span>
<span class="cm">will have an integer portion equal to 1, the `zExp&#39; input should be 1 less</span>
<span class="cm">than the desired result exponent whenever `zSig&#39; is a complete, normalized</span>
<span class="cm">significand.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">INLINE</span> <span class="n">float64</span> <span class="nf">packFloat64</span><span class="p">(</span> <span class="n">flag</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">int16</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">bits64</span> <span class="n">zSig</span> <span class="p">)</span>
<span class="p">{</span>

    <span class="k">return</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="n">zSign</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">63</span> <span class="p">)</span> <span class="o">+</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="n">zExp</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">52</span> <span class="p">)</span> <span class="o">+</span> <span class="n">zSig</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Takes an abstract floating-point value having sign `zSign&#39;, exponent `zExp&#39;,</span>
<span class="cm">and significand `zSig&#39;, and returns the proper double-precision floating-</span>
<span class="cm">point value corresponding to the abstract input.  Ordinarily, the abstract</span>
<span class="cm">value is simply rounded and packed into the double-precision format, with</span>
<span class="cm">the inexact exception raised if the abstract input cannot be represented</span>
<span class="cm">exactly.  If the abstract value is too large, however, the overflow and</span>
<span class="cm">inexact exceptions are raised and an infinity or maximal finite value is</span>
<span class="cm">returned.  If the abstract value is too small, the input value is rounded to</span>
<span class="cm">a subnormal number, and the underflow and inexact exceptions are raised if</span>
<span class="cm">the abstract input cannot be represented exactly as a subnormal double-</span>
<span class="cm">precision floating-point number.</span>
<span class="cm">    The input significand `zSig&#39; has its binary point between bits 62</span>
<span class="cm">and 61, which is 10 bits to the left of the usual location.  This shifted</span>
<span class="cm">significand must be normalized or smaller.  If `zSig&#39; is not normalized,</span>
<span class="cm">`zExp&#39; must be 0; in that case, the result returned is a subnormal number,</span>
<span class="cm">and it must not require rounding.  In the usual case that `zSig&#39; is</span>
<span class="cm">normalized, `zExp&#39; must be 1 less than the ``true&#39;&#39; floating-point exponent.</span>
<span class="cm">The handling of underflow and overflow follows the IEC/IEEE Standard for</span>
<span class="cm">Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">float64</span> <span class="nf">roundAndPackFloat64</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">flag</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">int16</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">bits64</span> <span class="n">zSig</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int8</span> <span class="n">roundingMode</span><span class="p">;</span>
    <span class="n">flag</span> <span class="n">roundNearestEven</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">roundIncrement</span><span class="p">,</span> <span class="n">roundBits</span><span class="p">;</span>
    <span class="n">flag</span> <span class="n">isTiny</span><span class="p">;</span>

    <span class="n">roundingMode</span> <span class="o">=</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
    <span class="n">roundNearestEven</span> <span class="o">=</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_nearest_even</span> <span class="p">);</span>
    <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mh">0x200</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">roundNearestEven</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_to_zero</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mh">0x3FF</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">zSign</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_up</span> <span class="p">)</span> <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_down</span> <span class="p">)</span> <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">roundBits</span> <span class="o">=</span> <span class="n">zSig</span> <span class="o">&amp;</span> <span class="mh">0x3FF</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mh">0x7FD</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">bits16</span><span class="p">)</span> <span class="n">zExp</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="mh">0x7FD</span> <span class="o">&lt;</span> <span class="n">zExp</span> <span class="p">)</span>
             <span class="o">||</span> <span class="p">(</span>    <span class="p">(</span> <span class="n">zExp</span> <span class="o">==</span> <span class="mh">0x7FD</span> <span class="p">)</span>
                  <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">zSig</span> <span class="o">+</span> <span class="n">roundIncrement</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">)</span>
           <span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>register int lr = <em>_builtin</em>return_address(0);
printk("roundAndPackFloat64 called from 0x%08x\n",lr);</p></td><td class="code"><div class="highlight"><pre>            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_overflow</span> <span class="o">|</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0x7FF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">-</span> <span class="p">(</span> <span class="n">roundIncrement</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">zExp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">isTiny</span> <span class="o">=</span>
                   <span class="p">(</span> <span class="n">float_detect_tininess</span> <span class="o">==</span> <span class="n">float_tininess_before_rounding</span> <span class="p">)</span>
                <span class="o">||</span> <span class="p">(</span> <span class="n">zExp</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
                <span class="o">||</span> <span class="p">(</span> <span class="n">zSig</span> <span class="o">+</span> <span class="n">roundIncrement</span> <span class="o">&lt;</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">)</span> <span class="p">);</span>
            <span class="n">shift64RightJamming</span><span class="p">(</span> <span class="n">zSig</span><span class="p">,</span> <span class="o">-</span> <span class="n">zExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig</span> <span class="p">);</span>
            <span class="n">zExp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">roundBits</span> <span class="o">=</span> <span class="n">zSig</span> <span class="o">&amp;</span> <span class="mh">0x3FF</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">isTiny</span> <span class="o">&amp;&amp;</span> <span class="n">roundBits</span> <span class="p">)</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_underflow</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">roundBits</span> <span class="p">)</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">zSig</span> <span class="o">+</span> <span class="n">roundIncrement</span> <span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">10</span><span class="p">;</span>
    <span class="n">zSig</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span> <span class="n">roundBits</span> <span class="o">^</span> <span class="mh">0x200</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">roundNearestEven</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">zSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">zExp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Takes an abstract floating-point value having sign `zSign&#39;, exponent `zExp&#39;,</span>
<span class="cm">and significand `zSig&#39;, and returns the proper double-precision floating-</span>
<span class="cm">point value corresponding to the abstract input.  This routine is just like</span>
<span class="cm">`roundAndPackFloat64&#39; except that `zSig&#39; does not have to be normalized in</span>
<span class="cm">any way.  In all cases, `zExp&#39; must be 1 less than the ``true&#39;&#39; floating-</span>
<span class="cm">point exponent.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">float64</span>
 <span class="nf">normalizeRoundAndPackFloat64</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">flag</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">int16</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">bits64</span> <span class="n">zSig</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int8</span> <span class="n">shiftCount</span><span class="p">;</span>

    <span class="n">shiftCount</span> <span class="o">=</span> <span class="n">countLeadingZeros64</span><span class="p">(</span> <span class="n">zSig</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">roundAndPackFloat64</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span> <span class="o">-</span> <span class="n">shiftCount</span><span class="p">,</span> <span class="n">zSig</span><span class="o">&lt;&lt;</span><span class="n">shiftCount</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cp">#ifdef FLOATX80</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the fraction bits of the extended double-precision floating-point</span>
<span class="cm">value `a&#39;.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">INLINE</span> <span class="n">bits64</span> <span class="nf">extractFloatx80Frac</span><span class="p">(</span> <span class="n">floatx80</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>

    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the exponent bits of the extended double-precision floating-point</span>
<span class="cm">value `a&#39;.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">INLINE</span> <span class="n">int32</span> <span class="nf">extractFloatx80Exp</span><span class="p">(</span> <span class="n">floatx80</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>

    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span> <span class="o">&amp;</span> <span class="mh">0x7FFF</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the sign bit of the extended double-precision floating-point value</span>
<span class="cm">`a&#39;.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">INLINE</span> <span class="n">flag</span> <span class="nf">extractFloatx80Sign</span><span class="p">(</span> <span class="n">floatx80</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>

    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span><span class="o">&gt;&gt;</span><span class="mi">15</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Normalizes the subnormal extended double-precision floating-point value</span>
<span class="cm">represented by the denormalized significand `aSig&#39;.  The normalized exponent</span>
<span class="cm">and significand are stored at the locations pointed to by `zExpPtr&#39; and</span>
<span class="cm">`zSigPtr&#39;, respectively.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span>
 <span class="nf">normalizeFloatx80Subnormal</span><span class="p">(</span> <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">int32</span> <span class="o">*</span><span class="n">zExpPtr</span><span class="p">,</span> <span class="n">bits64</span> <span class="o">*</span><span class="n">zSigPtr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int8</span> <span class="n">shiftCount</span><span class="p">;</span>

    <span class="n">shiftCount</span> <span class="o">=</span> <span class="n">countLeadingZeros64</span><span class="p">(</span> <span class="n">aSig</span> <span class="p">);</span>
    <span class="o">*</span><span class="n">zSigPtr</span> <span class="o">=</span> <span class="n">aSig</span><span class="o">&lt;&lt;</span><span class="n">shiftCount</span><span class="p">;</span>
    <span class="o">*</span><span class="n">zExpPtr</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">shiftCount</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Packs the sign `zSign&#39;, exponent `zExp&#39;, and significand `zSig&#39; into an</span>
<span class="cm">extended double-precision floating-point value, returning the result.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">INLINE</span> <span class="n">floatx80</span> <span class="nf">packFloatx80</span><span class="p">(</span> <span class="n">flag</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">int32</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">bits64</span> <span class="n">zSig</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">floatx80</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">z</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">zSig</span><span class="p">;</span>
    <span class="n">z</span><span class="p">.</span><span class="n">high</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits16</span><span class="p">)</span> <span class="n">zSign</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">15</span> <span class="p">)</span> <span class="o">+</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">z</span><span class="p">.</span><span class="n">__padding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Takes an abstract floating-point value having sign `zSign&#39;, exponent `zExp&#39;,</span>
<span class="cm">and extended significand formed by the concatenation of `zSig0&#39; and `zSig1&#39;,</span>
<span class="cm">and returns the proper extended double-precision floating-point value</span>
<span class="cm">corresponding to the abstract input.  Ordinarily, the abstract value is</span>
<span class="cm">rounded and packed into the extended double-precision format, with the</span>
<span class="cm">inexact exception raised if the abstract input cannot be represented</span>
<span class="cm">exactly.  If the abstract value is too large, however, the overflow and</span>
<span class="cm">inexact exceptions are raised and an infinity or maximal finite value is</span>
<span class="cm">returned.  If the abstract value is too small, the input value is rounded to</span>
<span class="cm">a subnormal number, and the underflow and inexact exceptions are raised if</span>
<span class="cm">the abstract input cannot be represented exactly as a subnormal extended</span>
<span class="cm">double-precision floating-point number.</span>
<span class="cm">    If `roundingPrecision&#39; is 32 or 64, the result is rounded to the same</span>
<span class="cm">number of bits as single or double precision, respectively.  Otherwise, the</span>
<span class="cm">result is rounded to the full precision of the extended double-precision</span>
<span class="cm">format.</span>
<span class="cm">    The input significand must be normalized or smaller.  If the input</span>
<span class="cm">significand is not normalized, `zExp&#39; must be 0; in that case, the result</span>
<span class="cm">returned is a subnormal number, and it must not require rounding.  The</span>
<span class="cm">handling of underflow and overflow follows the IEC/IEEE Standard for Binary</span>
<span class="cm">Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">floatx80</span>
 <span class="nf">roundAndPackFloatx80</span><span class="p">(</span>
     <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">flag</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">int32</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">bits64</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">bits64</span> <span class="n">zSig1</span>
 <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int8</span> <span class="n">roundingMode</span><span class="p">,</span> <span class="n">roundingPrecision</span><span class="p">;</span>
    <span class="n">flag</span> <span class="n">roundNearestEven</span><span class="p">,</span> <span class="n">increment</span><span class="p">,</span> <span class="n">isTiny</span><span class="p">;</span>
    <span class="n">int64</span> <span class="n">roundIncrement</span><span class="p">,</span> <span class="n">roundMask</span><span class="p">,</span> <span class="n">roundBits</span><span class="p">;</span>

    <span class="n">roundingMode</span> <span class="o">=</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
    <span class="n">roundingPrecision</span> <span class="o">=</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">precision</span><span class="p">;</span>
    <span class="n">roundNearestEven</span> <span class="o">=</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_nearest_even</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">roundingPrecision</span> <span class="o">==</span> <span class="mi">80</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">precision80</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">roundingPrecision</span> <span class="o">==</span> <span class="mi">64</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">roundIncrement</span> <span class="o">=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x0000000000000400</span> <span class="p">);</span>
        <span class="n">roundMask</span> <span class="o">=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x00000000000007FF</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">roundingPrecision</span> <span class="o">==</span> <span class="mi">32</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">roundIncrement</span> <span class="o">=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x0000008000000000</span> <span class="p">);</span>
        <span class="n">roundMask</span> <span class="o">=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x000000FFFFFFFFFF</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">goto</span> <span class="n">precision80</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">zSig0</span> <span class="o">|=</span> <span class="p">(</span> <span class="n">zSig1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">roundNearestEven</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_to_zero</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">roundIncrement</span> <span class="o">=</span> <span class="n">roundMask</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">zSign</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_up</span> <span class="p">)</span> <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_down</span> <span class="p">)</span> <span class="n">roundIncrement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">roundBits</span> <span class="o">=</span> <span class="n">zSig0</span> <span class="o">&amp;</span> <span class="n">roundMask</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mh">0x7FFD</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">bits32</span><span class="p">)</span> <span class="p">(</span> <span class="n">zExp</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="mh">0x7FFE</span> <span class="o">&lt;</span> <span class="n">zExp</span> <span class="p">)</span>
             <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">zExp</span> <span class="o">==</span> <span class="mh">0x7FFE</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">zSig0</span> <span class="o">+</span> <span class="n">roundIncrement</span> <span class="o">&lt;</span> <span class="n">zSig0</span> <span class="p">)</span> <span class="p">)</span>
           <span class="p">)</span> <span class="p">{</span>
            <span class="k">goto</span> <span class="n">overflow</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">zExp</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">isTiny</span> <span class="o">=</span>
                   <span class="p">(</span> <span class="n">float_detect_tininess</span> <span class="o">==</span> <span class="n">float_tininess_before_rounding</span> <span class="p">)</span>
                <span class="o">||</span> <span class="p">(</span> <span class="n">zExp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
                <span class="o">||</span> <span class="p">(</span> <span class="n">zSig0</span> <span class="o">&lt;=</span> <span class="n">zSig0</span> <span class="o">+</span> <span class="n">roundIncrement</span> <span class="p">);</span>
            <span class="n">shift64RightJamming</span><span class="p">(</span> <span class="n">zSig0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">zExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig0</span> <span class="p">);</span>
            <span class="n">zExp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">roundBits</span> <span class="o">=</span> <span class="n">zSig0</span> <span class="o">&amp;</span> <span class="n">roundMask</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">isTiny</span> <span class="o">&amp;&amp;</span> <span class="n">roundBits</span> <span class="p">)</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_underflow</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">roundBits</span> <span class="p">)</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
            <span class="n">zSig0</span> <span class="o">+=</span> <span class="n">roundIncrement</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">zSig0</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">zExp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">roundIncrement</span> <span class="o">=</span> <span class="n">roundMask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">roundNearestEven</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">roundBits</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="o">==</span> <span class="n">roundIncrement</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">roundMask</span> <span class="o">|=</span> <span class="n">roundIncrement</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">zSig0</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="n">roundMask</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig0</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">roundBits</span> <span class="p">)</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
    <span class="n">zSig0</span> <span class="o">+=</span> <span class="n">roundIncrement</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">zSig0</span> <span class="o">&lt;</span> <span class="n">roundIncrement</span> <span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">zExp</span><span class="p">;</span>
        <span class="n">zSig0</span> <span class="o">=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">roundIncrement</span> <span class="o">=</span> <span class="n">roundMask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">roundNearestEven</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">roundBits</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="o">==</span> <span class="n">roundIncrement</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">roundMask</span> <span class="o">|=</span> <span class="n">roundIncrement</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">zSig0</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="n">roundMask</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">zSig0</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">zExp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig0</span> <span class="p">);</span>
 <span class="nl">precision80:</span>
    <span class="n">increment</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">zSig1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">roundNearestEven</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_to_zero</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">increment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">zSign</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">increment</span> <span class="o">=</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_down</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">zSig1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">increment</span> <span class="o">=</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_up</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">zSig1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mh">0x7FFD</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">bits32</span><span class="p">)</span> <span class="p">(</span> <span class="n">zExp</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="mh">0x7FFE</span> <span class="o">&lt;</span> <span class="n">zExp</span> <span class="p">)</span>
             <span class="o">||</span> <span class="p">(</span>    <span class="p">(</span> <span class="n">zExp</span> <span class="o">==</span> <span class="mh">0x7FFE</span> <span class="p">)</span>
                  <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">zSig0</span> <span class="o">==</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0xFFFFFFFFFFFFFFFF</span> <span class="p">)</span> <span class="p">)</span>
                  <span class="o">&amp;&amp;</span> <span class="n">increment</span>
                <span class="p">)</span>
           <span class="p">)</span> <span class="p">{</span>
            <span class="n">roundMask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">overflow:</span>
            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_overflow</span> <span class="o">|</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_to_zero</span> <span class="p">)</span>
                 <span class="o">||</span> <span class="p">(</span> <span class="n">zSign</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_up</span> <span class="p">)</span> <span class="p">)</span>
                 <span class="o">||</span> <span class="p">(</span> <span class="o">!</span> <span class="n">zSign</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_down</span> <span class="p">)</span> <span class="p">)</span>
               <span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0x7FFE</span><span class="p">,</span> <span class="o">~</span> <span class="n">roundMask</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0x7FFF</span><span class="p">,</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">zExp</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">isTiny</span> <span class="o">=</span>
                   <span class="p">(</span> <span class="n">float_detect_tininess</span> <span class="o">==</span> <span class="n">float_tininess_before_rounding</span> <span class="p">)</span>
                <span class="o">||</span> <span class="p">(</span> <span class="n">zExp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
                <span class="o">||</span> <span class="o">!</span> <span class="n">increment</span>
                <span class="o">||</span> <span class="p">(</span> <span class="n">zSig0</span> <span class="o">&lt;</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0xFFFFFFFFFFFFFFFF</span> <span class="p">)</span> <span class="p">);</span>
            <span class="n">shift64ExtraRightJamming</span><span class="p">(</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">zExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig1</span> <span class="p">);</span>
            <span class="n">zExp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">isTiny</span> <span class="o">&amp;&amp;</span> <span class="n">zSig1</span> <span class="p">)</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_underflow</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">zSig1</span> <span class="p">)</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">roundNearestEven</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">increment</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">zSig1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">zSign</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">increment</span> <span class="o">=</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_down</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">zSig1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="n">increment</span> <span class="o">=</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_up</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">zSig1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">increment</span> <span class="p">)</span> <span class="p">{</span>
                <span class="o">++</span><span class="n">zSig0</span><span class="p">;</span>
                <span class="n">zSig0</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span> <span class="p">(</span> <span class="n">zSig1</span> <span class="o">+</span> <span class="n">zSig1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">roundNearestEven</span> <span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">zSig0</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">zExp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig0</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">zSig1</span> <span class="p">)</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">increment</span> <span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">zSig0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">zSig0</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">zExp</span><span class="p">;</span>
            <span class="n">zSig0</span> <span class="o">=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">zSig0</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span> <span class="p">(</span> <span class="n">zSig1</span> <span class="o">+</span> <span class="n">zSig1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">roundNearestEven</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">zSig0</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">zExp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig0</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Takes an abstract floating-point value having sign `zSign&#39;, exponent</span>
<span class="cm">`zExp&#39;, and significand formed by the concatenation of `zSig0&#39; and `zSig1&#39;,</span>
<span class="cm">and returns the proper extended double-precision floating-point value</span>
<span class="cm">corresponding to the abstract input.  This routine is just like</span>
<span class="cm">`roundAndPackFloatx80&#39; except that the input significand does not have to be</span>
<span class="cm">normalized.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">floatx80</span>
 <span class="nf">normalizeRoundAndPackFloatx80</span><span class="p">(</span>
     <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">flag</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">int32</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">bits64</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">bits64</span> <span class="n">zSig1</span>
 <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int8</span> <span class="n">shiftCount</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">zSig0</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">zSig0</span> <span class="o">=</span> <span class="n">zSig1</span><span class="p">;</span>
        <span class="n">zSig1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">zExp</span> <span class="o">-=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">shiftCount</span> <span class="o">=</span> <span class="n">countLeadingZeros64</span><span class="p">(</span> <span class="n">zSig0</span> <span class="p">);</span>
    <span class="n">shortShift128Left</span><span class="p">(</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">,</span> <span class="n">shiftCount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig1</span> <span class="p">);</span>
    <span class="n">zExp</span> <span class="o">-=</span> <span class="n">shiftCount</span><span class="p">;</span>
    <span class="k">return</span>
        <span class="n">roundAndPackFloatx80</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the 32-bit two&#39;s complement integer `a&#39; to</span>
<span class="cm">the single-precision floating-point format.  The conversion is performed</span>
<span class="cm">according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float32</span> <span class="nf">int32_to_float32</span><span class="p">(</span><span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">int32</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">zSign</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">a</span> <span class="o">==</span> <span class="mh">0x80000000</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x9E</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="n">zSign</span> <span class="o">=</span> <span class="p">(</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">normalizeRoundAndPackFloat32</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0x9C</span><span class="p">,</span> <span class="n">zSign</span> <span class="o">?</span> <span class="o">-</span> <span class="n">a</span> <span class="o">:</span> <span class="n">a</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the 32-bit two&#39;s complement integer `a&#39; to</span>
<span class="cm">the double-precision floating-point format.  The conversion is performed</span>
<span class="cm">according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float64</span> <span class="nf">int32_to_float64</span><span class="p">(</span> <span class="n">int32</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">uint32</span> <span class="n">absA</span><span class="p">;</span>
    <span class="n">int8</span> <span class="n">shiftCount</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">zSig</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="p">(</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="n">absA</span> <span class="o">=</span> <span class="n">aSign</span> <span class="o">?</span> <span class="o">-</span> <span class="n">a</span> <span class="o">:</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">shiftCount</span> <span class="o">=</span> <span class="n">countLeadingZeros32</span><span class="p">(</span> <span class="n">absA</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">21</span><span class="p">;</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="n">absA</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mh">0x432</span> <span class="o">-</span> <span class="n">shiftCount</span><span class="p">,</span> <span class="n">zSig</span><span class="o">&lt;&lt;</span><span class="n">shiftCount</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cp">#ifdef FLOATX80</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the 32-bit two&#39;s complement integer `a&#39;</span>
<span class="cm">to the extended double-precision floating-point format.  The conversion</span>
<span class="cm">is performed according to the IEC/IEEE Standard for Binary Floating-point</span>
<span class="cm">Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">floatx80</span> <span class="nf">int32_to_floatx80</span><span class="p">(</span> <span class="n">int32</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">zSign</span><span class="p">;</span>
    <span class="n">uint32</span> <span class="n">absA</span><span class="p">;</span>
    <span class="n">int8</span> <span class="n">shiftCount</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">zSig</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="n">zSign</span> <span class="o">=</span> <span class="p">(</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="n">absA</span> <span class="o">=</span> <span class="n">zSign</span> <span class="o">?</span> <span class="o">-</span> <span class="n">a</span> <span class="o">:</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">shiftCount</span> <span class="o">=</span> <span class="n">countLeadingZeros32</span><span class="p">(</span> <span class="n">absA</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">32</span><span class="p">;</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="n">absA</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0x403E</span> <span class="o">-</span> <span class="n">shiftCount</span><span class="p">,</span> <span class="n">zSig</span><span class="o">&lt;&lt;</span><span class="n">shiftCount</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the single-precision floating-point value</span>
<span class="cm">`a&#39; to the 32-bit two&#39;s complement integer format.  The conversion is</span>
<span class="cm">performed according to the IEC/IEEE Standard for Binary Floating-point</span>
<span class="cm">Arithmetic---which means in particular that the conversion is rounded</span>
<span class="cm">according to the current rounding mode.  If `a&#39; is a NaN, the largest</span>
<span class="cm">positive integer is returned.  Otherwise, if the conversion overflows, the</span>
<span class="cm">largest integer with the same sign as `a&#39; is returned.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">int32</span> <span class="nf">float32_to_int32</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float32</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">shiftCount</span><span class="p">;</span>
    <span class="n">bits32</span> <span class="n">aSig</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">zSig</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">aSig</span> <span class="p">)</span> <span class="n">aSign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="p">)</span> <span class="n">aSig</span> <span class="o">|=</span> <span class="mh">0x00800000</span><span class="p">;</span>
    <span class="n">shiftCount</span> <span class="o">=</span> <span class="mh">0xAF</span> <span class="o">-</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="n">aSig</span><span class="p">;</span>
    <span class="n">zSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">32</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">shiftCount</span> <span class="p">)</span> <span class="n">shift64RightJamming</span><span class="p">(</span> <span class="n">zSig</span><span class="p">,</span> <span class="n">shiftCount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">roundAndPackInt32</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">zSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the single-precision floating-point value</span>
<span class="cm">`a&#39; to the 32-bit two&#39;s complement integer format.  The conversion is</span>
<span class="cm">performed according to the IEC/IEEE Standard for Binary Floating-point</span>
<span class="cm">Arithmetic, except that the conversion is always rounded toward zero.  If</span>
<span class="cm">`a&#39; is a NaN, the largest positive integer is returned.  Otherwise, if the</span>
<span class="cm">conversion overflows, the largest integer with the same sign as `a&#39; is</span>
<span class="cm">returned.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">int32</span> <span class="nf">float32_to_int32_round_to_zero</span><span class="p">(</span> <span class="n">float32</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">shiftCount</span><span class="p">;</span>
    <span class="n">bits32</span> <span class="n">aSig</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">shiftCount</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">-</span> <span class="mh">0x9E</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">shiftCount</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">a</span> <span class="o">==</span> <span class="mh">0xCF000000</span> <span class="p">)</span> <span class="k">return</span> <span class="mh">0x80000000</span><span class="p">;</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">aSign</span> <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">aSig</span> <span class="p">)</span> <span class="p">)</span> <span class="k">return</span> <span class="mh">0x7FFFFFFF</span><span class="p">;</span>
        <span class="k">return</span> <span class="mh">0x80000000</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">&lt;=</span> <span class="mh">0x7E</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">|</span> <span class="n">aSig</span> <span class="p">)</span> <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_inexact</span> <span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">|</span> <span class="mh">0x00800000</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">aSig</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="o">-</span> <span class="n">shiftCount</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits32</span><span class="p">)</span> <span class="p">(</span> <span class="n">aSig</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">shiftCount</span> <span class="o">&amp;</span> <span class="mi">31</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_inexact</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">aSign</span> <span class="o">?</span> <span class="o">-</span> <span class="n">z</span> <span class="o">:</span> <span class="n">z</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the single-precision floating-point value</span>
<span class="cm">`a&#39; to the double-precision floating-point format.  The conversion is</span>
<span class="cm">performed according to the IEC/IEEE Standard for Binary Floating-point</span>
<span class="cm">Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float64</span> <span class="nf">float32_to_float64</span><span class="p">(</span> <span class="n">float32</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="n">bits32</span> <span class="n">aSig</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">commonNaNToFloat64</span><span class="p">(</span> <span class="n">float32ToCommonNaN</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mh">0x7FF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">normalizeFloat32Subnormal</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
        <span class="o">--</span><span class="n">aExp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">aExp</span> <span class="o">+</span> <span class="mh">0x380</span><span class="p">,</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="n">aSig</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">29</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cp">#ifdef FLOATX80</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the single-precision floating-point value</span>
<span class="cm">`a&#39; to the extended double-precision floating-point format.  The conversion</span>
<span class="cm">is performed according to the IEC/IEEE Standard for Binary Floating-point</span>
<span class="cm">Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">floatx80</span> <span class="nf">float32_to_floatx80</span><span class="p">(</span> <span class="n">float32</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="n">bits32</span> <span class="n">aSig</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">commonNaNToFloatx80</span><span class="p">(</span> <span class="n">float32ToCommonNaN</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mh">0x7FFF</span><span class="p">,</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">normalizeFloat32Subnormal</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">aSig</span> <span class="o">|=</span> <span class="mh">0x00800000</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">aExp</span> <span class="o">+</span> <span class="mh">0x3F80</span><span class="p">,</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="n">aSig</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">40</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Rounds the single-precision floating-point value `a&#39; to an integer, and</span>
<span class="cm">returns the result as a single-precision floating-point value.  The</span>
<span class="cm">operation is performed according to the IEC/IEEE Standard for Binary</span>
<span class="cm">Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float32</span> <span class="nf">float32_round_to_int</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float32</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="n">bits32</span> <span class="n">lastBitMask</span><span class="p">,</span> <span class="n">roundBitsMask</span><span class="p">;</span>
    <span class="n">int8</span> <span class="n">roundingMode</span><span class="p">;</span>
    <span class="n">float32</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mh">0x96</span> <span class="o">&lt;=</span> <span class="n">aExp</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">propagateFloat32NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">roundingMode</span> <span class="o">=</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">&lt;=</span> <span class="mh">0x7E</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits32</span><span class="p">)</span> <span class="p">(</span> <span class="n">a</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
        <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
        <span class="k">switch</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="p">)</span> <span class="p">{</span>
         <span class="k">case</span> <span class="n">float_round_nearest_even</span>:
            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7E</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mh">0x7F</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
         <span class="k">case</span> <span class="n">float_round_down</span>:
            <span class="k">return</span> <span class="n">aSign</span> <span class="o">?</span> <span class="mh">0xBF800000</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
         <span class="k">case</span> <span class="n">float_round_up</span>:
            <span class="k">return</span> <span class="n">aSign</span> <span class="o">?</span> <span class="mh">0x80000000</span> <span class="o">:</span> <span class="mh">0x3F800000</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">lastBitMask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">lastBitMask</span> <span class="o">&lt;&lt;=</span> <span class="mh">0x96</span> <span class="o">-</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="n">roundBitsMask</span> <span class="o">=</span> <span class="n">lastBitMask</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_nearest_even</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">z</span> <span class="o">+=</span> <span class="n">lastBitMask</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">z</span> <span class="o">&amp;</span> <span class="n">roundBitsMask</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">z</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="n">lastBitMask</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">!=</span> <span class="n">float_round_to_zero</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">z</span> <span class="p">)</span> <span class="o">^</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_up</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">z</span> <span class="o">+=</span> <span class="n">roundBitsMask</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">z</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="n">roundBitsMask</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">z</span> <span class="o">!=</span> <span class="n">a</span> <span class="p">)</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of adding the absolute values of the single-precision</span>
<span class="cm">floating-point values `a&#39; and `b&#39;.  If `zSign&#39; is true, the sum is negated</span>
<span class="cm">before being returned.  `zSign&#39; is ignored if the result is a NaN.  The</span>
<span class="cm">addition is performed according to the IEC/IEEE Standard for Binary</span>
<span class="cm">Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">float32</span> <span class="nf">addFloat32Sigs</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float32</span> <span class="n">a</span><span class="p">,</span> <span class="n">float32</span> <span class="n">b</span><span class="p">,</span> <span class="n">flag</span> <span class="n">zSign</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">bits32</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">zSig</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">expDiff</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">expDiff</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">-</span> <span class="n">bExp</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="n">bSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">expDiff</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat32NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="o">--</span><span class="n">expDiff</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">bSig</span> <span class="o">|=</span> <span class="mh">0x20000000</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">shift32RightJamming</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">expDiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bSig</span> <span class="p">);</span>
        <span class="n">zExp</span> <span class="o">=</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">expDiff</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat32NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">expDiff</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">aSig</span> <span class="o">|=</span> <span class="mh">0x20000000</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">shift32RightJamming</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">-</span> <span class="n">expDiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
        <span class="n">zExp</span> <span class="o">=</span> <span class="n">bExp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">|</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat32NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">+</span> <span class="n">bSig</span> <span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">6</span> <span class="p">);</span>
        <span class="n">zSig</span> <span class="o">=</span> <span class="mh">0x40000000</span> <span class="o">+</span> <span class="n">aSig</span> <span class="o">+</span> <span class="n">bSig</span><span class="p">;</span>
        <span class="n">zExp</span> <span class="o">=</span> <span class="n">aExp</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">roundAndPack</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSig</span> <span class="o">|=</span> <span class="mh">0x20000000</span><span class="p">;</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">+</span> <span class="n">bSig</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">;</span>
    <span class="o">--</span><span class="n">zExp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits32</span><span class="p">)</span> <span class="n">zSig</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">zSig</span> <span class="o">=</span> <span class="n">aSig</span> <span class="o">+</span> <span class="n">bSig</span><span class="p">;</span>
        <span class="o">++</span><span class="n">zExp</span><span class="p">;</span>
    <span class="p">}</span>
 <span class="nl">roundAndPack:</span>
    <span class="k">return</span> <span class="n">roundAndPackFloat32</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of subtracting the absolute values of the single-</span>
<span class="cm">precision floating-point values `a&#39; and `b&#39;.  If `zSign&#39; is true, the</span>
<span class="cm">difference is negated before being returned.  `zSign&#39; is ignored if the</span>
<span class="cm">result is a NaN.  The subtraction is performed according to the IEC/IEEE</span>
<span class="cm">Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">float32</span> <span class="nf">subFloat32Sigs</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float32</span> <span class="n">a</span><span class="p">,</span> <span class="n">float32</span> <span class="n">b</span><span class="p">,</span> <span class="n">flag</span> <span class="n">zSign</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">bits32</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">zSig</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">expDiff</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">expDiff</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">-</span> <span class="n">bExp</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="n">bSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">expDiff</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">aExpBigger</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">expDiff</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">bExpBigger</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">|</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat32NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">float32_default_nan</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">aExp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">bExp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">&lt;</span> <span class="n">aSig</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">aBigger</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">&lt;</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">bBigger</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">float_round_down</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
 <span class="nl">bExpBigger:</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat32NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">zSign</span> <span class="o">^</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">expDiff</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">aSig</span> <span class="o">|=</span> <span class="mh">0x40000000</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">shift32RightJamming</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">-</span> <span class="n">expDiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">|=</span> <span class="mh">0x40000000</span><span class="p">;</span>
 <span class="nl">bBigger:</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="n">bSig</span> <span class="o">-</span> <span class="n">aSig</span><span class="p">;</span>
    <span class="n">zExp</span> <span class="o">=</span> <span class="n">bExp</span><span class="p">;</span>
    <span class="n">zSign</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">normalizeRoundAndPack</span><span class="p">;</span>
 <span class="nl">aExpBigger:</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat32NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">expDiff</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">bSig</span> <span class="o">|=</span> <span class="mh">0x40000000</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">shift32RightJamming</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">expDiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bSig</span> <span class="p">);</span>
    <span class="n">aSig</span> <span class="o">|=</span> <span class="mh">0x40000000</span><span class="p">;</span>
 <span class="nl">aBigger:</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="n">aSig</span> <span class="o">-</span> <span class="n">bSig</span><span class="p">;</span>
    <span class="n">zExp</span> <span class="o">=</span> <span class="n">aExp</span><span class="p">;</span>
 <span class="nl">normalizeRoundAndPack:</span>
    <span class="o">--</span><span class="n">zExp</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">normalizeRoundAndPackFloat32</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of adding the single-precision floating-point values `a&#39;</span>
<span class="cm">and `b&#39;.  The operation is performed according to the IEC/IEEE Standard for</span>
<span class="cm">Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float32</span> <span class="nf">float32_add</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float32</span> <span class="n">a</span><span class="p">,</span> <span class="n">float32</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>

    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">==</span> <span class="n">bSign</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">addFloat32Sigs</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">aSign</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">subFloat32Sigs</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">aSign</span> <span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of subtracting the single-precision floating-point values</span>
<span class="cm">`a&#39; and `b&#39;.  The operation is performed according to the IEC/IEEE Standard</span>
<span class="cm">for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float32</span> <span class="nf">float32_sub</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float32</span> <span class="n">a</span><span class="p">,</span> <span class="n">float32</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>

    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">==</span> <span class="n">bSign</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">subFloat32Sigs</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">aSign</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">addFloat32Sigs</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">aSign</span> <span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of multiplying the single-precision floating-point values</span>
<span class="cm">`a&#39; and `b&#39;.  The operation is performed according to the IEC/IEEE Standard</span>
<span class="cm">for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float32</span> <span class="nf">float32_mul</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float32</span> <span class="n">a</span><span class="p">,</span> <span class="n">float32</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">,</span> <span class="n">zSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">bits32</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">zSig64</span><span class="p">;</span>
    <span class="n">bits32</span> <span class="n">zSig</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">zSign</span> <span class="o">=</span> <span class="n">aSign</span> <span class="o">^</span> <span class="n">bSign</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bSig</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">propagateFloat32NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">|</span> <span class="n">bSig</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">float32_default_nan</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat32NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">|</span> <span class="n">aSig</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">float32_default_nan</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">normalizeFloat32Subnormal</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">normalizeFloat32Subnormal</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">zExp</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">+</span> <span class="n">bExp</span> <span class="o">-</span> <span class="mh">0x7F</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">|</span> <span class="mh">0x00800000</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">|</span> <span class="mh">0x00800000</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>
    <span class="n">shift64RightJamming</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="n">aSig</span> <span class="p">)</span> <span class="o">*</span> <span class="n">bSig</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig64</span> <span class="p">);</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="n">zSig64</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">sbits32</span><span class="p">)</span> <span class="p">(</span> <span class="n">zSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">zSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="o">--</span><span class="n">zExp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">roundAndPackFloat32</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of dividing the single-precision floating-point value `a&#39;</span>
<span class="cm">by the corresponding value `b&#39;.  The operation is performed according to the</span>
<span class="cm">IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float32</span> <span class="nf">float32_div</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float32</span> <span class="n">a</span><span class="p">,</span> <span class="n">float32</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">,</span> <span class="n">zSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">bits32</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">zSig</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">zSign</span> <span class="o">=</span> <span class="n">aSign</span> <span class="o">^</span> <span class="n">bSign</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat32NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat32NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">float32_default_nan</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat32NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">|</span> <span class="n">aSig</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">float32_default_nan</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_divbyzero</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">normalizeFloat32Subnormal</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">normalizeFloat32Subnormal</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">zExp</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">-</span> <span class="n">bExp</span> <span class="o">+</span> <span class="mh">0x7D</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">|</span> <span class="mh">0x00800000</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">|</span> <span class="mh">0x00800000</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">&lt;=</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">+</span> <span class="n">aSig</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">aSig</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="o">++</span><span class="n">zExp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">{</span>
        <span class="n">bits64</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="n">aSig</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">;</span>
        <span class="n">do_div</span><span class="p">(</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">bSig</span> <span class="p">);</span>
        <span class="n">zSig</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">zSig</span> <span class="o">&amp;</span> <span class="mh">0x3F</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">zSig</span> <span class="o">|=</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="n">bSig</span> <span class="p">)</span> <span class="o">*</span> <span class="n">zSig</span> <span class="o">!=</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="n">aSig</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">32</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">roundAndPackFloat32</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the remainder of the single-precision floating-point value `a&#39;</span>
<span class="cm">with respect to the corresponding value `b&#39;.  The operation is performed</span>
<span class="cm">according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float32</span> <span class="nf">float32_rem</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float32</span> <span class="n">a</span><span class="p">,</span> <span class="n">float32</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">,</span> <span class="n">zSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">expDiff</span><span class="p">;</span>
    <span class="n">bits32</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">;</span>
    <span class="n">bits32</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig64</span><span class="p">,</span> <span class="n">bSig64</span><span class="p">,</span> <span class="n">q64</span><span class="p">;</span>
    <span class="n">bits32</span> <span class="n">alternateASig</span><span class="p">;</span>
    <span class="n">sbits32</span> <span class="n">sigMean</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bSig</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">propagateFloat32NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">float32_default_nan</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat32NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">float32_default_nan</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">normalizeFloat32Subnormal</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">normalizeFloat32Subnormal</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">expDiff</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">-</span> <span class="n">bExp</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">|=</span> <span class="mh">0x00800000</span><span class="p">;</span>
    <span class="n">bSig</span> <span class="o">|=</span> <span class="mh">0x00800000</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">expDiff</span> <span class="o">&lt;</span> <span class="mi">32</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">aSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
        <span class="n">bSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">expDiff</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">expDiff</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
            <span class="n">aSig</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">&lt;=</span> <span class="n">aSig</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">q</span> <span class="p">)</span> <span class="n">aSig</span> <span class="o">-=</span> <span class="n">bSig</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">expDiff</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">bits64</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="n">aSig</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">;</span>
            <span class="n">do_div</span><span class="p">(</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">bSig</span> <span class="p">);</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="n">q</span> <span class="o">&gt;&gt;=</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">expDiff</span><span class="p">;</span>
            <span class="n">bSig</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">aSig</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aSig</span><span class="o">&gt;&gt;</span><span class="mi">1</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">expDiff</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="o">-</span> <span class="n">bSig</span> <span class="o">*</span> <span class="n">q</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">aSig</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">bSig</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">&lt;=</span> <span class="n">aSig</span> <span class="p">)</span> <span class="n">aSig</span> <span class="o">-=</span> <span class="n">bSig</span><span class="p">;</span>
        <span class="n">aSig64</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="n">aSig</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">40</span><span class="p">;</span>
        <span class="n">bSig64</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="n">bSig</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">40</span><span class="p">;</span>
        <span class="n">expDiff</span> <span class="o">-=</span> <span class="mi">64</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">expDiff</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">q64</span> <span class="o">=</span> <span class="n">estimateDiv128To64</span><span class="p">(</span> <span class="n">aSig64</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bSig64</span> <span class="p">);</span>
            <span class="n">q64</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">q64</span> <span class="p">)</span> <span class="o">?</span> <span class="n">q64</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">aSig64</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">*</span> <span class="n">q64</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">38</span> <span class="p">);</span>
            <span class="n">expDiff</span> <span class="o">-=</span> <span class="mi">62</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">expDiff</span> <span class="o">+=</span> <span class="mi">64</span><span class="p">;</span>
        <span class="n">q64</span> <span class="o">=</span> <span class="n">estimateDiv128To64</span><span class="p">(</span> <span class="n">aSig64</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bSig64</span> <span class="p">);</span>
        <span class="n">q64</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">q64</span> <span class="p">)</span> <span class="o">?</span> <span class="n">q64</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">q64</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="mi">64</span> <span class="o">-</span> <span class="n">expDiff</span> <span class="p">);</span>
        <span class="n">bSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">6</span><span class="p">;</span>
        <span class="n">aSig</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aSig64</span><span class="o">&gt;&gt;</span><span class="mi">33</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">expDiff</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="o">-</span> <span class="n">bSig</span> <span class="o">*</span> <span class="n">q</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">alternateASig</span> <span class="o">=</span> <span class="n">aSig</span><span class="p">;</span>
        <span class="o">++</span><span class="n">q</span><span class="p">;</span>
        <span class="n">aSig</span> <span class="o">-=</span> <span class="n">bSig</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">sbits32</span><span class="p">)</span> <span class="n">aSig</span> <span class="p">);</span>
    <span class="n">sigMean</span> <span class="o">=</span> <span class="n">aSig</span> <span class="o">+</span> <span class="n">alternateASig</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">sigMean</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">sigMean</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">q</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">aSig</span> <span class="o">=</span> <span class="n">alternateASig</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">zSign</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits32</span><span class="p">)</span> <span class="n">aSig</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">zSign</span> <span class="p">)</span> <span class="n">aSig</span> <span class="o">=</span> <span class="o">-</span> <span class="n">aSig</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">normalizeRoundAndPackFloat32</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">aSign</span> <span class="o">^</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">aSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the square root of the single-precision floating-point value `a&#39;.</span>
<span class="cm">The operation is performed according to the IEC/IEEE Standard for Binary</span>
<span class="cm">Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float32</span> <span class="nf">float32_sqrt</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float32</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">bits32</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">zSig</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">rem</span><span class="p">,</span> <span class="n">term</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat32NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">aSign</span> <span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">float32_default_nan</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">|</span> <span class="n">aSig</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">float32_default_nan</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">normalizeFloat32Subnormal</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">zExp</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">-</span> <span class="mh">0x7F</span> <span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">+</span> <span class="mh">0x7E</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">|</span> <span class="mh">0x00800000</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="n">estimateSqrt32</span><span class="p">(</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">aSig</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">zSig</span> <span class="o">&amp;</span> <span class="mh">0x7F</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">zSig</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">zSig</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">aSig</span> <span class="o">&gt;&gt;=</span> <span class="n">aExp</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">term</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="n">zSig</span> <span class="p">)</span> <span class="o">*</span> <span class="n">zSig</span><span class="p">;</span>
            <span class="n">rem</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="n">aSig</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">32</span> <span class="p">)</span> <span class="o">-</span> <span class="n">term</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">rem</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
                <span class="o">--</span><span class="n">zSig</span><span class="p">;</span>
                <span class="n">rem</span> <span class="o">+=</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="n">zSig</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">zSig</span> <span class="o">|=</span> <span class="p">(</span> <span class="n">rem</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">shift32RightJamming</span><span class="p">(</span> <span class="n">zSig</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">roundAndPackFloat32</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the single-precision floating-point value `a&#39; is equal to the</span>
<span class="cm">corresponding value `b&#39;, and 0 otherwise.  The comparison is performed</span>
<span class="cm">according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">float32_eq</span><span class="p">(</span> <span class="n">float32</span> <span class="n">a</span><span class="p">,</span> <span class="n">float32</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">float32_is_signaling_nan</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">||</span> <span class="n">float32_is_signaling_nan</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="p">)</span> <span class="o">||</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits32</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the single-precision floating-point value `a&#39; is less than or</span>
<span class="cm">equal to the corresponding value `b&#39;, and 0 otherwise.  The comparison is</span>
<span class="cm">performed according to the IEC/IEEE Standard for Binary Floating-point</span>
<span class="cm">Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">float32_le</span><span class="p">(</span> <span class="n">float32</span> <span class="n">a</span><span class="p">,</span> <span class="n">float32</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">!=</span> <span class="n">bSign</span> <span class="p">)</span> <span class="k">return</span> <span class="n">aSign</span> <span class="o">||</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits32</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="p">)</span> <span class="o">||</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">^</span> <span class="p">(</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="p">)</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the single-precision floating-point value `a&#39; is less than</span>
<span class="cm">the corresponding value `b&#39;, and 0 otherwise.  The comparison is performed</span>
<span class="cm">according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">float32_lt</span><span class="p">(</span> <span class="n">float32</span> <span class="n">a</span><span class="p">,</span> <span class="n">float32</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">!=</span> <span class="n">bSign</span> <span class="p">)</span> <span class="k">return</span> <span class="n">aSign</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits32</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">^</span> <span class="p">(</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="p">)</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the single-precision floating-point value `a&#39; is equal to the</span>
<span class="cm">corresponding value `b&#39;, and 0 otherwise.  The invalid exception is raised</span>
<span class="cm">if either operand is a NaN.  Otherwise, the comparison is performed</span>
<span class="cm">according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">float32_eq_signaling</span><span class="p">(</span> <span class="n">float32</span> <span class="n">a</span><span class="p">,</span> <span class="n">float32</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="p">)</span> <span class="o">||</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits32</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the single-precision floating-point value `a&#39; is less than or</span>
<span class="cm">equal to the corresponding value `b&#39;, and 0 otherwise.  Quiet NaNs do not</span>
<span class="cm">cause an exception.  Otherwise, the comparison is performed according to the</span>
<span class="cm">IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">float32_le_quiet</span><span class="p">(</span> <span class="n">float32</span> <span class="n">a</span><span class="p">,</span> <span class="n">float32</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>int16 aExp, bExp;</p></td><td class="code"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Do nothing, even if NaN as we&#39;re quiet */</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">!=</span> <span class="n">bSign</span> <span class="p">)</span> <span class="k">return</span> <span class="n">aSign</span> <span class="o">||</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits32</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="p">)</span> <span class="o">||</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">^</span> <span class="p">(</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="p">)</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the single-precision floating-point value `a&#39; is less than</span>
<span class="cm">the corresponding value `b&#39;, and 0 otherwise.  Quiet NaNs do not cause an</span>
<span class="cm">exception.  Otherwise, the comparison is performed according to the IEC/IEEE</span>
<span class="cm">Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">float32_lt_quiet</span><span class="p">(</span> <span class="n">float32</span> <span class="n">a</span><span class="p">,</span> <span class="n">float32</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat32Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat32Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Do nothing, even if NaN as we&#39;re quiet */</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat32Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">!=</span> <span class="n">bSign</span> <span class="p">)</span> <span class="k">return</span> <span class="n">aSign</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits32</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">^</span> <span class="p">(</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="p">)</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the double-precision floating-point value</span>
<span class="cm">`a&#39; to the 32-bit two&#39;s complement integer format.  The conversion is</span>
<span class="cm">performed according to the IEC/IEEE Standard for Binary Floating-point</span>
<span class="cm">Arithmetic---which means in particular that the conversion is rounded</span>
<span class="cm">according to the current rounding mode.  If `a&#39; is a NaN, the largest</span>
<span class="cm">positive integer is returned.  Otherwise, if the conversion overflows, the</span>
<span class="cm">largest integer with the same sign as `a&#39; is returned.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">int32</span> <span class="nf">float64_to_int32</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float64</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">shiftCount</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">aSig</span> <span class="p">)</span> <span class="n">aSign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="p">)</span> <span class="n">aSig</span> <span class="o">|=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x0010000000000000</span> <span class="p">);</span>
    <span class="n">shiftCount</span> <span class="o">=</span> <span class="mh">0x42C</span> <span class="o">-</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">shiftCount</span> <span class="p">)</span> <span class="n">shift64RightJamming</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">shiftCount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">roundAndPackInt32</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">aSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the double-precision floating-point value</span>
<span class="cm">`a&#39; to the 32-bit two&#39;s complement integer format.  The conversion is</span>
<span class="cm">performed according to the IEC/IEEE Standard for Binary Floating-point</span>
<span class="cm">Arithmetic, except that the conversion is always rounded toward zero.  If</span>
<span class="cm">`a&#39; is a NaN, the largest positive integer is returned.  Otherwise, if the</span>
<span class="cm">conversion overflows, the largest integer with the same sign as `a&#39; is</span>
<span class="cm">returned.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">int32</span> <span class="nf">float64_to_int32_round_to_zero</span><span class="p">(</span> <span class="n">float64</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">shiftCount</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">savedASig</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">shiftCount</span> <span class="o">=</span> <span class="mh">0x433</span> <span class="o">-</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">shiftCount</span> <span class="o">&lt;</span> <span class="mi">21</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">aSig</span> <span class="p">)</span> <span class="n">aSign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="mi">52</span> <span class="o">&lt;</span> <span class="n">shiftCount</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">||</span> <span class="n">aSig</span> <span class="p">)</span> <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_inexact</span> <span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSig</span> <span class="o">|=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x0010000000000000</span> <span class="p">);</span>
    <span class="n">savedASig</span> <span class="o">=</span> <span class="n">aSig</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">&gt;&gt;=</span> <span class="n">shiftCount</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">aSig</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="p">)</span> <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">z</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">^</span> <span class="n">aSign</span> <span class="p">)</span> <span class="p">{</span>
 <span class="nl">invalid:</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">aSign</span> <span class="o">?</span> <span class="mh">0x80000000</span> <span class="o">:</span> <span class="mh">0x7FFFFFFF</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aSig</span><span class="o">&lt;&lt;</span><span class="n">shiftCount</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">savedASig</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_inexact</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the double-precision floating-point value</span>
<span class="cm">`a&#39; to the 32-bit two&#39;s complement unsigned integer format.  The conversion</span>
<span class="cm">is performed according to the IEC/IEEE Standard for Binary Floating-point</span>
<span class="cm">Arithmetic---which means in particular that the conversion is rounded</span>
<span class="cm">according to the current rounding mode.  If `a&#39; is a NaN, the largest</span>
<span class="cm">positive integer is returned.  Otherwise, if the conversion overflows, the</span>
<span class="cm">largest positive integer is returned.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">int32</span> <span class="nf">float64_to_uint32</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float64</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">shiftCount</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//extractFloat64Sign( a );</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>if ( ( aExp == 0x7FF ) &amp;&amp; aSig ) aSign = 0;</p></td><td class="code"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="p">)</span> <span class="n">aSig</span> <span class="o">|=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x0010000000000000</span> <span class="p">);</span>
    <span class="n">shiftCount</span> <span class="o">=</span> <span class="mh">0x42C</span> <span class="o">-</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">shiftCount</span> <span class="p">)</span> <span class="n">shift64RightJamming</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">shiftCount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">roundAndPackInt32</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">aSig</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the double-precision floating-point value</span>
<span class="cm">`a&#39; to the 32-bit two&#39;s complement integer format.  The conversion is</span>
<span class="cm">performed according to the IEC/IEEE Standard for Binary Floating-point</span>
<span class="cm">Arithmetic, except that the conversion is always rounded toward zero.  If</span>
<span class="cm">`a&#39; is a NaN, the largest positive integer is returned.  Otherwise, if the</span>
<span class="cm">conversion overflows, the largest positive integer is returned.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">int32</span> <span class="nf">float64_to_uint32_round_to_zero</span><span class="p">(</span> <span class="n">float64</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">shiftCount</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">savedASig</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">shiftCount</span> <span class="o">=</span> <span class="mh">0x433</span> <span class="o">-</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">shiftCount</span> <span class="o">&lt;</span> <span class="mi">21</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">aSig</span> <span class="p">)</span> <span class="n">aSign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="mi">52</span> <span class="o">&lt;</span> <span class="n">shiftCount</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">||</span> <span class="n">aSig</span> <span class="p">)</span> <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_inexact</span> <span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSig</span> <span class="o">|=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x0010000000000000</span> <span class="p">);</span>
    <span class="n">savedASig</span> <span class="o">=</span> <span class="n">aSig</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">&gt;&gt;=</span> <span class="n">shiftCount</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">aSig</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="p">)</span> <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">z</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">^</span> <span class="n">aSign</span> <span class="p">)</span> <span class="p">{</span>
 <span class="nl">invalid:</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">aSign</span> <span class="o">?</span> <span class="mh">0x80000000</span> <span class="o">:</span> <span class="mh">0x7FFFFFFF</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aSig</span><span class="o">&lt;&lt;</span><span class="n">shiftCount</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">savedASig</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_inexact</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the double-precision floating-point value</span>
<span class="cm">`a&#39; to the single-precision floating-point format.  The conversion is</span>
<span class="cm">performed according to the IEC/IEEE Standard for Binary Floating-point</span>
<span class="cm">Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float32</span> <span class="nf">float64_to_float32</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float64</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">;</span>
    <span class="n">bits32</span> <span class="n">zSig</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">commonNaNToFloat32</span><span class="p">(</span> <span class="n">float64ToCommonNaN</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">shift64RightJamming</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="n">aSig</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">||</span> <span class="n">zSig</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">zSig</span> <span class="o">|=</span> <span class="mh">0x40000000</span><span class="p">;</span>
        <span class="n">aExp</span> <span class="o">-=</span> <span class="mh">0x381</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">roundAndPackFloat32</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">zSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cp">#ifdef FLOATX80</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the double-precision floating-point value</span>
<span class="cm">`a&#39; to the extended double-precision floating-point format.  The conversion</span>
<span class="cm">is performed according to the IEC/IEEE Standard for Binary Floating-point</span>
<span class="cm">Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">floatx80</span> <span class="nf">float64_to_floatx80</span><span class="p">(</span> <span class="n">float64</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">commonNaNToFloatx80</span><span class="p">(</span> <span class="n">float64ToCommonNaN</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mh">0x7FFF</span><span class="p">,</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">normalizeFloat64Subnormal</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span>
        <span class="n">packFloatx80</span><span class="p">(</span>
            <span class="n">aSign</span><span class="p">,</span> <span class="n">aExp</span> <span class="o">+</span> <span class="mh">0x3C00</span><span class="p">,</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">|</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x0010000000000000</span> <span class="p">)</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">11</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Rounds the double-precision floating-point value `a&#39; to an integer, and</span>
<span class="cm">returns the result as a double-precision floating-point value.  The</span>
<span class="cm">operation is performed according to the IEC/IEEE Standard for Binary</span>
<span class="cm">Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float64</span> <span class="nf">float64_round_to_int</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float64</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">lastBitMask</span><span class="p">,</span> <span class="n">roundBitsMask</span><span class="p">;</span>
    <span class="n">int8</span> <span class="n">roundingMode</span><span class="p">;</span>
    <span class="n">float64</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mh">0x433</span> <span class="o">&lt;=</span> <span class="n">aExp</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">propagateFloat64NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">&lt;=</span> <span class="mh">0x3FE</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">a</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
        <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
        <span class="k">switch</span> <span class="p">(</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="p">)</span> <span class="p">{</span>
         <span class="k">case</span> <span class="n">float_round_nearest_even</span>:
            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x3FE</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mh">0x3FF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
         <span class="k">case</span> <span class="n">float_round_down</span>:
            <span class="k">return</span> <span class="n">aSign</span> <span class="o">?</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0xBFF0000000000000</span> <span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
         <span class="k">case</span> <span class="n">float_round_up</span>:
            <span class="k">return</span>
            <span class="n">aSign</span> <span class="o">?</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">)</span> <span class="o">:</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x3FF0000000000000</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">lastBitMask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">lastBitMask</span> <span class="o">&lt;&lt;=</span> <span class="mh">0x433</span> <span class="o">-</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="n">roundBitsMask</span> <span class="o">=</span> <span class="n">lastBitMask</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">roundingMode</span> <span class="o">=</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_nearest_even</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">z</span> <span class="o">+=</span> <span class="n">lastBitMask</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">z</span> <span class="o">&amp;</span> <span class="n">roundBitsMask</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">z</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="n">lastBitMask</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">!=</span> <span class="n">float_round_to_zero</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">z</span> <span class="p">)</span> <span class="o">^</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_up</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">z</span> <span class="o">+=</span> <span class="n">roundBitsMask</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">z</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="n">roundBitsMask</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">z</span> <span class="o">!=</span> <span class="n">a</span> <span class="p">)</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of adding the absolute values of the double-precision</span>
<span class="cm">floating-point values `a&#39; and `b&#39;.  If `zSign&#39; is true, the sum is negated</span>
<span class="cm">before being returned.  `zSign&#39; is ignored if the result is a NaN.  The</span>
<span class="cm">addition is performed according to the IEC/IEEE Standard for Binary</span>
<span class="cm">Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">float64</span> <span class="nf">addFloat64Sigs</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float64</span> <span class="n">a</span><span class="p">,</span> <span class="n">float64</span> <span class="n">b</span><span class="p">,</span> <span class="n">flag</span> <span class="n">zSign</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">zSig</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">expDiff</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">expDiff</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">-</span> <span class="n">bExp</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">9</span><span class="p">;</span>
    <span class="n">bSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">9</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">expDiff</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat64NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="o">--</span><span class="n">expDiff</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">bSig</span> <span class="o">|=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x2000000000000000</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">shift64RightJamming</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">expDiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bSig</span> <span class="p">);</span>
        <span class="n">zExp</span> <span class="o">=</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">expDiff</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat64NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0x7FF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">expDiff</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">aSig</span> <span class="o">|=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x2000000000000000</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">shift64RightJamming</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">-</span> <span class="n">expDiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
        <span class="n">zExp</span> <span class="o">=</span> <span class="n">bExp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">|</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat64NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">+</span> <span class="n">bSig</span> <span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">9</span> <span class="p">);</span>
        <span class="n">zSig</span> <span class="o">=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x4000000000000000</span> <span class="p">)</span> <span class="o">+</span> <span class="n">aSig</span> <span class="o">+</span> <span class="n">bSig</span><span class="p">;</span>
        <span class="n">zExp</span> <span class="o">=</span> <span class="n">aExp</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">roundAndPack</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSig</span> <span class="o">|=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x2000000000000000</span> <span class="p">);</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">+</span> <span class="n">bSig</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">;</span>
    <span class="o">--</span><span class="n">zExp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">zSig</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">zSig</span> <span class="o">=</span> <span class="n">aSig</span> <span class="o">+</span> <span class="n">bSig</span><span class="p">;</span>
        <span class="o">++</span><span class="n">zExp</span><span class="p">;</span>
    <span class="p">}</span>
 <span class="nl">roundAndPack:</span>
    <span class="k">return</span> <span class="n">roundAndPackFloat64</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of subtracting the absolute values of the double-</span>
<span class="cm">precision floating-point values `a&#39; and `b&#39;.  If `zSign&#39; is true, the</span>
<span class="cm">difference is negated before being returned.  `zSign&#39; is ignored if the</span>
<span class="cm">result is a NaN.  The subtraction is performed according to the IEC/IEEE</span>
<span class="cm">Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">float64</span> <span class="nf">subFloat64Sigs</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float64</span> <span class="n">a</span><span class="p">,</span> <span class="n">float64</span> <span class="n">b</span><span class="p">,</span> <span class="n">flag</span> <span class="n">zSign</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">zSig</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">expDiff</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">expDiff</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">-</span> <span class="n">bExp</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">bSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">expDiff</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">aExpBigger</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">expDiff</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">bExpBigger</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">|</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat64NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">float64_default_nan</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">aExp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">bExp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">&lt;</span> <span class="n">aSig</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">aBigger</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">&lt;</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">bBigger</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">float_round_down</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
 <span class="nl">bExpBigger:</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat64NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">zSign</span> <span class="o">^</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x7FF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">expDiff</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">aSig</span> <span class="o">|=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x4000000000000000</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">shift64RightJamming</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">-</span> <span class="n">expDiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">|=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x4000000000000000</span> <span class="p">);</span>
 <span class="nl">bBigger:</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="n">bSig</span> <span class="o">-</span> <span class="n">aSig</span><span class="p">;</span>
    <span class="n">zExp</span> <span class="o">=</span> <span class="n">bExp</span><span class="p">;</span>
    <span class="n">zSign</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">normalizeRoundAndPack</span><span class="p">;</span>
 <span class="nl">aExpBigger:</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat64NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">expDiff</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">bSig</span> <span class="o">|=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x4000000000000000</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">shift64RightJamming</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">expDiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bSig</span> <span class="p">);</span>
    <span class="n">aSig</span> <span class="o">|=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x4000000000000000</span> <span class="p">);</span>
 <span class="nl">aBigger:</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="n">aSig</span> <span class="o">-</span> <span class="n">bSig</span><span class="p">;</span>
    <span class="n">zExp</span> <span class="o">=</span> <span class="n">aExp</span><span class="p">;</span>
 <span class="nl">normalizeRoundAndPack:</span>
    <span class="o">--</span><span class="n">zExp</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">normalizeRoundAndPackFloat64</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of adding the double-precision floating-point values `a&#39;</span>
<span class="cm">and `b&#39;.  The operation is performed according to the IEC/IEEE Standard for</span>
<span class="cm">Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float64</span> <span class="nf">float64_add</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float64</span> <span class="n">a</span><span class="p">,</span> <span class="n">float64</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>

    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">==</span> <span class="n">bSign</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">addFloat64Sigs</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">aSign</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">subFloat64Sigs</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">aSign</span> <span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of subtracting the double-precision floating-point values</span>
<span class="cm">`a&#39; and `b&#39;.  The operation is performed according to the IEC/IEEE Standard</span>
<span class="cm">for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float64</span> <span class="nf">float64_sub</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float64</span> <span class="n">a</span><span class="p">,</span> <span class="n">float64</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>

    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">==</span> <span class="n">bSign</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">subFloat64Sigs</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">aSign</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">addFloat64Sigs</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">aSign</span> <span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of multiplying the double-precision floating-point values</span>
<span class="cm">`a&#39; and `b&#39;.  The operation is performed according to the IEC/IEEE Standard</span>
<span class="cm">for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float64</span> <span class="nf">float64_mul</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float64</span> <span class="n">a</span><span class="p">,</span> <span class="n">float64</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">,</span> <span class="n">zSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">zSign</span> <span class="o">=</span> <span class="n">aSign</span> <span class="o">^</span> <span class="n">bSign</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bSig</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">propagateFloat64NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">|</span> <span class="n">bSig</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">float64_default_nan</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0x7FF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat64NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">|</span> <span class="n">aSig</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">float64_default_nan</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0x7FF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">normalizeFloat64Subnormal</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">normalizeFloat64Subnormal</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">zExp</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">+</span> <span class="n">bExp</span> <span class="o">-</span> <span class="mh">0x3FF</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">|</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x0010000000000000</span> <span class="p">)</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">;</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">|</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x0010000000000000</span> <span class="p">)</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">11</span><span class="p">;</span>
    <span class="n">mul64To128</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig1</span> <span class="p">);</span>
    <span class="n">zSig0</span> <span class="o">|=</span> <span class="p">(</span> <span class="n">zSig1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">zSig0</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">zSig0</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="o">--</span><span class="n">zExp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">roundAndPackFloat64</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig0</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of dividing the double-precision floating-point value `a&#39;</span>
<span class="cm">by the corresponding value `b&#39;.  The operation is performed according to</span>
<span class="cm">the IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float64</span> <span class="nf">float64_div</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float64</span> <span class="n">a</span><span class="p">,</span> <span class="n">float64</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">,</span> <span class="n">zSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">zSig</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">rem0</span><span class="p">,</span> <span class="n">rem1</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">zSign</span> <span class="o">=</span> <span class="n">aSign</span> <span class="o">^</span> <span class="n">bSign</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat64NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat64NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">float64_default_nan</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0x7FF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat64NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">|</span> <span class="n">aSig</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">float64_default_nan</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_divbyzero</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0x7FF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">normalizeFloat64Subnormal</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">normalizeFloat64Subnormal</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">zExp</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">-</span> <span class="n">bExp</span> <span class="o">+</span> <span class="mh">0x3FD</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">|</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x0010000000000000</span> <span class="p">)</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">;</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">|</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x0010000000000000</span> <span class="p">)</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">11</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">&lt;=</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">+</span> <span class="n">aSig</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">aSig</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="o">++</span><span class="n">zExp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="n">estimateDiv128To64</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bSig</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">zSig</span> <span class="o">&amp;</span> <span class="mh">0x1FF</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">mul64To128</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">zSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term1</span> <span class="p">);</span>
        <span class="n">sub128</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem1</span> <span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">rem0</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="o">--</span><span class="n">zSig</span><span class="p">;</span>
            <span class="n">add128</span><span class="p">(</span> <span class="n">rem0</span><span class="p">,</span> <span class="n">rem1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem1</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">zSig</span> <span class="o">|=</span> <span class="p">(</span> <span class="n">rem1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">roundAndPackFloat64</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the remainder of the double-precision floating-point value `a&#39;</span>
<span class="cm">with respect to the corresponding value `b&#39;.  The operation is performed</span>
<span class="cm">according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float64</span> <span class="nf">float64_rem</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float64</span> <span class="n">a</span><span class="p">,</span> <span class="n">float64</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">,</span> <span class="n">zSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">expDiff</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">q</span><span class="p">,</span> <span class="n">alternateASig</span><span class="p">;</span>
    <span class="n">sbits64</span> <span class="n">sigMean</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bSig</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">propagateFloat64NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">float64_default_nan</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat64NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">float64_default_nan</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">normalizeFloat64Subnormal</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">normalizeFloat64Subnormal</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">expDiff</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">-</span> <span class="n">bExp</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">|</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x0010000000000000</span> <span class="p">)</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">11</span><span class="p">;</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">|</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x0010000000000000</span> <span class="p">)</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">11</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">expDiff</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">expDiff</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">aSig</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">q</span> <span class="o">=</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">&lt;=</span> <span class="n">aSig</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">q</span> <span class="p">)</span> <span class="n">aSig</span> <span class="o">-=</span> <span class="n">bSig</span><span class="p">;</span>
    <span class="n">expDiff</span> <span class="o">-=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">expDiff</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">estimateDiv128To64</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bSig</span> <span class="p">);</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">q</span> <span class="p">)</span> <span class="o">?</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">aSig</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span> <span class="p">(</span> <span class="n">bSig</span><span class="o">&gt;&gt;</span><span class="mi">2</span> <span class="p">)</span> <span class="o">*</span> <span class="n">q</span> <span class="p">);</span>
        <span class="n">expDiff</span> <span class="o">-=</span> <span class="mi">62</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">expDiff</span> <span class="o">+=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">expDiff</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">estimateDiv128To64</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bSig</span> <span class="p">);</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">q</span> <span class="p">)</span> <span class="o">?</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">q</span> <span class="o">&gt;&gt;=</span> <span class="mi">64</span> <span class="o">-</span> <span class="n">expDiff</span><span class="p">;</span>
        <span class="n">bSig</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">aSig</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aSig</span><span class="o">&gt;&gt;</span><span class="mi">1</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">expDiff</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="o">-</span> <span class="n">bSig</span> <span class="o">*</span> <span class="n">q</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">aSig</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">bSig</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">alternateASig</span> <span class="o">=</span> <span class="n">aSig</span><span class="p">;</span>
        <span class="o">++</span><span class="n">q</span><span class="p">;</span>
        <span class="n">aSig</span> <span class="o">-=</span> <span class="n">bSig</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">aSig</span> <span class="p">);</span>
    <span class="n">sigMean</span> <span class="o">=</span> <span class="n">aSig</span> <span class="o">+</span> <span class="n">alternateASig</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">sigMean</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">sigMean</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">q</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">aSig</span> <span class="o">=</span> <span class="n">alternateASig</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">zSign</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">aSig</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">zSign</span> <span class="p">)</span> <span class="n">aSig</span> <span class="o">=</span> <span class="o">-</span> <span class="n">aSig</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">normalizeRoundAndPackFloat64</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">aSign</span> <span class="o">^</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">aSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the square root of the double-precision floating-point value `a&#39;.</span>
<span class="cm">The operation is performed according to the IEC/IEEE Standard for Binary</span>
<span class="cm">Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float64</span> <span class="nf">float64_sqrt</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">float64</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int16</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">zSig</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">rem0</span><span class="p">,</span> <span class="n">rem1</span><span class="p">,</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">;</span> <span class="c1">//, shiftedRem;</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>float64 z;</p></td><td class="code"><div class="highlight"><pre>    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloat64NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">aSign</span> <span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">float64_default_nan</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">|</span> <span class="n">aSig</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">float64_default_nan</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">normalizeFloat64Subnormal</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">zExp</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">-</span> <span class="mh">0x3FF</span> <span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">+</span> <span class="mh">0x3FE</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">|=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x0010000000000000</span> <span class="p">);</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="n">estimateSqrt32</span><span class="p">(</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">aSig</span><span class="o">&gt;&gt;</span><span class="mi">21</span> <span class="p">);</span>
    <span class="n">zSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">31</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">9</span> <span class="o">-</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="n">zSig</span> <span class="o">=</span> <span class="n">estimateDiv128To64</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">zSig</span> <span class="p">)</span> <span class="o">+</span> <span class="n">zSig</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">zSig</span> <span class="o">&amp;</span> <span class="mh">0x3FF</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">zSig</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">zSig</span> <span class="o">=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0xFFFFFFFFFFFFFFFF</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">aSig</span> <span class="o">&lt;&lt;=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">mul64To128</span><span class="p">(</span> <span class="n">zSig</span><span class="p">,</span> <span class="n">zSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term1</span> <span class="p">);</span>
            <span class="n">sub128</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem1</span> <span class="p">);</span>
            <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">rem0</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
                <span class="o">--</span><span class="n">zSig</span><span class="p">;</span>
                <span class="n">shortShift128Left</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">zSig</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term1</span> <span class="p">);</span>
                <span class="n">term1</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">add128</span><span class="p">(</span> <span class="n">rem0</span><span class="p">,</span> <span class="n">rem1</span><span class="p">,</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem1</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="n">zSig</span> <span class="o">|=</span> <span class="p">(</span> <span class="p">(</span> <span class="n">rem0</span> <span class="o">|</span> <span class="n">rem1</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">shift64RightJamming</span><span class="p">(</span> <span class="n">zSig</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">roundAndPackFloat64</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the double-precision floating-point value `a&#39; is equal to the</span>
<span class="cm">corresponding value `b&#39;, and 0 otherwise.  The comparison is performed</span>
<span class="cm">according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">float64_eq</span><span class="p">(</span> <span class="n">float64</span> <span class="n">a</span><span class="p">,</span> <span class="n">float64</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">float64_is_signaling_nan</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">||</span> <span class="n">float64_is_signaling_nan</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="p">)</span> <span class="o">||</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the double-precision floating-point value `a&#39; is less than or</span>
<span class="cm">equal to the corresponding value `b&#39;, and 0 otherwise.  The comparison is</span>
<span class="cm">performed according to the IEC/IEEE Standard for Binary Floating-point</span>
<span class="cm">Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">float64_le</span><span class="p">(</span> <span class="n">float64</span> <span class="n">a</span><span class="p">,</span> <span class="n">float64</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">!=</span> <span class="n">bSign</span> <span class="p">)</span> <span class="k">return</span> <span class="n">aSign</span> <span class="o">||</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="p">)</span> <span class="o">||</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">^</span> <span class="p">(</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="p">)</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the double-precision floating-point value `a&#39; is less than</span>
<span class="cm">the corresponding value `b&#39;, and 0 otherwise.  The comparison is performed</span>
<span class="cm">according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">float64_lt</span><span class="p">(</span> <span class="n">float64</span> <span class="n">a</span><span class="p">,</span> <span class="n">float64</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">!=</span> <span class="n">bSign</span> <span class="p">)</span> <span class="k">return</span> <span class="n">aSign</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">^</span> <span class="p">(</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="p">)</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the double-precision floating-point value `a&#39; is equal to the</span>
<span class="cm">corresponding value `b&#39;, and 0 otherwise.  The invalid exception is raised</span>
<span class="cm">if either operand is a NaN.  Otherwise, the comparison is performed</span>
<span class="cm">according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">float64_eq_signaling</span><span class="p">(</span> <span class="n">float64</span> <span class="n">a</span><span class="p">,</span> <span class="n">float64</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="p">)</span> <span class="o">||</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the double-precision floating-point value `a&#39; is less than or</span>
<span class="cm">equal to the corresponding value `b&#39;, and 0 otherwise.  Quiet NaNs do not</span>
<span class="cm">cause an exception.  Otherwise, the comparison is performed according to the</span>
<span class="cm">IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">float64_le_quiet</span><span class="p">(</span> <span class="n">float64</span> <span class="n">a</span><span class="p">,</span> <span class="n">float64</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>int16 aExp, bExp;</p></td><td class="code"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Do nothing, even if NaN as we&#39;re quiet */</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">!=</span> <span class="n">bSign</span> <span class="p">)</span> <span class="k">return</span> <span class="n">aSign</span> <span class="o">||</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="p">)</span> <span class="o">||</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">^</span> <span class="p">(</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="p">)</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the double-precision floating-point value `a&#39; is less than</span>
<span class="cm">the corresponding value `b&#39;, and 0 otherwise.  Quiet NaNs do not cause an</span>
<span class="cm">exception.  Otherwise, the comparison is performed according to the IEC/IEEE</span>
<span class="cm">Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">float64_lt_quiet</span><span class="p">(</span> <span class="n">float64</span> <span class="n">a</span><span class="p">,</span> <span class="n">float64</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">extractFloat64Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">extractFloat64Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Do nothing, even if NaN as we&#39;re quiet */</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloat64Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">!=</span> <span class="n">bSign</span> <span class="p">)</span> <span class="k">return</span> <span class="n">aSign</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">^</span> <span class="p">(</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="p">)</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cp">#ifdef FLOATX80</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the extended double-precision floating-</span>
<span class="cm">point value `a&#39; to the 32-bit two&#39;s complement integer format.  The</span>
<span class="cm">conversion is performed according to the IEC/IEEE Standard for Binary</span>
<span class="cm">Floating-point Arithmetic---which means in particular that the conversion</span>
<span class="cm">is rounded according to the current rounding mode.  If `a&#39; is a NaN, the</span>
<span class="cm">largest positive integer is returned.  Otherwise, if the conversion</span>
<span class="cm">overflows, the largest integer with the same sign as `a&#39; is returned.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">int32</span> <span class="nf">floatx80_to_int32</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">shiftCount</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">aSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="n">aSign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">shiftCount</span> <span class="o">=</span> <span class="mh">0x4037</span> <span class="o">-</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">shiftCount</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">shiftCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">shift64RightJamming</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">shiftCount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">roundAndPackInt32</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">aSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the extended double-precision floating-</span>
<span class="cm">point value `a&#39; to the 32-bit two&#39;s complement integer format.  The</span>
<span class="cm">conversion is performed according to the IEC/IEEE Standard for Binary</span>
<span class="cm">Floating-point Arithmetic, except that the conversion is always rounded</span>
<span class="cm">toward zero.  If `a&#39; is a NaN, the largest positive integer is returned.</span>
<span class="cm">Otherwise, if the conversion overflows, the largest integer with the same</span>
<span class="cm">sign as `a&#39; is returned.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">int32</span> <span class="nf">floatx80_to_int32_round_to_zero</span><span class="p">(</span> <span class="n">floatx80</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">shiftCount</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">savedASig</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">shiftCount</span> <span class="o">=</span> <span class="mh">0x403E</span> <span class="o">-</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">shiftCount</span> <span class="o">&lt;</span> <span class="mi">32</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">aSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="n">aSign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="mi">63</span> <span class="o">&lt;</span> <span class="n">shiftCount</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">||</span> <span class="n">aSig</span> <span class="p">)</span> <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_inexact</span> <span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">savedASig</span> <span class="o">=</span> <span class="n">aSig</span><span class="p">;</span>
    <span class="n">aSig</span> <span class="o">&gt;&gt;=</span> <span class="n">shiftCount</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">aSig</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="p">)</span> <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">z</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">^</span> <span class="n">aSign</span> <span class="p">)</span> <span class="p">{</span>
 <span class="nl">invalid:</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">aSign</span> <span class="o">?</span> <span class="mh">0x80000000</span> <span class="o">:</span> <span class="mh">0x7FFFFFFF</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aSig</span><span class="o">&lt;&lt;</span><span class="n">shiftCount</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">savedASig</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_inexact</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the extended double-precision floating-</span>
<span class="cm">point value `a&#39; to the single-precision floating-point format.  The</span>
<span class="cm">conversion is performed according to the IEC/IEEE Standard for Binary</span>
<span class="cm">Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float32</span> <span class="nf">floatx80_to_float32</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">aSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">commonNaNToFloat32</span><span class="p">(</span> <span class="n">floatx80ToCommonNaN</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">packFloat32</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">shift64RightJamming</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">||</span> <span class="n">aSig</span> <span class="p">)</span> <span class="n">aExp</span> <span class="o">-=</span> <span class="mh">0x3F81</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">roundAndPackFloat32</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">aSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of converting the extended double-precision floating-</span>
<span class="cm">point value `a&#39; to the double-precision floating-point format.  The</span>
<span class="cm">conversion is performed according to the IEC/IEEE Standard for Binary</span>
<span class="cm">Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">float64</span> <span class="nf">floatx80_to_float64</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">zSig</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">aSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">commonNaNToFloat64</span><span class="p">(</span> <span class="n">floatx80ToCommonNaN</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">packFloat64</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mh">0x7FF</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">shift64RightJamming</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">||</span> <span class="n">aSig</span> <span class="p">)</span> <span class="n">aExp</span> <span class="o">-=</span> <span class="mh">0x3C01</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">roundAndPackFloat64</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">zSig</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Rounds the extended double-precision floating-point value `a&#39; to an integer,</span>
<span class="cm">and returns the result as an extended quadruple-precision floating-point</span>
<span class="cm">value.  The operation is performed according to the IEC/IEEE Standard for</span>
<span class="cm">Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">floatx80</span> <span class="nf">floatx80_round_to_int</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">lastBitMask</span><span class="p">,</span> <span class="n">roundBitsMask</span><span class="p">;</span>
    <span class="n">int8</span> <span class="n">roundingMode</span><span class="p">;</span>
    <span class="n">floatx80</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mh">0x403E</span> <span class="o">&lt;=</span> <span class="n">aExp</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">propagateFloatx80NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">&lt;=</span> <span class="mh">0x3FFE</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
             <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
        <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
        <span class="k">switch</span> <span class="p">(</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="p">)</span> <span class="p">{</span>
         <span class="k">case</span> <span class="n">float_round_nearest_even</span>:
            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x3FFE</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span>
               <span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span>
                    <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mh">0x3FFF</span><span class="p">,</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">)</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
         <span class="k">case</span> <span class="n">float_round_down</span>:
            <span class="k">return</span>
                  <span class="n">aSign</span> <span class="o">?</span>
                      <span class="n">packFloatx80</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x3FFF</span><span class="p">,</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">)</span> <span class="p">)</span>
                <span class="o">:</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
         <span class="k">case</span> <span class="n">float_round_up</span>:
            <span class="k">return</span>
                  <span class="n">aSign</span> <span class="o">?</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
                <span class="o">:</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x3FFF</span><span class="p">,</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">aSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">lastBitMask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">lastBitMask</span> <span class="o">&lt;&lt;=</span> <span class="mh">0x403E</span> <span class="o">-</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="n">roundBitsMask</span> <span class="o">=</span> <span class="n">lastBitMask</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">roundingMode</span> <span class="o">=</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_nearest_even</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">z</span><span class="p">.</span><span class="n">low</span> <span class="o">+=</span> <span class="n">lastBitMask</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">z</span><span class="p">.</span><span class="n">low</span> <span class="o">&amp;</span> <span class="n">roundBitsMask</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">z</span><span class="p">.</span><span class="n">low</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="n">lastBitMask</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">!=</span> <span class="n">float_round_to_zero</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">z</span> <span class="p">)</span> <span class="o">^</span> <span class="p">(</span> <span class="n">roundingMode</span> <span class="o">==</span> <span class="n">float_round_up</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">z</span><span class="p">.</span><span class="n">low</span> <span class="o">+=</span> <span class="n">roundBitsMask</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">z</span><span class="p">.</span><span class="n">low</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="n">roundBitsMask</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">z</span><span class="p">.</span><span class="n">low</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">z</span><span class="p">.</span><span class="n">high</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">z</span><span class="p">.</span><span class="n">low</span> <span class="o">!=</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span> <span class="p">)</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_inexact</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of adding the absolute values of the extended double-</span>
<span class="cm">precision floating-point values `a&#39; and `b&#39;.  If `zSign&#39; is true, the sum is</span>
<span class="cm">negated before being returned.  `zSign&#39; is ignored if the result is a NaN.</span>
<span class="cm">The addition is performed according to the IEC/IEEE Standard for Binary</span>
<span class="cm">Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">floatx80</span> <span class="nf">addFloatx80Sigs</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">a</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">b</span><span class="p">,</span> <span class="n">flag</span> <span class="n">zSign</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int32</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">expDiff</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">expDiff</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">-</span> <span class="n">bExp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">expDiff</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">aSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloatx80NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">--</span><span class="n">expDiff</span><span class="p">;</span>
        <span class="n">shift64ExtraRightJamming</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">expDiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig1</span> <span class="p">);</span>
        <span class="n">zExp</span> <span class="o">=</span> <span class="n">aExp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">expDiff</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">bSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloatx80NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0x7FFF</span><span class="p">,</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">++</span><span class="n">expDiff</span><span class="p">;</span>
        <span class="n">shift64ExtraRightJamming</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span> <span class="n">expDiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig1</span> <span class="p">);</span>
        <span class="n">zExp</span> <span class="o">=</span> <span class="n">bExp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">|</span> <span class="n">bSig</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">propagateFloatx80NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">zSig1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">zSig0</span> <span class="o">=</span> <span class="n">aSig</span> <span class="o">+</span> <span class="n">bSig</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">normalizeFloatx80Subnormal</span><span class="p">(</span> <span class="n">zSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig0</span> <span class="p">);</span>
            <span class="k">goto</span> <span class="n">roundAndPack</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">zExp</span> <span class="o">=</span> <span class="n">aExp</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">shiftRight1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">zSig0</span> <span class="o">=</span> <span class="n">aSig</span> <span class="o">+</span> <span class="n">bSig</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">zSig0</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">roundAndPack</span><span class="p">;</span> 
 <span class="n">shiftRight1</span><span class="o">:</span>
    <span class="n">shift64ExtraRightJamming</span><span class="p">(</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig1</span> <span class="p">);</span>
    <span class="n">zSig0</span> <span class="o">|=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">);</span>
    <span class="o">++</span><span class="n">zExp</span><span class="p">;</span>
 <span class="nl">roundAndPack:</span>
    <span class="k">return</span>
        <span class="n">roundAndPackFloatx80</span><span class="p">(</span>
            <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of subtracting the absolute values of the extended</span>
<span class="cm">double-precision floating-point values `a&#39; and `b&#39;.  If `zSign&#39; is true,</span>
<span class="cm">the difference is negated before being returned.  `zSign&#39; is ignored if the</span>
<span class="cm">result is a NaN.  The subtraction is performed according to the IEC/IEEE</span>
<span class="cm">Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">floatx80</span> <span class="nf">subFloatx80Sigs</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">a</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">b</span><span class="p">,</span> <span class="n">flag</span> <span class="n">zSign</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">int32</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">expDiff</span><span class="p">;</span>
    <span class="n">floatx80</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">expDiff</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">-</span> <span class="n">bExp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">expDiff</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">aExpBigger</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">expDiff</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">bExpBigger</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">|</span> <span class="n">bSig</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">propagateFloatx80NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">floatx80_default_nan_low</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">high</span> <span class="o">=</span> <span class="n">floatx80_default_nan_high</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">__padding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">aExp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">bExp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">zSig1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">&lt;</span> <span class="n">aSig</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">aBigger</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">&lt;</span> <span class="n">bSig</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">bBigger</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">float_round_down</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
 <span class="nl">bExpBigger:</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">bSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloatx80NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span> <span class="o">^</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x7FFF</span><span class="p">,</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">++</span><span class="n">expDiff</span><span class="p">;</span>
    <span class="n">shift128RightJamming</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span> <span class="n">expDiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig1</span> <span class="p">);</span>
 <span class="nl">bBigger:</span>
    <span class="n">sub128</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig1</span> <span class="p">);</span>
    <span class="n">zExp</span> <span class="o">=</span> <span class="n">bExp</span><span class="p">;</span>
    <span class="n">zSign</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">normalizeRoundAndPack</span><span class="p">;</span>
 <span class="nl">aExpBigger:</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">aSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloatx80NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">--</span><span class="n">expDiff</span><span class="p">;</span>
    <span class="n">shift128RightJamming</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">expDiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig1</span> <span class="p">);</span>
 <span class="nl">aBigger:</span>
    <span class="n">sub128</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig1</span> <span class="p">);</span>
    <span class="n">zExp</span> <span class="o">=</span> <span class="n">aExp</span><span class="p">;</span>
 <span class="nl">normalizeRoundAndPack:</span>
    <span class="k">return</span>
        <span class="n">normalizeRoundAndPackFloatx80</span><span class="p">(</span>
            <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of adding the extended double-precision floating-point</span>
<span class="cm">values `a&#39; and `b&#39;.  The operation is performed according to the IEC/IEEE</span>
<span class="cm">Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">floatx80</span> <span class="nf">floatx80_add</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">a</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>
    
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">==</span> <span class="n">bSign</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">addFloatx80Sigs</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">aSign</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">subFloatx80Sigs</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">aSign</span> <span class="p">);</span>
    <span class="p">}</span>
    
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of subtracting the extended double-precision floating-</span>
<span class="cm">point values `a&#39; and `b&#39;.  The operation is performed according to the</span>
<span class="cm">IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">floatx80</span> <span class="nf">floatx80_sub</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">a</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>

    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">==</span> <span class="n">bSign</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">subFloatx80Sigs</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">aSign</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">addFloatx80Sigs</span><span class="p">(</span> <span class="n">roundData</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">aSign</span> <span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of multiplying the extended double-precision floating-</span>
<span class="cm">point values `a&#39; and `b&#39;.  The operation is performed according to the</span>
<span class="cm">IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">floatx80</span> <span class="nf">floatx80_mul</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">a</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">,</span> <span class="n">zSign</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">;</span>
    <span class="n">floatx80</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">zSign</span> <span class="o">=</span> <span class="n">aSign</span> <span class="o">^</span> <span class="n">bSign</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">aSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span>
             <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">bSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">propagateFloatx80NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">|</span> <span class="n">bSig</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0x7FFF</span><span class="p">,</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">bSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloatx80NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">|</span> <span class="n">aSig</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
 <span class="nl">invalid:</span>
            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
            <span class="n">z</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">floatx80_default_nan_low</span><span class="p">;</span>
            <span class="n">z</span><span class="p">.</span><span class="n">high</span> <span class="o">=</span> <span class="n">floatx80_default_nan_high</span><span class="p">;</span>
            <span class="n">z</span><span class="p">.</span><span class="n">__padding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0x7FFF</span><span class="p">,</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">normalizeFloatx80Subnormal</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">normalizeFloatx80Subnormal</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">zExp</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">+</span> <span class="n">bExp</span> <span class="o">-</span> <span class="mh">0x3FFE</span><span class="p">;</span>
    <span class="n">mul64To128</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig1</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">zSig0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">shortShift128Left</span><span class="p">(</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zSig1</span> <span class="p">);</span>
        <span class="o">--</span><span class="n">zExp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span>
        <span class="n">roundAndPackFloatx80</span><span class="p">(</span>
            <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the result of dividing the extended double-precision floating-point</span>
<span class="cm">value `a&#39; by the corresponding value `b&#39;.  The operation is performed</span>
<span class="cm">according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">floatx80</span> <span class="nf">floatx80_div</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">a</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">,</span> <span class="n">zSign</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">rem0</span><span class="p">,</span> <span class="n">rem1</span><span class="p">,</span> <span class="n">rem2</span><span class="p">,</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="n">term2</span><span class="p">;</span>
    <span class="n">floatx80</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">aSig</span> <span class="o">=</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">zSign</span> <span class="o">=</span> <span class="n">aSign</span> <span class="o">^</span> <span class="n">bSign</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">aSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloatx80NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">bSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloatx80NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
            <span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0x7FFF</span><span class="p">,</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">bSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloatx80NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">|</span> <span class="n">aSig</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
 <span class="nl">invalid:</span>
                <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
                <span class="n">z</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">floatx80_default_nan_low</span><span class="p">;</span>
                <span class="n">z</span><span class="p">.</span><span class="n">high</span> <span class="o">=</span> <span class="n">floatx80_default_nan_high</span><span class="p">;</span>
                <span class="n">z</span><span class="p">.</span><span class="n">__padding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_divbyzero</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mh">0x7FFF</span><span class="p">,</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">normalizeFloatx80Subnormal</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="n">zSign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">normalizeFloatx80Subnormal</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">zExp</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">-</span> <span class="n">bExp</span> <span class="o">+</span> <span class="mh">0x3FFE</span><span class="p">;</span>
    <span class="n">rem1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">&lt;=</span> <span class="n">aSig</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">shift128Right</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem1</span> <span class="p">);</span>
        <span class="o">++</span><span class="n">zExp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">zSig0</span> <span class="o">=</span> <span class="n">estimateDiv128To64</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">rem1</span><span class="p">,</span> <span class="n">bSig</span> <span class="p">);</span>
    <span class="n">mul64To128</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term1</span> <span class="p">);</span>
    <span class="n">sub128</span><span class="p">(</span> <span class="n">aSig</span><span class="p">,</span> <span class="n">rem1</span><span class="p">,</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem1</span> <span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">rem0</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">zSig0</span><span class="p">;</span>
        <span class="n">add128</span><span class="p">(</span> <span class="n">rem0</span><span class="p">,</span> <span class="n">rem1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem1</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">zSig1</span> <span class="o">=</span> <span class="n">estimateDiv128To64</span><span class="p">(</span> <span class="n">rem1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bSig</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">zSig1</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">8</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">mul64To128</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term2</span> <span class="p">);</span>
        <span class="n">sub128</span><span class="p">(</span> <span class="n">rem1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="n">term2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem2</span> <span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">rem1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="o">--</span><span class="n">zSig1</span><span class="p">;</span>
            <span class="n">add128</span><span class="p">(</span> <span class="n">rem1</span><span class="p">,</span> <span class="n">rem2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem2</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">zSig1</span> <span class="o">|=</span> <span class="p">(</span> <span class="p">(</span> <span class="n">rem1</span> <span class="o">|</span> <span class="n">rem2</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span>
        <span class="n">roundAndPackFloatx80</span><span class="p">(</span>
            <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the remainder of the extended double-precision floating-point value</span>
<span class="cm">`a&#39; with respect to the corresponding value `b&#39;.  The operation is performed</span>
<span class="cm">according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">floatx80</span> <span class="nf">floatx80_rem</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">a</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">,</span> <span class="n">zSign</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">bExp</span><span class="p">,</span> <span class="n">expDiff</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span><span class="p">,</span> <span class="n">bSig</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">q</span><span class="p">,</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="n">alternateASig0</span><span class="p">,</span> <span class="n">alternateASig1</span><span class="p">;</span>
    <span class="n">floatx80</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">aSig0</span> <span class="o">=</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSig</span> <span class="o">=</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">aSig0</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span>
             <span class="o">||</span> <span class="p">(</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">bSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">propagateFloatx80NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">bSig</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloatx80NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
 <span class="nl">invalid:</span>
            <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
            <span class="n">z</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">floatx80_default_nan_low</span><span class="p">;</span>
            <span class="n">z</span><span class="p">.</span><span class="n">high</span> <span class="o">=</span> <span class="n">floatx80_default_nan_high</span><span class="p">;</span>
            <span class="n">z</span><span class="p">.</span><span class="n">__padding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">normalizeFloatx80Subnormal</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bSig</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">aSig0</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">normalizeFloatx80Subnormal</span><span class="p">(</span> <span class="n">aSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">bSig</span> <span class="o">|=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0x8000000000000000</span> <span class="p">);</span>
    <span class="n">zSign</span> <span class="o">=</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">expDiff</span> <span class="o">=</span> <span class="n">aExp</span> <span class="o">-</span> <span class="n">bExp</span><span class="p">;</span>
    <span class="n">aSig1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">expDiff</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">expDiff</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">shift128Right</span><span class="p">(</span> <span class="n">aSig0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig1</span> <span class="p">);</span>
        <span class="n">expDiff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">q</span> <span class="o">=</span> <span class="p">(</span> <span class="n">bSig</span> <span class="o">&lt;=</span> <span class="n">aSig0</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">q</span> <span class="p">)</span> <span class="n">aSig0</span> <span class="o">-=</span> <span class="n">bSig</span><span class="p">;</span>
    <span class="n">expDiff</span> <span class="o">-=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">expDiff</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">estimateDiv128To64</span><span class="p">(</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span><span class="p">,</span> <span class="n">bSig</span> <span class="p">);</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">q</span> <span class="p">)</span> <span class="o">?</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">mul64To128</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term1</span> <span class="p">);</span>
        <span class="n">sub128</span><span class="p">(</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span><span class="p">,</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig1</span> <span class="p">);</span>
        <span class="n">shortShift128Left</span><span class="p">(</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig1</span> <span class="p">);</span>
        <span class="n">expDiff</span> <span class="o">-=</span> <span class="mi">62</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">expDiff</span> <span class="o">+=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">expDiff</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">estimateDiv128To64</span><span class="p">(</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span><span class="p">,</span> <span class="n">bSig</span> <span class="p">);</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">q</span> <span class="p">)</span> <span class="o">?</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">q</span> <span class="o">&gt;&gt;=</span> <span class="mi">64</span> <span class="o">-</span> <span class="n">expDiff</span><span class="p">;</span>
        <span class="n">mul64To128</span><span class="p">(</span> <span class="n">bSig</span><span class="p">,</span> <span class="n">q</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="mi">64</span> <span class="o">-</span> <span class="n">expDiff</span> <span class="p">),</span> <span class="o">&amp;</span><span class="n">term0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term1</span> <span class="p">);</span>
        <span class="n">sub128</span><span class="p">(</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span><span class="p">,</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig1</span> <span class="p">);</span>
        <span class="n">shortShift128Left</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bSig</span><span class="p">,</span> <span class="mi">64</span> <span class="o">-</span> <span class="n">expDiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term1</span> <span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span> <span class="n">le128</span><span class="p">(</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">q</span><span class="p">;</span>
            <span class="n">sub128</span><span class="p">(</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span><span class="p">,</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig1</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">term1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">term0</span> <span class="o">=</span> <span class="n">bSig</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sub128</span><span class="p">(</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alternateASig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alternateASig1</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span>    <span class="n">lt128</span><span class="p">(</span> <span class="n">alternateASig0</span><span class="p">,</span> <span class="n">alternateASig1</span><span class="p">,</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span>    <span class="n">eq128</span><span class="p">(</span> <span class="n">alternateASig0</span><span class="p">,</span> <span class="n">alternateASig1</span><span class="p">,</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span> <span class="p">)</span>
              <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">q</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="n">aSig0</span> <span class="o">=</span> <span class="n">alternateASig0</span><span class="p">;</span>
        <span class="n">aSig1</span> <span class="o">=</span> <span class="n">alternateASig1</span><span class="p">;</span>
        <span class="n">zSign</span> <span class="o">=</span> <span class="o">!</span> <span class="n">zSign</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span>
        <span class="n">normalizeRoundAndPackFloatx80</span><span class="p">(</span>
            <span class="n">roundData</span><span class="p">,</span> <span class="n">zSign</span><span class="p">,</span> <span class="n">bExp</span> <span class="o">+</span> <span class="n">expDiff</span><span class="p">,</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns the square root of the extended double-precision floating-point</span>
<span class="cm">value `a&#39;.  The operation is performed according to the IEC/IEEE Standard</span>
<span class="cm">for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">floatx80</span> <span class="nf">floatx80_sqrt</span><span class="p">(</span> <span class="k">struct</span> <span class="n">roundingData</span> <span class="o">*</span><span class="n">roundData</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">;</span>
    <span class="n">int32</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">zExp</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">rem0</span><span class="p">,</span> <span class="n">rem1</span><span class="p">,</span> <span class="n">rem2</span><span class="p">,</span> <span class="n">rem3</span><span class="p">,</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="n">term2</span><span class="p">,</span> <span class="n">term3</span><span class="p">;</span>
    <span class="n">bits64</span> <span class="n">shiftedRem0</span><span class="p">,</span> <span class="n">shiftedRem1</span><span class="p">;</span>
    <span class="n">floatx80</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">aSig0</span> <span class="o">=</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aExp</span> <span class="o">=</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">aSig0</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="k">return</span> <span class="n">propagateFloatx80NaN</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">aSign</span> <span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">|</span> <span class="n">aSig0</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
 <span class="nl">invalid:</span>
        <span class="n">roundData</span><span class="o">-&gt;</span><span class="n">exception</span> <span class="o">|=</span> <span class="n">float_flag_invalid</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">floatx80_default_nan_low</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">high</span> <span class="o">=</span> <span class="n">floatx80_default_nan_high</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">__padding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aSig0</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">packFloatx80</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">normalizeFloatx80Subnormal</span><span class="p">(</span> <span class="n">aSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aExp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">zExp</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">-</span> <span class="mh">0x3FFF</span> <span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">+</span> <span class="mh">0x3FFF</span><span class="p">;</span>
    <span class="n">zSig0</span> <span class="o">=</span> <span class="n">estimateSqrt32</span><span class="p">(</span> <span class="n">aExp</span><span class="p">,</span> <span class="n">aSig0</span><span class="o">&gt;&gt;</span><span class="mi">32</span> <span class="p">);</span>
    <span class="n">zSig0</span> <span class="o">&lt;&lt;=</span> <span class="mi">31</span><span class="p">;</span>
    <span class="n">aSig1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">shift128Right</span><span class="p">(</span> <span class="n">aSig0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span> <span class="n">aExp</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig1</span> <span class="p">);</span>
    <span class="n">zSig0</span> <span class="o">=</span> <span class="n">estimateDiv128To64</span><span class="p">(</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span><span class="p">,</span> <span class="n">zSig0</span> <span class="p">)</span> <span class="o">+</span> <span class="n">zSig0</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">zSig0</span> <span class="p">)</span> <span class="n">zSig0</span> <span class="o">=</span> <span class="n">LIT64</span><span class="p">(</span> <span class="mh">0xFFFFFFFFFFFFFFFF</span> <span class="p">);</span>
    <span class="n">shortShift128Left</span><span class="p">(</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aSig1</span> <span class="p">);</span>
    <span class="n">mul64To128</span><span class="p">(</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term1</span> <span class="p">);</span>
    <span class="n">sub128</span><span class="p">(</span> <span class="n">aSig0</span><span class="p">,</span> <span class="n">aSig1</span><span class="p">,</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem1</span> <span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">rem0</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">zSig0</span><span class="p">;</span>
        <span class="n">shortShift128Left</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term1</span> <span class="p">);</span>
        <span class="n">term1</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">add128</span><span class="p">(</span> <span class="n">rem0</span><span class="p">,</span> <span class="n">rem1</span><span class="p">,</span> <span class="n">term0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem1</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">shortShift128Left</span><span class="p">(</span> <span class="n">rem0</span><span class="p">,</span> <span class="n">rem1</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shiftedRem0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shiftedRem1</span> <span class="p">);</span>
    <span class="n">zSig1</span> <span class="o">=</span> <span class="n">estimateDiv128To64</span><span class="p">(</span> <span class="n">shiftedRem0</span><span class="p">,</span> <span class="n">shiftedRem1</span><span class="p">,</span> <span class="n">zSig0</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">zSig1</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">zSig1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">zSig1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">mul64To128</span><span class="p">(</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term2</span> <span class="p">);</span>
        <span class="n">shortShift128Left</span><span class="p">(</span> <span class="n">term1</span><span class="p">,</span> <span class="n">term2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term2</span> <span class="p">);</span>
        <span class="n">sub128</span><span class="p">(</span> <span class="n">rem1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="n">term2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem2</span> <span class="p">);</span>
        <span class="n">mul64To128</span><span class="p">(</span> <span class="n">zSig1</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term3</span> <span class="p">);</span>
        <span class="n">sub192</span><span class="p">(</span> <span class="n">rem1</span><span class="p">,</span> <span class="n">rem2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">term2</span><span class="p">,</span> <span class="n">term3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem3</span> <span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">sbits64</span><span class="p">)</span> <span class="n">rem1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="o">--</span><span class="n">zSig1</span><span class="p">;</span>
            <span class="n">shortShift192Left</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term3</span> <span class="p">);</span>
            <span class="n">term3</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">add192</span><span class="p">(</span>
                <span class="n">rem1</span><span class="p">,</span> <span class="n">rem2</span><span class="p">,</span> <span class="n">rem3</span><span class="p">,</span> <span class="n">term1</span><span class="p">,</span> <span class="n">term2</span><span class="p">,</span> <span class="n">term3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem3</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">zSig1</span> <span class="o">|=</span> <span class="p">(</span> <span class="p">(</span> <span class="n">rem1</span> <span class="o">|</span> <span class="n">rem2</span> <span class="o">|</span> <span class="n">rem3</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span>
        <span class="n">roundAndPackFloatx80</span><span class="p">(</span>
            <span class="n">roundData</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">zExp</span><span class="p">,</span> <span class="n">zSig0</span><span class="p">,</span> <span class="n">zSig1</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the extended double-precision floating-point value `a&#39; is</span>
<span class="cm">equal to the corresponding value `b&#39;, and 0 otherwise.  The comparison is</span>
<span class="cm">performed according to the IEC/IEEE Standard for Binary Floating-point</span>
<span class="cm">Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">floatx80_eq</span><span class="p">(</span> <span class="n">floatx80</span> <span class="n">a</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span>    <span class="p">(</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span>
              <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span>    <span class="p">(</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span>
              <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span>    <span class="n">floatx80_is_signaling_nan</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span>
             <span class="o">||</span> <span class="n">floatx80_is_signaling_nan</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span>
           <span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">low</span> <span class="p">)</span>
        <span class="o">&amp;&amp;</span> <span class="p">(</span>    <span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span> <span class="p">)</span>
             <span class="o">||</span> <span class="p">(</span>    <span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
                  <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits16</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span> <span class="o">|</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">)</span>
           <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the extended double-precision floating-point value `a&#39; is</span>
<span class="cm">less than or equal to the corresponding value `b&#39;, and 0 otherwise.  The</span>
<span class="cm">comparison is performed according to the IEC/IEEE Standard for Binary</span>
<span class="cm">Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">floatx80_le</span><span class="p">(</span> <span class="n">floatx80</span> <span class="n">a</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span>    <span class="p">(</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span>
              <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span>    <span class="p">(</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span>
              <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">!=</span> <span class="n">bSign</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span>
               <span class="n">aSign</span>
            <span class="o">||</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits16</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span> <span class="o">|</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="o">|</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span> <span class="o">|</span> <span class="n">b</span><span class="p">.</span><span class="n">low</span> <span class="p">)</span>
                 <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span>
          <span class="n">aSign</span> <span class="o">?</span> <span class="n">le128</span><span class="p">(</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">low</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">le128</span><span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">low</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the extended double-precision floating-point value `a&#39; is</span>
<span class="cm">less than the corresponding value `b&#39;, and 0 otherwise.  The comparison</span>
<span class="cm">is performed according to the IEC/IEEE Standard for Binary Floating-point</span>
<span class="cm">Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">floatx80_lt</span><span class="p">(</span> <span class="n">floatx80</span> <span class="n">a</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span>    <span class="p">(</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span>
              <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span>    <span class="p">(</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span>
              <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">!=</span> <span class="n">bSign</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span>
               <span class="n">aSign</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits16</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span> <span class="o">|</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="o">|</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span> <span class="o">|</span> <span class="n">b</span><span class="p">.</span><span class="n">low</span> <span class="p">)</span>
                 <span class="o">!=</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span>
          <span class="n">aSign</span> <span class="o">?</span> <span class="n">lt128</span><span class="p">(</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">low</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">lt128</span><span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">low</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the extended double-precision floating-point value `a&#39; is equal</span>
<span class="cm">to the corresponding value `b&#39;, and 0 otherwise.  The invalid exception is</span>
<span class="cm">raised if either operand is a NaN.  Otherwise, the comparison is performed</span>
<span class="cm">according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">floatx80_eq_signaling</span><span class="p">(</span> <span class="n">floatx80</span> <span class="n">a</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span>    <span class="p">(</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span>
              <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span>    <span class="p">(</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span>
              <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="n">float_raise</span><span class="p">(</span> <span class="n">float_flag_invalid</span> <span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span>
           <span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">low</span> <span class="p">)</span>
        <span class="o">&amp;&amp;</span> <span class="p">(</span>    <span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span> <span class="p">)</span>
             <span class="o">||</span> <span class="p">(</span>    <span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
                  <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits16</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span> <span class="o">|</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">)</span>
           <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the extended double-precision floating-point value `a&#39; is less</span>
<span class="cm">than or equal to the corresponding value `b&#39;, and 0 otherwise.  Quiet NaNs</span>
<span class="cm">do not cause an exception.  Otherwise, the comparison is performed according</span>
<span class="cm">to the IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">floatx80_le_quiet</span><span class="p">(</span> <span class="n">floatx80</span> <span class="n">a</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span>    <span class="p">(</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span>
              <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span>    <span class="p">(</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span>
              <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Do nothing, even if NaN as we&#39;re quiet */</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">!=</span> <span class="n">bSign</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span>
               <span class="n">aSign</span>
            <span class="o">||</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits16</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span> <span class="o">|</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="o">|</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span> <span class="o">|</span> <span class="n">b</span><span class="p">.</span><span class="n">low</span> <span class="p">)</span>
                 <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span>
          <span class="n">aSign</span> <span class="o">?</span> <span class="n">le128</span><span class="p">(</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">low</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">le128</span><span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">low</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">Returns 1 if the extended double-precision floating-point value `a&#39; is less</span>
<span class="cm">than the corresponding value `b&#39;, and 0 otherwise.  Quiet NaNs do not cause</span>
<span class="cm">an exception.  Otherwise, the comparison is performed according to the</span>
<span class="cm">IEC/IEEE Standard for Binary Floating-point Arithmetic.</span>
<span class="cm">-------------------------------------------------------------------------------</span>
<span class="cm">*/</span>
<span class="n">flag</span> <span class="nf">floatx80_lt_quiet</span><span class="p">(</span> <span class="n">floatx80</span> <span class="n">a</span><span class="p">,</span> <span class="n">floatx80</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">flag</span> <span class="n">aSign</span><span class="p">,</span> <span class="n">bSign</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span>    <span class="p">(</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span>
              <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
         <span class="o">||</span> <span class="p">(</span>    <span class="p">(</span> <span class="n">extractFloatx80Exp</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="o">==</span> <span class="mh">0x7FFF</span> <span class="p">)</span>
              <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bits64</span><span class="p">)</span> <span class="p">(</span> <span class="n">extractFloatx80Frac</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Do nothing, even if NaN as we&#39;re quiet */</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">aSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
    <span class="n">bSign</span> <span class="o">=</span> <span class="n">extractFloatx80Sign</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">aSign</span> <span class="o">!=</span> <span class="n">bSign</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span>
               <span class="n">aSign</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span>    <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">bits16</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span> <span class="o">|</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="o">|</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span> <span class="o">|</span> <span class="n">b</span><span class="p">.</span><span class="n">low</span> <span class="p">)</span>
                 <span class="o">!=</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span>
          <span class="n">aSign</span> <span class="o">?</span> <span class="n">lt128</span><span class="p">(</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">low</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">lt128</span><span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">low</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">high</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">low</span> <span class="p">);</span>

<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
