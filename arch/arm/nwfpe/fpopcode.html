<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › nwfpe › fpopcode.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fpopcode.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">    NetWinder Floating Point Emulator</span>
<span class="cm">    (c) Rebel.COM, 1998,1999</span>
<span class="cm">    (c) Philip Blundell, 2001</span>

<span class="cm">    Direct questions, comments to Scott Bambrough &lt;scottb@netwinder.org&gt;</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm">*/</span>

<span class="cp">#ifndef __FPOPCODE_H__</span>
<span class="cp">#define __FPOPCODE_H__</span>


<span class="cm">/*</span>
<span class="cm">ARM Floating Point Instruction Classes</span>
<span class="cm">| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | </span>
<span class="cm">|c o n d|1 1 0 P|U|u|W|L|   Rn  |v|  Fd |0|0|0|1|  o f f s e t  | CPDT</span>
<span class="cm">|c o n d|1 1 0 P|U|w|W|L|   Rn  |x|  Fd |0|0|1|0|  o f f s e t  | CPDT (copro 2)</span>
<span class="cm">| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | </span>
<span class="cm">|c o n d|1 1 1 0|a|b|c|d|e|  Fn |j|  Fd |0|0|0|1|f|g|h|0|i|  Fm | CPDO</span>
<span class="cm">|c o n d|1 1 1 0|a|b|c|L|e|  Fn |   Rd  |0|0|0|1|f|g|h|1|i|  Fm | CPRT</span>
<span class="cm">|c o n d|1 1 1 0|a|b|c|1|e|  Fn |1|1|1|1|0|0|0|1|f|g|h|1|i|  Fm | comparisons</span>
<span class="cm">| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | </span>

<span class="cm">CPDT		data transfer instructions</span>
<span class="cm">		LDF, STF, LFM (copro 2), SFM (copro 2)</span>
<span class="cm">		</span>
<span class="cm">CPDO		dyadic arithmetic instructions</span>
<span class="cm">		ADF, MUF, SUF, RSF, DVF, RDF,</span>
<span class="cm">		POW, RPW, RMF, FML, FDV, FRD, POL</span>

<span class="cm">CPDO		monadic arithmetic instructions</span>
<span class="cm">		MVF, MNF, ABS, RND, SQT, LOG, LGN, EXP,</span>
<span class="cm">		SIN, COS, TAN, ASN, ACS, ATN, URD, NRM</span>
<span class="cm">		</span>
<span class="cm">CPRT		joint arithmetic/data transfer instructions</span>
<span class="cm">		FIX (arithmetic followed by load/store)</span>
<span class="cm">		FLT (load/store followed by arithmetic)</span>
<span class="cm">		CMF, CNF CMFE, CNFE (comparisons)</span>
<span class="cm">		WFS, RFS (write/read floating point status register)</span>
<span class="cm">		WFC, RFC (write/read floating point control register)</span>

<span class="cm">cond		condition codes</span>
<span class="cm">P		pre/post index bit: 0 = postindex, 1 = preindex</span>
<span class="cm">U		up/down bit: 0 = stack grows down, 1 = stack grows up</span>
<span class="cm">W		write back bit: 1 = update base register (Rn)</span>
<span class="cm">L		load/store bit: 0 = store, 1 = load</span>
<span class="cm">Rn		base register</span>
<span class="cm">Rd		destination/source register		</span>
<span class="cm">Fd		floating point destination register</span>
<span class="cm">Fn		floating point source register</span>
<span class="cm">Fm		floating point source register or floating point constant</span>

<span class="cm">uv		transfer length (TABLE 1)</span>
<span class="cm">wx		register count (TABLE 2)</span>
<span class="cm">abcd		arithmetic opcode (TABLES 3 &amp; 4)</span>
<span class="cm">ef		destination size (rounding precision) (TABLE 5)</span>
<span class="cm">gh		rounding mode (TABLE 6)</span>
<span class="cm">j		dyadic/monadic bit: 0 = dyadic, 1 = monadic</span>
<span class="cm">i 		constant bit: 1 = constant (TABLE 6)</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">TABLE 1</span>
<span class="cm">+-------------------------+---+---+---------+---------+</span>
<span class="cm">|  Precision              | u | v | FPSR.EP | length  |</span>
<span class="cm">+-------------------------+---+---+---------+---------+</span>
<span class="cm">| Single                  | 0 | 0 |    x    | 1 words |</span>
<span class="cm">| Double                  | 1 | 1 |    x    | 2 words |</span>
<span class="cm">| Extended                | 1 | 1 |    x    | 3 words |</span>
<span class="cm">| Packed decimal          | 1 | 1 |    0    | 3 words |</span>
<span class="cm">| Expanded packed decimal | 1 | 1 |    1    | 4 words |</span>
<span class="cm">+-------------------------+---+---+---------+---------+</span>
<span class="cm">Note: x = don&#39;t care</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">TABLE 2</span>
<span class="cm">+---+---+---------------------------------+</span>
<span class="cm">| w | x | Number of registers to transfer |</span>
<span class="cm">+---+---+---------------------------------+</span>
<span class="cm">| 0 | 1 |  1                              |</span>
<span class="cm">| 1 | 0 |  2                              |</span>
<span class="cm">| 1 | 1 |  3                              |</span>
<span class="cm">| 0 | 0 |  4                              |</span>
<span class="cm">+---+---+---------------------------------+</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">TABLE 3: Dyadic Floating Point Opcodes</span>
<span class="cm">+---+---+---+---+----------+-----------------------+-----------------------+</span>
<span class="cm">| a | b | c | d | Mnemonic | Description           | Operation             |</span>
<span class="cm">+---+---+---+---+----------+-----------------------+-----------------------+</span>
<span class="cm">| 0 | 0 | 0 | 0 | ADF      | Add                   | Fd := Fn + Fm         |</span>
<span class="cm">| 0 | 0 | 0 | 1 | MUF      | Multiply              | Fd := Fn * Fm         |</span>
<span class="cm">| 0 | 0 | 1 | 0 | SUF      | Subtract              | Fd := Fn - Fm         |</span>
<span class="cm">| 0 | 0 | 1 | 1 | RSF      | Reverse subtract      | Fd := Fm - Fn         |</span>
<span class="cm">| 0 | 1 | 0 | 0 | DVF      | Divide                | Fd := Fn / Fm         |</span>
<span class="cm">| 0 | 1 | 0 | 1 | RDF      | Reverse divide        | Fd := Fm / Fn         |</span>
<span class="cm">| 0 | 1 | 1 | 0 | POW      | Power                 | Fd := Fn ^ Fm         |</span>
<span class="cm">| 0 | 1 | 1 | 1 | RPW      | Reverse power         | Fd := Fm ^ Fn         |</span>
<span class="cm">| 1 | 0 | 0 | 0 | RMF      | Remainder             | Fd := IEEE rem(Fn/Fm) |</span>
<span class="cm">| 1 | 0 | 0 | 1 | FML      | Fast Multiply         | Fd := Fn * Fm         |</span>
<span class="cm">| 1 | 0 | 1 | 0 | FDV      | Fast Divide           | Fd := Fn / Fm         |</span>
<span class="cm">| 1 | 0 | 1 | 1 | FRD      | Fast reverse divide   | Fd := Fm / Fn         |</span>
<span class="cm">| 1 | 1 | 0 | 0 | POL      | Polar angle (ArcTan2) | Fd := arctan2(Fn,Fm)  |</span>
<span class="cm">| 1 | 1 | 0 | 1 |          | undefined instruction | trap                  |</span>
<span class="cm">| 1 | 1 | 1 | 0 |          | undefined instruction | trap                  |</span>
<span class="cm">| 1 | 1 | 1 | 1 |          | undefined instruction | trap                  |</span>
<span class="cm">+---+---+---+---+----------+-----------------------+-----------------------+</span>
<span class="cm">Note: POW, RPW, POL are deprecated, and are available for backwards</span>
<span class="cm">      compatibility only.</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">TABLE 4: Monadic Floating Point Opcodes</span>
<span class="cm">+---+---+---+---+----------+-----------------------+-----------------------+</span>
<span class="cm">| a | b | c | d | Mnemonic | Description           | Operation             |</span>
<span class="cm">+---+---+---+---+----------+-----------------------+-----------------------+</span>
<span class="cm">| 0 | 0 | 0 | 0 | MVF      | Move                  | Fd := Fm              |</span>
<span class="cm">| 0 | 0 | 0 | 1 | MNF      | Move negated          | Fd := - Fm            |</span>
<span class="cm">| 0 | 0 | 1 | 0 | ABS      | Absolute value        | Fd := abs(Fm)         |</span>
<span class="cm">| 0 | 0 | 1 | 1 | RND      | Round to integer      | Fd := int(Fm)         |</span>
<span class="cm">| 0 | 1 | 0 | 0 | SQT      | Square root           | Fd := sqrt(Fm)        |</span>
<span class="cm">| 0 | 1 | 0 | 1 | LOG      | Log base 10           | Fd := log10(Fm)       |</span>
<span class="cm">| 0 | 1 | 1 | 0 | LGN      | Log base e            | Fd := ln(Fm)          |</span>
<span class="cm">| 0 | 1 | 1 | 1 | EXP      | Exponent              | Fd := e ^ Fm          |</span>
<span class="cm">| 1 | 0 | 0 | 0 | SIN      | Sine                  | Fd := sin(Fm)         |</span>
<span class="cm">| 1 | 0 | 0 | 1 | COS      | Cosine                | Fd := cos(Fm)         |</span>
<span class="cm">| 1 | 0 | 1 | 0 | TAN      | Tangent               | Fd := tan(Fm)         |</span>
<span class="cm">| 1 | 0 | 1 | 1 | ASN      | Arc Sine              | Fd := arcsin(Fm)      |</span>
<span class="cm">| 1 | 1 | 0 | 0 | ACS      | Arc Cosine            | Fd := arccos(Fm)      |</span>
<span class="cm">| 1 | 1 | 0 | 1 | ATN      | Arc Tangent           | Fd := arctan(Fm)      |</span>
<span class="cm">| 1 | 1 | 1 | 0 | URD      | Unnormalized round    | Fd := int(Fm)         |</span>
<span class="cm">| 1 | 1 | 1 | 1 | NRM      | Normalize             | Fd := norm(Fm)        |</span>
<span class="cm">+---+---+---+---+----------+-----------------------+-----------------------+</span>
<span class="cm">Note: LOG, LGN, EXP, SIN, COS, TAN, ASN, ACS, ATN are deprecated, and are</span>
<span class="cm">      available for backwards compatibility only.</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">TABLE 5</span>
<span class="cm">+-------------------------+---+---+</span>
<span class="cm">|  Rounding Precision     | e | f |</span>
<span class="cm">+-------------------------+---+---+</span>
<span class="cm">| IEEE Single precision   | 0 | 0 |</span>
<span class="cm">| IEEE Double precision   | 0 | 1 |</span>
<span class="cm">| IEEE Extended precision | 1 | 0 |</span>
<span class="cm">| undefined (trap)        | 1 | 1 |</span>
<span class="cm">+-------------------------+---+---+</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">TABLE 5</span>
<span class="cm">+---------------------------------+---+---+</span>
<span class="cm">|  Rounding Mode                  | g | h |</span>
<span class="cm">+---------------------------------+---+---+</span>
<span class="cm">| Round to nearest (default)      | 0 | 0 |</span>
<span class="cm">| Round toward plus infinity      | 0 | 1 |</span>
<span class="cm">| Round toward negative infinity  | 1 | 0 |</span>
<span class="cm">| Round toward zero               | 1 | 1 |</span>
<span class="cm">+---------------------------------+---+---+</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">===</span>
<span class="cm">=== Definitions for load and store instructions</span>
<span class="cm">===</span>
<span class="cm">*/</span>

<span class="cm">/* bit masks */</span>
<span class="cp">#define BIT_PREINDEX	0x01000000</span>
<span class="cp">#define BIT_UP		0x00800000</span>
<span class="cp">#define BIT_WRITE_BACK	0x00200000</span>
<span class="cp">#define BIT_LOAD	0x00100000</span>

<span class="cm">/* masks for load/store */</span>
<span class="cp">#define MASK_CPDT		0x0c000000	</span><span class="cm">/* data processing opcode */</span><span class="cp"></span>
<span class="cp">#define MASK_OFFSET		0x000000ff</span>
<span class="cp">#define MASK_TRANSFER_LENGTH	0x00408000</span>
<span class="cp">#define MASK_REGISTER_COUNT	MASK_TRANSFER_LENGTH</span>
<span class="cp">#define MASK_COPROCESSOR	0x00000f00</span>

<span class="cm">/* Tests for transfer length */</span>
<span class="cp">#define TRANSFER_SINGLE		0x00000000</span>
<span class="cp">#define TRANSFER_DOUBLE		0x00008000</span>
<span class="cp">#define TRANSFER_EXTENDED	0x00400000</span>
<span class="cp">#define TRANSFER_PACKED		MASK_TRANSFER_LENGTH</span>

<span class="cm">/* Get the coprocessor number from the opcode. */</span>
<span class="cp">#define getCoprocessorNumber(opcode)	((opcode &amp; MASK_COPROCESSOR) &gt;&gt; 8)</span>

<span class="cm">/* Get the offset from the opcode. */</span>
<span class="cp">#define getOffset(opcode)		(opcode &amp; MASK_OFFSET)</span>

<span class="cm">/* Tests for specific data transfer load/store opcodes. */</span>
<span class="cp">#define TEST_OPCODE(opcode,mask)	(((opcode) &amp; (mask)) == (mask))</span>

<span class="cp">#define LOAD_OP(opcode)   TEST_OPCODE((opcode),MASK_CPDT | BIT_LOAD)</span>
<span class="cp">#define STORE_OP(opcode)  ((opcode &amp; (MASK_CPDT | BIT_LOAD)) == MASK_CPDT)</span>

<span class="cp">#define LDF_OP(opcode)	(LOAD_OP(opcode) &amp;&amp; (getCoprocessorNumber(opcode) == 1))</span>
<span class="cp">#define LFM_OP(opcode)	(LOAD_OP(opcode) &amp;&amp; (getCoprocessorNumber(opcode) == 2))</span>
<span class="cp">#define STF_OP(opcode)	(STORE_OP(opcode) &amp;&amp; (getCoprocessorNumber(opcode) == 1))</span>
<span class="cp">#define SFM_OP(opcode)	(STORE_OP(opcode) &amp;&amp; (getCoprocessorNumber(opcode) == 2))</span>

<span class="cp">#define PREINDEXED(opcode)		((opcode &amp; BIT_PREINDEX) != 0)</span>
<span class="cp">#define POSTINDEXED(opcode)		((opcode &amp; BIT_PREINDEX) == 0)</span>
<span class="cp">#define BIT_UP_SET(opcode)		((opcode &amp; BIT_UP) != 0)</span>
<span class="cp">#define BIT_UP_CLEAR(opcode)		((opcode &amp; BIT_DOWN) == 0)</span>
<span class="cp">#define WRITE_BACK(opcode)		((opcode &amp; BIT_WRITE_BACK) != 0)</span>
<span class="cp">#define LOAD(opcode)			((opcode &amp; BIT_LOAD) != 0)</span>
<span class="cp">#define STORE(opcode)			((opcode &amp; BIT_LOAD) == 0)</span>

<span class="cm">/*</span>
<span class="cm">===</span>
<span class="cm">=== Definitions for arithmetic instructions</span>
<span class="cm">===</span>
<span class="cm">*/</span>
<span class="cm">/* bit masks */</span>
<span class="cp">#define BIT_MONADIC	0x00008000</span>
<span class="cp">#define BIT_CONSTANT	0x00000008</span>

<span class="cp">#define CONSTANT_FM(opcode)		((opcode &amp; BIT_CONSTANT) != 0)</span>
<span class="cp">#define MONADIC_INSTRUCTION(opcode)	((opcode &amp; BIT_MONADIC) != 0)</span>

<span class="cm">/* instruction identification masks */</span>
<span class="cp">#define MASK_CPDO		0x0e000000	</span><span class="cm">/* arithmetic opcode */</span><span class="cp"></span>
<span class="cp">#define MASK_ARITHMETIC_OPCODE	0x00f08000</span>
<span class="cp">#define MASK_DESTINATION_SIZE	0x00080080</span>

<span class="cm">/* dyadic arithmetic opcodes. */</span>
<span class="cp">#define ADF_CODE	0x00000000</span>
<span class="cp">#define MUF_CODE	0x00100000</span>
<span class="cp">#define SUF_CODE	0x00200000</span>
<span class="cp">#define RSF_CODE	0x00300000</span>
<span class="cp">#define DVF_CODE	0x00400000</span>
<span class="cp">#define RDF_CODE	0x00500000</span>
<span class="cp">#define POW_CODE	0x00600000</span>
<span class="cp">#define RPW_CODE	0x00700000</span>
<span class="cp">#define RMF_CODE	0x00800000</span>
<span class="cp">#define FML_CODE	0x00900000</span>
<span class="cp">#define FDV_CODE	0x00a00000</span>
<span class="cp">#define FRD_CODE	0x00b00000</span>
<span class="cp">#define POL_CODE	0x00c00000</span>
<span class="cm">/* 0x00d00000 is an invalid dyadic arithmetic opcode */</span>
<span class="cm">/* 0x00e00000 is an invalid dyadic arithmetic opcode */</span>
<span class="cm">/* 0x00f00000 is an invalid dyadic arithmetic opcode */</span>

<span class="cm">/* monadic arithmetic opcodes. */</span>
<span class="cp">#define MVF_CODE	0x00008000</span>
<span class="cp">#define MNF_CODE	0x00108000</span>
<span class="cp">#define ABS_CODE	0x00208000</span>
<span class="cp">#define RND_CODE	0x00308000</span>
<span class="cp">#define SQT_CODE	0x00408000</span>
<span class="cp">#define LOG_CODE	0x00508000</span>
<span class="cp">#define LGN_CODE	0x00608000</span>
<span class="cp">#define EXP_CODE	0x00708000</span>
<span class="cp">#define SIN_CODE	0x00808000</span>
<span class="cp">#define COS_CODE	0x00908000</span>
<span class="cp">#define TAN_CODE	0x00a08000</span>
<span class="cp">#define ASN_CODE	0x00b08000</span>
<span class="cp">#define ACS_CODE	0x00c08000</span>
<span class="cp">#define ATN_CODE	0x00d08000</span>
<span class="cp">#define URD_CODE	0x00e08000</span>
<span class="cp">#define NRM_CODE	0x00f08000</span>

<span class="cm">/*</span>
<span class="cm">===</span>
<span class="cm">=== Definitions for register transfer and comparison instructions</span>
<span class="cm">===</span>
<span class="cm">*/</span>

<span class="cp">#define MASK_CPRT		0x0e000010	</span><span class="cm">/* register transfer opcode */</span><span class="cp"></span>
<span class="cp">#define MASK_CPRT_CODE		0x00f00000</span>
<span class="cp">#define FLT_CODE		0x00000000</span>
<span class="cp">#define FIX_CODE		0x00100000</span>
<span class="cp">#define WFS_CODE		0x00200000</span>
<span class="cp">#define RFS_CODE		0x00300000</span>
<span class="cp">#define WFC_CODE		0x00400000</span>
<span class="cp">#define RFC_CODE		0x00500000</span>
<span class="cp">#define CMF_CODE		0x00900000</span>
<span class="cp">#define CNF_CODE		0x00b00000</span>
<span class="cp">#define CMFE_CODE		0x00d00000</span>
<span class="cp">#define CNFE_CODE		0x00f00000</span>

<span class="cm">/*</span>
<span class="cm">===</span>
<span class="cm">=== Common definitions</span>
<span class="cm">===</span>
<span class="cm">*/</span>

<span class="cm">/* register masks */</span>
<span class="cp">#define MASK_Rd		0x0000f000</span>
<span class="cp">#define MASK_Rn		0x000f0000</span>
<span class="cp">#define MASK_Fd		0x00007000</span>
<span class="cp">#define MASK_Fm		0x00000007</span>
<span class="cp">#define MASK_Fn		0x00070000</span>

<span class="cm">/* condition code masks */</span>
<span class="cp">#define CC_MASK		0xf0000000</span>
<span class="cp">#define CC_NEGATIVE	0x80000000</span>
<span class="cp">#define CC_ZERO		0x40000000</span>
<span class="cp">#define CC_CARRY	0x20000000</span>
<span class="cp">#define CC_OVERFLOW	0x10000000</span>
<span class="cp">#define CC_EQ		0x00000000</span>
<span class="cp">#define CC_NE		0x10000000</span>
<span class="cp">#define CC_CS		0x20000000</span>
<span class="cp">#define CC_HS		CC_CS</span>
<span class="cp">#define CC_CC		0x30000000</span>
<span class="cp">#define CC_LO		CC_CC</span>
<span class="cp">#define CC_MI		0x40000000</span>
<span class="cp">#define CC_PL		0x50000000</span>
<span class="cp">#define CC_VS		0x60000000</span>
<span class="cp">#define CC_VC		0x70000000</span>
<span class="cp">#define CC_HI		0x80000000</span>
<span class="cp">#define CC_LS		0x90000000</span>
<span class="cp">#define CC_GE		0xa0000000</span>
<span class="cp">#define CC_LT		0xb0000000</span>
<span class="cp">#define CC_GT		0xc0000000</span>
<span class="cp">#define CC_LE		0xd0000000</span>
<span class="cp">#define CC_AL		0xe0000000</span>
<span class="cp">#define CC_NV		0xf0000000</span>

<span class="cm">/* rounding masks/values */</span>
<span class="cp">#define MASK_ROUNDING_MODE	0x00000060</span>
<span class="cp">#define ROUND_TO_NEAREST	0x00000000</span>
<span class="cp">#define ROUND_TO_PLUS_INFINITY	0x00000020</span>
<span class="cp">#define ROUND_TO_MINUS_INFINITY	0x00000040</span>
<span class="cp">#define ROUND_TO_ZERO		0x00000060</span>

<span class="cp">#define MASK_ROUNDING_PRECISION	0x00080080</span>
<span class="cp">#define ROUND_SINGLE		0x00000000</span>
<span class="cp">#define ROUND_DOUBLE		0x00000080</span>
<span class="cp">#define ROUND_EXTENDED		0x00080000</span>

<span class="cm">/* Get the condition code from the opcode. */</span>
<span class="cp">#define getCondition(opcode)		(opcode &gt;&gt; 28)</span>

<span class="cm">/* Get the source register from the opcode. */</span>
<span class="cp">#define getRn(opcode)			((opcode &amp; MASK_Rn) &gt;&gt; 16)</span>

<span class="cm">/* Get the destination floating point register from the opcode. */</span>
<span class="cp">#define getFd(opcode)			((opcode &amp; MASK_Fd) &gt;&gt; 12)</span>

<span class="cm">/* Get the first source floating point register from the opcode. */</span>
<span class="cp">#define getFn(opcode)		((opcode &amp; MASK_Fn) &gt;&gt; 16)</span>

<span class="cm">/* Get the second source floating point register from the opcode. */</span>
<span class="cp">#define getFm(opcode)		(opcode &amp; MASK_Fm)</span>

<span class="cm">/* Get the destination register from the opcode. */</span>
<span class="cp">#define getRd(opcode)		((opcode &amp; MASK_Rd) &gt;&gt; 12)</span>

<span class="cm">/* Get the rounding mode from the opcode. */</span>
<span class="cp">#define getRoundingMode(opcode)		((opcode &amp; MASK_ROUNDING_MODE) &gt;&gt; 5)</span>

<span class="cp">#ifdef CONFIG_FPE_NWFPE_XP</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">floatx80</span> <span class="n">__pure</span> <span class="nf">getExtendedConstant</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nIndex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="k">const</span> <span class="n">floatx80</span> <span class="n">floatx80Constant</span><span class="p">[];</span>
	<span class="k">return</span> <span class="n">floatx80Constant</span><span class="p">[</span><span class="n">nIndex</span><span class="p">];</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">float64</span> <span class="n">__pure</span> <span class="nf">getDoubleConstant</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nIndex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="k">const</span> <span class="n">float64</span> <span class="n">float64Constant</span><span class="p">[];</span>
	<span class="k">return</span> <span class="n">float64Constant</span><span class="p">[</span><span class="n">nIndex</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">float32</span> <span class="n">__pure</span> <span class="nf">getSingleConstant</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nIndex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="k">const</span> <span class="n">float32</span> <span class="n">float32Constant</span><span class="p">[];</span>
	<span class="k">return</span> <span class="n">float32Constant</span><span class="p">[</span><span class="n">nIndex</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">getTransferLength</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nRc</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">MASK_TRANSFER_LENGTH</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x00000000</span>:
		<span class="n">nRc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>		<span class="cm">/* single precision */</span>
	<span class="k">case</span> <span class="mh">0x00008000</span>:
		<span class="n">nRc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>		<span class="cm">/* double precision */</span>
	<span class="k">case</span> <span class="mh">0x00400000</span>:
		<span class="n">nRc</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>		<span class="cm">/* extended precision */</span>
	<span class="nl">default:</span>
		<span class="n">nRc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">nRc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">getRegisterCount</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nRc</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">MASK_REGISTER_COUNT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x00000000</span>:
		<span class="n">nRc</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x00008000</span>:
		<span class="n">nRc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x00400000</span>:
		<span class="n">nRc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x00408000</span>:
		<span class="n">nRc</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">nRc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">nRc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">getRoundingPrecision</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nRc</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">MASK_ROUNDING_PRECISION</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x00000000</span>:
		<span class="n">nRc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x00000080</span>:
		<span class="n">nRc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x00080000</span>:
		<span class="n">nRc</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">nRc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">nRc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">getDestinationSize</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nRc</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">MASK_DESTINATION_SIZE</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x00000000</span>:
		<span class="n">nRc</span> <span class="o">=</span> <span class="n">typeSingle</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x00000080</span>:
		<span class="n">nRc</span> <span class="o">=</span> <span class="n">typeDouble</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x00080000</span>:
		<span class="n">nRc</span> <span class="o">=</span> <span class="n">typeExtended</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">nRc</span> <span class="o">=</span> <span class="n">typeNone</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">nRc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">const</span> <span class="n">float64</span> <span class="n">float64Constant</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="n">float32</span> <span class="n">float32Constant</span><span class="p">[];</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
