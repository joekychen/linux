<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › arm › mach-at91 › gpio.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>gpio.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/arch/arm/mach-at91/gpio.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005 HP Labs</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/gpio.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/irqdomain.h&gt;</span>
<span class="cp">#include &lt;linux/of_address.h&gt;</span>
<span class="cp">#include &lt;linux/of_irq.h&gt;</span>
<span class="cp">#include &lt;linux/of_gpio.h&gt;</span>

<span class="cp">#include &lt;mach/hardware.h&gt;</span>
<span class="cp">#include &lt;mach/at91_pio.h&gt;</span>

<span class="cp">#include &quot;generic.h&quot;</span>

<span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span>	<span class="o">*</span><span class="n">next</span><span class="p">;</span>		<span class="cm">/* Bank sharing same clock */</span>
	<span class="kt">int</span>			<span class="n">pioc_hwirq</span><span class="p">;</span>	<span class="cm">/* PIO bank interrupt identifier on AIC */</span>
	<span class="kt">int</span>			<span class="n">pioc_virq</span><span class="p">;</span>	<span class="cm">/* PIO bank Linux virtual interrupt */</span>
	<span class="kt">int</span>			<span class="n">pioc_idx</span><span class="p">;</span>	<span class="cm">/* PIO bank index */</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">regbase</span><span class="p">;</span>	<span class="cm">/* PIO bank virtual address */</span>
	<span class="k">struct</span> <span class="n">clk</span>		<span class="o">*</span><span class="n">clock</span><span class="p">;</span>		<span class="cm">/* associated clock */</span>
	<span class="k">struct</span> <span class="n">irq_domain</span>	<span class="o">*</span><span class="n">domain</span><span class="p">;</span>	<span class="cm">/* associated irq domain */</span>
<span class="p">};</span>

<span class="cp">#define to_at91_gpio_chip(c) container_of(c, struct at91_gpio_chip, chip)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">at91_gpiolib_dbg_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">at91_gpiolib_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">at91_gpiolib_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">at91_gpiolib_direction_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">at91_gpiolib_direction_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="n">offset</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">at91_gpiolib_to_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">);</span>

<span class="cp">#define AT91_GPIO_CHIP(name, nr_gpio)					\</span>
<span class="cp">	{								\</span>
<span class="cp">		.chip = {						\</span>
<span class="cp">			.label		  = name,			\</span>
<span class="cp">			.direction_input  = at91_gpiolib_direction_input, \</span>
<span class="cp">			.direction_output = at91_gpiolib_direction_output, \</span>
<span class="cp">			.get		  = at91_gpiolib_get,		\</span>
<span class="cp">			.set		  = at91_gpiolib_set,		\</span>
<span class="cp">			.dbg_show	  = at91_gpiolib_dbg_show,	\</span>
<span class="cp">			.to_irq		  = at91_gpiolib_to_irq,	\</span>
<span class="cp">			.ngpio		  = nr_gpio,			\</span>
<span class="cp">		},							\</span>
<span class="cp">	}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="n">gpio_chip</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">AT91_GPIO_CHIP</span><span class="p">(</span><span class="s">&quot;pioA&quot;</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>
	<span class="n">AT91_GPIO_CHIP</span><span class="p">(</span><span class="s">&quot;pioB&quot;</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>
	<span class="n">AT91_GPIO_CHIP</span><span class="p">(</span><span class="s">&quot;pioC&quot;</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>
	<span class="n">AT91_GPIO_CHIP</span><span class="p">(</span><span class="s">&quot;pioD&quot;</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>
	<span class="n">AT91_GPIO_CHIP</span><span class="p">(</span><span class="s">&quot;pioE&quot;</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">gpio_banks</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">at91_gpio_caps</span><span class="p">;</span>

<span class="cm">/* All PIO controllers support PIO3 features */</span>
<span class="cp">#define AT91_GPIO_CAP_PIO3	(1 &lt;&lt;  0)</span>

<span class="cp">#define has_pio3()	(at91_gpio_caps &amp; AT91_GPIO_CAP_PIO3)</span>

<span class="cm">/*--------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">pin_to_controller</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pin</span> <span class="o">/=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pin</span> <span class="o">&lt;</span> <span class="n">gpio_banks</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">gpio_chip</span><span class="p">[</span><span class="n">pin</span><span class="p">].</span><span class="n">regbase</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">pin_to_mask</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">pin</span> <span class="o">%</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">char</span> <span class="nf">peripheral_function</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span>	<span class="n">ret</span> <span class="o">=</span> <span class="sc">&#39;X&#39;</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">select</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pio</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">has_pio3</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">select</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>
			<span class="n">select</span> <span class="o">|=</span> <span class="p">(</span><span class="o">!!</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="n">select</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">?</span>
							<span class="sc">&#39;B&#39;</span> <span class="o">:</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*--------------------------------------------------------------------------*/</span>

<span class="cm">/* Not all hardware capabilities are exposed through these calls; they</span>
<span class="cm"> * only encapsulate the most common features and modes.  (So if you</span>
<span class="cm"> * want to change signals in groups, do it directly.)</span>
<span class="cm"> *</span>
<span class="cm"> * Bootloaders will usually handle some of the pin multiplexing setup.</span>
<span class="cm"> * The intent is certainly that by the time Linux is fully booted, all</span>
<span class="cm"> * pins should have been fully initialized.  These setup calls should</span>
<span class="cm"> * only be used by board setup routines, or possibly in driver probe().</span>
<span class="cm"> *</span>
<span class="cm"> * For bootloaders doing all that setup, these calls could be inlined</span>
<span class="cm"> * as NOPs so Linux won&#39;t duplicate any setup code</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * mux the pin to the &quot;GPIO&quot; peripheral role.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">at91_set_GPIO_periph</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_pullup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IDR</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="p">(</span><span class="n">use_pullup</span> <span class="o">?</span> <span class="n">PIO_PUER</span> <span class="o">:</span> <span class="n">PIO_PUDR</span><span class="p">));</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_PER</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">at91_set_GPIO_periph</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * mux the pin to the &quot;A&quot; internal peripheral role.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">at91_set_A_periph</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_pullup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IDR</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="p">(</span><span class="n">use_pullup</span> <span class="o">?</span> <span class="n">PIO_PUER</span> <span class="o">:</span> <span class="n">PIO_PUDR</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_pio3</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">,</span>
							<span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR1</span><span class="p">);</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">,</span>
							<span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR2</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ASR</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_PDR</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">at91_set_A_periph</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * mux the pin to the &quot;B&quot; internal peripheral role.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">at91_set_B_periph</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_pullup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IDR</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="p">(</span><span class="n">use_pullup</span> <span class="o">?</span> <span class="n">PIO_PUER</span> <span class="o">:</span> <span class="n">PIO_PUDR</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_pio3</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR1</span><span class="p">)</span> <span class="o">|</span> <span class="n">mask</span><span class="p">,</span>
							<span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR1</span><span class="p">);</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">,</span>
							<span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR2</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_BSR</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_PDR</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">at91_set_B_periph</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * mux the pin to the &quot;C&quot; internal peripheral role.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">at91_set_C_periph</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_pullup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio</span> <span class="o">||</span> <span class="o">!</span><span class="n">has_pio3</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IDR</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="p">(</span><span class="n">use_pullup</span> <span class="o">?</span> <span class="n">PIO_PUER</span> <span class="o">:</span> <span class="n">PIO_PUDR</span><span class="p">));</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR1</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR2</span><span class="p">)</span> <span class="o">|</span> <span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR2</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_PDR</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">at91_set_C_periph</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * mux the pin to the &quot;D&quot; internal peripheral role.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">at91_set_D_periph</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_pullup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio</span> <span class="o">||</span> <span class="o">!</span><span class="n">has_pio3</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IDR</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="p">(</span><span class="n">use_pullup</span> <span class="o">?</span> <span class="n">PIO_PUER</span> <span class="o">:</span> <span class="n">PIO_PUDR</span><span class="p">));</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR1</span><span class="p">)</span> <span class="o">|</span> <span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR1</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR2</span><span class="p">)</span> <span class="o">|</span> <span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ABCDSR2</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_PDR</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">at91_set_D_periph</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * mux the pin to the gpio controller (instead of &quot;A&quot;, &quot;B&quot;, &quot;C&quot;</span>
<span class="cm"> * or &quot;D&quot; peripheral), and configure it for an input.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">at91_set_gpio_input</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_pullup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IDR</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="p">(</span><span class="n">use_pullup</span> <span class="o">?</span> <span class="n">PIO_PUER</span> <span class="o">:</span> <span class="n">PIO_PUDR</span><span class="p">));</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ODR</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_PER</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">at91_set_gpio_input</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * mux the pin to the gpio controller (instead of &quot;A&quot;, &quot;B&quot;, &quot;C&quot;</span>
<span class="cm"> * or &quot;D&quot; peripheral), and configure it for an output.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">at91_set_gpio_output</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IDR</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_PUDR</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="p">(</span><span class="n">value</span> <span class="o">?</span> <span class="n">PIO_SODR</span> <span class="o">:</span> <span class="n">PIO_CODR</span><span class="p">));</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_OER</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_PER</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">at91_set_gpio_output</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * enable/disable the glitch filter; mostly used with IRQ handling.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">at91_set_deglitch</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_pio3</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">is_on</span><span class="p">)</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IFSCDR</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="p">(</span><span class="n">is_on</span> <span class="o">?</span> <span class="n">PIO_IFER</span> <span class="o">:</span> <span class="n">PIO_IFDR</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">at91_set_deglitch</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * enable/disable the debounce filter;</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">at91_set_debounce</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_on</span><span class="p">,</span> <span class="kt">int</span> <span class="n">div</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio</span> <span class="o">||</span> <span class="o">!</span><span class="n">has_pio3</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IFSCER</span><span class="p">);</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">div</span> <span class="o">&amp;</span> <span class="n">PIO_SCDR_DIV</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_SCDR</span><span class="p">);</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IFER</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IFDR</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">at91_set_debounce</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * enable/disable the multi-driver; This is only valid for output and</span>
<span class="cm"> * allows the output pin to run as an open collector output.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">at91_set_multi_drive</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="p">(</span><span class="n">is_on</span> <span class="o">?</span> <span class="n">PIO_MDER</span> <span class="o">:</span> <span class="n">PIO_MDDR</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">at91_set_multi_drive</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * enable/disable the pull-down.</span>
<span class="cm"> * If pull-up already enabled while calling the function, we disable it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">at91_set_pulldown</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio</span> <span class="o">||</span> <span class="o">!</span><span class="n">has_pio3</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Disable pull-up anyway */</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_PUDR</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="p">(</span><span class="n">is_on</span> <span class="o">?</span> <span class="n">PIO_PPDER</span> <span class="o">:</span> <span class="n">PIO_PPDDR</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">at91_set_pulldown</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * disable Schmitt trigger</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">at91_disable_schmitt_trig</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio</span> <span class="o">||</span> <span class="o">!</span><span class="n">has_pio3</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_SCHMITT</span><span class="p">)</span> <span class="o">|</span> <span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_SCHMITT</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">at91_disable_schmitt_trig</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * assuming the pin is muxed as a gpio output, set its value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">at91_set_gpio_value</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="p">(</span><span class="n">value</span> <span class="o">?</span> <span class="n">PIO_SODR</span> <span class="o">:</span> <span class="n">PIO_CODR</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">at91_set_gpio_value</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * read the pin&#39;s value (works even if it&#39;s not muxed as a gpio).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">at91_get_gpio_value</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
	<span class="n">u32</span>		<span class="n">pdsr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pio</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pdsr</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_PDSR</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pdsr</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">at91_get_gpio_value</span><span class="p">);</span>

<span class="cm">/*--------------------------------------------------------------------------*/</span>

<span class="cp">#ifdef CONFIG_PM</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">wakeups</span><span class="p">[</span><span class="n">MAX_GPIO_BANKS</span><span class="p">];</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">backups</span><span class="p">[</span><span class="n">MAX_GPIO_BANKS</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpio_irq_set_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="o">*</span><span class="n">at91_gpio</span> <span class="o">=</span> <span class="n">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hwirq</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">bank</span> <span class="o">=</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bank</span> <span class="o">&gt;=</span> <span class="n">MAX_GPIO_BANKS</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span>
		<span class="n">wakeups</span><span class="p">[</span><span class="n">bank</span><span class="p">]</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">wakeups</span><span class="p">[</span><span class="n">bank</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>

	<span class="n">irq_set_irq_wake</span><span class="p">(</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_virq</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">at91_gpio_suspend</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gpio_banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">gpio_chip</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">regbase</span><span class="p">;</span>

		<span class="n">backups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IMR</span><span class="p">);</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">backups</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IDR</span><span class="p">);</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">wakeups</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IER</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wakeups</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">clk_unprepare</span><span class="p">(</span><span class="n">gpio_chip</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clock</span><span class="p">);</span>
			<span class="n">clk_disable</span><span class="p">(</span><span class="n">gpio_chip</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_PM_DEBUG</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;GPIO-%c may wake for %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">wakeups</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">at91_gpio_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gpio_banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">gpio_chip</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">regbase</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wakeups</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">clk_prepare</span><span class="p">(</span><span class="n">gpio_chip</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clock</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">clk_enable</span><span class="p">(</span><span class="n">gpio_chip</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">wakeups</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IDR</span><span class="p">);</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">backups</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IER</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="cp">#define gpio_irq_set_wake	NULL</span>
<span class="cp">#endif</span>


<span class="cm">/* Several AIC controller irqs are dispatched through this GPIO handler.</span>
<span class="cm"> * To use any AT91_PIN_* as an externally triggered IRQ, first call</span>
<span class="cm"> * at91_set_gpio_input() then maybe enable its glitch filter.</span>
<span class="cm"> * Then just request_irq() with the pin ID; it works like any ARM IRQ</span>
<span class="cm"> * handler.</span>
<span class="cm"> * First implementation always triggers on rising and falling edges</span>
<span class="cm"> * whereas the newer PIO3 can be additionally configured to trigger on</span>
<span class="cm"> * level, edge with any polarity.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, certain pins may be used directly as IRQ0..IRQ6 after</span>
<span class="cm"> * configuring them with at91_set_a_periph() or at91_set_b_periph().</span>
<span class="cm"> * IRQ0..IRQ6 should be configurable, e.g. level vs edge triggering.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gpio_irq_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="o">*</span><span class="n">at91_gpio</span> <span class="o">=</span> <span class="n">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hwirq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pio</span><span class="p">)</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IDR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gpio_irq_unmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="o">*</span><span class="n">at91_gpio</span> <span class="o">=</span> <span class="n">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hwirq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pio</span><span class="p">)</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IER</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpio_irq_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IRQ_TYPE_NONE</span>:
	<span class="k">case</span> <span class="n">IRQ_TYPE_EDGE_BOTH</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Alternate irq type for PIO3 support */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alt_gpio_irq_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="o">*</span><span class="n">at91_gpio</span> <span class="o">=</span> <span class="n">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">hwirq</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IRQ_TYPE_EDGE_RISING</span>:
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ESR</span><span class="p">);</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_REHLSR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRQ_TYPE_EDGE_FALLING</span>:
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ESR</span><span class="p">);</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_FELLSR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRQ_TYPE_LEVEL_LOW</span>:
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_LSR</span><span class="p">);</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_FELLSR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRQ_TYPE_LEVEL_HIGH</span>:
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_LSR</span><span class="p">);</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_REHLSR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRQ_TYPE_EDGE_BOTH</span>:
		<span class="cm">/*</span>
<span class="cm">		 * disable additional interrupt modes:</span>
<span class="cm">		 * fall back to default behavior</span>
<span class="cm">		 */</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_AIMDR</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IRQ_TYPE_NONE</span>:
	<span class="nl">default:</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;AT91: No type for irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gpio_to_irq</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* enable additional interrupt modes */</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_AIMER</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">gpio_irqchip</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;GPIO&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_disable</span>	<span class="o">=</span> <span class="n">gpio_irq_mask</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span>	<span class="o">=</span> <span class="n">gpio_irq_mask</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span>	<span class="o">=</span> <span class="n">gpio_irq_unmask</span><span class="p">,</span>
	<span class="cm">/* .irq_set_type is set dynamically */</span>
	<span class="p">.</span><span class="n">irq_set_wake</span>	<span class="o">=</span> <span class="n">gpio_irq_set_wake</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gpio_irq_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">idata</span> <span class="o">=</span> <span class="n">irq_desc_get_irq_data</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">irq_data_get_irq_chip</span><span class="p">(</span><span class="n">idata</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="o">*</span><span class="n">at91_gpio</span> <span class="o">=</span> <span class="n">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="n">idata</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">isr</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">n</span><span class="p">;</span>

	<span class="cm">/* temporarily mask (level sensitive) parent IRQ */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_ack</span><span class="p">(</span><span class="n">idata</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/* Reading ISR acks pending (edge triggered) GPIO interrupts.</span>
<span class="cm">		 * When there none are pending, we&#39;re finished unless we need</span>
<span class="cm">		 * to process multiple banks (like ID_PIOCDE on sam9263).</span>
<span class="cm">		 */</span>
		<span class="n">isr</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ISR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IMR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">at91_gpio</span> <span class="o">=</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">pio</span> <span class="o">=</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">n</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isr</span><span class="p">,</span> <span class="n">BITS_PER_LONG</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">generic_handle_irq</span><span class="p">(</span><span class="n">irq_find_mapping</span><span class="p">(</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isr</span><span class="p">,</span> <span class="n">BITS_PER_LONG</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_unmask</span><span class="p">(</span><span class="n">idata</span><span class="p">);</span>
	<span class="cm">/* now it may re-trigger */</span>
<span class="p">}</span>

<span class="cm">/*--------------------------------------------------------------------------*/</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gpio_printf</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">trigger</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">polarity</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_IMR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_pio3</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_AIMMR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="p">))</span> <span class="p">{</span>
			<span class="n">trigger</span> <span class="o">=</span> <span class="s">&quot;edge&quot;</span><span class="p">;</span>
			<span class="n">polarity</span> <span class="o">=</span> <span class="s">&quot;both&quot;</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ELSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">trigger</span> <span class="o">=</span> <span class="s">&quot;level&quot;</span><span class="p">;</span>
				<span class="n">polarity</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_FRLHSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">?</span>
					<span class="s">&quot;high&quot;</span> <span class="o">:</span> <span class="s">&quot;low&quot;</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">trigger</span> <span class="o">=</span> <span class="s">&quot;edge&quot;</span><span class="p">;</span>
				<span class="n">polarity</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_FRLHSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">?</span>
						<span class="s">&quot;rising&quot;</span> <span class="o">:</span> <span class="s">&quot;falling&quot;</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;IRQ:%s-%s</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">trigger</span><span class="p">,</span> <span class="n">polarity</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;GPIO:%s</span><span class="se">\t\t</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_PDSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">?</span> <span class="s">&quot;1&quot;</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">at91_gpio_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bank</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="cm">/* print heading */</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;Pin</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bank</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bank</span> <span class="o">&lt;</span> <span class="n">gpio_banks</span><span class="p">;</span> <span class="n">bank</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;PIO%c</span><span class="se">\t\t</span><span class="s">&quot;</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="n">bank</span><span class="p">);</span>
	<span class="p">};</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* print pin status */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%i:</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">bank</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bank</span> <span class="o">&lt;</span> <span class="n">gpio_banks</span><span class="p">;</span> <span class="n">bank</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span>	<span class="n">pin</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="n">bank</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
			<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
			<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_PSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
				<span class="n">gpio_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pio</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%c</span><span class="se">\t\t</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">peripheral_function</span><span class="p">(</span><span class="n">pio</span><span class="p">,</span> <span class="n">mask</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">at91_gpio_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">at91_gpio_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">at91_gpio_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">at91_gpio_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">at91_gpio_debugfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* /sys/kernel/debug/at91_gpio */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;at91_gpio&quot;</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">at91_gpio_operations</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">postcore_initcall</span><span class="p">(</span><span class="n">at91_gpio_debugfs_init</span><span class="p">);</span>

<span class="cp">#endif</span>

<span class="cm">/*--------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * This lock class tells lockdep that GPIO irqs are in a different</span>
<span class="cm"> * category than their parents, so it won&#39;t report false recursion.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">gpio_lock_class</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_OF)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">at91_gpio_irq_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_domain</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">virq</span><span class="p">,</span>
							<span class="n">irq_hw_number_t</span> <span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span>	<span class="o">*</span><span class="n">at91_gpio</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">host_data</span><span class="p">;</span>

	<span class="n">irq_set_lockdep_class</span><span class="p">(</span><span class="n">virq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_lock_class</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Can use the &quot;simple&quot; and not &quot;edge&quot; handler since it&#39;s</span>
<span class="cm">	 * shorter, and the AIC handles interrupts sanely.</span>
<span class="cm">	 */</span>
	<span class="n">irq_set_chip_and_handler</span><span class="p">(</span><span class="n">virq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_irqchip</span><span class="p">,</span>
				 <span class="n">handle_simple_irq</span><span class="p">);</span>
	<span class="n">set_irq_flags</span><span class="p">(</span><span class="n">virq</span><span class="p">,</span> <span class="n">IRQF_VALID</span><span class="p">);</span>
	<span class="n">irq_set_chip_data</span><span class="p">(</span><span class="n">virq</span><span class="p">,</span> <span class="n">at91_gpio</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_domain_ops</span> <span class="n">at91_gpio_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">map</span>	<span class="o">=</span> <span class="n">at91_gpio_irq_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xlate</span>	<span class="o">=</span> <span class="n">irq_domain_xlate_twocell</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">at91_gpio_of_irq_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span>	<span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">alias_idx</span> <span class="o">=</span> <span class="n">of_alias_get_id</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;gpio&quot;</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span>	<span class="o">*</span><span class="n">at91_gpio</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_chip</span><span class="p">[</span><span class="n">alias_idx</span><span class="p">];</span>

	<span class="cm">/* Setup proper .irq_set_type function */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_pio3</span><span class="p">())</span>
		<span class="n">gpio_irqchip</span><span class="p">.</span><span class="n">irq_set_type</span> <span class="o">=</span> <span class="n">alt_gpio_irq_type</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">gpio_irqchip</span><span class="p">.</span><span class="n">irq_set_type</span> <span class="o">=</span> <span class="n">gpio_irq_type</span><span class="p">;</span>

	<span class="cm">/* Disable irqs of this PIO controller */</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span> <span class="o">+</span> <span class="n">PIO_IDR</span><span class="p">);</span>

	<span class="cm">/* Setup irq domain */</span>
	<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">=</span> <span class="n">irq_domain_add_linear</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ngpio</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">at91_gpio_ops</span><span class="p">,</span> <span class="n">at91_gpio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;at91_gpio.%d: couldn&#39;t allocate irq domain (DT).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_idx</span><span class="p">);</span>

	<span class="cm">/* Setup chained handler */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_idx</span><span class="p">)</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_chip</span><span class="p">[</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* The toplevel handler handles one bank of GPIOs, except</span>
<span class="cm">	 * on some SoC it can handles up to three...</span>
<span class="cm">	 * We only set up the handler for the first of the list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">at91_gpio</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_virq</span> <span class="o">=</span> <span class="n">irq_create_mapping</span><span class="p">(</span><span class="n">irq_find_host</span><span class="p">(</span><span class="n">parent</span><span class="p">),</span>
							<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_hwirq</span><span class="p">);</span>
	<span class="n">irq_set_chip_data</span><span class="p">(</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_virq</span><span class="p">,</span> <span class="n">at91_gpio</span><span class="p">);</span>
	<span class="n">irq_set_chained_handler</span><span class="p">(</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_virq</span><span class="p">,</span> <span class="n">gpio_irq_handler</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">at91_gpio_of_irq_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * irqdomain initialization: pile up irqdomains on top of AIC range</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">at91_gpio_irqdomain</span><span class="p">(</span><span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="o">*</span><span class="n">at91_gpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq_base</span><span class="p">;</span>

	<span class="n">irq_base</span> <span class="o">=</span> <span class="n">irq_alloc_descs</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ngpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_base</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;at91_gpio.%d: error %d: couldn&#39;t allocate IRQ numbers.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_idx</span><span class="p">,</span> <span class="n">irq_base</span><span class="p">);</span>
	<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">domain</span> <span class="o">=</span> <span class="n">irq_domain_add_legacy</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ngpio</span><span class="p">,</span>
						  <span class="n">irq_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">irq_domain_simple_ops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;at91_gpio.%d: couldn&#39;t allocate irq domain.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from the processor-specific init to enable GPIO interrupt support.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">at91_gpio_irq_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>		<span class="n">pioc</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">gpio_irqnbr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span>	<span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>

	<span class="cm">/* Setup proper .irq_set_type function */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_pio3</span><span class="p">())</span>
		<span class="n">gpio_irqchip</span><span class="p">.</span><span class="n">irq_set_type</span> <span class="o">=</span> <span class="n">alt_gpio_irq_type</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">gpio_irqchip</span><span class="p">.</span><span class="n">irq_set_type</span> <span class="o">=</span> <span class="n">gpio_irq_type</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pioc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">this</span> <span class="o">=</span> <span class="n">gpio_chip</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">pioc</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">gpio_banks</span><span class="p">;</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="n">this</span><span class="p">,</span> <span class="n">this</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">__raw_writel</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">regbase</span> <span class="o">+</span> <span class="n">PIO_IDR</span><span class="p">);</span>

		<span class="cm">/* setup irq domain for this GPIO controller */</span>
		<span class="n">at91_gpio_irqdomain</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ngpio</span><span class="p">;</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">virq</span> <span class="o">=</span> <span class="n">irq_find_mapping</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="n">irq_set_lockdep_class</span><span class="p">(</span><span class="n">virq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_lock_class</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Can use the &quot;simple&quot; and not &quot;edge&quot; handler since it&#39;s</span>
<span class="cm">			 * shorter, and the AIC handles interrupts sanely.</span>
<span class="cm">			 */</span>
			<span class="n">irq_set_chip_and_handler</span><span class="p">(</span><span class="n">virq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_irqchip</span><span class="p">,</span>
						 <span class="n">handle_simple_irq</span><span class="p">);</span>
			<span class="n">set_irq_flags</span><span class="p">(</span><span class="n">virq</span><span class="p">,</span> <span class="n">IRQF_VALID</span><span class="p">);</span>
			<span class="n">irq_set_chip_data</span><span class="p">(</span><span class="n">virq</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>

			<span class="n">gpio_irqnbr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* The toplevel handler handles one bank of GPIOs, except</span>
<span class="cm">		 * on some SoC it can handles up to three...</span>
<span class="cm">		 * We only set up the handler for the first of the list.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">this</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">this</span><span class="o">-&gt;</span><span class="n">pioc_virq</span> <span class="o">=</span> <span class="n">irq_create_mapping</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">pioc_hwirq</span><span class="p">);</span>
		<span class="n">irq_set_chip_data</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">pioc_virq</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
		<span class="n">irq_set_chained_handler</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">pioc_virq</span><span class="p">,</span> <span class="n">gpio_irq_handler</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;AT91: %d gpio irqs in %d banks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gpio_irqnbr</span><span class="p">,</span> <span class="n">gpio_banks</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* gpiolib support */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">at91_gpiolib_direction_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="o">*</span><span class="n">at91_gpio</span> <span class="o">=</span> <span class="n">to_at91_gpio_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_ODR</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">at91_gpiolib_direction_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="o">*</span><span class="n">at91_gpio</span> <span class="o">=</span> <span class="n">to_at91_gpio_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="p">(</span><span class="n">val</span> <span class="o">?</span> <span class="n">PIO_SODR</span> <span class="o">:</span> <span class="n">PIO_CODR</span><span class="p">));</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_OER</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">at91_gpiolib_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="o">*</span><span class="n">at91_gpio</span> <span class="o">=</span> <span class="n">to_at91_gpio_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pdsr</span><span class="p">;</span>

	<span class="n">pdsr</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_PDSR</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pdsr</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">at91_gpiolib_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="o">*</span><span class="n">at91_gpio</span> <span class="o">=</span> <span class="n">to_at91_gpio_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pio</span> <span class="o">+</span> <span class="p">(</span><span class="n">val</span> <span class="o">?</span> <span class="n">PIO_SODR</span> <span class="o">:</span> <span class="n">PIO_CODR</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">at91_gpiolib_dbg_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">pin</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pio</span> <span class="o">=</span> <span class="n">pin_to_controller</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">pin_to_mask</span><span class="p">(</span><span class="n">pin</span><span class="p">);</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">gpio_label</span><span class="p">;</span>

		<span class="n">gpio_label</span> <span class="o">=</span> <span class="n">gpiochip_is_requested</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gpio_label</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;[%s] GPIO%s%d: &quot;</span><span class="p">,</span>
				   <span class="n">gpio_label</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__raw_readl</span><span class="p">(</span><span class="n">pio</span> <span class="o">+</span> <span class="n">PIO_PSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
				<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;[gpio] %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">at91_get_gpio_value</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span> <span class="o">?</span>
					   <span class="s">&quot;set&quot;</span> <span class="o">:</span> <span class="s">&quot;clear&quot;</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;[periph %c]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">peripheral_function</span><span class="p">(</span><span class="n">pio</span><span class="p">,</span> <span class="n">mask</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">at91_gpiolib_to_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="o">*</span><span class="n">at91_gpio</span> <span class="o">=</span> <span class="n">to_at91_gpio_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">virq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span><span class="p">)</span>
		<span class="n">virq</span> <span class="o">=</span> <span class="n">irq_create_mapping</span><span class="p">(</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">virq</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: request IRQ for GPIO %d, return %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">virq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">virq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">at91_gpio_setup_clk</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="o">*</span><span class="n">at91_gpio</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_chip</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

	<span class="cm">/* retreive PIO controller&#39;s clock */</span>
	<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">=</span> <span class="n">clk_get_sys</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">label</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;at91_gpio.%d, failed to get clock, ignoring.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk_prepare</span><span class="p">(</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">clk_prep_err</span><span class="p">;</span>

	<span class="cm">/* enable PIO controller&#39;s clock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clk_enable</span><span class="p">(</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;at91_gpio.%d, failed to enable clock, ignoring.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">clk_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">clk_err:</span>
	<span class="n">clk_unprepare</span><span class="p">(</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span>
<span class="nl">clk_prep_err:</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_OF_GPIO</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">of_at91_gpio_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">alias_idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="o">*</span><span class="n">at91_gpio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">alias_idx</span> <span class="o">=</span> <span class="n">of_alias_get_id</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;gpio&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alias_idx</span> <span class="o">&gt;=</span> <span class="n">MAX_GPIO_BANKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;at91_gpio, failed alias idx(%d) &gt; MAX_GPIO_BANKS(%d), ignoring.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">alias_idx</span><span class="p">,</span> <span class="n">MAX_GPIO_BANKS</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">at91_gpio</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_chip</span><span class="p">[</span><span class="n">alias_idx</span><span class="p">];</span>
	<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">alias_idx</span> <span class="o">*</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ngpio</span><span class="p">;</span>

	<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span> <span class="o">=</span> <span class="n">of_iomap</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;at91_gpio.%d, failed to map registers, ignoring.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">alias_idx</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the interrupts property */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_property_read_u32</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;interrupts&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_hwirq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;at91_gpio.%d, failed to get interrupts property, ignoring.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">alias_idx</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">ioremap_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get capabilities from compatibility property */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;atmel,at91sam9x5-gpio&quot;</span><span class="p">))</span>
		<span class="n">at91_gpio_caps</span> <span class="o">|=</span> <span class="n">AT91_GPIO_CAP_PIO3</span><span class="p">;</span>

	<span class="cm">/* Setup clock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">at91_gpio_setup_clk</span><span class="p">(</span><span class="n">alias_idx</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">ioremap_err</span><span class="p">;</span>

	<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">of_node</span> <span class="o">=</span> <span class="n">np</span><span class="p">;</span>
	<span class="n">gpio_banks</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">gpio_banks</span><span class="p">,</span> <span class="n">alias_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_idx</span> <span class="o">=</span> <span class="n">alias_idx</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">ioremap_err:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">of_at91_gpio_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This isn&#39;t ideal, but it gets things hooked up until this</span>
<span class="cm">	 * driver is converted into a platform_device</span>
<span class="cm">	 */</span>
	<span class="n">for_each_compatible_node</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;atmel,at91rm9200-gpio&quot;</span><span class="p">)</span>
		<span class="n">of_at91_gpio_init_one</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">gpio_banks</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">of_at91_gpio_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">at91_gpio_init_one</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">regbase</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pioc_hwirq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="o">*</span><span class="n">at91_gpio</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_chip</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

	<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ngpio</span><span class="p">;</span>
	<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_hwirq</span> <span class="o">=</span> <span class="n">pioc_hwirq</span><span class="p">;</span>
	<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">regbase</span><span class="p">,</span> <span class="mi">512</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;at91_gpio.%d, failed to map registers, ignoring.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">at91_gpio_setup_clk</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">ioremap_err</span><span class="p">;</span>

	<span class="n">gpio_banks</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">gpio_banks</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">ioremap_err:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">regbase</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from the processor-specific init to enable GPIO pin support.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">at91_gpio_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">at91_gpio_bank</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_banks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">at91_gpio_chip</span> <span class="o">*</span><span class="n">at91_gpio</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nr_banks</span> <span class="o">&gt;</span> <span class="n">MAX_GPIO_BANKS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">of_at91_gpio_init</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No GPIO controller found in device tree */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">at91_gpio_init_one</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">regbase</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gpio_banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">at91_gpio</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_chip</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * GPIO controller are grouped on some SoC:</span>
<span class="cm">		 * PIOC, PIOD and PIOE can share the same IRQ line</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">pioc_hwirq</span> <span class="o">==</span> <span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">pioc_hwirq</span><span class="p">)</span>
			<span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">at91_gpio</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">at91_gpio</span><span class="p">;</span>

		<span class="n">gpiochip_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at91_gpio</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
