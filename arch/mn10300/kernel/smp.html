<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mn10300 › kernel › smp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>smp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* SMP support routines.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Panasonic Corporation</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * version 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/profile.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/bitops.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/bug.h&gt;</span>
<span class="cp">#include &lt;asm/exceptions.h&gt;</span>
<span class="cp">#include &lt;asm/hardirq.h&gt;</span>
<span class="cp">#include &lt;asm/fpu.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/thread_info.h&gt;</span>
<span class="cp">#include &lt;asm/cpu-regs.h&gt;</span>
<span class="cp">#include &lt;asm/intctl-regs.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sleep_mode</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">run_sleep_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">run_wakeup_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Debug Message function</span>
<span class="cm"> */</span>

<span class="cp">#undef DEBUG_SMP</span>
<span class="cp">#ifdef DEBUG_SMP</span>
<span class="cp">#define Dprintk(fmt, ...) printk(KERN_DEBUG fmt, ##__VA_ARGS__)</span>
<span class="cp">#else</span>
<span class="cp">#define Dprintk(fmt, ...) no_printk(KERN_DEBUG fmt, ##__VA_ARGS__)</span>
<span class="cp">#endif</span>

<span class="cm">/* timeout value in msec for smp_nmi_call_function. zero is no timeout. */</span>
<span class="cp">#define	CALL_FUNCTION_NMI_IPI_TIMEOUT	0</span>

<span class="cm">/*</span>
<span class="cm"> * Structure and data for smp_nmi_call_function().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nmi_call_data_struct</span> <span class="p">{</span>
	<span class="n">smp_call_func_t</span>	<span class="n">func</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="n">cpumask_t</span>	<span class="n">started</span><span class="p">;</span>
	<span class="n">cpumask_t</span>	<span class="n">finished</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">wait</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="n">size_alignment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">__attribute__</span> <span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="n">SMP_CACHE_BYTES</span><span class="p">)));</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="n">SMP_CACHE_BYTES</span><span class="p">)));</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">smp_nmi_call_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nmi_call_data_struct</span> <span class="o">*</span><span class="n">nmi_call_data</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Data structures and variables</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">cpumask_t</span> <span class="n">cpu_callin_map</span><span class="p">;</span>	<span class="cm">/* Bitmask of callin CPUs */</span>
<span class="k">static</span> <span class="n">cpumask_t</span> <span class="n">cpu_callout_map</span><span class="p">;</span>	<span class="cm">/* Bitmask of callout CPUs */</span>
<span class="n">cpumask_t</span> <span class="n">cpu_boot_map</span><span class="p">;</span>			<span class="cm">/* Bitmask of boot APs */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_stack</span><span class="p">[</span><span class="n">NR_CPUS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * Per CPU parameters</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mn10300_cpuinfo</span> <span class="n">cpu_data</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">]</span> <span class="n">__cacheline_aligned</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cpucount</span><span class="p">;</span>			<span class="cm">/* The count of boot CPUs */</span>
<span class="k">static</span> <span class="n">cpumask_t</span> <span class="n">smp_commenced_mask</span><span class="p">;</span>
<span class="n">cpumask_t</span> <span class="n">cpu_initialized</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="n">CPU_MASK_NONE</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Function Prototypes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">do_boot_cpu</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smp_show_cpu_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu_id</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smp_callin</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smp_online</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smp_store_cpu_info</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smp_cpu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smp_tune_scheduling</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">send_IPI_mask</span><span class="p">(</span><span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">init_ipi</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * IPI Initialization interrupt definitions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mn10300_ipi_disable</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mn10300_ipi_enable</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mn10300_ipi_chip_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mn10300_ipi_chip_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mn10300_ipi_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mn10300_ipi_nop</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">mn10300_ipi_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;cpu_ipi&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_disable</span>	<span class="o">=</span> <span class="n">mn10300_ipi_chip_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_enable</span>	<span class="o">=</span> <span class="n">mn10300_ipi_chip_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_ack</span>	<span class="o">=</span> <span class="n">mn10300_ipi_ack</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_eoi</span>	<span class="o">=</span> <span class="n">mn10300_ipi_nop</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">smp_reschedule_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">smp_call_function_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">reschedule_ipi</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span>	<span class="o">=</span> <span class="n">smp_reschedule_interrupt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;smp reschedule IPI&quot;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">call_function_ipi</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span>	<span class="o">=</span> <span class="n">smp_call_function_interrupt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;smp call function IPI&quot;</span>
<span class="p">};</span>

<span class="cp">#if !defined(CONFIG_GENERIC_CLOCKEVENTS) || defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST)</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">smp_ipi_timer_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">local_timer_ipi</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span>	<span class="o">=</span> <span class="n">smp_ipi_timer_interrupt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">IRQF_DISABLED</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;smp local timer IPI&quot;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * init_ipi - Initialise the IPI mechanism</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_ipi</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tmp16</span><span class="p">;</span>

	<span class="cm">/* set up the reschedule IPI */</span>
	<span class="n">irq_set_chip_and_handler</span><span class="p">(</span><span class="n">RESCHEDULE_IPI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mn10300_ipi_type</span><span class="p">,</span>
				 <span class="n">handle_percpu_irq</span><span class="p">);</span>
	<span class="n">setup_irq</span><span class="p">(</span><span class="n">RESCHEDULE_IPI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reschedule_ipi</span><span class="p">);</span>
	<span class="n">set_intr_level</span><span class="p">(</span><span class="n">RESCHEDULE_IPI</span><span class="p">,</span> <span class="n">RESCHEDULE_GxICR_LV</span><span class="p">);</span>
	<span class="n">mn10300_ipi_enable</span><span class="p">(</span><span class="n">RESCHEDULE_IPI</span><span class="p">);</span>

	<span class="cm">/* set up the call function IPI */</span>
	<span class="n">irq_set_chip_and_handler</span><span class="p">(</span><span class="n">CALL_FUNC_SINGLE_IPI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mn10300_ipi_type</span><span class="p">,</span>
				 <span class="n">handle_percpu_irq</span><span class="p">);</span>
	<span class="n">setup_irq</span><span class="p">(</span><span class="n">CALL_FUNC_SINGLE_IPI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">call_function_ipi</span><span class="p">);</span>
	<span class="n">set_intr_level</span><span class="p">(</span><span class="n">CALL_FUNC_SINGLE_IPI</span><span class="p">,</span> <span class="n">CALL_FUNCTION_GxICR_LV</span><span class="p">);</span>
	<span class="n">mn10300_ipi_enable</span><span class="p">(</span><span class="n">CALL_FUNC_SINGLE_IPI</span><span class="p">);</span>

	<span class="cm">/* set up the local timer IPI */</span>
<span class="cp">#if !defined(CONFIG_GENERIC_CLOCKEVENTS) || \</span>
<span class="cp">    defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST)</span>
	<span class="n">irq_set_chip_and_handler</span><span class="p">(</span><span class="n">LOCAL_TIMER_IPI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mn10300_ipi_type</span><span class="p">,</span>
				 <span class="n">handle_percpu_irq</span><span class="p">);</span>
	<span class="n">setup_irq</span><span class="p">(</span><span class="n">LOCAL_TIMER_IPI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local_timer_ipi</span><span class="p">);</span>
	<span class="n">set_intr_level</span><span class="p">(</span><span class="n">LOCAL_TIMER_IPI</span><span class="p">,</span> <span class="n">LOCAL_TIMER_GxICR_LV</span><span class="p">);</span>
	<span class="n">mn10300_ipi_enable</span><span class="p">(</span><span class="n">LOCAL_TIMER_IPI</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MN10300_CACHE_ENABLED</span>
	<span class="cm">/* set up the cache flush IPI */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">arch_local_cli_save</span><span class="p">();</span>
	<span class="n">__set_intr_stub</span><span class="p">(</span><span class="n">NUM2EXCEP_IRQ_LEVEL</span><span class="p">(</span><span class="n">FLUSH_CACHE_GxICR_LV</span><span class="p">),</span>
			<span class="n">mn10300_low_ipi_handler</span><span class="p">);</span>
	<span class="n">GxICR</span><span class="p">(</span><span class="n">FLUSH_CACHE_IPI</span><span class="p">)</span> <span class="o">=</span> <span class="n">FLUSH_CACHE_GxICR_LV</span> <span class="o">|</span> <span class="n">GxICR_DETECT</span><span class="p">;</span>
	<span class="n">mn10300_ipi_enable</span><span class="p">(</span><span class="n">FLUSH_CACHE_IPI</span><span class="p">);</span>
	<span class="n">arch_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* set up the NMI call function IPI */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">arch_local_cli_save</span><span class="p">();</span>
	<span class="n">GxICR</span><span class="p">(</span><span class="n">CALL_FUNCTION_NMI_IPI</span><span class="p">)</span> <span class="o">=</span> <span class="n">GxICR_NMI</span> <span class="o">|</span> <span class="n">GxICR_ENABLE</span> <span class="o">|</span> <span class="n">GxICR_DETECT</span><span class="p">;</span>
	<span class="n">tmp16</span> <span class="o">=</span> <span class="n">GxICR</span><span class="p">(</span><span class="n">CALL_FUNCTION_NMI_IPI</span><span class="p">);</span>
	<span class="n">arch_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* set up the SMP boot IPI */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">arch_local_cli_save</span><span class="p">();</span>
	<span class="n">__set_intr_stub</span><span class="p">(</span><span class="n">NUM2EXCEP_IRQ_LEVEL</span><span class="p">(</span><span class="n">SMP_BOOT_GxICR_LV</span><span class="p">),</span>
			<span class="n">mn10300_low_ipi_handler</span><span class="p">);</span>
	<span class="n">arch_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mn10300_ipi_shutdown - Shut down handling of an IPI</span>
<span class="cm"> * @irq: The IPI to be shut down.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mn10300_ipi_shutdown</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">arch_local_cli_save</span><span class="p">();</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">GxICR</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">GxICR</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">GxICR_LEVEL</span><span class="p">)</span> <span class="o">|</span> <span class="n">GxICR_DETECT</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">GxICR</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">arch_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mn10300_ipi_enable - Enable an IPI</span>
<span class="cm"> * @irq: The IPI to be enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mn10300_ipi_enable</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">arch_local_cli_save</span><span class="p">();</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">GxICR</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">GxICR</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">GxICR_LEVEL</span><span class="p">)</span> <span class="o">|</span> <span class="n">GxICR_ENABLE</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">GxICR</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">arch_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mn10300_ipi_chip_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mn10300_ipi_enable</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mn10300_ipi_disable - Disable an IPI</span>
<span class="cm"> * @irq: The IPI to be disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mn10300_ipi_disable</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">arch_local_cli_save</span><span class="p">();</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">GxICR</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">GxICR</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">GxICR_LEVEL</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">GxICR</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">arch_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mn10300_ipi_chip_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mn10300_ipi_disable</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * mn10300_ipi_ack - Acknowledge an IPI interrupt in the PIC</span>
<span class="cm"> * @irq: The IPI to be acknowledged.</span>
<span class="cm"> *</span>
<span class="cm"> * Clear the interrupt detection flag for the IPI on the appropriate interrupt</span>
<span class="cm"> * channel in the PIC.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mn10300_ipi_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">arch_local_cli_save</span><span class="p">();</span>
	<span class="n">GxICR_u8</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span> <span class="o">=</span> <span class="n">GxICR_DETECT</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">GxICR</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">arch_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mn10300_ipi_nop - Dummy IPI action</span>
<span class="cm"> * @irq: The IPI to be acted upon.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mn10300_ipi_nop</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * send_IPI_mask - Send IPIs to all CPUs in list</span>
<span class="cm"> * @cpumask: The list of CPUs to target.</span>
<span class="cm"> * @irq: The IPI request to be sent.</span>
<span class="cm"> *</span>
<span class="cm"> * Send the specified IPI to all the CPUs in the list, not waiting for them to</span>
<span class="cm"> * finish before returning.  The caller is responsible for synchronisation if</span>
<span class="cm"> * that is needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">send_IPI_mask</span><span class="p">(</span><span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cpumask</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* send IPI */</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">CROSS_GxICR</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">CROSS_GxICR</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span>
				<span class="n">tmp</span> <span class="o">|</span> <span class="n">GxICR_REQUEST</span> <span class="o">|</span> <span class="n">GxICR_DETECT</span><span class="p">;</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">CROSS_GxICR</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="cm">/* flush write buffer */</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * send_IPI_self - Send an IPI to this CPU.</span>
<span class="cm"> * @irq: The IPI request to be sent.</span>
<span class="cm"> *</span>
<span class="cm"> * Send the specified IPI to the current CPU.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">send_IPI_self</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">send_IPI_mask</span><span class="p">(</span><span class="n">cpumask_of</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()),</span> <span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * send_IPI_allbutself - Send IPIs to all the other CPUs.</span>
<span class="cm"> * @irq: The IPI request to be sent.</span>
<span class="cm"> *</span>
<span class="cm"> * Send the specified IPI to all CPUs in the system barring the current one,</span>
<span class="cm"> * not waiting for them to finish before returning.  The caller is responsible</span>
<span class="cm"> * for synchronisation if that is needed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">send_IPI_allbutself</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_t</span> <span class="n">cpumask</span><span class="p">;</span>

	<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">cpumask</span><span class="p">);</span>
	<span class="n">send_IPI_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arch_send_call_function_ipi_mask</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="cm">/*send_IPI_mask(mask, CALL_FUNCTION_IPI);*/</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arch_send_call_function_single_ipi</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">send_IPI_mask</span><span class="p">(</span><span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">CALL_FUNC_SINGLE_IPI</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_send_reschedule - Send reschedule IPI to a CPU</span>
<span class="cm"> * @cpu: The CPU to target.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">smp_send_reschedule</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">send_IPI_mask</span><span class="p">(</span><span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">RESCHEDULE_IPI</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_nmi_call_function - Send a call function NMI IPI to all CPUs</span>
<span class="cm"> * @func: The function to ask to be run.</span>
<span class="cm"> * @info: The context data to pass to that function.</span>
<span class="cm"> * @wait: If true, wait (atomically) until function is run on all CPUs.</span>
<span class="cm"> *</span>
<span class="cm"> * Send a non-maskable request to all CPUs in the system, requesting them to</span>
<span class="cm"> * run the specified function with the given context data, and, potentially, to</span>
<span class="cm"> * wait for completion of that function on all CPUs.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, -ETIMEDOUT if we were asked to wait, but hit the</span>
<span class="cm"> * timeout.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">smp_nmi_call_function</span><span class="p">(</span><span class="n">smp_call_func_t</span> <span class="n">func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nmi_call_data_struct</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpus</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpus</span> <span class="o">=</span> <span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpus</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">data</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">.</span><span class="n">started</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">.</span><span class="n">started</span><span class="p">);</span>
	<span class="n">data</span><span class="p">.</span><span class="n">wait</span> <span class="o">=</span> <span class="n">wait</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span>
		<span class="n">data</span><span class="p">.</span><span class="n">finished</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">started</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smp_nmi_call_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">nmi_call_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="cm">/* Send a message to all other CPUs and wait for them to respond */</span>
	<span class="n">send_IPI_allbutself</span><span class="p">(</span><span class="n">CALL_FUNCTION_NMI_IPI</span><span class="p">);</span>

	<span class="cm">/* Wait for response */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CALL_FUNCTION_NMI_IPI_TIMEOUT</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">CALL_FUNCTION_NMI_IPI_TIMEOUT</span> <span class="o">&amp;&amp;</span>
			     <span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">.</span><span class="n">started</span><span class="p">);</span>
		     <span class="n">cnt</span><span class="o">++</span><span class="p">)</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wait</span> <span class="o">&amp;&amp;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">CALL_FUNCTION_NMI_IPI_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			     <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">CALL_FUNCTION_NMI_IPI_TIMEOUT</span> <span class="o">&amp;&amp;</span>
				     <span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">.</span><span class="n">finished</span><span class="p">);</span>
			     <span class="n">cnt</span><span class="o">++</span><span class="p">)</span>
				<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">CALL_FUNCTION_NMI_IPI_TIMEOUT</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* If timeout value is zero, wait until cpumask has been</span>
<span class="cm">		 * cleared */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">.</span><span class="n">started</span><span class="p">))</span>
			<span class="n">barrier</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">.</span><span class="n">finished</span><span class="p">))</span>
				<span class="n">barrier</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smp_nmi_call_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_jump_to_debugger - Make other CPUs enter the debugger by sending an IPI</span>
<span class="cm"> *</span>
<span class="cm"> * Send a non-maskable request to all other CPUs in the system, instructing</span>
<span class="cm"> * them to jump into the debugger.  The caller is responsible for checking that</span>
<span class="cm"> * the other CPUs responded to the instruction.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller should make sure that this CPU&#39;s debugger IPI is disabled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">smp_jump_to_debugger</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="cm">/* Send a message to all other CPUs */</span>
		<span class="n">send_IPI_allbutself</span><span class="p">(</span><span class="n">DEBUGGER_NMI_IPI</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * stop_this_cpu - Callback to stop a CPU.</span>
<span class="cm"> * @unused: Callback context (ignored).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">stop_this_cpu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="n">stopflag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_GDBSTUB</span>
	<span class="cm">/* In case of single stepping smp_send_stop by other CPU,</span>
<span class="cm">	 * clear procindebug to avoid deadlock.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">procindebug</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()],</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_GDBSTUB */</span><span class="cp"></span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">arch_local_cli_save</span><span class="p">();</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stopflag</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">arch_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_send_stop - Send a stop request to all CPUs.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">smp_send_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_nmi_call_function</span><span class="p">(</span><span class="n">stop_this_cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_reschedule_interrupt - Reschedule IPI handler</span>
<span class="cm"> * @irq: The interrupt number.</span>
<span class="cm"> * @dev_id: The device ID.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns IRQ_HANDLED to indicate we handled the interrupt successfully.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">smp_reschedule_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scheduler_ipi</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_call_function_interrupt - Call function IPI handler</span>
<span class="cm"> * @irq: The interrupt number.</span>
<span class="cm"> * @dev_id: The device ID.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns IRQ_HANDLED to indicate we handled the interrupt successfully.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">smp_call_function_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* generic_smp_call_function_interrupt(); */</span>
	<span class="n">generic_smp_call_function_single_interrupt</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_nmi_call_function_interrupt - Non-maskable call function IPI handler</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">smp_nmi_call_function_interrupt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_call_func_t</span> <span class="n">func</span> <span class="o">=</span> <span class="n">nmi_call_data</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">nmi_call_data</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wait</span> <span class="o">=</span> <span class="n">nmi_call_data</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">;</span>

	<span class="cm">/* Notify the initiating CPU that I&#39;ve grabbed the data and am about to</span>
<span class="cm">	 * execute the function</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">nmi_call_data</span><span class="o">-&gt;</span><span class="n">started</span><span class="p">);</span>
	<span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span>
				  <span class="o">&amp;</span><span class="n">nmi_call_data</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#if !defined(CONFIG_GENERIC_CLOCKEVENTS) || \</span>
<span class="cp">    defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST)</span>
<span class="cm">/**</span>
<span class="cm"> * smp_ipi_timer_interrupt - Local timer IPI handler</span>
<span class="cm"> * @irq: The interrupt number.</span>
<span class="cm"> * @dev_id: The device ID.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns IRQ_HANDLED to indicate we handled the interrupt successfully.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">smp_ipi_timer_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">local_timer_interrupt</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_init_cpus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_cpu_init - Initialise AP in start_secondary.</span>
<span class="cm"> *</span>
<span class="cm"> * For this Application Processor, set up init_mm, initialise FPU and set</span>
<span class="cm"> * interrupt level 0-6 setting.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_cpu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu_id</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">u16</span> <span class="n">tmp16</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_initialized</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;CPU#%d already initialized!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(;;)</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Initializing CPU#%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">mm_count</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>

	<span class="n">enter_lazy_tlb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="cm">/* Force FPU initialization */</span>
	<span class="n">clear_using_fpu</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="n">GxICR</span><span class="p">(</span><span class="n">CALL_FUNC_SINGLE_IPI</span><span class="p">)</span> <span class="o">=</span> <span class="n">CALL_FUNCTION_GxICR_LV</span> <span class="o">|</span> <span class="n">GxICR_DETECT</span><span class="p">;</span>
	<span class="n">mn10300_ipi_enable</span><span class="p">(</span><span class="n">CALL_FUNC_SINGLE_IPI</span><span class="p">);</span>

	<span class="n">GxICR</span><span class="p">(</span><span class="n">LOCAL_TIMER_IPI</span><span class="p">)</span> <span class="o">=</span> <span class="n">LOCAL_TIMER_GxICR_LV</span> <span class="o">|</span> <span class="n">GxICR_DETECT</span><span class="p">;</span>
	<span class="n">mn10300_ipi_enable</span><span class="p">(</span><span class="n">LOCAL_TIMER_IPI</span><span class="p">);</span>

	<span class="n">GxICR</span><span class="p">(</span><span class="n">RESCHEDULE_IPI</span><span class="p">)</span> <span class="o">=</span> <span class="n">RESCHEDULE_GxICR_LV</span> <span class="o">|</span> <span class="n">GxICR_DETECT</span><span class="p">;</span>
	<span class="n">mn10300_ipi_enable</span><span class="p">(</span><span class="n">RESCHEDULE_IPI</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MN10300_CACHE_ENABLED</span>
	<span class="n">GxICR</span><span class="p">(</span><span class="n">FLUSH_CACHE_IPI</span><span class="p">)</span> <span class="o">=</span> <span class="n">FLUSH_CACHE_GxICR_LV</span> <span class="o">|</span> <span class="n">GxICR_DETECT</span><span class="p">;</span>
	<span class="n">mn10300_ipi_enable</span><span class="p">(</span><span class="n">FLUSH_CACHE_IPI</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">mn10300_ipi_shutdown</span><span class="p">(</span><span class="n">SMP_BOOT_IRQ</span><span class="p">);</span>

	<span class="cm">/* Set up the non-maskable call function IPI */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">arch_local_cli_save</span><span class="p">();</span>
	<span class="n">GxICR</span><span class="p">(</span><span class="n">CALL_FUNCTION_NMI_IPI</span><span class="p">)</span> <span class="o">=</span> <span class="n">GxICR_NMI</span> <span class="o">|</span> <span class="n">GxICR_ENABLE</span> <span class="o">|</span> <span class="n">GxICR_DETECT</span><span class="p">;</span>
	<span class="n">tmp16</span> <span class="o">=</span> <span class="n">GxICR</span><span class="p">(</span><span class="n">CALL_FUNCTION_NMI_IPI</span><span class="p">);</span>
	<span class="n">arch_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_prepare_cpu_init - Initialise CPU in startup_secondary</span>
<span class="cm"> *</span>
<span class="cm"> * Set interrupt level 0-6 setting and init ICR of the kernel debugger.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">smp_prepare_cpu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">loop</span><span class="p">;</span>

	<span class="cm">/* Set the interrupt vector registers */</span>
	<span class="n">IVAR0</span> <span class="o">=</span> <span class="n">EXCEP_IRQ_LEVEL0</span><span class="p">;</span>
	<span class="n">IVAR1</span> <span class="o">=</span> <span class="n">EXCEP_IRQ_LEVEL1</span><span class="p">;</span>
	<span class="n">IVAR2</span> <span class="o">=</span> <span class="n">EXCEP_IRQ_LEVEL2</span><span class="p">;</span>
	<span class="n">IVAR3</span> <span class="o">=</span> <span class="n">EXCEP_IRQ_LEVEL3</span><span class="p">;</span>
	<span class="n">IVAR4</span> <span class="o">=</span> <span class="n">EXCEP_IRQ_LEVEL4</span><span class="p">;</span>
	<span class="n">IVAR5</span> <span class="o">=</span> <span class="n">EXCEP_IRQ_LEVEL5</span><span class="p">;</span>
	<span class="n">IVAR6</span> <span class="o">=</span> <span class="n">EXCEP_IRQ_LEVEL6</span><span class="p">;</span>

	<span class="cm">/* Disable all interrupts and set to priority 6 (lowest) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&lt;</span> <span class="n">GxICR_NUM_IRQS</span><span class="p">;</span> <span class="n">loop</span><span class="o">++</span><span class="p">)</span>
		<span class="n">GxICR</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span> <span class="o">=</span> <span class="n">GxICR_LEVEL_6</span> <span class="o">|</span> <span class="n">GxICR_DETECT</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_KERNEL_DEBUGGER</span>
	<span class="cm">/* initialise the kernel debugger interrupt */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">tmp16</span><span class="p">;</span>

		<span class="n">flags</span> <span class="o">=</span> <span class="n">arch_local_cli_save</span><span class="p">();</span>
		<span class="n">GxICR</span><span class="p">(</span><span class="n">DEBUGGER_NMI_IPI</span><span class="p">)</span> <span class="o">=</span> <span class="n">GxICR_NMI</span> <span class="o">|</span> <span class="n">GxICR_ENABLE</span> <span class="o">|</span> <span class="n">GxICR_DETECT</span><span class="p">;</span>
		<span class="n">tmp16</span> <span class="o">=</span> <span class="n">GxICR</span><span class="p">(</span><span class="n">DEBUGGER_NMI_IPI</span><span class="p">);</span>
		<span class="n">arch_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * start_secondary - Activate a secondary CPU (AP)</span>
<span class="cm"> * @unused: Thread parameter (ignored).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">start_secondary</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_cpu_init</span><span class="p">();</span>
	<span class="n">smp_callin</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">smp_commenced_mask</span><span class="p">))</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="n">local_flush_tlb</span><span class="p">();</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">smp_online</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_GENERIC_CLOCKEVENTS</span>
	<span class="n">init_clockevents</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">cpu_idle</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_prepare_cpus - Boot up secondary CPUs (APs)</span>
<span class="cm"> * @max_cpus: Maximum number of CPUs to boot.</span>
<span class="cm"> *</span>
<span class="cm"> * Call do_boot_cpu, and boot up APs.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_prepare_cpus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">phy_id</span><span class="p">;</span>

	<span class="cm">/* Setup boot CPU information */</span>
	<span class="n">smp_store_cpu_info</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">smp_tune_scheduling</span><span class="p">();</span>

	<span class="n">init_ipi</span><span class="p">();</span>

	<span class="cm">/* If SMP should be disabled, then finish */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_cpus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SMP mode deactivated.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">smp_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Boot secondary CPUs (for which phy_id &gt; 0) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">phy_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">phy_id</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">phy_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Don&#39;t boot primary CPU */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_cpus</span> <span class="o">&lt;=</span> <span class="n">cpucount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phy_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">do_boot_cpu</span><span class="p">(</span><span class="n">phy_id</span><span class="p">);</span>
		<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">phy_id</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">smp_show_cpu_info</span><span class="p">(</span><span class="n">phy_id</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">smp_done:</span>
	<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;Boot done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_store_cpu_info - Save a CPU&#39;s information</span>
<span class="cm"> * @cpu: The CPU to save for.</span>
<span class="cm"> *</span>
<span class="cm"> * Save boot_cpu_data and jiffy for the specified CPU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_store_cpu_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mn10300_cpuinfo</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">boot_cpu_data</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">loops_per_jiffy</span> <span class="o">=</span> <span class="n">loops_per_jiffy</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">CPUREV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_tune_scheduling - Set time slice value</span>
<span class="cm"> *</span>
<span class="cm"> * Nothing to do here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_tune_scheduling</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_boot_cpu: Boot up one CPU</span>
<span class="cm"> * @phy_id: Physical ID of CPU to boot.</span>
<span class="cm"> *</span>
<span class="cm"> * Send an IPI to a secondary CPU to boot it.  Returns 0 on success, 1</span>
<span class="cm"> * otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">do_boot_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">phy_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">send_status</span><span class="p">,</span> <span class="n">callin_status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">;</span>

	<span class="n">send_status</span> <span class="o">=</span> <span class="n">GxICR_REQUEST</span><span class="p">;</span>
	<span class="n">callin_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpu_id</span> <span class="o">=</span> <span class="n">phy_id</span><span class="p">;</span>

	<span class="n">cpucount</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Create idle thread for this CPU */</span>
	<span class="n">idle</span> <span class="o">=</span> <span class="n">fork_idle</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">idle</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Failed fork for CPU#%d.&quot;</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>

	<span class="n">idle</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">pc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start_secondary</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Booting CPU#%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>
	<span class="n">start_stack</span><span class="p">[</span><span class="n">cpu_id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">idle</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sp</span><span class="p">;</span>

	<span class="n">task_thread_info</span><span class="p">(</span><span class="n">idle</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu_id</span><span class="p">;</span>

	<span class="cm">/* Send boot IPI to AP */</span>
	<span class="n">send_IPI_mask</span><span class="p">(</span><span class="n">cpumask_of</span><span class="p">(</span><span class="n">phy_id</span><span class="p">),</span> <span class="n">SMP_BOOT_IRQ</span><span class="p">);</span>

	<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;Waiting for send to finish...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Wait for AP&#39;s IPI receive in 100[ms] */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
		<span class="n">send_status</span> <span class="o">=</span>
			<span class="n">CROSS_GxICR</span><span class="p">(</span><span class="n">SMP_BOOT_IRQ</span><span class="p">,</span> <span class="n">phy_id</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">GxICR_REQUEST</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">send_status</span> <span class="o">==</span> <span class="n">GxICR_REQUEST</span> <span class="o">&amp;&amp;</span> <span class="n">timeout</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">);</span>

	<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;Waiting for cpu_callin_map.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">send_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Allow AP to start initializing */</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callout_map</span><span class="p">);</span>

		<span class="cm">/* Wait for setting cpu_callin_map */</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
			<span class="n">callin_status</span> <span class="o">=</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">cpu_callin_map</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">callin_status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">timeout</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">callin_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;Not responding.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;IPI not delivered.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">send_status</span> <span class="o">==</span> <span class="n">GxICR_REQUEST</span> <span class="o">||</span> <span class="n">callin_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callout_map</span><span class="p">);</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callin_map</span><span class="p">);</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_initialized</span><span class="p">);</span>
		<span class="n">cpucount</span><span class="o">--</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_show_cpu_info - Show SMP CPU information</span>
<span class="cm"> * @cpu: The CPU of interest.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_show_cpu_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mn10300_cpuinfo</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
	       <span class="s">&quot;CPU#%d : ioclk speed: %lu.%02luMHz : bogomips : %lu.%02lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">cpu</span><span class="p">,</span>
	       <span class="n">MN10300_IOCLK</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">MN10300_IOCLK</span> <span class="o">/</span> <span class="mi">10000</span><span class="p">)</span> <span class="o">%</span> <span class="mi">100</span><span class="p">,</span>
	       <span class="n">ci</span><span class="o">-&gt;</span><span class="n">loops_per_jiffy</span> <span class="o">/</span> <span class="p">(</span><span class="mi">500000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">loops_per_jiffy</span> <span class="o">/</span> <span class="p">(</span><span class="mi">5000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">))</span> <span class="o">%</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_callin - Set cpu_callin_map of the current CPU ID</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_callin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callin_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;CPU#%d already present.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;CPU#%d waiting for CALLOUT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/* Wait for AP startup 2s total */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callout_map</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;BUG: CPU#%d started up but did not get a callout!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">cpu</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CALIBRATE_DELAY</span>
	<span class="n">calibrate_delay</span><span class="p">();</span>		<span class="cm">/* Get our bogomips */</span>
<span class="cp">#endif</span>

	<span class="cm">/* Save our processor parameters */</span>
	<span class="n">smp_store_cpu_info</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/* Allow the boot processor to continue */</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callin_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_online - Set cpu_online_mask</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_online</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">notify_cpu_starting</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">ipi_call_lock</span><span class="p">();</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">ipi_call_unlock</span><span class="p">();</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * smp_cpus_done -</span>
<span class="cm"> * @max_cpus: Maximum CPU count.</span>
<span class="cm"> *</span>
<span class="cm"> * Do nothing.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_cpus_done</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * smp_prepare_boot_cpu - Set up stuff for the boot processor.</span>
<span class="cm"> *</span>
<span class="cm"> * Set up the cpu_online_mask, cpu_callout_map and cpu_callin_map of the boot</span>
<span class="cm"> * processor (CPU 0).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">smp_prepare_boot_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callout_map</span><span class="p">);</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callin_map</span><span class="p">);</span>
	<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * initialize_secondary - Initialise a secondary CPU (Application Processor).</span>
<span class="cm"> *</span>
<span class="cm"> * Set SP register and jump to thread&#39;s PC address.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">initialize_secondary</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span>
		<span class="s">&quot;mov	%0,sp	</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;jmp	(%1)	</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="o">:</span>
		<span class="o">:</span> <span class="s">&quot;a&quot;</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sp</span><span class="p">),</span> <span class="s">&quot;a&quot;</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">pc</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __cpu_up - Set smp_commenced_mask for the nominated CPU</span>
<span class="cm"> * @cpu: The target CPU.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">__cpu_up</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tidle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">disable_hlt</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sleep_mode</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span>
		<span class="n">run_wakeup_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smp_commenced_mask</span><span class="p">);</span>

	<span class="cm">/* Wait 5s total for a response */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">5000</span> <span class="p">;</span> <span class="n">timeout</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * setup_profiling_timer - Set up the profiling timer</span>
<span class="cm"> * @multiplier - The frequency multiplier to use</span>
<span class="cm"> *</span>
<span class="cm"> * The frequency of the profiling timer can be changed by writing a multiplier</span>
<span class="cm"> * value into /proc/profile.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">setup_profiling_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">multiplier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * CPU hotplug routines</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_devices</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">topology_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">register_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_devices</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span> <span class="n">cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;topology_init: register_cpu %d failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">cpu</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">topology_init</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__cpu_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">migrate_irqs</span><span class="p">();</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm_cpumask</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__cpu_die</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">run_sleep_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">enable_hlt</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MN10300_CACHE_ENABLED</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hotplug_cpu_disable_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
		<span class="s">&quot;	movhu	(%1),%0	</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	and	%2,%0	</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	movhu	%0,(%1)	</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;1:	movhu	(%1),%0	</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	btst	%3,%0	</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	bne	1b	</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;a&quot;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CHCTR</span><span class="p">),</span>
		  <span class="s">&quot;i&quot;</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">CHCTR_ICEN</span> <span class="o">|</span> <span class="n">CHCTR_DCEN</span><span class="p">)),</span>
		  <span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">CHCTR_ICBUSY</span> <span class="o">|</span> <span class="n">CHCTR_DCBUSY</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">,</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hotplug_cpu_enable_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
		<span class="s">&quot;movhu	(%1),%0	</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;or	%2,%0	</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;movhu	%0,(%1)	</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;a&quot;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CHCTR</span><span class="p">),</span>
		  <span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">CHCTR_ICEN</span> <span class="o">|</span> <span class="n">CHCTR_DCEN</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">,</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hotplug_cpu_invalidate_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span>
		<span class="s">&quot;movhu	(%1),%0	</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;or	%2,%0	</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;movhu	%0,(%1)	</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;a&quot;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CHCTR</span><span class="p">),</span>
		  <span class="s">&quot;i&quot;</span><span class="p">(</span><span class="n">CHCTR_ICINV</span> <span class="o">|</span> <span class="n">CHCTR_DCINV</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_MN10300_CACHE_ENABLED */</span><span class="cp"></span>
<span class="cp">#define hotplug_cpu_disable_cache()	do {} while (0)</span>
<span class="cp">#define hotplug_cpu_enable_cache()	do {} while (0)</span>
<span class="cp">#define hotplug_cpu_invalidate_cache()	do {} while (0)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MN10300_CACHE_ENABLED */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * hotplug_cpu_nmi_call_function - Call a function on other CPUs for hotplug</span>
<span class="cm"> * @cpumask: List of target CPUs.</span>
<span class="cm"> * @func: The function to call on those CPUs.</span>
<span class="cm"> * @info: The context data for the function to be called.</span>
<span class="cm"> * @wait: Whether to wait for the calls to complete.</span>
<span class="cm"> *</span>
<span class="cm"> * Non-maskably call a function on another CPU for hotplug purposes.</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be called with maskable interrupts disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hotplug_cpu_nmi_call_function</span><span class="p">(</span><span class="n">cpumask_t</span> <span class="n">cpumask</span><span class="p">,</span>
					 <span class="n">smp_call_func_t</span> <span class="n">func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The address and the size of nmi_call_func_mask_data</span>
<span class="cm">	 * need to be aligned on L1_CACHE_BYTES.</span>
<span class="cm">	 */</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">nmi_call_data_struct</span> <span class="n">nmi_call_func_mask_data</span>
		<span class="n">__cacheline_aligned</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nmi_call_func_mask_data</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nmi_call_data_struct</span><span class="p">);</span>

	<span class="n">nmi_call_func_mask_data</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
	<span class="n">nmi_call_func_mask_data</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">nmi_call_func_mask_data</span><span class="p">.</span><span class="n">started</span> <span class="o">=</span> <span class="n">cpumask</span><span class="p">;</span>
	<span class="n">nmi_call_func_mask_data</span><span class="p">.</span><span class="n">wait</span> <span class="o">=</span> <span class="n">wait</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span>
		<span class="n">nmi_call_func_mask_data</span><span class="p">.</span><span class="n">finished</span> <span class="o">=</span> <span class="n">cpumask</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smp_nmi_call_lock</span><span class="p">);</span>
	<span class="n">nmi_call_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nmi_call_func_mask_data</span><span class="p">;</span>
	<span class="n">mn10300_local_dcache_flush_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="n">send_IPI_mask</span><span class="p">(</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">CALL_FUNCTION_NMI_IPI</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">mn10300_local_dcache_inv_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmi_call_func_mask_data</span><span class="p">.</span><span class="n">started</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">mn10300_local_dcache_inv_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
			<span class="n">barrier</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmi_call_func_mask_data</span><span class="p">.</span><span class="n">finished</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smp_nmi_call_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">restart_wakeup_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_callin_map</span><span class="p">);</span>
	<span class="n">local_flush_tlb</span><span class="p">();</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">prepare_sleep_cpu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sleep_mode</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="n">mn10300_local_dcache_flush_inv</span><span class="p">();</span>
	<span class="n">hotplug_cpu_disable_cache</span><span class="p">();</span>
	<span class="n">hotplug_cpu_invalidate_cache</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* when this function called, IE=0, NMID=0. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sleep_cpu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * CALL_FUNCTION_NMI_IPI for wakeup_cpu() shall not be requested,</span>
<span class="cm">	 * before this cpu goes in SLEEP mode.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="n">__sleep_cpu</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">sleep_mode</span><span class="p">[</span><span class="n">cpu_id</span><span class="p">]);</span>
	<span class="n">restart_wakeup_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">run_sleep_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">cpumask_t</span> <span class="n">cpumask</span><span class="p">;</span>

	<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpumask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">arch_local_cli_save</span><span class="p">();</span>
	<span class="n">hotplug_cpu_nmi_call_function</span><span class="p">(</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">prepare_sleep_cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">hotplug_cpu_nmi_call_function</span><span class="p">(</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">sleep_cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>		<span class="cm">/* delay for the cpu to sleep. */</span>
	<span class="n">arch_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wakeup_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hotplug_cpu_invalidate_cache</span><span class="p">();</span>
	<span class="n">hotplug_cpu_enable_cache</span><span class="p">();</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="n">sleep_mode</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">run_wakeup_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">arch_local_cli_save</span><span class="p">();</span>
<span class="cp">#if NR_CPUS == 2</span>
	<span class="n">mn10300_local_dcache_flush_inv</span><span class="p">();</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * Before waking up the cpu,</span>
<span class="cm">	 * all online cpus should stop and flush D-Cache for global data.</span>
<span class="cm">	 */</span>
<span class="cp">#error not support NR_CPUS &gt; 2, when CONFIG_HOTPLUG_CPU=y.</span>
<span class="cp">#endif</span>
	<span class="n">hotplug_cpu_nmi_call_function</span><span class="p">(</span><span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">wakeup_cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">arch_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
