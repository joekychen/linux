<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › kernel › process.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>process.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/preempt.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;linux/elfcore.h&gt;</span>
<span class="cp">#include &lt;linux/tick.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/tracehook.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;asm/stack.h&gt;</span>
<span class="cp">#include &lt;asm/switch_to.h&gt;</span>
<span class="cp">#include &lt;asm/homecache.h&gt;</span>
<span class="cp">#include &lt;asm/syscalls.h&gt;</span>
<span class="cp">#include &lt;asm/traps.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#ifdef CONFIG_HARDWALL</span>
<span class="cp">#include &lt;asm/hardwall.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;arch/chip.h&gt;</span>
<span class="cp">#include &lt;arch/abi.h&gt;</span>
<span class="cp">#include &lt;arch/sim_def.h&gt;</span>


<span class="cm">/*</span>
<span class="cm"> * Use the (x86) &quot;idle=poll&quot; option to prefer low latency when leaving the</span>
<span class="cm"> * idle loop over low power while in the idle loop, e.g. if we have</span>
<span class="cm"> * one thread per core and we want to get threads out of futex waits fast.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">no_idle_nap</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">idle_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;poll&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;using polling idle threads.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">no_idle_nap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;halt&quot;</span><span class="p">))</span>
		<span class="n">no_idle_nap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;idle&quot;</span><span class="p">,</span> <span class="n">idle_setup</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The idle thread. There&#39;s no useful work to be</span>
<span class="cm"> * done, so just try to conserve power and have a</span>
<span class="cm"> * low exit latency (ie sit in a loop waiting for</span>
<span class="cm"> * somebody to say that they&#39;d like to reschedule)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cpu_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>


	<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">TS_POLLING</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">no_idle_nap</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span>
				<span class="n">cpu_relax</span><span class="p">();</span>
			<span class="n">schedule</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* endless idle loop with no priority at all */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tick_nohz_idle_enter</span><span class="p">();</span>
		<span class="n">rcu_idle_enter</span><span class="p">();</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_offline</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
				<span class="n">BUG</span><span class="p">();</span>  <span class="cm">/* no HOTPLUG_CPU */</span>

			<span class="n">local_irq_disable</span><span class="p">();</span>
			<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">irq_stat</span><span class="p">).</span><span class="n">idle_timestamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TS_POLLING</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * TS_POLLING-cleared state must be visible before we</span>
<span class="cm">			 * test NEED_RESCHED:</span>
<span class="cm">			 */</span>
			<span class="n">smp_mb</span><span class="p">();</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span>
				<span class="n">_cpu_idle</span><span class="p">();</span>
			<span class="k">else</span>
				<span class="n">local_irq_enable</span><span class="p">();</span>
			<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">TS_POLLING</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rcu_idle_exit</span><span class="p">();</span>
		<span class="n">tick_nohz_idle_exit</span><span class="p">();</span>
		<span class="n">schedule_preempt_disabled</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release a thread_info structure</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">arch_release_thread_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">single_step_state</span> <span class="o">*</span><span class="n">step_state</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">step_state</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HARDWALL</span>
	<span class="cm">/*</span>
<span class="cm">	 * We free a thread_info from the context of the task that has</span>
<span class="cm">	 * been scheduled next, so the original task is already dead.</span>
<span class="cm">	 * Calling deactivate here just frees up the data structures.</span>
<span class="cm">	 * If the task we&#39;re freeing held the last reference to a</span>
<span class="cm">	 * hardwall fd, it would have been released prior to this point</span>
<span class="cm">	 * anyway via exit_files(), and the hardwall_task.info pointers</span>
<span class="cm">	 * would be NULL by now.</span>
<span class="cm">	 */</span>
	<span class="n">hardwall_deactivate_all</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">step_state</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * FIXME: we don&#39;t munmap step_state-&gt;buffer</span>
<span class="cm">		 * because the mm_struct for this process (info-&gt;task-&gt;mm)</span>
<span class="cm">		 * has already been zeroed in exit_mm().  Keeping a</span>
<span class="cm">		 * reference to it here seems like a bad move, so this</span>
<span class="cm">		 * means we can&#39;t munmap() the buffer, and therefore if we</span>
<span class="cm">		 * ptrace multiple threads in a process, we will slowly</span>
<span class="cm">		 * leak user memory.  (Note that as soon as the last</span>
<span class="cm">		 * thread in a process dies, we will reclaim all user</span>
<span class="cm">		 * memory including single-step buffers in the usual way.)</span>
<span class="cm">		 * We should either assign a kernel VA to this buffer</span>
<span class="cm">		 * somehow, or we should associate the buffer(s) with the</span>
<span class="cm">		 * mm itself so we can clean them up that way.</span>
<span class="cm">		 */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">step_state</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">save_arch_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">copy_thread</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_size</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">childregs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ksp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When creating a new kernel thread we pass sp as zero.</span>
<span class="cm">	 * Assign it to a reasonable value now that we have the stack.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ex1</span> <span class="o">==</span> <span class="n">PL_ICS_EX1</span><span class="p">(</span><span class="n">KERNEL_PL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="n">KSTK_TOP</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do not clone step state from the parent; each thread</span>
<span class="cm">	 * must make its own lazily.</span>
<span class="cm">	 */</span>
	<span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">step_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start new thread in ret_from_fork so it schedules properly</span>
<span class="cm">	 * and then return from interrupt like the parent.</span>
<span class="cm">	 */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">pc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ret_from_fork</span><span class="p">;</span>

	<span class="cm">/* Save user stack top pointer so we can ID the stack vm area later. */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">usp0</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>

	<span class="cm">/* Record the pid of the process that created this one. */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">creator_pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the registers onto the kernel stack so the</span>
<span class="cm">	 * return-from-interrupt code will reload it into registers.</span>
<span class="cm">	 */</span>
	<span class="n">childregs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="o">*</span><span class="n">childregs</span> <span class="o">=</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">childregs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         <span class="cm">/* return value is zero */</span>
	<span class="n">childregs</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>  <span class="cm">/* override with new user stack pointer */</span>

	<span class="cm">/*</span>
<span class="cm">	 * If CLONE_SETTLS is set, set &quot;tp&quot; in the new task to &quot;r4&quot;,</span>
<span class="cm">	 * which is passed in as arg #5 to sys_clone().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_SETTLS</span><span class="p">)</span>
		<span class="n">childregs</span><span class="o">-&gt;</span><span class="n">tp</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the callee-saved registers from the passed pt_regs struct</span>
<span class="cm">	 * into the context-switch callee-saved registers area.</span>
<span class="cm">	 * This way when we start the interrupt-return sequence, the</span>
<span class="cm">	 * callee-save registers will be correctly in registers, which</span>
<span class="cm">	 * is how we assume the compiler leaves them as we start doing</span>
<span class="cm">	 * the normal return-from-interrupt path after calling C code.</span>
<span class="cm">	 * Zero out the C ABI save area to mark the top of the stack.</span>
<span class="cm">	 */</span>
	<span class="n">ksp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">childregs</span><span class="p">;</span>
	<span class="n">ksp</span> <span class="o">-=</span> <span class="n">C_ABI_SAVE_AREA_SIZE</span><span class="p">;</span>   <span class="cm">/* interrupt-entry save area */</span>
	<span class="p">((</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">ksp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">ksp</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ksp</span> <span class="o">-=</span> <span class="n">CALLEE_SAVED_REGS_COUNT</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ksp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">CALLEE_SAVED_FIRST_REG</span><span class="p">],</span>
	       <span class="n">CALLEE_SAVED_REGS_COUNT</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>
	<span class="n">ksp</span> <span class="o">-=</span> <span class="n">C_ABI_SAVE_AREA_SIZE</span><span class="p">;</span>   <span class="cm">/* __switch_to() save area */</span>
	<span class="p">((</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">ksp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">ksp</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">ksp</span> <span class="o">=</span> <span class="n">ksp</span><span class="p">;</span>

<span class="cp">#if CHIP_HAS_TILE_DMA()</span>
	<span class="cm">/*</span>
<span class="cm">	 * No DMA in the new thread.  We model this on the fact that</span>
<span class="cm">	 * fork() clears the pending signals, alarms, and aio for the child.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">tile_dma_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_dma_state</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dma_async_tlb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">async_tlb</span><span class="p">));</span>
<span class="cp">#endif</span>

<span class="cp">#if CHIP_HAS_SN_PROC()</span>
	<span class="cm">/* Likewise, the new thread is not running static processor code. */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sn_proc_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sn_async_tlb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">async_tlb</span><span class="p">));</span>
<span class="cp">#endif</span>

<span class="cp">#if CHIP_HAS_PROC_STATUS_SPR()</span>
	<span class="cm">/* New thread has its miscellaneous processor state bits clear. */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">proc_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HARDWALL</span>
	<span class="cm">/* New thread does not own any networks. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">hardwall</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_task</span><span class="p">)</span> <span class="o">*</span> <span class="n">HARDWALL_TYPES</span><span class="p">);</span>
<span class="cp">#endif</span>


	<span class="cm">/*</span>
<span class="cm">	 * Start the new thread with the current architecture state</span>
<span class="cm">	 * (user interrupt masks, etc.).</span>
<span class="cm">	 */</span>
	<span class="n">save_arch_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return &quot;current&quot; if it looks plausible, or else a pointer to a dummy.</span>
<span class="cm"> * This can be helpful if we are just trying to emit a clean panic.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">validate_current</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="n">corrupt</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">comm</span> <span class="o">=</span> <span class="s">&quot;&lt;corrupt&gt;&quot;</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tsk</span> <span class="o">&lt;</span> <span class="n">PAGE_OFFSET</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">high_memory</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">tsk</span> <span class="o">&gt;</span> <span class="n">high_memory</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tsk</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__alignof__</span><span class="p">(</span><span class="o">*</span><span class="n">tsk</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Corrupt &#39;current&#39; %p (sp %#lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="n">stack_pointer</span><span class="p">);</span>
		<span class="n">tsk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">corrupt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">tsk</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Take and return the pointer to the previous task, for schedule_tail(). */</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">sim_notify_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_SIM_CONTROL</span><span class="p">,</span> <span class="n">SIM_CONTROL_OS_FORK_PARENT</span> <span class="o">|</span>
		     <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">creator_pid</span> <span class="o">&lt;&lt;</span> <span class="n">_SIM_CONTROL_OPERATOR_BITS</span><span class="p">));</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_SIM_CONTROL</span><span class="p">,</span> <span class="n">SIM_CONTROL_OS_FORK</span> <span class="o">|</span>
		     <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">&lt;&lt;</span> <span class="n">_SIM_CONTROL_OPERATOR_BITS</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dump_task_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="n">elf_gregset_t</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">ptregs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">elf_core_copy_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">ptregs</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if CHIP_HAS_TILE_DMA()</span>

<span class="cm">/* Allow user processes to access the DMA SPRs */</span>
<span class="kt">void</span> <span class="nf">grant_dma_mpls</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if CONFIG_KERNEL_PL == 2</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_DMA_CPL_SET_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_DMA_NOTIFY_SET_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_DMA_CPL_SET_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_DMA_NOTIFY_SET_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Forbid user processes from accessing the DMA SPRs */</span>
<span class="kt">void</span> <span class="nf">restrict_dma_mpls</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if CONFIG_KERNEL_PL == 2</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_DMA_CPL_SET_2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_DMA_NOTIFY_SET_2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_DMA_CPL_SET_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_DMA_NOTIFY_SET_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Pause the DMA engine, then save off its state registers. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">save_tile_dma_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">tile_dma_state</span> <span class="o">*</span><span class="n">dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_DMA_USER_STATUS</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">post_suspend_state</span><span class="p">;</span>

	<span class="cm">/* If we&#39;re running, suspend the engine. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DMA_STATUS_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SPR_DMA_STATUS__RUNNING_MASK</span><span class="p">)</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_DMA_CTR</span><span class="p">,</span> <span class="n">SPR_DMA_CTR__SUSPEND_MASK</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for the engine to idle, then save regs.  Note that we</span>
<span class="cm">	 * want to record the &quot;running&quot; bit from before suspension,</span>
<span class="cm">	 * and the &quot;done&quot; bit from after, so that we can properly</span>
<span class="cm">	 * distinguish a case where the user suspended the engine from</span>
<span class="cm">	 * the case where the kernel suspended as part of the context</span>
<span class="cm">	 * swap.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">post_suspend_state</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_DMA_USER_STATUS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">post_suspend_state</span> <span class="o">&amp;</span> <span class="n">SPR_DMA_STATUS__BUSY_MASK</span><span class="p">);</span>

	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">src</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_DMA_SRC_ADDR</span><span class="p">);</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">src_chunk</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_DMA_SRC_CHUNK_ADDR</span><span class="p">);</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">dest</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_DMA_DST_ADDR</span><span class="p">);</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">dest_chunk</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_DMA_DST_CHUNK_ADDR</span><span class="p">);</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">strides</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_DMA_STRIDE</span><span class="p">);</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">chunk_size</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_DMA_CHUNK_SIZE</span><span class="p">);</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">byte</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_DMA_BYTE</span><span class="p">);</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">SPR_DMA_STATUS__RUNNING_MASK</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">post_suspend_state</span> <span class="o">&amp;</span> <span class="n">SPR_DMA_STATUS__DONE_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Restart a DMA that was running before we were context-switched out. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">restore_tile_dma_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tile_dma_state</span> <span class="o">*</span><span class="n">dma</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">tile_dma_state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The only way to restore the done bit is to run a zero</span>
<span class="cm">	 * length transaction.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SPR_DMA_STATUS__DONE_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_DMA_USER_STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SPR_DMA_STATUS__DONE_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_DMA_BYTE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_DMA_CTR</span><span class="p">,</span> <span class="n">SPR_DMA_CTR__REQUEST_MASK</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_DMA_USER_STATUS</span><span class="p">)</span> <span class="o">&amp;</span>
		       <span class="n">SPR_DMA_STATUS__BUSY_MASK</span><span class="p">)</span>
			<span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_DMA_SRC_ADDR</span><span class="p">,</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_DMA_SRC_CHUNK_ADDR</span><span class="p">,</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">src_chunk</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_DMA_DST_ADDR</span><span class="p">,</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_DMA_DST_CHUNK_ADDR</span><span class="p">,</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">dest_chunk</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_DMA_STRIDE</span><span class="p">,</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">strides</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_DMA_CHUNK_SIZE</span><span class="p">,</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">chunk_size</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_DMA_BYTE</span><span class="p">,</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">byte</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restart the engine if we were running and not done.</span>
<span class="cm">	 * Clear a pending async DMA fault that we were waiting on return</span>
<span class="cm">	 * to user space to execute, since we expect the DMA engine</span>
<span class="cm">	 * to regenerate those faults for us now.  Note that we don&#39;t</span>
<span class="cm">	 * try to clear the TIF_ASYNC_TLB flag, since it&#39;s relatively</span>
<span class="cm">	 * harmless if set, and it covers both DMA and the SN processor.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">DMA_STATUS_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SPR_DMA_STATUS__RUNNING_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">dma_async_tlb</span><span class="p">.</span><span class="n">fault_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_DMA_CTR</span><span class="p">,</span> <span class="n">SPR_DMA_CTR__REQUEST_MASK</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">save_arch_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if CHIP_HAS_SPLIT_INTR_MASK()</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_INTERRUPT_MASK_0_0</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_INTERRUPT_MASK_0_1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_INTERRUPT_MASK_0</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">ex_context</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_EX_CONTEXT_0_0</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">ex_context</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_EX_CONTEXT_0_1</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">system_save</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_SYSTEM_SAVE_0_0</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">system_save</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_SYSTEM_SAVE_0_1</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">system_save</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_SYSTEM_SAVE_0_2</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">system_save</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_SYSTEM_SAVE_0_3</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">intctrl_0</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_INTCTRL_0_STATUS</span><span class="p">);</span>
<span class="cp">#if CHIP_HAS_PROC_STATUS_SPR()</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">proc_status</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_PROC_STATUS</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if !CHIP_HAS_FIXED_INTVEC_BASE()</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">interrupt_vector_base</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_INTERRUPT_VECTOR_BASE_0</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_TILE_RTF_HWM()</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tile_rtf_hwm</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_TILE_RTF_HWM</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_DSTREAM_PF()</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">dstream_pf</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_DSTREAM_PF</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">restore_arch_state</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if CHIP_HAS_SPLIT_INTR_MASK()</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_INTERRUPT_MASK_0_0</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_INTERRUPT_MASK_0_1</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_INTERRUPT_MASK_0</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_EX_CONTEXT_0_0</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">ex_context</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_EX_CONTEXT_0_1</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">ex_context</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_SYSTEM_SAVE_0_0</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">system_save</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_SYSTEM_SAVE_0_1</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">system_save</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_SYSTEM_SAVE_0_2</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">system_save</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_SYSTEM_SAVE_0_3</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">system_save</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_INTCTRL_0_STATUS</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">intctrl_0</span><span class="p">);</span>
<span class="cp">#if CHIP_HAS_PROC_STATUS_SPR()</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_PROC_STATUS</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">proc_status</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if !CHIP_HAS_FIXED_INTVEC_BASE()</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_INTERRUPT_VECTOR_BASE_0</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">interrupt_vector_base</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_TILE_RTF_HWM()</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_TILE_RTF_HWM</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">tile_rtf_hwm</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_DSTREAM_PF()</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_DSTREAM_PF</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">dstream_pf</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">_prepare_arch_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if CHIP_HAS_SN_PROC()</span>
	<span class="kt">int</span> <span class="n">snctl</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_TILE_DMA()</span>
	<span class="k">struct</span> <span class="n">tile_dma_state</span> <span class="o">*</span><span class="n">dma</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">tile_dma_state</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="n">save_tile_dma_state</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_SN_PROC()</span>
	<span class="cm">/*</span>
<span class="cm">	 * Suspend the static network processor if it was running.</span>
<span class="cm">	 * We do not suspend the fabric itself, just like we don&#39;t</span>
<span class="cm">	 * try to suspend the UDN.</span>
<span class="cm">	 */</span>
	<span class="n">snctl</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_SNCTL</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sn_proc_running</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">snctl</span> <span class="o">&amp;</span> <span class="n">SPR_SNCTL__FRZPROC_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sn_proc_running</span><span class="p">)</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_SNCTL</span><span class="p">,</span> <span class="n">snctl</span> <span class="o">|</span> <span class="n">SPR_SNCTL__FRZPROC_MASK</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">__sched</span> <span class="nf">_switch_to</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* DMA state is already saved; save off other arch state. */</span>
	<span class="n">save_arch_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>

<span class="cp">#if CHIP_HAS_TILE_DMA()</span>
	<span class="cm">/*</span>
<span class="cm">	 * Restore DMA in new task if desired.</span>
<span class="cm">	 * Note that it is only safe to restart here since interrupts</span>
<span class="cm">	 * are disabled, so we can&#39;t take any DMATLB miss or access</span>
<span class="cm">	 * interrupts before we have finished switching stacks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">tile_dma_state</span><span class="p">.</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">restore_tile_dma_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
		<span class="n">grant_dma_mpls</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">restrict_dma_mpls</span><span class="p">();</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Restore other arch state. */</span>
	<span class="n">restore_arch_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>

<span class="cp">#if CHIP_HAS_SN_PROC()</span>
	<span class="cm">/*</span>
<span class="cm">	 * Restart static network processor in the new process</span>
<span class="cm">	 * if it was running before.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sn_proc_running</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">snctl</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_SNCTL</span><span class="p">);</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_SNCTL</span><span class="p">,</span> <span class="n">snctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPR_SNCTL__FRZPROC_MASK</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HARDWALL</span>
	<span class="cm">/* Enable or disable access to the network registers appropriately. */</span>
	<span class="n">hardwall_switch_tasks</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Switch kernel SP, PC, and callee-saved registers.</span>
<span class="cm">	 * In the context of the new task, return the old task pointer</span>
<span class="cm">	 * (i.e. the task that actually called __switch_to).</span>
<span class="cm">	 * Pass the value to use for SYSTEM_SAVE_K_0 when we reset our sp.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">__switch_to</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">next_current_ksp0</span><span class="p">(</span><span class="n">next</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine is called on return from interrupt if any of the</span>
<span class="cm"> * TIF_WORK_MASK flags are set in thread_info-&gt;flags.  It is</span>
<span class="cm"> * entered with interrupts disabled so we don&#39;t miss an event</span>
<span class="cm"> * that modified the thread_info flags.  If any flag is set, we</span>
<span class="cm"> * handle it and return, and the calling assembly code will</span>
<span class="cm"> * re-disable interrupts, reload the thread flags, and call back</span>
<span class="cm"> * if more flags need to be handled.</span>
<span class="cm"> *</span>
<span class="cm"> * We return whether we need to check the thread_info flags again</span>
<span class="cm"> * or not.  Note that we don&#39;t clear TIF_SINGLESTEP here, so it&#39;s</span>
<span class="cm"> * important that it be tested last, and then claim that we don&#39;t</span>
<span class="cm"> * need to recheck the flags.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">do_work_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">thread_info_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If we enter in kernel mode, do nothing and exit the caller loop. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">thread_info_flags</span> <span class="o">&amp;</span> <span class="n">_TIF_NEED_RESCHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if CHIP_HAS_TILE_DMA() || CHIP_HAS_SN_PROC()</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thread_info_flags</span> <span class="o">&amp;</span> <span class="n">_TIF_ASYNC_TLB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_async_page_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thread_info_flags</span> <span class="o">&amp;</span> <span class="n">_TIF_SIGPENDING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_signal</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thread_info_flags</span> <span class="o">&amp;</span> <span class="n">_TIF_NOTIFY_RESUME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_thread_flag</span><span class="p">(</span><span class="n">TIF_NOTIFY_RESUME</span><span class="p">);</span>
		<span class="n">tracehook_notify_resume</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thread_info_flags</span> <span class="o">&amp;</span> <span class="n">_TIF_SINGLESTEP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">single_step_once</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;work_pending: bad flags %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">thread_info_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Note there is an implicit fifth argument if (clone_flags &amp; CLONE_SETTLS). */</span>
<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">clone</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">newsp</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">parent_tidptr</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">child_tidptr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">,</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newsp</span><span class="p">)</span>
		<span class="n">newsp</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">do_fork</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">newsp</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="n">parent_tidptr</span><span class="p">,</span> <span class="n">child_tidptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sys_execve() executes a new program.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">execve</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="k">const</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="k">const</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">envp</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">,</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>

	<span class="n">filename</span> <span class="o">=</span> <span class="n">getname</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">do_execve</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">single_step_execve</span><span class="p">();</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="kt">long</span> <span class="n">compat_sys_execve</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
		       <span class="n">compat_uptr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argv</span><span class="p">,</span>
		       <span class="n">compat_uptr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">envp</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>

	<span class="n">filename</span> <span class="o">=</span> <span class="n">getname</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">compat_do_execve</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">single_step_execve</span><span class="p">();</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_wchan</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">KBacktraceIterator</span> <span class="n">kbt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="n">p</span> <span class="o">==</span> <span class="n">current</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_RUNNING</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">KBacktraceIterator_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kbt</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	     <span class="o">!</span><span class="n">KBacktraceIterator_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kbt</span><span class="p">);</span>
	     <span class="n">KBacktraceIterator_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kbt</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_sched_functions</span><span class="p">(</span><span class="n">kbt</span><span class="p">.</span><span class="n">it</span><span class="p">.</span><span class="n">pc</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">kbt</span><span class="p">.</span><span class="n">it</span><span class="p">.</span><span class="n">pc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We pass in lr as zero (cleared in kernel_thread) and the caller</span>
<span class="cm"> * part of the backtrace ABI on the stack also zeroed (in copy_thread)</span>
<span class="cm"> * so that backtraces will stop with this function.</span>
<span class="cm"> * Note that we don&#39;t use r0, since copy_thread() clears it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">start_kernel_thread</span><span class="p">(</span><span class="kt">int</span> <span class="n">dummy</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span> <span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">do_exit</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create a kernel thread</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">kernel_thread</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="n">regs</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">ex1</span> <span class="o">=</span> <span class="n">PL_ICS_EX1</span><span class="p">(</span><span class="n">KERNEL_PL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="cm">/* run at kernel PL, no ICS */</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">pc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">start_kernel_thread</span><span class="p">;</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">PT_FLAGS_CALLER_SAVES</span><span class="p">;</span>   <span class="cm">/* need to restore r1 and r2 */</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">fn</span><span class="p">;</span>             <span class="cm">/* function pointer */</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>            <span class="cm">/* parameter register */</span>

	<span class="cm">/* Ok, create the new process.. */</span>
	<span class="k">return</span> <span class="n">do_fork</span><span class="p">(</span><span class="n">flags</span> <span class="o">|</span> <span class="n">CLONE_VM</span> <span class="o">|</span> <span class="n">CLONE_UNTRACED</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">,</span>
		       <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_thread</span><span class="p">);</span>

<span class="cm">/* Flush thread state. */</span>
<span class="kt">void</span> <span class="nf">flush_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Nothing */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free current thread data structures etc..</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">exit_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Nothing */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">show_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">validate_current</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot; Pid: %d, comm: %20s, CPU: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
<span class="cp">#ifdef __tilegx__</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">51</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot; r%-2d: &quot;</span><span class="n">REGFMT</span><span class="s">&quot; r%-2d: &quot;</span><span class="n">REGFMT</span><span class="s">&quot; r%-2d: &quot;</span><span class="n">REGFMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">i</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
		       <span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot; r51: &quot;</span><span class="n">REGFMT</span><span class="s">&quot; r52: &quot;</span><span class="n">REGFMT</span><span class="s">&quot; tp : &quot;</span><span class="n">REGFMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">51</span><span class="p">],</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">52</span><span class="p">],</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot; sp : &quot;</span><span class="n">REGFMT</span><span class="s">&quot; lr : &quot;</span><span class="n">REGFMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">lr</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">52</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot; r%-2d: &quot;</span><span class="n">REGFMT</span><span class="s">&quot; r%-2d: &quot;</span><span class="n">REGFMT</span>
		       <span class="s">&quot; r%-2d: &quot;</span><span class="n">REGFMT</span><span class="s">&quot; r%-2d: &quot;</span><span class="n">REGFMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">i</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
		       <span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">]);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot; r52: &quot;</span><span class="n">REGFMT</span><span class="s">&quot; tp : &quot;</span><span class="n">REGFMT</span><span class="s">&quot; sp : &quot;</span><span class="n">REGFMT</span><span class="s">&quot; lr : &quot;</span><span class="n">REGFMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">52</span><span class="p">],</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">lr</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot; pc : &quot;</span><span class="n">REGFMT</span><span class="s">&quot; ex1: %ld     faultnum: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ex1</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">faultnum</span><span class="p">);</span>

	<span class="n">dump_stack_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
