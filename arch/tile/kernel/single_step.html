<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › kernel › single_step.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>single_step.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> *</span>
<span class="cm"> * A code-rewriter that enables instruction single-stepping.</span>
<span class="cm"> * Derived from iLib&#39;s single-stepping code.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __tilegx__   </span><span class="cm">/* Hardware support for single step unavailable. */</span><span class="cp"></span>

<span class="cm">/* These functions are only used on the TILE platform */</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/thread_info.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;arch/abi.h&gt;</span>
<span class="cp">#include &lt;arch/opcode.h&gt;</span>

<span class="cp">#define signExtend17(val) sign_extend((val), 17)</span>
<span class="cp">#define TILE_X1_MASK (0xffffffffULL &lt;&lt; 31)</span>

<span class="kt">int</span> <span class="n">unaligned_printk</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_unaligned_printk</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strict_strtol</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">unaligned_printk</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Printk for each unaligned data accesses is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">unaligned_printk</span> <span class="o">?</span> <span class="s">&quot;enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;unaligned_printk=&quot;</span><span class="p">,</span> <span class="n">setup_unaligned_printk</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unaligned_fixup_count</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">mem_op</span> <span class="p">{</span>
	<span class="n">MEMOP_NONE</span><span class="p">,</span>
	<span class="n">MEMOP_LOAD</span><span class="p">,</span>
	<span class="n">MEMOP_STORE</span><span class="p">,</span>
	<span class="n">MEMOP_LOAD_POSTINCR</span><span class="p">,</span>
	<span class="n">MEMOP_STORE_POSTINCR</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">tile_bundle_bits</span> <span class="nf">set_BrOff_X1</span><span class="p">(</span><span class="n">tile_bundle_bits</span> <span class="n">n</span><span class="p">,</span> <span class="n">s32</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tile_bundle_bits</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* mask out the old offset */</span>
	<span class="n">tile_bundle_bits</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">create_BrOff_X1</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">);</span>

	<span class="cm">/* or in the new offset */</span>
	<span class="n">result</span> <span class="o">|=</span> <span class="n">create_BrOff_X1</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">tile_bundle_bits</span> <span class="nf">move_X1</span><span class="p">(</span><span class="n">tile_bundle_bits</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tile_bundle_bits</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">tile_bundle_bits</span> <span class="n">op</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">TILE_X1_MASK</span><span class="p">);</span>

	<span class="n">op</span> <span class="o">=</span> <span class="n">create_Opcode_X1</span><span class="p">(</span><span class="n">SPECIAL_0_OPCODE_X1</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">create_RRROpcodeExtension_X1</span><span class="p">(</span><span class="n">OR_SPECIAL_0_OPCODE_X1</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">create_Dest_X1</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">create_SrcB_X1</span><span class="p">(</span><span class="n">TREG_ZERO</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">create_SrcA_X1</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="p">;</span>

	<span class="n">result</span> <span class="o">|=</span> <span class="n">op</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">tile_bundle_bits</span> <span class="nf">nop_X1</span><span class="p">(</span><span class="n">tile_bundle_bits</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">move_X1</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">TREG_ZERO</span><span class="p">,</span> <span class="n">TREG_ZERO</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">tile_bundle_bits</span> <span class="nf">addi_X1</span><span class="p">(</span>
	<span class="n">tile_bundle_bits</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">imm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">n</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TILE_X1_MASK</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">|=</span>  <span class="p">(</span><span class="n">create_SrcA_X1</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="o">|</span>
	       <span class="n">create_Dest_X1</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">|</span>
	       <span class="n">create_Imm8_X1</span><span class="p">(</span><span class="n">imm</span><span class="p">)</span> <span class="o">|</span>
	       <span class="n">create_S_X1</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
	       <span class="n">create_Opcode_X1</span><span class="p">(</span><span class="n">IMM_0_OPCODE_X1</span><span class="p">)</span> <span class="o">|</span>
	       <span class="n">create_ImmOpcodeExtension_X1</span><span class="p">(</span><span class="n">ADDI_IMM_0_OPCODE_X1</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">tile_bundle_bits</span> <span class="nf">rewrite_load_store_unaligned</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">single_step_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
	<span class="n">tile_bundle_bits</span> <span class="n">bundle</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">mem_op</span> <span class="n">mem_op</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sign_ext</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val_reg</span><span class="p">,</span> <span class="n">addr_reg</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>

	<span class="cm">/* Get address and value registers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bundle</span> <span class="o">&amp;</span> <span class="n">TILEPRO_BUNDLE_Y_ENCODING_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr_reg</span> <span class="o">=</span> <span class="n">get_SrcA_Y2</span><span class="p">(</span><span class="n">bundle</span><span class="p">);</span>
		<span class="n">val_reg</span> <span class="o">=</span> <span class="n">get_SrcBDest_Y2</span><span class="p">(</span><span class="n">bundle</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mem_op</span> <span class="o">==</span> <span class="n">MEMOP_LOAD</span> <span class="o">||</span> <span class="n">mem_op</span> <span class="o">==</span> <span class="n">MEMOP_LOAD_POSTINCR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr_reg</span> <span class="o">=</span> <span class="n">get_SrcA_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">);</span>
		<span class="n">val_reg</span>  <span class="o">=</span> <span class="n">get_Dest_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">addr_reg</span> <span class="o">=</span> <span class="n">get_SrcA_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">);</span>
		<span class="n">val_reg</span>  <span class="o">=</span> <span class="n">get_SrcB_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If registers are not GPRs, don&#39;t try to handle it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * FIXME: we could handle non-GPR loads by getting the real value</span>
<span class="cm">	 * from memory, writing it to the single step buffer, using a</span>
<span class="cm">	 * temp_reg to hold a pointer to that memory, then executing that</span>
<span class="cm">	 * instruction and resetting temp_reg.  For non-GPR stores, it&#39;s a</span>
<span class="cm">	 * little trickier; we could use the single step buffer for that</span>
<span class="cm">	 * too, but we&#39;d have to add some more state bits so that we could</span>
<span class="cm">	 * call back in here to copy that value to the real target.  For</span>
<span class="cm">	 * now, we just handle the simple case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">val_reg</span> <span class="o">&gt;=</span> <span class="n">PTREGS_NR_GPRS</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">val_reg</span> <span class="o">!=</span> <span class="n">TREG_ZERO</span> <span class="o">||</span>
	      <span class="n">mem_op</span> <span class="o">==</span> <span class="n">MEMOP_LOAD</span> <span class="o">||</span>
	      <span class="n">mem_op</span> <span class="o">==</span> <span class="n">MEMOP_LOAD_POSTINCR</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">addr_reg</span> <span class="o">&gt;=</span> <span class="n">PTREGS_NR_GPRS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bundle</span><span class="p">;</span>

	<span class="cm">/* If it&#39;s aligned, don&#39;t handle it specially */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">addr_reg</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span> <span class="o">%</span> <span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bundle</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return SIGBUS with the unaligned address, if requested.</span>
<span class="cm">	 * Note that we return SIGBUS even for completely invalid addresses</span>
<span class="cm">	 * as long as they are in fact unaligned; this matches what the</span>
<span class="cm">	 * tilepro hardware would be doing, if it could provide us with the</span>
<span class="cm">	 * actual bad address in an SPR, which it doesn&#39;t.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unaligned_fixup</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">siginfo_t</span> <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGBUS</span><span class="p">,</span>
			<span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">BUS_ADRALN</span><span class="p">,</span>
			<span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="n">addr</span>
		<span class="p">};</span>
		<span class="n">trace_unhandled_signal</span><span class="p">(</span><span class="s">&quot;unaligned trap&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">SIGBUS</span><span class="p">);</span>
		<span class="n">force_sig_info</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">si_signo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">tilepro_bundle_bits</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Handle unaligned load/store */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_op</span> <span class="o">==</span> <span class="n">MEMOP_LOAD</span> <span class="o">||</span> <span class="n">mem_op</span> <span class="o">==</span> <span class="n">MEMOP_LOAD_POSTINCR</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">val_16</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val_16</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val_16</span><span class="p">));</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">sign_ext</span> <span class="o">?</span> <span class="p">((</span><span class="kt">short</span><span class="p">)</span><span class="n">val_16</span><span class="p">)</span> <span class="o">:</span> <span class="n">val_16</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">update_reg</span> <span class="o">=</span> <span class="n">val_reg</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">update_value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">update</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">val_16</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val_reg</span> <span class="o">==</span> <span class="n">TREG_ZERO</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">val_reg</span><span class="p">];</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">val_16</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val_16</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val_16</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">siginfo_t</span> <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGSEGV</span><span class="p">,</span>
			<span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">SEGV_MAPERR</span><span class="p">,</span>
			<span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="n">addr</span>
		<span class="p">};</span>
		<span class="n">trace_unhandled_signal</span><span class="p">(</span><span class="s">&quot;segfault&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">SIGSEGV</span><span class="p">);</span>
		<span class="n">force_sig_info</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">si_signo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">tile_bundle_bits</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unaligned_printk</span> <span class="o">||</span> <span class="n">unaligned_fixup_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Process %d/%s: PC %#lx: Fixup of&quot;</span>
			<span class="s">&quot; unaligned %s at %#lx.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">,</span>
			<span class="p">(</span><span class="n">mem_op</span> <span class="o">==</span> <span class="n">MEMOP_LOAD</span> <span class="o">||</span>
			 <span class="n">mem_op</span> <span class="o">==</span> <span class="n">MEMOP_LOAD_POSTINCR</span><span class="p">)</span> <span class="o">?</span>
			<span class="s">&quot;load&quot;</span> <span class="o">:</span> <span class="s">&quot;store&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unaligned_printk</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#define P pr_info</span>
<span class="n">P</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">P</span><span class="p">(</span><span class="s">&quot;Unaligned fixups in the kernel will slow your application considerably.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">P</span><span class="p">(</span><span class="s">&quot;To find them, write a </span><span class="se">\&quot;</span><span class="s">1</span><span class="se">\&quot;</span><span class="s"> to /proc/sys/tile/unaligned_fixup/printk,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">P</span><span class="p">(</span><span class="s">&quot;which requests the kernel show all unaligned fixups, or write a </span><span class="se">\&quot;</span><span class="s">0</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">P</span><span class="p">(</span><span class="s">&quot;to /proc/sys/tile/unaligned_fixup/enabled, in which case each unaligned</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">P</span><span class="p">(</span><span class="s">&quot;access will become a SIGBUS you can debug. No further warnings will be</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">P</span><span class="p">(</span><span class="s">&quot;shown so as to avoid additional slowdown, but you can track the number</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">P</span><span class="p">(</span><span class="s">&quot;of fixups performed via /proc/sys/tile/unaligned_fixup/count.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">P</span><span class="p">(</span><span class="s">&quot;Use the tile-addr2line command (see </span><span class="se">\&quot;</span><span class="s">info addr2line</span><span class="se">\&quot;</span><span class="s">) to decode PCs.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">P</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#undef P</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">++</span><span class="n">unaligned_fixup_count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bundle</span> <span class="o">&amp;</span> <span class="n">TILEPRO_BUNDLE_Y_ENCODING_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Convert the Y2 instruction to a prefetch. */</span>
		<span class="n">bundle</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">create_SrcBDest_Y2</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
			    <span class="n">create_Opcode_Y2</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
		<span class="n">bundle</span> <span class="o">|=</span> <span class="p">(</span><span class="n">create_SrcBDest_Y2</span><span class="p">(</span><span class="n">TREG_ZERO</span><span class="p">)</span> <span class="o">|</span>
			   <span class="n">create_Opcode_Y2</span><span class="p">(</span><span class="n">LW_OPCODE_Y2</span><span class="p">));</span>
	<span class="cm">/* Replace the load postincr with an addi */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mem_op</span> <span class="o">==</span> <span class="n">MEMOP_LOAD_POSTINCR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bundle</span> <span class="o">=</span> <span class="n">addi_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">addr_reg</span><span class="p">,</span> <span class="n">addr_reg</span><span class="p">,</span>
				 <span class="n">get_Imm8_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">));</span>
	<span class="cm">/* Replace the store postincr with an addi */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mem_op</span> <span class="o">==</span> <span class="n">MEMOP_STORE_POSTINCR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bundle</span> <span class="o">=</span> <span class="n">addi_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">addr_reg</span><span class="p">,</span> <span class="n">addr_reg</span><span class="p">,</span>
				 <span class="n">get_Dest_Imm8_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Convert the X1 instruction to a nop. */</span>
		<span class="n">bundle</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">create_Opcode_X1</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
			    <span class="n">create_UnShOpcodeExtension_X1</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
			    <span class="n">create_UnOpcodeExtension_X1</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
		<span class="n">bundle</span> <span class="o">|=</span> <span class="p">(</span><span class="n">create_Opcode_X1</span><span class="p">(</span><span class="n">SHUN_0_OPCODE_X1</span><span class="p">)</span> <span class="o">|</span>
			   <span class="n">create_UnShOpcodeExtension_X1</span><span class="p">(</span>
				   <span class="n">UN_0_SHUN_0_OPCODE_X1</span><span class="p">)</span> <span class="o">|</span>
			   <span class="n">create_UnOpcodeExtension_X1</span><span class="p">(</span>
				   <span class="n">NOP_UN_0_SHUN_0_OPCODE_X1</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bundle</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called after execve() has started the new image.  This allows us</span>
<span class="cm"> * to reset the info state.  Note that the the mmap&#39;ed memory, if there</span>
<span class="cm"> * was any, has already been unmapped by the exec.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">single_step_execve</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">current_thread_info</span><span class="p">();</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">step_state</span><span class="p">);</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">step_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * single_step_once() - entry point when single stepping has been triggered.</span>
<span class="cm"> * @regs: The machine register state</span>
<span class="cm"> *</span>
<span class="cm"> *  When we arrive at this routine via a trampoline, the single step</span>
<span class="cm"> *  engine copies the executing bundle to the single step buffer.</span>
<span class="cm"> *  If the instruction is a condition branch, then the target is</span>
<span class="cm"> *  reset to one past the next instruction. If the instruction</span>
<span class="cm"> *  sets the lr, then that is noted. If the instruction is a jump</span>
<span class="cm"> *  or call, then the new target pc is preserved and the current</span>
<span class="cm"> *  bundle instruction set to null.</span>
<span class="cm"> *</span>
<span class="cm"> *  The necessary post-single-step rewriting information is stored in</span>
<span class="cm"> *  single_step_state-&gt;  We use data segment values because the</span>
<span class="cm"> *  stack will be rewound when we run the rewritten single-stepped</span>
<span class="cm"> *  instruction.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">single_step_once</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="n">tile_bundle_bits</span> <span class="n">__single_step_ill_insn</span><span class="p">;</span>
	<span class="k">extern</span> <span class="n">tile_bundle_bits</span> <span class="n">__single_step_j_insn</span><span class="p">;</span>
	<span class="k">extern</span> <span class="n">tile_bundle_bits</span> <span class="n">__single_step_addli_insn</span><span class="p">;</span>
	<span class="k">extern</span> <span class="n">tile_bundle_bits</span> <span class="n">__single_step_auli_insn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">current_thread_info</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">single_step_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">step_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_single_step</span> <span class="o">=</span> <span class="n">test_ti_thread_flag</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">TIF_SINGLESTEP</span><span class="p">);</span>
	<span class="n">tile_bundle_bits</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>
	<span class="n">tile_bundle_bits</span> <span class="n">bundle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">temp_reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">target_reg</span> <span class="o">=</span> <span class="n">TREG_LR</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">mem_op</span> <span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_NONE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sign_ext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* happy compiler */</span>

	<span class="n">asm</span><span class="p">(</span>
<span class="s">&quot;    .pushsection .rodata.single_step</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;    .align 8</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;    .globl    __single_step_ill_insn</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;__single_step_ill_insn:</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;    ill</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;    .globl    __single_step_addli_insn</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;__single_step_addli_insn:</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;    { nop; addli r0, zero, 0 }</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;    .globl    __single_step_auli_insn</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;__single_step_auli_insn:</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;    { nop; auli r0, r0, 0 }</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;    .globl    __single_step_j_insn</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;__single_step_j_insn:</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;    j .</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;    .popsection</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable interrupts here to allow touching userspace and the like.</span>
<span class="cm">	 * The callers expect this: do_trap() already has interrupts</span>
<span class="cm">	 * enabled, and do_work_pending() handles functions that enable</span>
<span class="cm">	 * interrupts internally.</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* allocate a page of writable, executable memory */</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">single_step_state</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Out of kernel memory trying to single-step</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* allocate a cache line of writable, executable memory */</span>
		<span class="n">buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">vm_mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span>
					  <span class="n">PROT_EXEC</span> <span class="o">|</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
					  <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span>
					  <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">((</span><span class="kt">void</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Out of kernel pages trying to single-step</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">state</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">is_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">step_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

		<span class="cm">/* Validate our stored instruction patterns */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">get_Opcode_X1</span><span class="p">(</span><span class="n">__single_step_addli_insn</span><span class="p">)</span> <span class="o">!=</span>
		       <span class="n">ADDLI_OPCODE_X1</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">get_Opcode_X1</span><span class="p">(</span><span class="n">__single_step_auli_insn</span><span class="p">)</span> <span class="o">!=</span>
		       <span class="n">AULI_OPCODE_X1</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">get_SrcA_X1</span><span class="p">(</span><span class="n">__single_step_addli_insn</span><span class="p">)</span> <span class="o">!=</span> <span class="n">TREG_ZERO</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">get_Dest_X1</span><span class="p">(</span><span class="n">__single_step_addli_insn</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">get_JOffLong_X1</span><span class="p">(</span><span class="n">__single_step_j_insn</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are returning from a syscall, we still haven&#39;t hit the</span>
<span class="cm">	 * &quot;ill&quot; for the swint1 instruction.  So back the PC up to be</span>
<span class="cm">	 * pointing at the swint1, but we&#39;ll actually return directly</span>
<span class="cm">	 * back to the &quot;ill&quot; so we come back in via SIGILL as if we</span>
<span class="cm">	 * had &quot;executed&quot; the swint1 without ever being in kernel space.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">faultnum</span> <span class="o">==</span> <span class="n">INT_SWINT_1</span><span class="p">)</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="n">pc</span> <span class="o">=</span> <span class="p">(</span><span class="n">tile_bundle_bits</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">pc</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t read instruction at %p trying to step</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We&#39;ll follow the instruction with 2 ill op bundles */</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">orig_pc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pc</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">next_pc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">pc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">branch_next_pc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">update</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bundle</span> <span class="o">&amp;</span> <span class="n">TILEPRO_BUNDLE_Y_ENCODING_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* two wide, check for control flow */</span>
		<span class="kt">int</span> <span class="n">opcode</span> <span class="o">=</span> <span class="n">get_Opcode_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* branches */</span>
		<span class="k">case</span> <span class="n">BRANCH_OPCODE_X1</span>:
		<span class="p">{</span>
			<span class="n">s32</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">signExtend17</span><span class="p">(</span><span class="n">get_BrOff_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">));</span>

			<span class="cm">/*</span>
<span class="cm">			 * For branches, we use a rewriting trick to let the</span>
<span class="cm">			 * hardware evaluate whether the branch is taken or</span>
<span class="cm">			 * untaken.  We record the target offset and then</span>
<span class="cm">			 * rewrite the branch instruction to target 1 insn</span>
<span class="cm">			 * ahead if the branch is taken.  We then follow the</span>
<span class="cm">			 * rewritten branch with two bundles, each containing</span>
<span class="cm">			 * an &quot;ill&quot; instruction. The supervisor examines the</span>
<span class="cm">			 * pc after the single step code is executed, and if</span>
<span class="cm">			 * the pc is the first ill instruction, then the</span>
<span class="cm">			 * branch (if any) was not taken.  If the pc is the</span>
<span class="cm">			 * second ill instruction, then the branch was</span>
<span class="cm">			 * taken. The new pc is computed for these cases, and</span>
<span class="cm">			 * inserted into the registers for the thread.  If</span>
<span class="cm">			 * the pc is the start of the single step code, then</span>
<span class="cm">			 * an exception or interrupt was taken before the</span>
<span class="cm">			 * code started processing, and the same &quot;original&quot;</span>
<span class="cm">			 * pc is restored.  This change, different from the</span>
<span class="cm">			 * original implementation, has the advantage of</span>
<span class="cm">			 * executing a single user instruction.</span>
<span class="cm">			 */</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">branch_next_pc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">pc</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

			<span class="cm">/* rewrite branch offset to go forward one bundle */</span>
			<span class="n">bundle</span> <span class="o">=</span> <span class="n">set_BrOff_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* jumps */</span>
		<span class="k">case</span> <span class="n">JALB_OPCODE_X1</span>:
		<span class="k">case</span> <span class="n">JALF_OPCODE_X1</span>:
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">update</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">next_pc</span> <span class="o">=</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">pc</span> <span class="o">+</span> <span class="n">get_JOffLong_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">JB_OPCODE_X1</span>:
		<span class="k">case</span> <span class="n">JF_OPCODE_X1</span>:
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">next_pc</span> <span class="o">=</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">pc</span> <span class="o">+</span> <span class="n">get_JOffLong_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">));</span>
			<span class="n">bundle</span> <span class="o">=</span> <span class="n">nop_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SPECIAL_0_OPCODE_X1</span>:
			<span class="k">switch</span> <span class="p">(</span><span class="n">get_RRROpcodeExtension_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* jump-register */</span>
			<span class="k">case</span> <span class="n">JALRP_SPECIAL_0_OPCODE_X1</span>:
			<span class="k">case</span> <span class="n">JALR_SPECIAL_0_OPCODE_X1</span>:
				<span class="n">state</span><span class="o">-&gt;</span><span class="n">update</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">state</span><span class="o">-&gt;</span><span class="n">next_pc</span> <span class="o">=</span>
					<span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">get_SrcA_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">)];</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">JRP_SPECIAL_0_OPCODE_X1</span>:
			<span class="k">case</span> <span class="n">JR_SPECIAL_0_OPCODE_X1</span>:
				<span class="n">state</span><span class="o">-&gt;</span><span class="n">next_pc</span> <span class="o">=</span>
					<span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">get_SrcA_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">)];</span>
				<span class="n">bundle</span> <span class="o">=</span> <span class="n">nop_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">LNK_SPECIAL_0_OPCODE_X1</span>:
				<span class="n">state</span><span class="o">-&gt;</span><span class="n">update</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">target_reg</span> <span class="o">=</span> <span class="n">get_Dest_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* stores */</span>
			<span class="k">case</span> <span class="n">SH_SPECIAL_0_OPCODE_X1</span>:
				<span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_STORE</span><span class="p">;</span>
				<span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SW_SPECIAL_0_OPCODE_X1</span>:
				<span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_STORE</span><span class="p">;</span>
				<span class="n">size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* loads and iret */</span>
		<span class="k">case</span> <span class="n">SHUN_0_OPCODE_X1</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">get_UnShOpcodeExtension_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">)</span> <span class="o">==</span>
			    <span class="n">UN_0_SHUN_0_OPCODE_X1</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">get_UnOpcodeExtension_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">LH_UN_0_SHUN_0_OPCODE_X1</span>:
					<span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_LOAD</span><span class="p">;</span>
					<span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
					<span class="n">sign_ext</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="k">case</span> <span class="n">LH_U_UN_0_SHUN_0_OPCODE_X1</span>:
					<span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_LOAD</span><span class="p">;</span>
					<span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
					<span class="n">sign_ext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="k">case</span> <span class="n">LW_UN_0_SHUN_0_OPCODE_X1</span>:
					<span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_LOAD</span><span class="p">;</span>
					<span class="n">size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="k">case</span> <span class="n">IRET_UN_0_SHUN_0_OPCODE_X1</span>:
				<span class="p">{</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ex0_0</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span>
						<span class="n">SPR_EX_CONTEXT_0_0</span><span class="p">);</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ex0_1</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span>
						<span class="n">SPR_EX_CONTEXT_0_1</span><span class="p">);</span>
					<span class="cm">/*</span>
<span class="cm">					 * Special-case it if we&#39;re iret&#39;ing</span>
<span class="cm">					 * to PL0 again.  Otherwise just let</span>
<span class="cm">					 * it run and it will generate SIGILL.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">EX1_PL</span><span class="p">(</span><span class="n">ex0_1</span><span class="p">)</span> <span class="o">==</span> <span class="n">USER_PL</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">state</span><span class="o">-&gt;</span><span class="n">next_pc</span> <span class="o">=</span> <span class="n">ex0_0</span><span class="p">;</span>
						<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ex1</span> <span class="o">=</span> <span class="n">ex0_1</span><span class="p">;</span>
						<span class="n">bundle</span> <span class="o">=</span> <span class="n">nop_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

<span class="cp">#if CHIP_HAS_WH64()</span>
		<span class="cm">/* postincrement operations */</span>
		<span class="k">case</span> <span class="n">IMM_0_OPCODE_X1</span>:
			<span class="k">switch</span> <span class="p">(</span><span class="n">get_ImmOpcodeExtension_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">LWADD_IMM_0_OPCODE_X1</span>:
				<span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_LOAD_POSTINCR</span><span class="p">;</span>
				<span class="n">size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">LHADD_IMM_0_OPCODE_X1</span>:
				<span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_LOAD_POSTINCR</span><span class="p">;</span>
				<span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">sign_ext</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">LHADD_U_IMM_0_OPCODE_X1</span>:
				<span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_LOAD_POSTINCR</span><span class="p">;</span>
				<span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">sign_ext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SWADD_IMM_0_OPCODE_X1</span>:
				<span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_STORE_POSTINCR</span><span class="p">;</span>
				<span class="n">size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SHADD_IMM_0_OPCODE_X1</span>:
				<span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_STORE_POSTINCR</span><span class="p">;</span>
				<span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="nl">default:</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CHIP_HAS_WH64() */</span><span class="cp"></span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Get an available register.  We start with a</span>
<span class="cm">			 * bitmask with 1&#39;s for available registers.</span>
<span class="cm">			 * We truncate to the low 32 registers since</span>
<span class="cm">			 * we are guaranteed to have set bits in the</span>
<span class="cm">			 * low 32 bits, then use ctz to pick the first.</span>
<span class="cm">			 */</span>
			<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">~</span><span class="p">((</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">get_Dest_X0</span><span class="p">(</span><span class="n">bundle</span><span class="p">))</span> <span class="o">|</span>
					   <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">get_SrcA_X0</span><span class="p">(</span><span class="n">bundle</span><span class="p">))</span> <span class="o">|</span>
					   <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">get_SrcB_X0</span><span class="p">(</span><span class="n">bundle</span><span class="p">))</span> <span class="o">|</span>
					   <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">target_reg</span><span class="p">));</span>
			<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">update_reg</span> <span class="o">=</span> <span class="n">temp_reg</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">update_value</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">temp_reg</span><span class="p">];</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">temp_reg</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">pc</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PT_FLAGS_RESTORE_REGS</span><span class="p">;</span>
			<span class="n">bundle</span> <span class="o">=</span> <span class="n">move_X1</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">target_reg</span><span class="p">,</span> <span class="n">temp_reg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">opcode</span> <span class="o">=</span> <span class="n">get_Opcode_Y2</span><span class="p">(</span><span class="n">bundle</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* loads */</span>
		<span class="k">case</span> <span class="n">LH_OPCODE_Y2</span>:
			<span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_LOAD</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">sign_ext</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">LH_U_OPCODE_Y2</span>:
			<span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_LOAD</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">sign_ext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">LW_OPCODE_Y2</span>:
			<span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_LOAD</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* stores */</span>
		<span class="k">case</span> <span class="n">SH_OPCODE_Y2</span>:
			<span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_STORE</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SW_OPCODE_Y2</span>:
			<span class="n">mem_op</span> <span class="o">=</span> <span class="n">MEMOP_STORE</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if we need to rewrite an unaligned load/store.</span>
<span class="cm">	 * Returning zero is a special value meaning we need to SIGSEGV.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_op</span> <span class="o">!=</span> <span class="n">MEMOP_NONE</span> <span class="o">&amp;&amp;</span> <span class="n">unaligned_fixup</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bundle</span> <span class="o">=</span> <span class="n">rewrite_load_store_unaligned</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span>
						      <span class="n">mem_op</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">sign_ext</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bundle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* write the bundle to our execution area */</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">buffer</span><span class="o">++</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re really single-stepping, we take an INT_ILL after.</span>
<span class="cm">	 * If we&#39;re just handling an unaligned access, we can just</span>
<span class="cm">	 * jump directly back to where we were in user code.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_single_step</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">__single_step_ill_insn</span><span class="p">,</span> <span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">__single_step_ill_insn</span><span class="p">,</span> <span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We have some state to update; do it inline */</span>
			<span class="kt">int</span> <span class="n">ha16</span><span class="p">;</span>
			<span class="n">bundle</span> <span class="o">=</span> <span class="n">__single_step_addli_insn</span><span class="p">;</span>
			<span class="n">bundle</span> <span class="o">|=</span> <span class="n">create_Dest_X1</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">update_reg</span><span class="p">);</span>
			<span class="n">bundle</span> <span class="o">|=</span> <span class="n">create_Imm16_X1</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">update_value</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
			<span class="n">bundle</span> <span class="o">=</span> <span class="n">__single_step_auli_insn</span><span class="p">;</span>
			<span class="n">bundle</span> <span class="o">|=</span> <span class="n">create_Dest_X1</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">update_reg</span><span class="p">);</span>
			<span class="n">bundle</span> <span class="o">|=</span> <span class="n">create_SrcA_X1</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">update_reg</span><span class="p">);</span>
			<span class="n">ha16</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">update_value</span> <span class="o">+</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">bundle</span> <span class="o">|=</span> <span class="n">create_Imm16_X1</span><span class="p">(</span><span class="n">ha16</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">update</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* End with a jump back to the next instruction */</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="p">((</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">+</span> <span class="n">TILE_BUNDLE_SIZE_IN_BYTES</span><span class="p">)</span> <span class="o">-</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buffer</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
			<span class="n">TILE_LOG2_BUNDLE_ALIGNMENT_IN_BYTES</span><span class="p">;</span>
		<span class="n">bundle</span> <span class="o">=</span> <span class="n">__single_step_j_insn</span><span class="p">;</span>
		<span class="n">bundle</span> <span class="o">|=</span> <span class="n">create_JOffLong_X1</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">buffer</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Fault when writing to single-step buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flush the buffer.</span>
<span class="cm">	 * We do a local flush only, since this is a thread-specific buffer.</span>
<span class="cm">	 */</span>
	<span class="n">__flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buffer</span><span class="p">);</span>

	<span class="cm">/* Indicate enabled */</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">is_enabled</span> <span class="o">=</span> <span class="n">is_single_step</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>

	<span class="cm">/* Fault immediately if we are coming back from a syscall. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">faultnum</span> <span class="o">==</span> <span class="n">INT_SWINT_1</span><span class="p">)</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;arch/spr_def.h&gt;</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">ss_saved_pc</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Called directly on the occasion of an interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * If the process doesn&#39;t have single step set, then we use this as an</span>
<span class="cm"> * opportunity to turn single step off.</span>
<span class="cm"> *</span>
<span class="cm"> * It has been mentioned that we could conditionally turn off single stepping</span>
<span class="cm"> * on each entry into the kernel and rely on single_step_once to turn it</span>
<span class="cm"> * on for the processes that matter (as we already do), but this</span>
<span class="cm"> * implementation is somewhat more efficient in that we muck with registers</span>
<span class="cm"> * once on a bum interrupt rather than on every entry into the kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * If SINGLE_STEP_CONTROL_K has CANCELED set, then an interrupt occurred,</span>
<span class="cm"> * so we have to run through this process again before we can say that an</span>
<span class="cm"> * instruction has executed.</span>
<span class="cm"> *</span>
<span class="cm"> * swint will set CANCELED, but it&#39;s a legitimate instruction.  Fortunately</span>
<span class="cm"> * it changes the PC.  If it hasn&#39;t changed, then we know that the interrupt</span>
<span class="cm"> * wasn&#39;t generated by swint and we&#39;ll need to run this process again before</span>
<span class="cm"> * we can say an instruction has executed.</span>
<span class="cm"> *</span>
<span class="cm"> * If either CANCELED == 0 or the PC&#39;s changed, we send out SIGTRAPs and get</span>
<span class="cm"> * on with our lives.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">gx_singlestep_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fault_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ss_pc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ss_saved_pc</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">current_thread_info</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">is_single_step</span> <span class="o">=</span> <span class="n">test_ti_thread_flag</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">TIF_SINGLESTEP</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">control</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_SINGLE_STEP_CONTROL_K</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_single_step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_SINGLE_STEP_EN_K_K</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">ss_pc</span> <span class="o">!=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">)</span> <span class="o">||</span>
		   <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">SPR_SINGLE_STEP_CONTROL_1__CANCELED_MASK</span><span class="p">)))</span> <span class="p">{</span>

		<span class="n">ptrace_notify</span><span class="p">(</span><span class="n">SIGTRAP</span><span class="p">);</span>
		<span class="n">control</span> <span class="o">|=</span> <span class="n">SPR_SINGLE_STEP_CONTROL_1__CANCELED_MASK</span><span class="p">;</span>
		<span class="n">control</span> <span class="o">|=</span> <span class="n">SPR_SINGLE_STEP_CONTROL_1__INHIBIT_MASK</span><span class="p">;</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_SINGLE_STEP_CONTROL_K</span><span class="p">,</span> <span class="n">control</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Called from need_singlestep.  Set up the control registers and the enable</span>
<span class="cm"> * register, then return back.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">single_step_once</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ss_pc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ss_saved_pc</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">control</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_SINGLE_STEP_CONTROL_K</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ss_pc</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">;</span>
	<span class="n">control</span> <span class="o">|=</span> <span class="n">SPR_SINGLE_STEP_CONTROL_1__CANCELED_MASK</span><span class="p">;</span>
	<span class="n">control</span> <span class="o">|=</span> <span class="n">SPR_SINGLE_STEP_CONTROL_1__INHIBIT_MASK</span><span class="p">;</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_SINGLE_STEP_CONTROL_K</span><span class="p">,</span> <span class="n">control</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_SINGLE_STEP_EN_K_K</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USER_PL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">single_step_execve</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Nothing */</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !__tilegx__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
