<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › kernel › backtrace.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>backtrace.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2011 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;asm/backtrace.h&gt;</span>
<span class="cp">#include &lt;asm/tile-desc.h&gt;</span>
<span class="cp">#include &lt;arch/abi.h&gt;</span>

<span class="cp">#ifdef __tilegx__</span>
<span class="cp">#define TILE_MAX_INSTRUCTIONS_PER_BUNDLE TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE</span>
<span class="cp">#define tile_decoded_instruction tilegx_decoded_instruction</span>
<span class="cp">#define tile_mnemonic tilegx_mnemonic</span>
<span class="cp">#define parse_insn_tile parse_insn_tilegx</span>
<span class="cp">#define TILE_OPC_IRET TILEGX_OPC_IRET</span>
<span class="cp">#define TILE_OPC_ADDI TILEGX_OPC_ADDI</span>
<span class="cp">#define TILE_OPC_ADDLI TILEGX_OPC_ADDLI</span>
<span class="cp">#define TILE_OPC_INFO TILEGX_OPC_INFO</span>
<span class="cp">#define TILE_OPC_INFOL TILEGX_OPC_INFOL</span>
<span class="cp">#define TILE_OPC_JRP TILEGX_OPC_JRP</span>
<span class="cp">#define TILE_OPC_MOVE TILEGX_OPC_MOVE</span>
<span class="cp">#define OPCODE_STORE TILEGX_OPC_ST</span>
<span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">bt_int_reg_t</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#define TILE_MAX_INSTRUCTIONS_PER_BUNDLE TILEPRO_MAX_INSTRUCTIONS_PER_BUNDLE</span>
<span class="cp">#define tile_decoded_instruction tilepro_decoded_instruction</span>
<span class="cp">#define tile_mnemonic tilepro_mnemonic</span>
<span class="cp">#define parse_insn_tile parse_insn_tilepro</span>
<span class="cp">#define TILE_OPC_IRET TILEPRO_OPC_IRET</span>
<span class="cp">#define TILE_OPC_ADDI TILEPRO_OPC_ADDI</span>
<span class="cp">#define TILE_OPC_ADDLI TILEPRO_OPC_ADDLI</span>
<span class="cp">#define TILE_OPC_INFO TILEPRO_OPC_INFO</span>
<span class="cp">#define TILE_OPC_INFOL TILEPRO_OPC_INFOL</span>
<span class="cp">#define TILE_OPC_JRP TILEPRO_OPC_JRP</span>
<span class="cp">#define TILE_OPC_MOVE TILEPRO_OPC_MOVE</span>
<span class="cp">#define OPCODE_STORE TILEPRO_OPC_SW</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">bt_int_reg_t</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/* A decoded bundle used for backtracer analysis. */</span>
<span class="k">struct</span> <span class="n">BacktraceBundle</span> <span class="p">{</span>
	<span class="n">tile_bundle_bits</span> <span class="n">bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_insns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tile_decoded_instruction</span>
	<span class="n">insns</span><span class="p">[</span><span class="n">TILE_MAX_INSTRUCTIONS_PER_BUNDLE</span><span class="p">];</span>
<span class="p">};</span>


<span class="cm">/* Locates an instruction inside the given bundle that</span>
<span class="cm"> * has the specified mnemonic, and whose first &#39;num_operands_to_match&#39;</span>
<span class="cm"> * operands exactly match those in &#39;operand_values&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tile_decoded_instruction</span> <span class="o">*</span><span class="nf">find_matching_insn</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">BacktraceBundle</span> <span class="o">*</span><span class="n">bundle</span><span class="p">,</span>
	<span class="n">tile_mnemonic</span> <span class="n">mnemonic</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">operand_values</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">num_operands_to_match</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">match</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bundle</span><span class="o">-&gt;</span><span class="n">num_insns</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">tile_decoded_instruction</span> <span class="o">*</span><span class="n">insn</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">bundle</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="o">-&gt;</span><span class="n">mnemonic</span> <span class="o">!=</span> <span class="n">mnemonic</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">match</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num_operands_to_match</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">operand_values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">operand_values</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">match</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">insn</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Does this bundle contain an &#39;iret&#39; instruction? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">bt_has_iret</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">BacktraceBundle</span> <span class="o">*</span><span class="n">bundle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">find_matching_insn</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">TILE_OPC_IRET</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Does this bundle contain an &#39;addi sp, sp, OFFSET&#39; or</span>
<span class="cm"> * &#39;addli sp, sp, OFFSET&#39; instruction, and if so, what is OFFSET?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">bt_has_addi_sp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">BacktraceBundle</span> <span class="o">*</span><span class="n">bundle</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">adjust</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">vals</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">TREG_SP</span><span class="p">,</span> <span class="n">TREG_SP</span> <span class="p">};</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">tile_decoded_instruction</span> <span class="o">*</span><span class="n">insn</span> <span class="o">=</span>
		<span class="n">find_matching_insn</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">TILE_OPC_ADDI</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">insn</span> <span class="o">=</span> <span class="n">find_matching_insn</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">TILE_OPC_ADDLI</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="cp">#ifdef __tilegx__</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">insn</span> <span class="o">=</span> <span class="n">find_matching_insn</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">TILEGX_OPC_ADDXLI</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">insn</span> <span class="o">=</span> <span class="n">find_matching_insn</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">TILEGX_OPC_ADDXI</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="o">*</span><span class="n">adjust</span> <span class="o">=</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">operand_values</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Does this bundle contain any &#39;info OP&#39; or &#39;infol OP&#39;</span>
<span class="cm"> * instruction, and if so, what are their OP?  Note that OP is interpreted</span>
<span class="cm"> * as an unsigned value by this code since that&#39;s what the caller wants.</span>
<span class="cm"> * Returns the number of info ops found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bt_get_info_ops</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">BacktraceBundle</span> <span class="o">*</span><span class="n">bundle</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">operands</span><span class="p">[</span><span class="n">MAX_INFO_OPS_PER_BUNDLE</span><span class="p">])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_ops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bundle</span><span class="o">-&gt;</span><span class="n">num_insns</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">tile_decoded_instruction</span> <span class="o">*</span><span class="n">insn</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">bundle</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="o">-&gt;</span><span class="n">mnemonic</span> <span class="o">==</span> <span class="n">TILE_OPC_INFO</span> <span class="o">||</span>
		    <span class="n">insn</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="o">-&gt;</span><span class="n">mnemonic</span> <span class="o">==</span> <span class="n">TILE_OPC_INFOL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">operands</span><span class="p">[</span><span class="n">num_ops</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">operand_values</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">num_ops</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Does this bundle contain a jrp instruction, and if so, to which</span>
<span class="cm"> * register is it jumping?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">bt_has_jrp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">BacktraceBundle</span> <span class="o">*</span><span class="n">bundle</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">target_reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tile_decoded_instruction</span> <span class="o">*</span><span class="n">insn</span> <span class="o">=</span>
		<span class="n">find_matching_insn</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">TILE_OPC_JRP</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="o">*</span><span class="n">target_reg</span> <span class="o">=</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">operand_values</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Does this bundle modify the specified register in any way? */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">bt_modifies_reg</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">BacktraceBundle</span> <span class="o">*</span><span class="n">bundle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bundle</span><span class="o">-&gt;</span><span class="n">num_insns</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">tile_decoded_instruction</span> <span class="o">*</span><span class="n">insn</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">bundle</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="o">-&gt;</span><span class="n">implicitly_written_register</span> <span class="o">==</span> <span class="n">reg</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="o">-&gt;</span><span class="n">num_operands</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">operands</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is_dest_reg</span> <span class="o">&amp;&amp;</span>
			    <span class="n">insn</span><span class="o">-&gt;</span><span class="n">operand_values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">reg</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Does this bundle modify sp? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">bt_modifies_sp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">BacktraceBundle</span> <span class="o">*</span><span class="n">bundle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bt_modifies_reg</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">TREG_SP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Does this bundle modify lr? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">bt_modifies_lr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">BacktraceBundle</span> <span class="o">*</span><span class="n">bundle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bt_modifies_reg</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">TREG_LR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Does this bundle contain the instruction &#39;move fp, sp&#39;? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">bt_has_move_r52_sp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">BacktraceBundle</span> <span class="o">*</span><span class="n">bundle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">vals</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">52</span><span class="p">,</span> <span class="n">TREG_SP</span> <span class="p">};</span>
	<span class="k">return</span> <span class="n">find_matching_insn</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">TILE_OPC_MOVE</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Does this bundle contain a store of lr to sp? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">bt_has_sw_sp_lr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">BacktraceBundle</span> <span class="o">*</span><span class="n">bundle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">vals</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">TREG_SP</span><span class="p">,</span> <span class="n">TREG_LR</span> <span class="p">};</span>
	<span class="k">return</span> <span class="n">find_matching_insn</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">OPCODE_STORE</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __tilegx__</span>
<span class="cm">/* Track moveli values placed into registers. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bt_update_moveli</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">BacktraceBundle</span> <span class="o">*</span><span class="n">bundle</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">moveli_args</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bundle</span><span class="o">-&gt;</span><span class="n">num_insns</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">tile_decoded_instruction</span> <span class="o">*</span><span class="n">insn</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">bundle</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="o">-&gt;</span><span class="n">mnemonic</span> <span class="o">==</span> <span class="n">TILEGX_OPC_MOVELI</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">operand_values</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">moveli_args</span><span class="p">[</span><span class="n">reg</span><span class="p">]</span> <span class="o">=</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">operand_values</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Does this bundle contain an &#39;add sp, sp, reg&#39; instruction</span>
<span class="cm"> * from a register that we saw a moveli into, and if so, what</span>
<span class="cm"> * is the value in the register?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">bt_has_add_sp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">BacktraceBundle</span> <span class="o">*</span><span class="n">bundle</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">adjust</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">moveli_args</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">vals</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">TREG_SP</span><span class="p">,</span> <span class="n">TREG_SP</span> <span class="p">};</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">tile_decoded_instruction</span> <span class="o">*</span><span class="n">insn</span> <span class="o">=</span>
		<span class="n">find_matching_insn</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">TILEGX_OPC_ADDX</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">operand_values</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">moveli_args</span><span class="p">[</span><span class="n">reg</span><span class="p">])</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">adjust</span> <span class="o">=</span> <span class="n">moveli_args</span><span class="p">[</span><span class="n">reg</span><span class="p">];</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Locates the caller&#39;s PC and SP for a program starting at the</span>
<span class="cm"> * given address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">find_caller_pc_and_caller_sp</span><span class="p">(</span><span class="n">CallerLocation</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pc</span><span class="p">,</span>
					 <span class="n">BacktraceMemoryReader</span> <span class="n">read_memory_func</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="o">*</span><span class="n">read_memory_func_extra</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Have we explicitly decided what the sp is,</span>
<span class="cm">	 * rather than just the default?</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="n">sp_determined</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Has any bundle seen so far modified lr? */</span>
	<span class="n">bool</span> <span class="n">lr_modified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Have we seen a move from sp to fp? */</span>
	<span class="n">bool</span> <span class="n">sp_moved_to_r52</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Have we seen a terminating bundle? */</span>
	<span class="n">bool</span> <span class="n">seen_terminating_bundle</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Cut down on round-trip reading overhead by reading several</span>
<span class="cm">	 * bundles at a time.</span>
<span class="cm">	 */</span>
	<span class="n">tile_bundle_bits</span> <span class="n">prefetched_bundles</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">num_bundles_prefetched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next_bundle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">;</span>

<span class="cp">#ifdef __tilegx__</span>
	<span class="cm">/* Naively try to track moveli values to support addx for -m32. */</span>
	<span class="kt">int</span> <span class="n">moveli_args</span><span class="p">[</span><span class="n">TILEGX_NUM_REGISTERS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="cp">#endif</span>

	<span class="cm">/* Default to assuming that the caller&#39;s sp is the current sp.</span>
<span class="cm">	 * This is necessary to handle the case where we start backtracing</span>
<span class="cm">	 * right at the end of the epilog.</span>
<span class="cm">	 */</span>
	<span class="n">location</span><span class="o">-&gt;</span><span class="n">sp_location</span> <span class="o">=</span> <span class="n">SP_LOC_OFFSET</span><span class="p">;</span>
	<span class="n">location</span><span class="o">-&gt;</span><span class="n">sp_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Default to having no idea where the caller PC is. */</span>
	<span class="n">location</span><span class="o">-&gt;</span><span class="n">pc_location</span> <span class="o">=</span> <span class="n">PC_LOC_UNKNOWN</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t even try if the PC is not aligned. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_pc</span> <span class="o">%</span> <span class="n">TILE_BUNDLE_ALIGNMENT_IN_BYTES</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pc</span> <span class="o">=</span> <span class="n">start_pc</span><span class="p">;;</span> <span class="n">pc</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tile_bundle_bits</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">struct</span> <span class="n">BacktraceBundle</span> <span class="n">bundle</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">num_info_ops</span><span class="p">,</span> <span class="n">info_operands</span><span class="p">[</span><span class="n">MAX_INFO_OPS_PER_BUNDLE</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">one_ago</span><span class="p">,</span> <span class="n">jrp_reg</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">has_jrp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">next_bundle</span> <span class="o">&gt;=</span> <span class="n">num_bundles_prefetched</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Prefetch some bytes, but don&#39;t cross a page</span>
<span class="cm">			 * boundary since that might cause a read failure we</span>
<span class="cm">			 * don&#39;t care about if we only need the first few</span>
<span class="cm">			 * bytes. Note: we don&#39;t care what the actual page</span>
<span class="cm">			 * size is; using the minimum possible page size will</span>
<span class="cm">			 * prevent any problems.</span>
<span class="cm">			 */</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes_to_prefetch</span> <span class="o">=</span> <span class="mi">4096</span> <span class="o">-</span> <span class="p">(</span><span class="n">pc</span> <span class="o">&amp;</span> <span class="mi">4095</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes_to_prefetch</span> <span class="o">&gt;</span> <span class="k">sizeof</span> <span class="n">prefetched_bundles</span><span class="p">)</span>
				<span class="n">bytes_to_prefetch</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="n">prefetched_bundles</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_memory_func</span><span class="p">(</span><span class="n">prefetched_bundles</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span>
					      <span class="n">bytes_to_prefetch</span><span class="p">,</span>
					      <span class="n">read_memory_func_extra</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pc</span> <span class="o">==</span> <span class="n">start_pc</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* The program probably called a bad</span>
<span class="cm">					 * address, such as a NULL pointer.</span>
<span class="cm">					 * So treat this as if we are at the</span>
<span class="cm">					 * start of the function prolog so the</span>
<span class="cm">					 * backtrace will show how we got here.</span>
<span class="cm">					 */</span>
					<span class="n">location</span><span class="o">-&gt;</span><span class="n">pc_location</span> <span class="o">=</span> <span class="n">PC_LOC_IN_LR</span><span class="p">;</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* Unreadable address. Give up. */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">next_bundle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">num_bundles_prefetched</span> <span class="o">=</span>
				<span class="n">bytes_to_prefetch</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tile_bundle_bits</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Decode the next bundle. */</span>
		<span class="n">bundle</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">prefetched_bundles</span><span class="p">[</span><span class="n">next_bundle</span><span class="o">++</span><span class="p">];</span>
		<span class="n">bundle</span><span class="p">.</span><span class="n">num_insns</span> <span class="o">=</span>
			<span class="n">parse_insn_tile</span><span class="p">(</span><span class="n">bundle</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">bundle</span><span class="p">.</span><span class="n">insns</span><span class="p">);</span>
		<span class="n">num_info_ops</span> <span class="o">=</span> <span class="n">bt_get_info_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bundle</span><span class="p">,</span> <span class="n">info_operands</span><span class="p">);</span>

		<span class="cm">/* First look at any one_ago info ops if they are interesting,</span>
<span class="cm">		 * since they should shadow any non-one-ago info ops.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">one_ago</span> <span class="o">=</span> <span class="p">(</span><span class="n">pc</span> <span class="o">!=</span> <span class="n">start_pc</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">one_ago</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">one_ago</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_info_ops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">info_operand</span> <span class="o">=</span> <span class="n">info_operands</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">info_operand</span> <span class="o">&lt;</span> <span class="n">CALLER_UNKNOWN_BASE</span><span class="p">)</span>	<span class="p">{</span>
					<span class="cm">/* Weird; reserved value, ignore it. */</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* Skip info ops which are not in the</span>
<span class="cm">				 * &quot;one_ago&quot; mode we want right now.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(((</span><span class="n">info_operand</span> <span class="o">&amp;</span> <span class="n">ONE_BUNDLE_AGO_FLAG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				    <span class="o">!=</span> <span class="p">(</span><span class="n">one_ago</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="cm">/* Clear the flag to make later checking</span>
<span class="cm">				 * easier. */</span>
				<span class="n">info_operand</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ONE_BUNDLE_AGO_FLAG</span><span class="p">;</span>

				<span class="cm">/* Default to looking at PC_IN_LR_FLAG. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">info_operand</span> <span class="o">&amp;</span> <span class="n">PC_IN_LR_FLAG</span><span class="p">)</span>
					<span class="n">location</span><span class="o">-&gt;</span><span class="n">pc_location</span> <span class="o">=</span>
						<span class="n">PC_LOC_IN_LR</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">location</span><span class="o">-&gt;</span><span class="n">pc_location</span> <span class="o">=</span>
						<span class="n">PC_LOC_ON_STACK</span><span class="p">;</span>

				<span class="k">switch</span> <span class="p">(</span><span class="n">info_operand</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">CALLER_UNKNOWN_BASE</span>:
					<span class="n">location</span><span class="o">-&gt;</span><span class="n">pc_location</span> <span class="o">=</span> <span class="n">PC_LOC_UNKNOWN</span><span class="p">;</span>
					<span class="n">location</span><span class="o">-&gt;</span><span class="n">sp_location</span> <span class="o">=</span> <span class="n">SP_LOC_UNKNOWN</span><span class="p">;</span>
					<span class="k">return</span><span class="p">;</span>

				<span class="k">case</span> <span class="n">CALLER_SP_IN_R52_BASE</span>:
				<span class="k">case</span> <span class="n">CALLER_SP_IN_R52_BASE</span> <span class="o">|</span> <span class="n">PC_IN_LR_FLAG</span>:
					<span class="n">location</span><span class="o">-&gt;</span><span class="n">sp_location</span> <span class="o">=</span> <span class="n">SP_LOC_IN_R52</span><span class="p">;</span>
					<span class="k">return</span><span class="p">;</span>

				<span class="nl">default:</span>
				<span class="p">{</span>
					<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">info_operand</span>
						<span class="o">-</span> <span class="n">CALLER_SP_OFFSET_BASE</span><span class="p">;</span>
					<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sp_offset</span> <span class="o">=</span>
						<span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="n">NUM_INFO_OP_FLAGS</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">sp_offset</span> <span class="o">&lt;</span> <span class="mi">32768</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* This is a properly encoded</span>
<span class="cm">						 * SP offset. */</span>
						<span class="n">location</span><span class="o">-&gt;</span><span class="n">sp_location</span> <span class="o">=</span>
							<span class="n">SP_LOC_OFFSET</span><span class="p">;</span>
						<span class="n">location</span><span class="o">-&gt;</span><span class="n">sp_offset</span> <span class="o">=</span>
							<span class="n">sp_offset</span><span class="p">;</span>
						<span class="k">return</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="cm">/* This looked like an SP</span>
<span class="cm">						 * offset, but it&#39;s outside</span>
<span class="cm">						 * the legal range, so this</span>
<span class="cm">						 * must be an unrecognized</span>
<span class="cm">						 * info operand.  Ignore it.</span>
<span class="cm">						 */</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">seen_terminating_bundle</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We saw a terminating bundle during the previous</span>
<span class="cm">			 * iteration, so we were only looking for an info op.</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bundle</span><span class="p">.</span><span class="n">bits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Wacky terminating bundle. Stop looping, and hope</span>
<span class="cm">			 * we&#39;ve already seen enough to find the caller.</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Try to determine caller&#39;s SP.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp_determined</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">adjust</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bt_has_addi_sp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bundle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adjust</span><span class="p">)</span>
<span class="cp">#ifdef __tilegx__</span>
			    <span class="o">||</span> <span class="n">bt_has_add_sp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bundle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adjust</span><span class="p">,</span> <span class="n">moveli_args</span><span class="p">)</span>
<span class="cp">#endif</span>
				<span class="p">)</span> <span class="p">{</span>
				<span class="n">location</span><span class="o">-&gt;</span><span class="n">sp_location</span> <span class="o">=</span> <span class="n">SP_LOC_OFFSET</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">adjust</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* We are in prolog about to adjust</span>
<span class="cm">					 * SP. */</span>
					<span class="n">location</span><span class="o">-&gt;</span><span class="n">sp_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* We are in epilog restoring SP. */</span>
					<span class="n">location</span><span class="o">-&gt;</span><span class="n">sp_offset</span> <span class="o">=</span> <span class="n">adjust</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">sp_determined</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bt_has_move_r52_sp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bundle</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* Maybe in prolog, creating an</span>
<span class="cm">					 * alloca-style frame.  But maybe in</span>
<span class="cm">					 * the middle of a fixed-size frame</span>
<span class="cm">					 * clobbering r52 with SP.</span>
<span class="cm">					 */</span>
					<span class="n">sp_moved_to_r52</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">bt_modifies_sp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bundle</span><span class="p">))</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">sp_moved_to_r52</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* We saw SP get saved into</span>
<span class="cm">						 * r52 earlier (or now), which</span>
<span class="cm">						 * must have been in the</span>
<span class="cm">						 * prolog, so we now know that</span>
<span class="cm">						 * SP is still holding the</span>
<span class="cm">						 * caller&#39;s sp value.</span>
<span class="cm">						 */</span>
						<span class="n">location</span><span class="o">-&gt;</span><span class="n">sp_location</span> <span class="o">=</span>
							<span class="n">SP_LOC_OFFSET</span><span class="p">;</span>
						<span class="n">location</span><span class="o">-&gt;</span><span class="n">sp_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="cm">/* Someone must have saved</span>
<span class="cm">						 * aside the caller&#39;s SP value</span>
<span class="cm">						 * into r52, so r52 holds the</span>
<span class="cm">						 * current value.</span>
<span class="cm">						 */</span>
						<span class="n">location</span><span class="o">-&gt;</span><span class="n">sp_location</span> <span class="o">=</span>
							<span class="n">SP_LOC_IN_R52</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">sp_determined</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

<span class="cp">#ifdef __tilegx__</span>
			<span class="cm">/* Track moveli arguments for -m32 mode. */</span>
			<span class="n">bt_update_moveli</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bundle</span><span class="p">,</span> <span class="n">moveli_args</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bt_has_iret</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bundle</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* This is a terminating bundle. */</span>
			<span class="n">seen_terminating_bundle</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Try to determine caller&#39;s PC.</span>
<span class="cm">		 */</span>

		<span class="n">jrp_reg</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">has_jrp</span> <span class="o">=</span> <span class="n">bt_has_jrp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bundle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jrp_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">has_jrp</span><span class="p">)</span>
			<span class="n">seen_terminating_bundle</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">location</span><span class="o">-&gt;</span><span class="n">pc_location</span> <span class="o">==</span> <span class="n">PC_LOC_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">has_jrp</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">jrp_reg</span> <span class="o">==</span> <span class="n">TREG_LR</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lr_modified</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Looks like a leaf function, or else</span>
<span class="cm">					 * lr is already restored. */</span>
					<span class="n">location</span><span class="o">-&gt;</span><span class="n">pc_location</span> <span class="o">=</span>
						<span class="n">PC_LOC_IN_LR</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">location</span><span class="o">-&gt;</span><span class="n">pc_location</span> <span class="o">=</span>
						<span class="n">PC_LOC_ON_STACK</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bt_has_sw_sp_lr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bundle</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* In prolog, spilling initial lr to stack. */</span>
				<span class="n">location</span><span class="o">-&gt;</span><span class="n">pc_location</span> <span class="o">=</span> <span class="n">PC_LOC_IN_LR</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bt_modifies_lr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bundle</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">lr_modified</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Initializes a backtracer to start from the given location.</span>
<span class="cm"> *</span>
<span class="cm"> * If the frame pointer cannot be determined it is set to -1.</span>
<span class="cm"> *</span>
<span class="cm"> * state: The state to be filled in.</span>
<span class="cm"> * read_memory_func: A callback that reads memory.</span>
<span class="cm"> * read_memory_func_extra: An arbitrary argument to read_memory_func.</span>
<span class="cm"> * pc: The current PC.</span>
<span class="cm"> * lr: The current value of the &#39;lr&#39; register.</span>
<span class="cm"> * sp: The current value of the &#39;sp&#39; register.</span>
<span class="cm"> * r52: The current value of the &#39;r52&#39; register.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">backtrace_init</span><span class="p">(</span><span class="n">BacktraceIterator</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		    <span class="n">BacktraceMemoryReader</span> <span class="n">read_memory_func</span><span class="p">,</span>
		    <span class="kt">void</span> <span class="o">*</span><span class="n">read_memory_func_extra</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lr</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r52</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">CallerLocation</span> <span class="n">location</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp</span><span class="p">,</span> <span class="n">initial_frame_caller_pc</span><span class="p">;</span>

	<span class="cm">/* Find out where we are in the initial frame. */</span>
	<span class="n">find_caller_pc_and_caller_sp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">location</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span>
				     <span class="n">read_memory_func</span><span class="p">,</span> <span class="n">read_memory_func_extra</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">sp_location</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SP_LOC_UNKNOWN</span>:
		<span class="cm">/* Give up. */</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SP_LOC_IN_R52</span>:
		<span class="n">fp</span> <span class="o">=</span> <span class="n">r52</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SP_LOC_OFFSET</span>:
		<span class="n">fp</span> <span class="o">=</span> <span class="n">sp</span> <span class="o">+</span> <span class="n">location</span><span class="p">.</span><span class="n">sp_offset</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* Give up. */</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If the frame pointer is not aligned to the basic word size</span>
<span class="cm">	 * something terrible happened and we should mark it as invalid.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bt_int_reg_t</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* -1 means &quot;don&#39;t know initial_frame_caller_pc&quot;. */</span>
	<span class="n">initial_frame_caller_pc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">pc_location</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PC_LOC_UNKNOWN</span>:
		<span class="cm">/* Give up. */</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PC_LOC_IN_LR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">lr</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">lr</span> <span class="o">%</span> <span class="n">TILE_BUNDLE_ALIGNMENT_IN_BYTES</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Give up. */</span>
			<span class="n">fp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">initial_frame_caller_pc</span> <span class="o">=</span> <span class="n">lr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PC_LOC_ON_STACK</span>:
		<span class="cm">/* Leave initial_frame_caller_pc as -1,</span>
<span class="cm">		 * meaning check the stack.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* Give up. */</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">state</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">=</span> <span class="n">pc</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">initial_frame_caller_pc</span> <span class="o">=</span> <span class="n">initial_frame_caller_pc</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">read_memory_func</span> <span class="o">=</span> <span class="n">read_memory_func</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">read_memory_func_extra</span> <span class="o">=</span> <span class="n">read_memory_func_extra</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Handle the case where the register holds more bits than the VA. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">valid_addr_reg</span><span class="p">(</span><span class="n">bt_int_reg_t</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">reg</span> <span class="o">==</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Advances the backtracing state to the calling frame, returning</span>
<span class="cm"> * true iff successful.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">backtrace_next</span><span class="p">(</span><span class="n">BacktraceIterator</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_fp</span><span class="p">,</span> <span class="n">next_pc</span><span class="p">;</span>
	<span class="n">bt_int_reg_t</span> <span class="n">next_frame</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">fp</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No parent frame. */</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Try to read the frame linkage data chaining to the next function. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">read_memory_func</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_frame</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">next_frame</span><span class="p">,</span>
				     <span class="n">state</span><span class="o">-&gt;</span><span class="n">read_memory_func_extra</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">next_fp</span> <span class="o">=</span> <span class="n">next_frame</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_addr_reg</span><span class="p">(</span><span class="n">next_frame</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">||</span>
	    <span class="n">next_fp</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bt_int_reg_t</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Caller&#39;s frame pointer is suspect, so give up. */</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">initial_frame_caller_pc</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We must be in the initial stack frame and already know the</span>
<span class="cm">		 * caller PC.</span>
<span class="cm">		 */</span>
		<span class="n">next_pc</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">initial_frame_caller_pc</span><span class="p">;</span>

		<span class="cm">/* Force reading stack next time, in case we were in the</span>
<span class="cm">		 * initial frame.  We don&#39;t do this above just to paranoidly</span>
<span class="cm">		 * avoid changing the struct at all when we return false.</span>
<span class="cm">		 */</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">initial_frame_caller_pc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Get the caller PC from the frame linkage area. */</span>
		<span class="n">next_pc</span> <span class="o">=</span> <span class="n">next_frame</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_addr_reg</span><span class="p">(</span><span class="n">next_frame</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">||</span> <span class="n">next_pc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">next_pc</span> <span class="o">%</span> <span class="n">TILE_BUNDLE_ALIGNMENT_IN_BYTES</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The PC is suspect, so give up. */</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Update state to become the caller&#39;s stack frame. */</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">=</span> <span class="n">next_pc</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">fp</span> <span class="o">=</span> <span class="n">next_fp</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
