<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › kernel › pci.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pci.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2011 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/hv_driver.h&gt;</span>
<span class="cp">#include &lt;hv/drv_pcie_rc_intf.h&gt;</span>


<span class="cm">/*</span>
<span class="cm"> * Initialization flow and process</span>
<span class="cm"> * -------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * This files contains the routines to search for PCI buses,</span>
<span class="cm"> * enumerate the buses, and configure any attached devices.</span>
<span class="cm"> *</span>
<span class="cm"> * There are two entry points here:</span>
<span class="cm"> * 1) tile_pci_init</span>
<span class="cm"> *    This sets up the pci_controller structs, and opens the</span>
<span class="cm"> *    FDs to the hypervisor.  This is called from setup_arch() early</span>
<span class="cm"> *    in the boot process.</span>
<span class="cm"> * 2) pcibios_init</span>
<span class="cm"> *    This probes the PCI bus(es) for any attached hardware.  It&#39;s</span>
<span class="cm"> *    called by subsys_initcall.  All of the real work is done by the</span>
<span class="cm"> *    generic Linux PCI layer.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This flag tells if the platform is TILEmpower that needs</span>
<span class="cm"> * special configuration for the PLX switch chip.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__write_once</span> <span class="n">tile_plx_gen1</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_controller</span> <span class="n">controllers</span><span class="p">[</span><span class="n">TILE_NUM_PCIE</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">num_controllers</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pci_scan_flags</span><span class="p">[</span><span class="n">TILE_NUM_PCIE</span><span class="p">];</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_ops</span> <span class="n">tile_cfg_ops</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * We don&#39;t need to worry about the alignment of resources.</span>
<span class="cm"> */</span>
<span class="n">resource_size_t</span> <span class="nf">pcibios_align_resource</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			    <span class="n">resource_size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pcibios_align_resource</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Open a FD to the hypervisor PCI device.</span>
<span class="cm"> *</span>
<span class="cm"> * controller_id is the controller number, config type is 0 or 1 for</span>
<span class="cm"> * config0 or config1 operations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">tile_pcie_open</span><span class="p">(</span><span class="kt">int</span> <span class="n">controller_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">config_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">filename</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;pcie/%d/config%d&quot;</span><span class="p">,</span> <span class="n">controller_id</span><span class="p">,</span> <span class="n">config_type</span><span class="p">);</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">hv_dev_open</span><span class="p">((</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="n">filename</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Get the IRQ numbers from the HV and set up the handlers for them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">tile_init_irqs</span><span class="p">(</span><span class="kt">int</span> <span class="n">controller_id</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">controller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">filename</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcie_rc_config</span> <span class="n">rc_config</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;pcie/%d/ctl&quot;</span><span class="p">,</span> <span class="n">controller_id</span><span class="p">);</span>
	<span class="n">fd</span> <span class="o">=</span> <span class="n">hv_dev_open</span><span class="p">((</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="n">filename</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;PCI: hv_dev_open(%s) failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">hv_dev_pread</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">rc_config</span><span class="p">),</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="n">rc_config</span><span class="p">),</span> <span class="n">PCIE_RC_CONFIG_MASK_OFF</span><span class="p">);</span>
	<span class="n">hv_dev_close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rc_config</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;PCI: wanted %zd bytes, got %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">rc_config</span><span class="p">),</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Record irq_base so that we can map INTx to IRQ # later. */</span>
	<span class="n">controller</span><span class="o">-&gt;</span><span class="n">irq_base</span> <span class="o">=</span> <span class="n">rc_config</span><span class="p">.</span><span class="n">intr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
		<span class="n">tile_irq_activate</span><span class="p">(</span><span class="n">rc_config</span><span class="p">.</span><span class="n">intr</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span>
				  <span class="n">TILE_IRQ_HW_CLEAR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc_config</span><span class="p">.</span><span class="n">plx_gen1</span><span class="p">)</span>
		<span class="n">controller</span><span class="o">-&gt;</span><span class="n">plx_gen1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * First initialization entry point, called from setup_arch().</span>
<span class="cm"> *</span>
<span class="cm"> * Find valid controllers and fill in pci_controller structs for each</span>
<span class="cm"> * of them.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of controllers discovered.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">tile_pci_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;PCI: Searching for controllers...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Re-init number of PCIe controllers to support hot-plug feature. */</span>
	<span class="n">num_controllers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Do any configuration we need before using the PCIe */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TILE_NUM_PCIE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * To see whether we need a real config op based on</span>
<span class="cm">		 * the results of pcibios_init(), to support PCIe hot-plug.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_scan_flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">hv_cfg_fd0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">hv_cfg_fd1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">hv_mem_fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">controller</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Open the fd to the HV.  If it fails then this</span>
<span class="cm">			 * device doesn&#39;t exist.</span>
<span class="cm">			 */</span>
			<span class="n">hv_cfg_fd0</span> <span class="o">=</span> <span class="n">tile_pcie_open</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hv_cfg_fd0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">hv_cfg_fd1</span> <span class="o">=</span> <span class="n">tile_pcie_open</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hv_cfg_fd1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;PCI: Couldn&#39;t open config fd to HV &quot;</span>
				    <span class="s">&quot;for controller %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err_cont</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;pcie/%d/mem&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">hv_mem_fd</span> <span class="o">=</span> <span class="n">hv_dev_open</span><span class="p">((</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hv_mem_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;PCI: Could not open mem fd to HV!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err_cont</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;PCI: Found PCI controller #%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

			<span class="n">controller</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">controllers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="n">controller</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">controller</span><span class="o">-&gt;</span><span class="n">hv_cfg_fd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">hv_cfg_fd0</span><span class="p">;</span>
			<span class="n">controller</span><span class="o">-&gt;</span><span class="n">hv_cfg_fd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hv_cfg_fd1</span><span class="p">;</span>
			<span class="n">controller</span><span class="o">-&gt;</span><span class="n">hv_mem_fd</span> <span class="o">=</span> <span class="n">hv_mem_fd</span><span class="p">;</span>
			<span class="n">controller</span><span class="o">-&gt;</span><span class="n">first_busno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">controller</span><span class="o">-&gt;</span><span class="n">last_busno</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">controller</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tile_cfg_ops</span><span class="p">;</span>

			<span class="n">num_controllers</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

<span class="nl">err_cont:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hv_cfg_fd0</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">hv_dev_close</span><span class="p">(</span><span class="n">hv_cfg_fd0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hv_cfg_fd1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">hv_dev_close</span><span class="p">(</span><span class="n">hv_cfg_fd1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hv_mem_fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">hv_dev_close</span><span class="p">(</span><span class="n">hv_mem_fd</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Before using the PCIe, see if we need to do any platform-specific</span>
<span class="cm">	 * configuration, such as the PLX switch Gen 1 issue on TILEmpower.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_controllers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">controller</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">controllers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">plx_gen1</span><span class="p">)</span>
			<span class="n">tile_plx_gen1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">num_controllers</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * (pin - 1) converts from the PCI standard&#39;s [1:4] convention to</span>
<span class="cm"> * a normal [0:3] range.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tile_map_irq</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">slot</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">controller</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sysdata</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">irq_base</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">fixup_read_and_payload_sizes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">smallest_max_payload</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span> <span class="cm">/* Tile maxes out at 256 bytes. */</span>
	<span class="kt">int</span> <span class="n">max_read_size</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">;</span> <span class="cm">/* Limit to 512 byte reads. */</span>
	<span class="n">u16</span> <span class="n">new_values</span><span class="p">;</span>

	<span class="cm">/* Scan for the smallest maximum payload size. */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pcie_caps_offset</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">devcap</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">max_payload</span><span class="p">;</span>

		<span class="n">pcie_caps_offset</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_EXP</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcie_caps_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pcie_caps_offset</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCAP</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">devcap</span><span class="p">);</span>
		<span class="n">max_payload</span> <span class="o">=</span> <span class="n">devcap</span> <span class="o">&amp;</span> <span class="n">PCI_EXP_DEVCAP_PAYLOAD</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_payload</span> <span class="o">&lt;</span> <span class="n">smallest_max_payload</span><span class="p">)</span>
			<span class="n">smallest_max_payload</span> <span class="o">=</span> <span class="n">max_payload</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now, set the max_payload_size for all devices to that value. */</span>
	<span class="n">new_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_read_size</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">smallest_max_payload</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pcie_caps_offset</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">devctl</span><span class="p">;</span>

		<span class="n">pcie_caps_offset</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_EXP</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcie_caps_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pcie_caps_offset</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">devctl</span><span class="p">);</span>
		<span class="n">devctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PCI_EXP_DEVCTL_PAYLOAD</span> <span class="o">|</span> <span class="n">PCI_EXP_DEVCTL_READRQ</span><span class="p">);</span>
		<span class="n">devctl</span> <span class="o">|=</span> <span class="n">new_values</span><span class="p">;</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pcie_caps_offset</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span>
				      <span class="n">devctl</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Second PCI initialization entry point, called by subsys_initcall.</span>
<span class="cm"> *</span>
<span class="cm"> * The controllers have been set up by the time we get here, by a call to</span>
<span class="cm"> * tile_pci_init.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">pcibios_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;PCI: Probing PCI hardware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Delay a bit in case devices aren&#39;t ready.  Some devices are</span>
<span class="cm">	 * known to require at least 20ms here, but we use a more</span>
<span class="cm">	 * conservative value.</span>
<span class="cm">	 */</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">250</span><span class="p">);</span>

	<span class="cm">/* Scan all of the recorded PCI controllers.  */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TILE_NUM_PCIE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do real pcibios init ops if the controller is initialized</span>
<span class="cm">		 * by tile_pci_init() successfully and not initialized by</span>
<span class="cm">		 * pcibios_init() yet to support PCIe hot-plug.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_scan_flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">controllers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ops</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">controller</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">controllers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tile_init_irqs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">controller</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;PCI: Could not initialize IRQs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;PCI: initializing controller #%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * This comes from the generic Linux PCI driver.</span>
<span class="cm">			 *</span>
<span class="cm">			 * It reads the PCI tree for this bus into the Linux</span>
<span class="cm">			 * data structures.</span>
<span class="cm">			 *</span>
<span class="cm">			 * This is inlined in linux/pci.h and calls into</span>
<span class="cm">			 * pci_scan_bus_parented() in probe.c.</span>
<span class="cm">			 */</span>
			<span class="n">bus</span> <span class="o">=</span> <span class="n">pci_scan_bus</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">,</span> <span class="n">controller</span><span class="p">);</span>
			<span class="n">controller</span><span class="o">-&gt;</span><span class="n">root_bus</span> <span class="o">=</span> <span class="n">bus</span><span class="p">;</span>
			<span class="n">controller</span><span class="o">-&gt;</span><span class="n">last_busno</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Do machine dependent PCI interrupt routing */</span>
	<span class="n">pci_fixup_irqs</span><span class="p">(</span><span class="n">pci_common_swizzle</span><span class="p">,</span> <span class="n">tile_map_irq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This comes from the generic Linux PCI driver.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It allocates all of the resources (I/O memory, etc)</span>
<span class="cm">	 * associated with the devices read in above.</span>
<span class="cm">	 */</span>
	<span class="n">pci_assign_unassigned_resources</span><span class="p">();</span>

	<span class="cm">/* Configure the max_read_size and max_payload_size values. */</span>
	<span class="n">fixup_read_and_payload_sizes</span><span class="p">();</span>

	<span class="cm">/* Record the I/O resources in the PCI controller structure. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TILE_NUM_PCIE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do real pcibios init ops if the controller is initialized</span>
<span class="cm">		 * by tile_pci_init() successfully and not initialized by</span>
<span class="cm">		 * pcibios_init() yet to support PCIe hot-plug.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_scan_flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">controllers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ops</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">root_bus</span> <span class="o">=</span> <span class="n">controllers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">root_bus</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">next_bus</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_bus</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">bus_list</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Find the PCI host controller, ie. the 1st</span>
<span class="cm">				 * bridge.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCI_CLASS_BRIDGE_PCI</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">next_bus</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="p">;</span>
					<span class="n">controllers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem_resources</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
						<span class="o">*</span><span class="n">next_bus</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
					<span class="n">controllers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem_resources</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
						 <span class="o">*</span><span class="n">next_bus</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
					<span class="n">controllers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem_resources</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
						 <span class="o">*</span><span class="n">next_bus</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

					<span class="cm">/* Setup flags. */</span>
					<span class="n">pci_scan_flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">pcibios_init</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * No bus fixups needed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pcibios_fixup_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Nothing needs to be done. */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pcibios_set_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* No special bus mastering setup handling. */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This can be called from the generic PCI layer, but doesn&#39;t need to</span>
<span class="cm"> * do anything.</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="n">__devinit</span> <span class="o">*</span><span class="nf">pcibios_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Nothing needs to be done. */</span>
	<span class="k">return</span> <span class="n">str</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called from the generic Linux layer.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pcibios_update_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_INTERRUPT_LINE</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable memory and/or address decoding, as appropriate, for the</span>
<span class="cm"> * device described by the &#39;dev&#39; struct.</span>
<span class="cm"> *</span>
<span class="cm"> * This is called from the generic PCI layer, and can be called</span>
<span class="cm"> * for bridges or endpoints.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pcibios_enable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">old_cmd</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">header_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_HEADER_TYPE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header_type</span><span class="p">);</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">old_cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">header_type</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCI_HEADER_TYPE_BRIDGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For bridges, we enable both memory and I/O decoding</span>
<span class="cm">		 * in call cases.</span>
<span class="cm">		 */</span>
		<span class="n">cmd</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_IO</span><span class="p">;</span>
		<span class="n">cmd</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_MEMORY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For endpoints, we enable memory and/or I/O decoding</span>
<span class="cm">		 * only if they have a memory resource of that type.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_UNSET</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;PCI: Device %s not available &quot;</span>
				       <span class="s">&quot;because of resource collisions</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_IO</span><span class="p">)</span>
				<span class="n">cmd</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_IO</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">)</span>
				<span class="n">cmd</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_MEMORY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We only write the command if it changed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">old_cmd</span><span class="p">)</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/****************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Tile PCI config space read/write routines</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * These are the normal read and write ops</span>
<span class="cm"> * These are expanded with macros from  pci_bus_read_config_byte() etc.</span>
<span class="cm"> *</span>
<span class="cm"> * devfn is the combined PCI slot &amp; function.</span>
<span class="cm"> *</span>
<span class="cm"> * offset is in bytes, from the start of config space for the</span>
<span class="cm"> * specified bus &amp; slot.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">tile_cfg_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">controller</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">sysdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">busnum</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="p">(</span><span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">function</span> <span class="o">=</span> <span class="n">devfn</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">config_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is no bridge between the Tile and bus 0, so we</span>
<span class="cm">	 * use config0 to talk to bus 0.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we&#39;re talking to a bus other than zero then we</span>
<span class="cm">	 * must have found a bridge.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">busnum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We fake an empty slot for (busnum == 0) &amp;&amp; (slot &gt; 0),</span>
<span class="cm">		 * since there is only one slot on bus 0.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">config_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">busnum</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">;</span>		<span class="cm">/* Bus in 27:20 */</span>
	<span class="n">addr</span> <span class="o">|=</span> <span class="n">slot</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">;</span>		<span class="cm">/* Slot (device) in 19:15 */</span>
	<span class="n">addr</span> <span class="o">|=</span> <span class="n">function</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">;</span>		<span class="cm">/* Function is in 14:12 */</span>
	<span class="n">addr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">);</span>	<span class="cm">/* byte address in 0:11 */</span>

	<span class="k">return</span> <span class="n">hv_dev_pread</span><span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">hv_cfg_fd</span><span class="p">[</span><span class="n">config_mode</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)(</span><span class="n">val</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * See tile_cfg_read() for relevant comments.</span>
<span class="cm"> * Note that &quot;val&quot; is the value to write, not a pointer to that value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">tile_cfg_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">controller</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">sysdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">busnum</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="p">(</span><span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">function</span> <span class="o">=</span> <span class="n">devfn</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">config_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">HV_VirtAddr</span> <span class="n">valp</span> <span class="o">=</span> <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For bus 0 slot 0 we use config 0 accesses.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">busnum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We fake an empty slot for (busnum == 0) &amp;&amp; (slot &gt; 0),</span>
<span class="cm">		 * since there is only one slot on bus 0.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">config_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">busnum</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">;</span>		<span class="cm">/* Bus in 27:20 */</span>
	<span class="n">addr</span> <span class="o">|=</span> <span class="n">slot</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">;</span>		<span class="cm">/* Slot (device) in 19:15 */</span>
	<span class="n">addr</span> <span class="o">|=</span> <span class="n">function</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">;</span>		<span class="cm">/* Function is in 14:12 */</span>
	<span class="n">addr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">);</span>	<span class="cm">/* byte address in 0:11 */</span>

<span class="cp">#ifdef __BIG_ENDIAN</span>
	<span class="cm">/* Point to the correct part of the 32-bit &quot;val&quot;. */</span>
	<span class="n">valp</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">size</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">hv_dev_pwrite</span><span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">hv_cfg_fd</span><span class="p">[</span><span class="n">config_mode</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">valp</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_ops</span> <span class="n">tile_cfg_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span>         <span class="n">tile_cfg_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span>        <span class="n">tile_cfg_write</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * In the following, each PCI controller&#39;s mem_resources[1]</span>
<span class="cm"> * represents its (non-prefetchable) PCI memory resource.</span>
<span class="cm"> * mem_resources[0] and mem_resources[2] refer to its PCI I/O and</span>
<span class="cm"> * prefetchable PCI memory resources, respectively.</span>
<span class="cm"> * For more details, see pci_setup_bridge() in setup-bus.c.</span>
<span class="cm"> * By comparing the target PCI memory address against the</span>
<span class="cm"> * end address of controller 0, we can determine the controller</span>
<span class="cm"> * that should accept the PCI memory access.</span>
<span class="cm"> */</span>
<span class="cp">#define TILE_READ(size, type)						\</span>
<span class="cp">type _tile_read##size(unsigned long addr)				\</span>
<span class="cp">{									\</span>
<span class="cp">	type val;							\</span>
<span class="cp">	int idx = 0;							\</span>
<span class="cp">	if (addr &gt; controllers[0].mem_resources[1].end &amp;&amp;		\</span>
<span class="cp">	    addr &gt; controllers[0].mem_resources[2].end)			\</span>
<span class="cp">		idx = 1;                                                \</span>
<span class="cp">	if (hv_dev_pread(controllers[idx].hv_mem_fd, 0,			\</span>
<span class="cp">			 (HV_VirtAddr)(&amp;val), sizeof(type), addr))	\</span>
<span class="cp">		pr_err(&quot;PCI: read %zd bytes at 0x%lX failed\n&quot;,		\</span>
<span class="cp">		       sizeof(type), addr);				\</span>
<span class="cp">	return val;							\</span>
<span class="cp">}									\</span>
<span class="cp">EXPORT_SYMBOL(_tile_read##size)</span>

<span class="n">TILE_READ</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="n">TILE_READ</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
<span class="n">TILE_READ</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
<span class="n">TILE_READ</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">u64</span><span class="p">);</span>

<span class="cp">#define TILE_WRITE(size, type)						\</span>
<span class="cp">void _tile_write##size(type val, unsigned long addr)			\</span>
<span class="cp">{									\</span>
<span class="cp">	int idx = 0;							\</span>
<span class="cp">	if (addr &gt; controllers[0].mem_resources[1].end &amp;&amp;		\</span>
<span class="cp">	    addr &gt; controllers[0].mem_resources[2].end)			\</span>
<span class="cp">		idx = 1;                                                \</span>
<span class="cp">	if (hv_dev_pwrite(controllers[idx].hv_mem_fd, 0,		\</span>
<span class="cp">			  (HV_VirtAddr)(&amp;val), sizeof(type), addr))	\</span>
<span class="cp">		pr_err(&quot;PCI: write %zd bytes at 0x%lX failed\n&quot;,	\</span>
<span class="cp">		       sizeof(type), addr);				\</span>
<span class="cp">}									\</span>
<span class="cp">EXPORT_SYMBOL(_tile_write##size)</span>

<span class="n">TILE_WRITE</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="n">TILE_WRITE</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
<span class="n">TILE_WRITE</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
<span class="n">TILE_WRITE</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">u64</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
