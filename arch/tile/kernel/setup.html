<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › kernel › setup.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>setup.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mmzone.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/node.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/kexec.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/initrd.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/start_kernel.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;hv/hypervisor.h&gt;</span>
<span class="cp">#include &lt;arch/interrupts.h&gt;</span>

<span class="cm">/* &lt;linux/smp.h&gt; doesn&#39;t provide this definition. */</span>
<span class="cp">#ifndef CONFIG_SMP</span>
<span class="cp">#define setup_max_cpus 1</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ABS</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="o">-</span><span class="n">x</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Chip information */</span>
<span class="kt">char</span> <span class="n">chip_model</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="n">__write_once</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">pglist_data</span> <span class="n">node_data</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">node_data</span><span class="p">);</span>

<span class="cm">/* Information on the NUMA nodes that we compute early */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__cpuinitdata</span> <span class="n">node_start_pfn</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__cpuinitdata</span> <span class="n">node_end_pfn</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__initdata</span> <span class="n">node_memmap_pfn</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__initdata</span> <span class="n">node_percpu_pfn</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__initdata</span> <span class="n">node_free_pfn</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__initdata</span> <span class="n">node_percpu</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * per-CPU stack and boot info.</span>
<span class="cm"> */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">boot_sp</span><span class="p">)</span> <span class="o">=</span>
	<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">init_stack</span> <span class="o">+</span> <span class="n">THREAD_SIZE</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">boot_pc</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start_kernel</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cm">/*</span>
<span class="cm"> * The variable must be __initdata since it references __init code.</span>
<span class="cm"> * With CONFIG_SMP it is per-cpu data, which is exempt from validation.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__initdata</span> <span class="n">boot_pc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start_kernel</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
<span class="cm">/* Page frame index of end of lowmem on each controller. */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__cpuinitdata</span> <span class="n">node_lowmem_end_pfn</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>

<span class="cm">/* Number of pages that can be mapped into lowmem. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__initdata</span> <span class="n">mappable_physpages</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/* Data on which physical memory controller corresponds to which NUMA node */</span>
<span class="kt">int</span> <span class="n">node_controller</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">MAX_NUMNODES</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
<span class="cm">/* Map information from VAs to PAs */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pbase_map</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">HPAGE_SHIFT</span><span class="p">)]</span>
  <span class="n">__write_once</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="n">L2_CACHE_BYTES</span><span class="p">)));</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pbase_map</span><span class="p">);</span>

<span class="cm">/* Map information from PAs to VAs */</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">vbase_map</span><span class="p">[</span><span class="n">NR_PA_HIGHBIT_VALUES</span><span class="p">]</span>
  <span class="n">__write_once</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="n">L2_CACHE_BYTES</span><span class="p">)));</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vbase_map</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Node number as a function of the high PA bits */</span>
<span class="kt">int</span> <span class="n">highbits_to_node</span><span class="p">[</span><span class="n">NR_PA_HIGHBIT_VALUES</span><span class="p">]</span> <span class="n">__write_once</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">highbits_to_node</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">maxmem_pfn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1U</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">maxnodemem_pfn</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">MAX_NUMNODES</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1U</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">nodemask_t</span> <span class="n">__initdata</span> <span class="n">isolnodes</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">DEFAULT_PCI_RESERVE_MB</span> <span class="o">=</span> <span class="mi">64</span> <span class="p">};</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">pci_reserve_mb</span> <span class="o">=</span> <span class="n">DEFAULT_PCI_RESERVE_MB</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__initdata</span> <span class="n">pci_reserve_start_pfn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1U</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__initdata</span> <span class="n">pci_reserve_end_pfn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1U</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_maxmem</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">maxmem</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="p">(</span><span class="n">maxmem</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">maxmem_pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxmem</span> <span class="o">&gt;&gt;</span> <span class="n">HPAGE_SHIFT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">HPAGE_SHIFT</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Forcing RAM used to no more than %dMB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">maxmem_pfn</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;maxmem&quot;</span><span class="p">,</span> <span class="n">setup_maxmem</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_maxnodemem</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">maxnodemem</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">str</span> <span class="o">?</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">INT_MAX</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">&gt;=</span> <span class="n">MAX_NUMNODES</span> <span class="o">||</span> <span class="o">*</span><span class="n">endp</span> <span class="o">!=</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">maxnodemem</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">endp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">maxnodemem_pfn</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxnodemem</span> <span class="o">&gt;&gt;</span> <span class="n">HPAGE_SHIFT</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
		<span class="p">(</span><span class="n">HPAGE_SHIFT</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Forcing RAM used on node %ld to no more than %dMB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">node</span><span class="p">,</span> <span class="n">maxnodemem_pfn</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;maxnodemem&quot;</span><span class="p">,</span> <span class="n">setup_maxnodemem</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_isolnodes</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_NUMNODES</span> <span class="o">*</span> <span class="mi">5</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">nodelist_parse</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">isolnodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">nodelist_scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">isolnodes</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Set isolnodes value to &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;isolnodes&quot;</span><span class="p">,</span> <span class="n">setup_isolnodes</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_pci_reserve</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mb</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">mb</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pci_reserve_mb</span> <span class="o">=</span> <span class="n">mb</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Reserving %dMB for PCIE root complex mappings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">pci_reserve_mb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;pci_reserve&quot;</span><span class="p">,</span> <span class="n">setup_pci_reserve</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __tilegx__</span>
<span class="cm">/*</span>
<span class="cm"> * vmalloc=size forces the vmalloc area to be exactly &#39;size&#39; bytes.</span>
<span class="cm"> * This can be used to increase (or decrease) the vmalloc area.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parse_vmalloc</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arg</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">VMALLOC_RESERVE</span> <span class="o">=</span> <span class="p">(</span><span class="n">memparse</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="n">PGDIR_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PGDIR_MASK</span><span class="p">;</span>

	<span class="cm">/* See validate_va() for more on this test. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">_VMALLOC_START</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">early_panic</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">vmalloc=%#lx</span><span class="se">\&quot;</span><span class="s"> value too large: maximum %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">VMALLOC_RESERVE</span><span class="p">,</span> <span class="n">_VMALLOC_END</span> <span class="o">-</span> <span class="mh">0x80000000UL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;vmalloc&quot;</span><span class="p">,</span> <span class="n">parse_vmalloc</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
<span class="cm">/*</span>
<span class="cm"> * Determine for each controller where its lowmem is mapped and how much of</span>
<span class="cm"> * it is mapped there.  On controller zero, the first few megabytes are</span>
<span class="cm"> * already mapped in as code at MEM_SV_INTRPT, so in principle we could</span>
<span class="cm"> * start our data mappings higher up, but for now we don&#39;t bother, to avoid</span>
<span class="cm"> * additional confusion.</span>
<span class="cm"> *</span>
<span class="cm"> * One question is whether, on systems with more than 768 Mb and</span>
<span class="cm"> * controllers of different sizes, to map in a proportionate amount of</span>
<span class="cm"> * each one, or to try to map the same amount from each controller.</span>
<span class="cm"> * (E.g. if we have three controllers with 256MB, 1GB, and 256MB</span>
<span class="cm"> * respectively, do we map 256MB from each, or do we map 128 MB, 512</span>
<span class="cm"> * MB, and 128 MB respectively?)  For now we use a proportionate</span>
<span class="cm"> * solution like the latter.</span>
<span class="cm"> *</span>
<span class="cm"> * The VA/PA mapping demands that we align our decisions at 16 MB</span>
<span class="cm"> * boundaries so that we can rapidly convert VA to PA.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">__init</span> <span class="nf">setup_pa_va_mapping</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">curr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span><span class="p">;</span>
	<span class="n">nodemask_t</span> <span class="n">highonlynodes</span> <span class="o">=</span> <span class="n">isolnodes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">pbase_map</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pbase_map</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">vbase_map</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vbase_map</span><span class="p">));</span>

	<span class="cm">/* Node zero cannot be isolated for LOWMEM purposes. */</span>
	<span class="n">node_clear</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">highonlynodes</span><span class="p">);</span>

	<span class="cm">/* Count up the number of pages on non-highonlynodes controllers. */</span>
	<span class="n">mappable_physpages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_isset</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">highonlynodes</span><span class="p">))</span>
			<span class="n">mappable_physpages</span> <span class="o">+=</span>
				<span class="n">node_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_start_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">node_start_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">node_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr_end</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">node_isset</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">highonlynodes</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Mark this controller as having no lowmem. */</span>
			<span class="n">node_lowmem_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">curr_pages</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mappable_physpages</span> <span class="o">&gt;</span> <span class="n">MAXMEM_PFN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vaddr_end</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span> <span class="o">+</span>
				<span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="n">curr_pages</span> <span class="o">*</span> <span class="n">MAXMEM_PFN</span> <span class="o">/</span>
				  <span class="n">mappable_physpages</span><span class="p">)</span>
				 <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">vaddr_end</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="p">(</span><span class="n">curr_pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">vaddr_end</span><span class="p">;</span> <span class="n">vaddr</span> <span class="o">+=</span> <span class="n">HPAGE_SIZE</span><span class="p">,</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">this_pfn</span> <span class="o">=</span>
				<span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="n">HUGETLB_PAGE_ORDER</span><span class="p">);</span>
			<span class="n">pbase_map</span><span class="p">[</span><span class="n">vaddr</span> <span class="o">&gt;&gt;</span> <span class="n">HPAGE_SHIFT</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_pfn</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vbase_map</span><span class="p">[</span><span class="n">__pfn_to_highbits</span><span class="p">(</span><span class="n">this_pfn</span><span class="p">)]</span> <span class="o">==</span>
			    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="n">vbase_map</span><span class="p">[</span><span class="n">__pfn_to_highbits</span><span class="p">(</span><span class="n">this_pfn</span><span class="p">)]</span> <span class="o">=</span>
					<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">vaddr</span> <span class="o">&amp;</span> <span class="n">HPAGE_MASK</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">node_lowmem_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="n">HUGETLB_PAGE_ORDER</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">node_lowmem_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Return highest address of any mapped memory. */</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">vaddr</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HIGHMEM */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Register our most important memory mappings with the debug stub.</span>
<span class="cm"> *</span>
<span class="cm"> * This is up to 4 mappings for lowmem, one mapping per memory</span>
<span class="cm"> * controller, plus one for our text segment.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">store_permanent_mappings</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">HV_PhysAddr</span> <span class="n">pa</span> <span class="o">=</span> <span class="p">((</span><span class="n">HV_PhysAddr</span><span class="p">)</span><span class="n">node_start_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
		<span class="n">HV_PhysAddr</span> <span class="n">high_mapped_pa</span> <span class="o">=</span> <span class="n">node_lowmem_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cp">#else</span>
		<span class="n">HV_PhysAddr</span> <span class="n">high_mapped_pa</span> <span class="o">=</span> <span class="n">node_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cp">#endif</span>

		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span> <span class="o">=</span> <span class="n">high_mapped_pa</span> <span class="o">-</span> <span class="n">node_start_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">HV_VirtAddr</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span> <span class="n">__va</span><span class="p">(</span><span class="n">pa</span><span class="p">);</span>
		<span class="n">hv_store_mapping</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">pa</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hv_store_mapping</span><span class="p">((</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="n">_stext</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">_einittext</span> <span class="o">-</span> <span class="n">_stext</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use hv_inquire_physical() to populate node_{start,end}_pfn[]</span>
<span class="cm"> * and node_online_map, doing suitable sanity-checking.</span>
<span class="cm"> * Also set min_low_pfn, max_low_pfn, and max_pfn.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">highbits_seen</span><span class="p">[</span><span class="n">NR_PA_HIGHBIT_VALUES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="kt">long</span> <span class="n">highmem_pages</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef __tilegx__</span>
	<span class="kt">int</span> <span class="n">cap</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(CONFIG_HIGHMEM) || defined(__tilegx__)</span>
	<span class="kt">long</span> <span class="n">lowmem_pages</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* We are using a char to hold the cpu_2_node[] mapping */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MAX_NUMNODES</span> <span class="o">&gt;</span> <span class="mi">127</span><span class="p">);</span>

	<span class="cm">/* Discover the ranges of memory available to us */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">highbits</span><span class="p">;</span>
		<span class="n">HV_PhysAddrRange</span> <span class="n">range</span> <span class="o">=</span> <span class="n">hv_inquire_physical</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_FLATMEM</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Can&#39;t use discontiguous PAs: %#llx..%#llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">range</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">range</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef __tilegx__</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Range not at 4GB multiple: %#llx..%#llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">range</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HPAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HPAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">start_pa</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">orig_size</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
			<span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_pa</span> <span class="o">+</span> <span class="n">HPAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HPAGE_MASK</span><span class="p">;</span>
			<span class="n">range</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">-</span> <span class="n">start_pa</span><span class="p">);</span>
			<span class="n">range</span><span class="p">.</span><span class="n">size</span> <span class="o">&amp;=</span> <span class="n">HPAGE_MASK</span><span class="p">;</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Range not hugepage-aligned: %#llx..%#llx:&quot;</span>
			       <span class="s">&quot; now %#llx-%#llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">start_pa</span><span class="p">,</span> <span class="n">start_pa</span> <span class="o">+</span> <span class="n">orig_size</span><span class="p">,</span>
			       <span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">range</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">highbits</span> <span class="o">=</span> <span class="n">__pa_to_highbits</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">highbits</span> <span class="o">&gt;=</span> <span class="n">NR_PA_HIGHBIT_VALUES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;PA high bits too high: %#llx..%#llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">range</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">highbits_seen</span><span class="p">[</span><span class="n">highbits</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Range overlaps in high bits: %#llx..%#llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">range</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">highbits_seen</span><span class="p">[</span><span class="n">highbits</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxnodemem_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">max_size</span> <span class="o">=</span> <span class="n">maxnodemem_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">max_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Maxnodemem reduced node %d to&quot;</span>
				       <span class="s">&quot; %d pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">max_size</span><span class="p">);</span>
				<span class="n">range</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">max_size</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Maxnodemem disabled node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_physpages</span> <span class="o">+</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxmem_pfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">max_size</span> <span class="o">=</span> <span class="n">maxmem_pfn</span> <span class="o">-</span> <span class="n">num_physpages</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">max_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Maxmem reduced node %d to %d pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">i</span><span class="p">,</span> <span class="n">max_size</span><span class="p">);</span>
				<span class="n">range</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">max_size</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Maxmem disabled node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Too many PA nodes (#%d): %#llx...%#llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">i</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">start</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

<span class="cp">#ifndef __tilegx__</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">HV_PhysAddr</span><span class="p">)</span><span class="n">end</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">range</span><span class="p">.</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;PAs too high to represent: %#llx..%#llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">range</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_PCI</span>
		<span class="cm">/*</span>
<span class="cm">		 * Blocks that overlap the pci reserved region must</span>
<span class="cm">		 * have enough space to hold the maximum percpu data</span>
<span class="cm">		 * region at the top of the range.  If there isn&#39;t</span>
<span class="cm">		 * enough space above the reserved region, just</span>
<span class="cm">		 * truncate the node.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">pci_reserve_start_pfn</span> <span class="o">&amp;&amp;</span>
		    <span class="n">end</span> <span class="o">&gt;</span> <span class="n">pci_reserve_start_pfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">per_cpu_size</span> <span class="o">=</span>
				<span class="n">__per_cpu_end</span> <span class="o">-</span> <span class="n">__per_cpu_start</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">percpu_pages</span> <span class="o">=</span>
				<span class="n">NR_CPUS</span> <span class="o">*</span> <span class="p">(</span><span class="n">PFN_UP</span><span class="p">(</span><span class="n">per_cpu_size</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">pci_reserve_end_pfn</span> <span class="o">+</span> <span class="n">percpu_pages</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">pci_reserve_start_pfn</span><span class="p">;</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;PCI mapping region reduced node %d to&quot;</span>
				       <span class="s">&quot; %ld pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#endif</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">__pfn_to_highbits</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		     <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">__pfn_to_highbits</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">highbits_to_node</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">node_start_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">node_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
		<span class="n">node_controller</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">controller</span><span class="p">;</span>
		<span class="n">num_physpages</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">max_pfn</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>

		<span class="cm">/* Mark node as online */</span>
		<span class="n">node_set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">node_online_map</span><span class="p">);</span>
		<span class="n">node_set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">node_possible_map</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifndef __tilegx__</span>
	<span class="cm">/*</span>
<span class="cm">	 * For 4KB pages, mem_map &quot;struct page&quot; data is 1% of the size</span>
<span class="cm">	 * of the physical memory, so can be quite big (640 MB for</span>
<span class="cm">	 * four 16G zones).  These structures must be mapped in</span>
<span class="cm">	 * lowmem, and since we currently cap out at about 768 MB,</span>
<span class="cm">	 * it&#39;s impractical to try to use this much address space.</span>
<span class="cm">	 * For now, arbitrarily cap the amount of physical memory</span>
<span class="cm">	 * we&#39;re willing to use at 8 million pages (32GB of 4KB pages).</span>
<span class="cm">	 */</span>
	<span class="n">cap</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>  <span class="cm">/* 8 million pages */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_physpages</span> <span class="o">&gt;</span> <span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">num_online_nodes</span><span class="p">();</span>
		<span class="kt">int</span> <span class="n">cap_each</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">/</span> <span class="n">num_nodes</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dropped_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_nodes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">node_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_start_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">cap_each</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dropped_pages</span> <span class="o">+=</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">cap_each</span><span class="p">);</span>
				<span class="n">node_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_start_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">cap_each</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">num_physpages</span> <span class="o">-=</span> <span class="n">dropped_pages</span><span class="p">;</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Only using %ldMB memory;&quot;</span>
		       <span class="s">&quot; ignoring %ldMB.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">num_physpages</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span>
		       <span class="n">dropped_pages</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Consider using a larger page size.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Heap starts just above the last loaded address. */</span>
	<span class="n">min_low_pfn</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_end</span> <span class="o">-</span> <span class="n">PAGE_OFFSET</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="cm">/* Find where we map lowmem from each controller. */</span>
	<span class="n">high_memory</span> <span class="o">=</span> <span class="n">setup_pa_va_mapping</span><span class="p">();</span>

	<span class="cm">/* Set max_low_pfn based on what node 0 can directly address. */</span>
	<span class="n">max_low_pfn</span> <span class="o">=</span> <span class="n">node_lowmem_end_pfn</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">lowmem_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">mappable_physpages</span> <span class="o">&gt;</span> <span class="n">MAXMEM_PFN</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">MAXMEM_PFN</span> <span class="o">:</span> <span class="n">mappable_physpages</span><span class="p">;</span>
	<span class="n">highmem_pages</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">num_physpages</span> <span class="o">-</span> <span class="n">lowmem_pages</span><span class="p">);</span>

	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;%ldMB HIGHMEM available.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">pages_to_mb</span><span class="p">(</span><span class="n">highmem_pages</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">highmem_pages</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;%ldMB LOWMEM available.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pages_to_mb</span><span class="p">(</span><span class="n">lowmem_pages</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="cm">/* Set max_low_pfn based on what node 0 can directly address. */</span>
	<span class="n">max_low_pfn</span> <span class="o">=</span> <span class="n">node_end_pfn</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="cp">#ifndef __tilegx__</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_end_pfn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">MAXMEM_PFN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Only using %ldMB LOWMEM.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">MAXMEM</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">);</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Use a HIGHMEM enabled kernel.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">max_low_pfn</span> <span class="o">=</span> <span class="n">MAXMEM_PFN</span><span class="p">;</span>
		<span class="n">max_pfn</span> <span class="o">=</span> <span class="n">MAXMEM_PFN</span><span class="p">;</span>
		<span class="n">num_physpages</span> <span class="o">=</span> <span class="n">MAXMEM_PFN</span><span class="p">;</span>
		<span class="n">node_end_pfn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MAXMEM_PFN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;%ldMB memory available.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">pages_to_mb</span><span class="p">(</span><span class="n">node_end_pfn</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node_start_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">node_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">high_memory</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">node_end_pfn</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="cp">#else</span>
	<span class="n">lowmem_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pages</span> <span class="o">=</span> <span class="n">node_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_start_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">lowmem_pages</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span>
			<span class="n">high_memory</span> <span class="o">=</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">node_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;%ldMB memory available.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">pages_to_mb</span><span class="p">(</span><span class="n">lowmem_pages</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * On 32-bit machines, we only put bootmem on the low controller,</span>
<span class="cm"> * since PAs &gt; 4GB can&#39;t be used in bootmem.  In principle one could</span>
<span class="cm"> * imagine, e.g., multiple 1 GB controllers all of which could support</span>
<span class="cm"> * bootmem, but in practice using controllers this small isn&#39;t a</span>
<span class="cm"> * particularly interesting scenario, so we just keep it simple and</span>
<span class="cm"> * use only the first controller for bootmem on 32-bit machines.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">node_has_bootmem</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">nid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">alloc_bootmem_pfn</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">kva</span> <span class="o">=</span> <span class="n">__alloc_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span>
					 <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">kaddr_to_pfn</span><span class="p">(</span><span class="n">kva</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">goal</span> <span class="o">&amp;&amp;</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">pfn</span><span class="p">)</span> <span class="o">!=</span> <span class="n">goal</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_bootmem_allocator_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">mapsize</span><span class="p">,</span> <span class="n">mapstart</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node_has_bootmem</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">NODE_DATA</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bootmem_node_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Share controller zero&#39;s bdata for now. */</span>
		<span class="n">NODE_DATA</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bootmem_node_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Skip up to after the bss in node 0. */</span>
	<span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">min_low_pfn</span> <span class="o">:</span> <span class="n">node_start_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="cm">/* Only lowmem, if we&#39;re a HIGHMEM build. */</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">node_lowmem_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cp">#else</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">node_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cp">#endif</span>

	<span class="cm">/* No memory here. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">start</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Figure out where the bootmem bitmap is located. */</span>
	<span class="n">mapsize</span> <span class="o">=</span> <span class="n">bootmem_bootmap_pages</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Use some space right before the heap on node 0. */</span>
		<span class="n">mapstart</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="n">mapsize</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Allocate bitmap on node 0 to avoid page table issues. */</span>
		<span class="n">mapstart</span> <span class="o">=</span> <span class="n">alloc_bootmem_pfn</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">mapsize</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize a node. */</span>
	<span class="n">init_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">mapstart</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="cm">/* Free all the space back into the allocator. */</span>
	<span class="n">free_bootmem</span><span class="p">(</span><span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">));</span>

<span class="cp">#if defined(CONFIG_PCI)</span>
	<span class="cm">/*</span>
<span class="cm">	 * Throw away any memory aliased by the PCI region.  FIXME: this</span>
<span class="cm">	 * is a temporary hack to work around bug 10502, and needs to be</span>
<span class="cm">	 * fixed properly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_reserve_start_pfn</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">pci_reserve_end_pfn</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span>
		<span class="n">reserve_bootmem</span><span class="p">(</span><span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">pci_reserve_start_pfn</span><span class="p">),</span>
				<span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">pci_reserve_end_pfn</span> <span class="o">-</span>
					 <span class="n">pci_reserve_start_pfn</span><span class="p">),</span>
				<span class="n">BOOTMEM_EXCLUSIVE</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_bootmem_allocator</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">setup_bootmem_allocator_node</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_KEXEC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crashk_res</span><span class="p">.</span><span class="n">start</span> <span class="o">!=</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span><span class="p">)</span>
		<span class="n">reserve_bootmem</span><span class="p">(</span><span class="n">crashk_res</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crashk_res</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">__init</span> <span class="nf">alloc_remap</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pages</span> <span class="o">=</span> <span class="n">node_end_pfn</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_start_pfn</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">node_memmap_pfn</span><span class="p">[</span><span class="n">nid</span><span class="p">]);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="n">pages</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">map</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">percpu_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">__per_cpu_end</span> <span class="o">-</span> <span class="n">__per_cpu_start</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">PERCPU_MODULE_RESERVE</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">PERCPU_DYNAMIC_EARLY_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">PCPU_MIN_UNIT_SIZE</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">PCPU_MIN_UNIT_SIZE</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="cm">/* In several places we assume the per-cpu data fits on a huge page. */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">kdata_huge</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">HPAGE_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">zone_sizes_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zones_size</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">percpu_size</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">num_cpus</span> <span class="o">=</span> <span class="n">smp_height</span> <span class="o">*</span> <span class="n">smp_width</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_cpus</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">node_percpu</span><span class="p">[</span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">node_start_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">node_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lowmem_end</span> <span class="o">=</span> <span class="n">node_lowmem_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cp">#else</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lowmem_end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="kt">int</span> <span class="n">memmap_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">node_free_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set aside pages for per-cpu data and the mem_map array.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Since the per-cpu data requires special homecaching,</span>
<span class="cm">		 * if we are in kdata_huge mode, we put it at the end of</span>
<span class="cm">		 * the lowmem region.  If we&#39;re not in kdata_huge mode,</span>
<span class="cm">		 * we take the per-cpu pages from the bottom of the</span>
<span class="cm">		 * controller, since that avoids fragmenting a huge page</span>
<span class="cm">		 * that users might want.  We always take the memmap</span>
<span class="cm">		 * from the bottom of the controller, since with</span>
<span class="cm">		 * kdata_huge that lets it be under a huge TLB entry.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If the user has requested isolnodes for a controller,</span>
<span class="cm">		 * though, there&#39;ll be no lowmem, so we just alloc_bootmem</span>
<span class="cm">		 * the memmap.  There will be no percpu memory either.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_isset</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">isolnodes</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">node_memmap_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">alloc_bootmem_pfn</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">memmap_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">node_percpu</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node_has_bootmem</span><span class="p">(</span><span class="n">start</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">node_memmap_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">alloc_bootmem_pfn</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">memmap_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kdata_huge</span><span class="p">)</span>
				<span class="n">goal</span> <span class="o">=</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">lowmem_end</span><span class="p">)</span> <span class="o">-</span> <span class="n">node_percpu</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">node_percpu</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">node_percpu_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">alloc_bootmem_pfn</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">node_percpu</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							  <span class="n">goal</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* In non-bootmem zones, just reserve some pages. */</span>
			<span class="n">node_memmap_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_free_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">node_free_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">memmap_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kdata_huge</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">node_percpu_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_free_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">node_free_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">node_percpu</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">node_percpu_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">lowmem_end</span> <span class="o">-</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">node_percpu</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">lowmem_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">zones_size</span><span class="p">[</span><span class="n">ZONE_NORMAL</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">zones_size</span><span class="p">[</span><span class="n">ZONE_HIGHMEM</span><span class="p">]</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">zones_size</span><span class="p">[</span><span class="n">ZONE_NORMAL</span><span class="p">]</span> <span class="o">=</span> <span class="n">lowmem_end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
			<span class="n">zones_size</span><span class="p">[</span><span class="n">ZONE_HIGHMEM</span><span class="p">]</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">lowmem_end</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#else</span>
		<span class="n">zones_size</span><span class="p">[</span><span class="n">ZONE_NORMAL</span><span class="p">]</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="cm">/* Take zone metadata from controller 0 if we&#39;re isolnode. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_isset</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">isolnodes</span><span class="p">))</span>
			<span class="n">NODE_DATA</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bootmem_node_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="n">free_area_init_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">zones_size</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  Normal zone: %ld per-cpu pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">PFN_UP</span><span class="p">(</span><span class="n">node_percpu</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>

		<span class="cm">/* Track the type of memory on each node */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zones_size</span><span class="p">[</span><span class="n">ZONE_NORMAL</span><span class="p">])</span>
			<span class="n">node_set_state</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">!=</span> <span class="n">start</span><span class="p">)</span>
			<span class="n">node_set_state</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N_HIGH_MEMORY</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="n">node_set_online</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NUMA</span>

<span class="cm">/* which logical CPUs are on which nodes */</span>
<span class="k">struct</span> <span class="n">cpumask</span> <span class="n">node_2_cpu_mask</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">]</span> <span class="n">__write_once</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">node_2_cpu_mask</span><span class="p">);</span>

<span class="cm">/* which node each logical CPU is on */</span>
<span class="kt">char</span> <span class="n">cpu_2_node</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">]</span> <span class="n">__write_once</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="n">L2_CACHE_BYTES</span><span class="p">)));</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cpu_2_node</span><span class="p">);</span>

<span class="cm">/* Return cpu_to_node() except for cpus not yet assigned, which return -1 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cpu_to_bound_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span><span class="o">*</span> <span class="n">unbound_cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_possible</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">||</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">unbound_cpus</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Return number of immediately-adjacent tiles sharing the same NUMA node. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">node_neighbors</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">unbound_cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">smp_width</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">smp_height</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cpu</span> <span class="o">%</span> <span class="n">w</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">cpu</span> <span class="o">/</span> <span class="n">w</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_to_bound_node</span><span class="p">(</span><span class="n">cpu</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">unbound_cpus</span><span class="p">)</span> <span class="o">==</span> <span class="n">node</span><span class="p">)</span>
		<span class="o">++</span><span class="n">neighbors</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">w</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_to_bound_node</span><span class="p">(</span><span class="n">cpu</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">unbound_cpus</span><span class="p">)</span> <span class="o">==</span> <span class="n">node</span><span class="p">)</span>
		<span class="o">++</span><span class="n">neighbors</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_to_bound_node</span><span class="p">(</span><span class="n">cpu</span><span class="o">-</span><span class="n">w</span><span class="p">,</span> <span class="n">unbound_cpus</span><span class="p">)</span> <span class="o">==</span> <span class="n">node</span><span class="p">)</span>
		<span class="o">++</span><span class="n">neighbors</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_to_bound_node</span><span class="p">(</span><span class="n">cpu</span><span class="o">+</span><span class="n">w</span><span class="p">,</span> <span class="n">unbound_cpus</span><span class="p">)</span> <span class="o">==</span> <span class="n">node</span><span class="p">)</span>
		<span class="o">++</span><span class="n">neighbors</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">neighbors</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_numa_mapping</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">distance</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">][</span><span class="n">NR_CPUS</span><span class="p">];</span>
	<span class="n">HV_Coord</span> <span class="n">coord</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cpus</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">num_online_nodes</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="n">unbound_cpus</span><span class="p">;</span>
	<span class="n">nodemask_t</span> <span class="n">default_nodes</span><span class="p">;</span>

	<span class="n">cpumask_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unbound_cpus</span><span class="p">);</span>

	<span class="cm">/* Get set of nodes we will use for defaults */</span>
	<span class="n">nodes_andnot</span><span class="p">(</span><span class="n">default_nodes</span><span class="p">,</span> <span class="n">node_online_map</span><span class="p">,</span> <span class="n">isolnodes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nodes_empty</span><span class="p">(</span><span class="n">default_nodes</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">node_isset</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_online_map</span><span class="p">));</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Forcing NUMA node zero available as a default node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">node_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">default_nodes</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Populate the distance[] array */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">distance</span><span class="p">));</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">coord</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">coord</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">smp_height</span><span class="p">;</span> <span class="o">++</span><span class="n">coord</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">coord</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">coord</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">smp_width</span><span class="p">;</span>
		     <span class="o">++</span><span class="n">coord</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">++</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_possible</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">cpu_2_node</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">default_nodes</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">HV_MemoryControllerInfo</span> <span class="n">info</span> <span class="o">=</span>
					<span class="n">hv_inquire_memory_controller</span><span class="p">(</span>
						<span class="n">coord</span><span class="p">,</span> <span class="n">node_controller</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>
				<span class="n">distance</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">ABS</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">coord</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">ABS</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">coord</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unbound_cpus</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cpus</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Round-robin through the NUMA nodes until all the cpus are</span>
<span class="cm">	 * assigned.  We could be more clever here (e.g. create four</span>
<span class="cm">	 * sorted linked lists on the same set of cpu nodes, and pull</span>
<span class="cm">	 * off them in round-robin sequence, removing from all four</span>
<span class="cm">	 * lists each time) but given the relatively small numbers</span>
<span class="cm">	 * involved, O(n^2) seem OK for a one-time cost.</span>
<span class="cm">	 */</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">default_nodes</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unbound_cpus</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">best_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">best_distance</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">cpus</span><span class="p">;</span> <span class="o">++</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unbound_cpus</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Compute metric, which is how much</span>
<span class="cm">				 * closer the cpu is to this memory</span>
<span class="cm">				 * controller than the others, shifted</span>
<span class="cm">				 * up, and then the number of</span>
<span class="cm">				 * neighbors already in the node as an</span>
<span class="cm">				 * epsilon adjustment to try to keep</span>
<span class="cm">				 * the nodes compact.</span>
<span class="cm">				 */</span>
				<span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">cpu</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_nodes</span><span class="p">;</span>
				<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">default_nodes</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">node</span><span class="p">)</span>
						<span class="n">d</span> <span class="o">-=</span> <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">cpu</span><span class="p">];</span>
				<span class="p">}</span>
				<span class="n">d</span> <span class="o">*=</span> <span class="mi">8</span><span class="p">;</span>  <span class="cm">/* allow space for epsilon */</span>
				<span class="n">d</span> <span class="o">-=</span> <span class="n">node_neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unbound_cpus</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">best_distance</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">best_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
					<span class="n">best_distance</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">best_cpu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">best_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_2_cpu_mask</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>
		<span class="n">cpu_2_node</span><span class="p">[</span><span class="n">best_cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">best_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unbound_cpus</span><span class="p">);</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">next_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">default_nodes</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">default_nodes</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Print out node assignments and set defaults for disabled cpus */</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">smp_height</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;NUMA cpu-to-node row %d:&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">smp_width</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">,</span> <span class="o">++</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; -&quot;</span><span class="p">);</span>
				<span class="n">cpu_2_node</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">default_nodes</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; %d&quot;</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cpu</span> <span class="n">cpu_devices</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">topology_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">register_one_node</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">smp_height</span> <span class="o">*</span> <span class="n">smp_width</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">register_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_devices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">topology_init</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_NUMA */</span><span class="cp"></span>

<span class="cp">#define setup_numa_mapping() do { } while (0)</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_NUMA */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Initialize hugepage support on this cpu.  We do this on all cores</span>
<span class="cm"> * early in boot: before argument parsing for the boot cpu, and after</span>
<span class="cm"> * argument parsing but before the init functions run on the secondaries.</span>
<span class="cm"> * So the values we set up here in the hypervisor may be overridden on</span>
<span class="cm"> * the boot cpu as arguments are parsed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__cpuinit</span> <span class="kt">void</span> <span class="nf">init_super_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_HUGETLB_SUPER_PAGES</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HUGE_SHIFT_ENTRIES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">hv_set_pte_super_shift</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">huge_shift</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * setup_cpu() - Do all necessary per-cpu, tile-specific initialization.</span>
<span class="cm"> * @boot: Is this the boot cpu?</span>
<span class="cm"> *</span>
<span class="cm"> * Called from setup_arch() on the boot cpu, or online_secondary().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">setup_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">boot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The boot cpu sets up its permanent mappings much earlier. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">boot</span><span class="p">)</span>
		<span class="n">store_permanent_mappings</span><span class="p">();</span>

	<span class="cm">/* Allow asynchronous TLB interrupts. */</span>
<span class="cp">#if CHIP_HAS_TILE_DMA()</span>
	<span class="n">arch_local_irq_unmask</span><span class="p">(</span><span class="n">INT_DMATLB_MISS</span><span class="p">);</span>
	<span class="n">arch_local_irq_unmask</span><span class="p">(</span><span class="n">INT_DMATLB_ACCESS</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_SN_PROC()</span>
	<span class="n">arch_local_irq_unmask</span><span class="p">(</span><span class="n">INT_SNITLB_MISS</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef __tilegx__</span>
	<span class="n">arch_local_irq_unmask</span><span class="p">(</span><span class="n">INT_SINGLE_STEP_K</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow user access to many generic SPRs, like the cycle</span>
<span class="cm">	 * counter, PASS/FAIL/DONE, INTERRUPT_CRITICAL_SECTION, etc.</span>
<span class="cm">	 */</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_WORLD_ACCESS_SET_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="cp">#if CHIP_HAS_SN()</span>
	<span class="cm">/* Static network is not restricted. */</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_SN_ACCESS_SET_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_SN_PROC()</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_SN_NOTIFY_SET_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_SN_CPL_SET_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the MPL for interrupt control 0 &amp; 1 to the corresponding</span>
<span class="cm">	 * values.  This includes access to the SYSTEM_SAVE and EX_CONTEXT</span>
<span class="cm">	 * SPRs, as well as the interrupt mask.</span>
<span class="cm">	 */</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_INTCTRL_0_SET_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_INTCTRL_1_SET_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Initialize IRQ support for this cpu. */</span>
	<span class="n">setup_irq_regs</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_HARDWALL</span>
	<span class="cm">/* Reset the network state on this cpu. */</span>
	<span class="n">reset_network_state</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="n">init_super_pages</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>

<span class="cm">/*</span>
<span class="cm"> * Note that the kernel can potentially support other compression</span>
<span class="cm"> * techniques than gz, though we don&#39;t do so by default.  If we ever</span>
<span class="cm"> * decide to do so we can either look for other filename extensions,</span>
<span class="cm"> * or just allow a file with this name to be compressed with an</span>
<span class="cm"> * arbitrary compressor (somewhat counterintuitively).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">set_initramfs_file</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">__initdata</span> <span class="n">initramfs_file</span><span class="p">[</span><span class="mi">128</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;initramfs.cpio.gz&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_initramfs_file</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">initramfs_file</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">initramfs_file</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">set_initramfs_file</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;initramfs_file&quot;</span><span class="p">,</span> <span class="n">setup_initramfs_file</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We look for an &quot;initramfs.cpio.gz&quot; file in the hvfs.</span>
<span class="cm"> * If there is one, we allocate some memory for it and it will be</span>
<span class="cm"> * unpacked to the initramfs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">load_hv_initrd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">HV_FS_StatInfo</span> <span class="n">stat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">initrd</span><span class="p">;</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">hv_fs_findfile</span><span class="p">((</span><span class="n">HV_VirtAddr</span><span class="p">)</span> <span class="n">initramfs_file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="n">HV_ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set_initramfs_file</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;No such hvfs initramfs file &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">initramfs_file</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">stat</span> <span class="o">=</span> <span class="n">hv_fs_fstat</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">stat</span><span class="p">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HV_FS_ISDIR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Ignoring hvfs file &#39;%s&#39;: it&#39;s a directory.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">initramfs_file</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">initrd</span> <span class="o">=</span> <span class="n">alloc_bootmem_pages</span><span class="p">(</span><span class="n">stat</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hv_fs_pread</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span> <span class="n">initrd</span><span class="p">,</span> <span class="n">stat</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">stat</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error reading %d bytes from hvfs file &#39;%s&#39;: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">stat</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">initramfs_file</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">free_initrd_mem</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">initrd</span><span class="p">,</span> <span class="n">stat</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">initrd_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">initrd</span><span class="p">;</span>
	<span class="n">initrd_end</span> <span class="o">=</span> <span class="n">initrd_start</span> <span class="o">+</span> <span class="n">stat</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">free_initrd_mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">begin</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_bootmem</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">load_hv_initrd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_BLK_DEV_INITRD */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">validate_hv</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * It may already be too late, but let&#39;s check our built-in</span>
<span class="cm">	 * configuration against what the hypervisor is providing.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">glue_size</span> <span class="o">=</span> <span class="n">hv_sysconf</span><span class="p">(</span><span class="n">HV_SYSCONF_GLUE_SIZE</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">hv_page_size</span> <span class="o">=</span> <span class="n">hv_sysconf</span><span class="p">(</span><span class="n">HV_SYSCONF_PAGE_SIZE_SMALL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">hv_hpage_size</span> <span class="o">=</span> <span class="n">hv_sysconf</span><span class="p">(</span><span class="n">HV_SYSCONF_PAGE_SIZE_LARGE</span><span class="p">);</span>
	<span class="n">HV_ASIDRange</span> <span class="n">asid_range</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_SMP</span>
	<span class="n">HV_Topology</span> <span class="n">topology</span> <span class="o">=</span> <span class="n">hv_inquire_topology</span><span class="p">();</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">topology</span><span class="p">.</span><span class="n">coord</span><span class="p">.</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">topology</span><span class="p">.</span><span class="n">coord</span><span class="p">.</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">topology</span><span class="p">.</span><span class="n">width</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">topology</span><span class="p">.</span><span class="n">height</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: booting UP kernel on %dx%d grid;&quot;</span>
			   <span class="s">&quot; will ignore all but first tile.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">topology</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">topology</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="n">HV_GLUE_START_CPA</span> <span class="o">+</span> <span class="n">glue_size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_text</span><span class="p">)</span>
		<span class="n">early_panic</span><span class="p">(</span><span class="s">&quot;Hypervisor glue size %ld is too big!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">glue_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hv_page_size</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">early_panic</span><span class="p">(</span><span class="s">&quot;Hypervisor page size %#x != our %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">hv_page_size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hv_hpage_size</span> <span class="o">!=</span> <span class="n">HPAGE_SIZE</span><span class="p">)</span>
		<span class="n">early_panic</span><span class="p">(</span><span class="s">&quot;Hypervisor huge page size %#x != our %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">hv_hpage_size</span><span class="p">,</span> <span class="n">HPAGE_SIZE</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/*</span>
<span class="cm">	 * Some hypervisor APIs take a pointer to a bitmap array</span>
<span class="cm">	 * whose size is at least the number of cpus on the chip.</span>
<span class="cm">	 * We use a struct cpumask for this, so it must be big enough.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">smp_height</span> <span class="o">*</span> <span class="n">smp_width</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
		<span class="n">early_panic</span><span class="p">(</span><span class="s">&quot;Hypervisor %d x %d grid too big for Linux&quot;</span>
			    <span class="s">&quot; NR_CPUS %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smp_height</span><span class="p">,</span> <span class="n">smp_width</span><span class="p">,</span>
			    <span class="n">nr_cpu_ids</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check that we&#39;re using allowed ASIDs, and initialize the</span>
<span class="cm">	 * various asid variables to their appropriate initial states.</span>
<span class="cm">	 */</span>
	<span class="n">asid_range</span> <span class="o">=</span> <span class="n">hv_inquire_asid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">current_asid</span><span class="p">)</span> <span class="o">=</span> <span class="n">min_asid</span> <span class="o">=</span> <span class="n">asid_range</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
	<span class="n">max_asid</span> <span class="o">=</span> <span class="n">asid_range</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">asid_range</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hv_confstr</span><span class="p">(</span><span class="n">HV_CONFSTR_CHIP_MODEL</span><span class="p">,</span> <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span><span class="n">chip_model</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">chip_model</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Warning: HV_CONFSTR_CHIP_MODEL not available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">chip_model</span><span class="p">,</span> <span class="s">&quot;unknown&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chip_model</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">validate_va</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef __tilegx__   </span><span class="cm">/* FIXME: GX: probably some validation relevant here */</span><span class="cp"></span>
	<span class="cm">/*</span>
<span class="cm">	 * Similarly, make sure we&#39;re only using allowed VAs.</span>
<span class="cm">	 * We assume we can contiguously use MEM_USER_INTRPT .. MEM_HV_INTRPT,</span>
<span class="cm">	 * and 0 .. KERNEL_HIGH_VADDR.</span>
<span class="cm">	 * In addition, make sure we CAN&#39;T use the end of memory, since</span>
<span class="cm">	 * we use the last chunk of each pgd for the pgd_list.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">user_kernel_ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_va</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">list_va</span> <span class="o">=</span>
		<span class="p">((</span><span class="n">PGD_LIST_OFFSET</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pgd_t</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">PGDIR_SHIFT</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">HV_VirtAddrRange</span> <span class="n">range</span> <span class="o">=</span> <span class="n">hv_inquire_virtual</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">MEM_USER_INTRPT</span> <span class="o">&amp;&amp;</span>
		    <span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">range</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">MEM_HV_INTRPT</span><span class="p">)</span>
			<span class="n">user_kernel_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">max_va</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">range</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">list_va</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_kernel_ok</span><span class="p">)</span>
		<span class="n">early_panic</span><span class="p">(</span><span class="s">&quot;Hypervisor not configured for user/kernel VAs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_va</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">early_panic</span><span class="p">(</span><span class="s">&quot;Hypervisor not configured for low VAs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_va</span> <span class="o">&lt;</span> <span class="n">KERNEL_HIGH_VADDR</span><span class="p">)</span>
		<span class="n">early_panic</span><span class="p">(</span><span class="s">&quot;Hypervisor max VA %#lx smaller than %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">max_va</span><span class="p">,</span> <span class="n">KERNEL_HIGH_VADDR</span><span class="p">);</span>

	<span class="cm">/* Kernel PCs must have their high bit set; see intvec.S. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">VMALLOC_START</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">early_panic</span><span class="p">(</span>
			<span class="s">&quot;Linux VMALLOC region below the 2GB line (%#lx)!</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;Reconfigure the kernel with fewer NR_HUGE_VMAPS</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;or smaller VMALLOC_RESERVE.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">VMALLOC_START</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cpu_lotar_map lists all the cpus that are valid for the supervisor</span>
<span class="cm"> * to cache data on at a page level, i.e. what cpus can be placed in</span>
<span class="cm"> * the LOTAR field of a PTE.  It is equivalent to the set of possible</span>
<span class="cm"> * cpus plus any other cpus that are willing to share their cache.</span>
<span class="cm"> * It is set by hv_inquire_tiles(HV_INQ_TILES_LOTAR).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cpumask</span> <span class="n">__write_once</span> <span class="n">cpu_lotar_map</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cpu_lotar_map</span><span class="p">);</span>

<span class="cp">#if CHIP_HAS_CBOX_HOME_MAP()</span>
<span class="cm">/*</span>
<span class="cm"> * hash_for_home_map lists all the tiles that hash-for-home data</span>
<span class="cm"> * will be cached on.  Note that this may includes tiles that are not</span>
<span class="cm"> * valid for this supervisor to use otherwise (e.g. if a hypervisor</span>
<span class="cm"> * device is being shared between multiple supervisors).</span>
<span class="cm"> * It is set by hv_inquire_tiles(HV_INQ_TILES_HFH_CACHE).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cpumask</span> <span class="n">hash_for_home_map</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">hash_for_home_map</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * cpu_cacheable_map lists all the cpus whose caches the hypervisor can</span>
<span class="cm"> * flush on our behalf.  It is set to cpu_possible_mask OR&#39;ed with</span>
<span class="cm"> * hash_for_home_map, and it is what should be passed to</span>
<span class="cm"> * hv_flush_remote() to flush all caches.  Note that if there are</span>
<span class="cm"> * dedicated hypervisor driver tiles that have authorized use of their</span>
<span class="cm"> * cache, those tiles will only appear in cpu_lotar_map, NOT in</span>
<span class="cm"> * cpu_cacheable_map, as they are a special case.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cpumask</span> <span class="n">__write_once</span> <span class="n">cpu_cacheable_map</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cpu_cacheable_map</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__initdata</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="n">disabled_map</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">disabled_cpus</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">boot_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">cpulist_parse_crop</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disabled_map</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">boot_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disabled_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;disabled_cpus: can&#39;t disable boot cpu %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">boot_cpu</span><span class="p">);</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">boot_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disabled_map</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;disabled_cpus&quot;</span><span class="p">,</span> <span class="n">disabled_cpus</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">print_disabled_cpus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disabled_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
		<span class="n">cpulist_scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">disabled_map</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;CPUs not available for Linux: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_cpu_maps</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="n">hv_disabled_map</span><span class="p">,</span> <span class="n">cpu_possible_init</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">boot_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">cpus</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Learn which cpus are allowed by the hypervisor. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hv_inquire_tiles</span><span class="p">(</span><span class="n">HV_INQ_TILES_AVAIL</span><span class="p">,</span>
			      <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_possible_init</span><span class="p">),</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="n">cpu_cacheable_map</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">early_panic</span><span class="p">(</span><span class="s">&quot;hv_inquire_tiles(AVAIL) failed: rc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">boot_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_possible_init</span><span class="p">))</span>
		<span class="n">early_panic</span><span class="p">(</span><span class="s">&quot;Boot CPU %d disabled by hypervisor!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">boot_cpu</span><span class="p">);</span>

	<span class="cm">/* Compute the cpus disabled by the hvconfig file. */</span>
	<span class="n">cpumask_complement</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hv_disabled_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_possible_init</span><span class="p">);</span>

	<span class="cm">/* Include them with the cpus disabled by &quot;disabled_cpus&quot;. */</span>
	<span class="n">cpumask_or</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disabled_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disabled_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hv_disabled_map</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable every cpu after &quot;setup_max_cpus&quot;.  But don&#39;t mark</span>
<span class="cm">	 * as disabled the cpus that are outside of our initial rectangle,</span>
<span class="cm">	 * since that turns out to be confusing.</span>
<span class="cm">	 */</span>
	<span class="n">cpus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>                          <span class="cm">/* this cpu */</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">boot_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disabled_map</span><span class="p">);</span>   <span class="cm">/* ignore this cpu */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cpus</span> <span class="o">&lt;</span> <span class="n">setup_max_cpus</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disabled_map</span><span class="p">))</span>
			<span class="o">++</span><span class="n">cpus</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">smp_height</span> <span class="o">*</span> <span class="n">smp_width</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disabled_map</span><span class="p">);</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">boot_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disabled_map</span><span class="p">);</span> <span class="cm">/* reset this cpu */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">smp_height</span> <span class="o">*</span> <span class="n">smp_width</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disabled_map</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup cpu_possible map as every cpu allocated to us, minus</span>
<span class="cm">	 * the results of any &quot;disabled_cpus&quot; settings.</span>
<span class="cm">	 */</span>
	<span class="n">cpumask_andnot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_possible_init</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_possible_init</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disabled_map</span><span class="p">);</span>
	<span class="n">init_cpu_possible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_possible_init</span><span class="p">);</span>

	<span class="cm">/* Learn which cpus are valid for LOTAR caching. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hv_inquire_tiles</span><span class="p">(</span><span class="n">HV_INQ_TILES_LOTAR</span><span class="p">,</span>
			      <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_lotar_map</span><span class="p">),</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="n">cpu_lotar_map</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;warning: no HV_INQ_TILES_LOTAR; using AVAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cpu_lotar_map</span> <span class="o">=</span> <span class="o">*</span><span class="n">cpu_possible_mask</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if CHIP_HAS_CBOX_HOME_MAP()</span>
	<span class="cm">/* Retrieve set of CPUs used for hash-for-home caching */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hv_inquire_tiles</span><span class="p">(</span><span class="n">HV_INQ_TILES_HFH_CACHE</span><span class="p">,</span>
			      <span class="p">(</span><span class="n">HV_VirtAddr</span><span class="p">)</span> <span class="n">hash_for_home_map</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="n">hash_for_home_map</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">early_panic</span><span class="p">(</span><span class="s">&quot;hv_inquire_tiles(HFH_CACHE) failed: rc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="n">cpumask_or</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_cacheable_map</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash_for_home_map</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">cpu_cacheable_map</span> <span class="o">=</span> <span class="o">*</span><span class="n">cpu_possible_mask</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dataplane</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;WARNING: dataplane support disabled in this kernel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;dataplane&quot;</span><span class="p">,</span> <span class="n">dataplane</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CMDLINE_BOOL</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">__initdata</span> <span class="n">builtin_cmdline</span><span class="p">[</span><span class="n">COMMAND_LINE_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="n">CONFIG_CMDLINE</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_arch</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">cmdline_p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_CMDLINE_BOOL) &amp;&amp; defined(CONFIG_CMDLINE_OVERRIDE)</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">hv_get_command_line</span><span class="p">((</span><span class="n">HV_VirtAddr</span><span class="p">)</span> <span class="n">boot_command_line</span><span class="p">,</span>
				  <span class="n">COMMAND_LINE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_command_line</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;WARNING: ignoring dynamic command line </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">boot_command_line</span><span class="p">);</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">boot_command_line</span><span class="p">,</span> <span class="n">builtin_cmdline</span><span class="p">,</span> <span class="n">COMMAND_LINE_SIZE</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">hv_cmdline</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_CMDLINE_BOOL)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">builtin_cmdline</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">builtin_len</span> <span class="o">=</span> <span class="n">strlcpy</span><span class="p">(</span><span class="n">boot_command_line</span><span class="p">,</span> <span class="n">builtin_cmdline</span><span class="p">,</span>
					  <span class="n">COMMAND_LINE_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">builtin_len</span> <span class="o">&lt;</span> <span class="n">COMMAND_LINE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">boot_command_line</span><span class="p">[</span><span class="n">builtin_len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
		<span class="n">hv_cmdline</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boot_command_line</span><span class="p">[</span><span class="n">builtin_len</span><span class="p">];</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">COMMAND_LINE_SIZE</span> <span class="o">-</span> <span class="n">builtin_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
	<span class="p">{</span>
		<span class="n">hv_cmdline</span> <span class="o">=</span> <span class="n">boot_command_line</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">COMMAND_LINE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">hv_get_command_line</span><span class="p">((</span><span class="n">HV_VirtAddr</span><span class="p">)</span> <span class="n">hv_cmdline</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">COMMAND_LINE_SIZE</span><span class="p">)</span>
		<span class="n">early_panic</span><span class="p">(</span><span class="s">&quot;hv_get_command_line failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="o">*</span><span class="n">cmdline_p</span> <span class="o">=</span> <span class="n">boot_command_line</span><span class="p">;</span>

	<span class="cm">/* Set disabled_map and setup_max_cpus very early */</span>
	<span class="n">parse_early_param</span><span class="p">();</span>

	<span class="cm">/* Make sure the kernel is compatible with the hypervisor. */</span>
	<span class="n">validate_hv</span><span class="p">();</span>
	<span class="n">validate_va</span><span class="p">();</span>

	<span class="n">setup_cpu_maps</span><span class="p">();</span>


<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initialize the PCI structures.  This is done before memory</span>
<span class="cm">	 * setup so that we know whether or not a pci_reserve region</span>
<span class="cm">	 * is necessary.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tile_pci_init</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pci_reserve_mb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* PCI systems reserve a region just below 4GB for mapping iomem. */</span>
	<span class="n">pci_reserve_end_pfn</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
	<span class="n">pci_reserve_start_pfn</span> <span class="o">=</span> <span class="n">pci_reserve_end_pfn</span> <span class="o">-</span>
		<span class="p">(</span><span class="n">pci_reserve_mb</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="n">init_mm</span><span class="p">.</span><span class="n">start_code</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_text</span><span class="p">;</span>
	<span class="n">init_mm</span><span class="p">.</span><span class="n">end_code</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_etext</span><span class="p">;</span>
	<span class="n">init_mm</span><span class="p">.</span><span class="n">end_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_edata</span><span class="p">;</span>
	<span class="n">init_mm</span><span class="p">.</span><span class="n">brk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_end</span><span class="p">;</span>

	<span class="n">setup_memory</span><span class="p">();</span>
	<span class="n">store_permanent_mappings</span><span class="p">();</span>
	<span class="n">setup_bootmem_allocator</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE: before this point _nobody_ is allowed to allocate</span>
<span class="cm">	 * any memory using the bootmem allocator.</span>
<span class="cm">	 */</span>

	<span class="n">paging_init</span><span class="p">();</span>
	<span class="n">setup_numa_mapping</span><span class="p">();</span>
	<span class="n">zone_sizes_init</span><span class="p">();</span>
	<span class="n">set_page_homes</span><span class="p">();</span>
	<span class="n">setup_cpu</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">setup_clock</span><span class="p">();</span>
	<span class="n">load_hv_initrd</span><span class="p">();</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Set up per-cpu memory.</span>
<span class="cm"> */</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__per_cpu_offset</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">]</span> <span class="n">__write_once</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__per_cpu_offset</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="n">__initdata</span> <span class="n">pfn_offset</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__initdata</span> <span class="n">percpu_pfn</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * As the percpu code allocates pages, we return the pages from the</span>
<span class="cm"> * end of the node for the specified cpu.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">__init</span> <span class="nf">pcpu_fc_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">node_percpu_pfn</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">+</span> <span class="n">pfn_offset</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pfn_offset</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">+=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">node_percpu</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">node_percpu</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">percpu_pfn</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">percpu_pfn</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Pages reserved for percpu memory are not freeable, and in any case we are</span>
<span class="cm"> * on a short path to panic() in setup_per_cpu_area() at this point anyway.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">pcpu_fc_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up vmalloc page tables using bootmem for the percpu code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">pcpu_fc_populate_pte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pgd_addr_invalid</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">VMALLOC_START</span> <span class="o">||</span> <span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">VMALLOC_END</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;PCPU addr %#lx outside vmalloc range %#lx..%#lx;&quot;</span>
		      <span class="s">&quot; try increasing CONFIG_VMALLOC_RESERVE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">addr</span><span class="p">,</span> <span class="n">VMALLOC_START</span><span class="p">,</span> <span class="n">VMALLOC_END</span><span class="p">);</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">swapper_pg_dir</span> <span class="o">+</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pud_present</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">));</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pmd_huge_page</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">L2_KERNEL_PGTABLE_SIZE</span><span class="p">,</span>
				      <span class="n">HV_PAGE_TABLE_ALIGN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">pmd_populate_kernel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_per_cpu_areas</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">lowmem_va</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">percpu_size</span><span class="p">();</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pcpu_page_first_chunk</span><span class="p">(</span><span class="n">PERCPU_MODULE_RESERVE</span><span class="p">,</span> <span class="n">pcpu_fc_alloc</span><span class="p">,</span>
				   <span class="n">pcpu_fc_free</span><span class="p">,</span> <span class="n">pcpu_fc_populate_pte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Cannot initialize percpu area (err=%d)&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pcpu_base_addr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__per_cpu_start</span><span class="p">;</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__per_cpu_offset</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">+</span> <span class="n">pcpu_unit_offsets</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

		<span class="cm">/* finv the copy out of cache so we can change homecache */</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">pcpu_base_addr</span> <span class="o">+</span> <span class="n">pcpu_unit_offsets</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
		<span class="n">__finv_buffer</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">pfn</span> <span class="o">=</span> <span class="n">percpu_pfn</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

		<span class="cm">/* Rewrite the page tables to cache on that cpu */</span>
		<span class="n">pg</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="o">++</span><span class="n">pfn</span><span class="p">,</span> <span class="o">++</span><span class="n">pg</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Update the vmalloc mapping and page home. */</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">virt_to_pte</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pfn</span> <span class="o">!=</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
			<span class="n">pte</span> <span class="o">=</span> <span class="n">hv_pte_set_mode</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">HV_PTE_MODE_CACHE_TILE_L3</span><span class="p">);</span>
			<span class="n">pte</span> <span class="o">=</span> <span class="n">set_remote_cache_cpu</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="n">set_pte_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>

			<span class="cm">/* Update the lowmem mapping for consistency. */</span>
			<span class="n">lowmem_va</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
			<span class="n">ptep</span> <span class="o">=</span> <span class="n">virt_to_pte</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">lowmem_va</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pte_huge</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;early shatter of huge page&quot;</span>
				       <span class="s">&quot; at %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lowmem_va</span><span class="p">);</span>
				<span class="n">shatter_pmd</span><span class="p">((</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ptep</span><span class="p">);</span>
				<span class="n">ptep</span> <span class="o">=</span> <span class="n">virt_to_pte</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">lowmem_va</span><span class="p">);</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pte_huge</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pfn</span> <span class="o">!=</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">));</span>
			<span class="n">set_pte_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">lowmem_va</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Set our thread pointer appropriately. */</span>
	<span class="n">set_my_cpu_offset</span><span class="p">(</span><span class="n">__per_cpu_offset</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()]);</span>

	<span class="cm">/* Make sure the finv&#39;s have completed. */</span>
	<span class="n">mb_incoherent</span><span class="p">();</span>

	<span class="cm">/* Flush the TLB so we reference it properly from here on out. */</span>
	<span class="n">local_flush_tlb_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">data_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;Kernel data&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">end</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>	<span class="o">=</span> <span class="n">IORESOURCE_BUSY</span> <span class="o">|</span> <span class="n">IORESOURCE_MEM</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">code_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;Kernel code&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">end</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>	<span class="o">=</span> <span class="n">IORESOURCE_BUSY</span> <span class="o">|</span> <span class="n">IORESOURCE_MEM</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * We reserve all resources above 4GB so that PCI won&#39;t try to put</span>
<span class="cm"> * mappings above 4GB; the standard allows that for some devices but</span>
<span class="cm"> * the probing code trunates values to 32 bits.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span><span class="o">*</span> <span class="n">__init</span>
<span class="nf">insert_non_bus_resource</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span>
		<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Non-Bus Physical Address Space&quot;</span><span class="p">;</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1LL</span><span class="p">;</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_BUSY</span> <span class="o">|</span> <span class="n">IORESOURCE_MEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insert_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span><span class="o">*</span> <span class="n">__init</span>
<span class="nf">insert_ram_resource</span><span class="p">(</span><span class="n">u64</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span>
		<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;System RAM&quot;</span><span class="p">;</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">start_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_BUSY</span> <span class="o">|</span> <span class="n">IORESOURCE_MEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insert_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Request address space for all standard resources</span>
<span class="cm"> *</span>
<span class="cm"> * If the system includes PCI root complex drivers, we need to create</span>
<span class="cm"> * a window just below 4GB where PCI BARs can be mapped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">request_standard_resources</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span> <span class="n">CODE_DELTA</span> <span class="o">=</span> <span class="n">MEM_SV_INTRPT</span> <span class="o">-</span> <span class="n">PAGE_OFFSET</span> <span class="p">};</span>

	<span class="n">iomem_resource</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1LL</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="n">insert_non_bus_resource</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">start_pfn</span> <span class="o">=</span> <span class="n">node_start_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">u64</span> <span class="n">end_pfn</span> <span class="o">=</span> <span class="n">node_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="cp">#ifdef CONFIG_PCI</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start_pfn</span> <span class="o">&lt;=</span> <span class="n">pci_reserve_start_pfn</span> <span class="o">&amp;&amp;</span>
		    <span class="n">end_pfn</span> <span class="o">&gt;</span> <span class="n">pci_reserve_start_pfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end_pfn</span> <span class="o">&gt;</span> <span class="n">pci_reserve_end_pfn</span><span class="p">)</span>
				<span class="n">insert_ram_resource</span><span class="p">(</span><span class="n">pci_reserve_end_pfn</span><span class="p">,</span>
						     <span class="n">end_pfn</span><span class="p">);</span>
			<span class="n">end_pfn</span> <span class="o">=</span> <span class="n">pci_reserve_start_pfn</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">insert_ram_resource</span><span class="p">(</span><span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">code_resource</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">_text</span> <span class="o">-</span> <span class="n">CODE_DELTA</span><span class="p">);</span>
	<span class="n">code_resource</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">_etext</span> <span class="o">-</span> <span class="n">CODE_DELTA</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">data_resource</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">_sdata</span><span class="p">);</span>
	<span class="n">data_resource</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">_end</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">insert_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">code_resource</span><span class="p">);</span>
	<span class="n">insert_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_resource</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_KEXEC</span>
	<span class="n">insert_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">crashk_res</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">request_standard_resources</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
