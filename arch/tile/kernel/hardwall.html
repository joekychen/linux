<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › kernel › hardwall.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hardwall.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/cdev.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;asm/hardwall.h&gt;</span>
<span class="cp">#include &lt;asm/traps.h&gt;</span>
<span class="cp">#include &lt;asm/siginfo.h&gt;</span>
<span class="cp">#include &lt;asm/irq_regs.h&gt;</span>

<span class="cp">#include &lt;arch/interrupts.h&gt;</span>
<span class="cp">#include &lt;arch/spr_def.h&gt;</span>


<span class="cm">/*</span>
<span class="cm"> * Implement a per-cpu &quot;hardwall&quot; resource class such as UDN or IPI.</span>
<span class="cm"> * We use &quot;hardwall&quot; nomenclature throughout for historical reasons.</span>
<span class="cm"> * The lock here controls access to the list data structure as well as</span>
<span class="cm"> * to the items on the list.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hardwall_type</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_xdn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_idn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">disabled</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc_dir</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">hardwall_index</span> <span class="p">{</span>
	<span class="n">HARDWALL_UDN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="cp">#ifndef __tilepro__</span>
	<span class="n">HARDWALL_IDN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">HARDWALL_IPI</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="n">_HARDWALL_TYPES</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hardwall_type</span> <span class="n">hardwall_types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>  <span class="cm">/* user-space access to UDN */</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="mi">1</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="s">&quot;udn&quot;</span><span class="p">,</span>
		<span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">hardwall_types</span><span class="p">[</span><span class="n">HARDWALL_UDN</span><span class="p">].</span><span class="n">list</span><span class="p">),</span>
		<span class="n">__SPIN_LOCK_INITIALIZER</span><span class="p">(</span><span class="n">hardwall_types</span><span class="p">[</span><span class="n">HARDWALL_UDN</span><span class="p">].</span><span class="n">lock</span><span class="p">),</span>
		<span class="nb">NULL</span>
	<span class="p">},</span>
<span class="cp">#ifndef __tilepro__</span>
	<span class="p">{</span>  <span class="cm">/* user-space access to IDN */</span>
		<span class="mi">1</span><span class="p">,</span>
		<span class="mi">1</span><span class="p">,</span>
		<span class="mi">1</span><span class="p">,</span>
		<span class="mi">1</span><span class="p">,</span>  <span class="cm">/* disabled pending hypervisor support */</span>
		<span class="s">&quot;idn&quot;</span><span class="p">,</span>
		<span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">hardwall_types</span><span class="p">[</span><span class="n">HARDWALL_IDN</span><span class="p">].</span><span class="n">list</span><span class="p">),</span>
		<span class="n">__SPIN_LOCK_INITIALIZER</span><span class="p">(</span><span class="n">hardwall_types</span><span class="p">[</span><span class="n">HARDWALL_IDN</span><span class="p">].</span><span class="n">lock</span><span class="p">),</span>
		<span class="nb">NULL</span>
	<span class="p">},</span>
	<span class="p">{</span>  <span class="cm">/* access to user-space IPI */</span>
		<span class="mi">2</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="s">&quot;ipi&quot;</span><span class="p">,</span>
		<span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">hardwall_types</span><span class="p">[</span><span class="n">HARDWALL_IPI</span><span class="p">].</span><span class="n">list</span><span class="p">),</span>
		<span class="n">__SPIN_LOCK_INITIALIZER</span><span class="p">(</span><span class="n">hardwall_types</span><span class="p">[</span><span class="n">HARDWALL_IPI</span><span class="p">].</span><span class="n">lock</span><span class="p">),</span>
		<span class="nb">NULL</span>
	<span class="p">},</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This data structure tracks the cpu data, etc., associated</span>
<span class="cm"> * one-to-one with a &quot;struct file *&quot; from opening a hardwall device file.</span>
<span class="cm"> * Note that the file&#39;s private data points back to this structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hardwall_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>             <span class="cm">/* for hardwall_types.list */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">task_head</span><span class="p">;</span>        <span class="cm">/* head of tasks in this hardwall */</span>
	<span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>        <span class="cm">/* type of this resource */</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="n">cpumask</span><span class="p">;</span>            <span class="cm">/* cpus reserved */</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>                            <span class="cm">/* integer id for this hardwall */</span>
	<span class="kt">int</span> <span class="n">teardown_in_progress</span><span class="p">;</span>          <span class="cm">/* are we tearing this one down? */</span>

	<span class="cm">/* Remaining fields only valid for user-network resources. */</span>
	<span class="kt">int</span> <span class="n">ulhc_x</span><span class="p">;</span>                        <span class="cm">/* upper left hand corner x coord */</span>
	<span class="kt">int</span> <span class="n">ulhc_y</span><span class="p">;</span>                        <span class="cm">/* upper left hand corner y coord */</span>
	<span class="kt">int</span> <span class="n">width</span><span class="p">;</span>                         <span class="cm">/* rectangle width */</span>
	<span class="kt">int</span> <span class="n">height</span><span class="p">;</span>                        <span class="cm">/* rectangle height */</span>
<span class="cp">#if CHIP_HAS_REV1_XDN()</span>
	<span class="n">atomic_t</span> <span class="n">xdn_pending_count</span><span class="p">;</span>        <span class="cm">/* cores in phase 1 of drain */</span>
<span class="cp">#endif</span>
<span class="p">};</span>


<span class="cm">/* /proc/tile/hardwall */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">hardwall_proc_dir</span><span class="p">;</span>

<span class="cm">/* Functions to manage files in /proc/tile/hardwall. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hardwall_add_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hardwall_remove_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Allow disabling UDN access. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">noudn</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;User-space UDN access is disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">hardwall_types</span><span class="p">[</span><span class="n">HARDWALL_UDN</span><span class="p">].</span><span class="n">disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;noudn&quot;</span><span class="p">,</span> <span class="n">noudn</span><span class="p">);</span>

<span class="cp">#ifndef __tilepro__</span>
<span class="cm">/* Allow disabling IDN access. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">noidn</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;User-space IDN access is disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">hardwall_types</span><span class="p">[</span><span class="n">HARDWALL_IDN</span><span class="p">].</span><span class="n">disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;noidn&quot;</span><span class="p">,</span> <span class="n">noidn</span><span class="p">);</span>

<span class="cm">/* Allow disabling IPI access. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">noipi</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;User-space IPI access is disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">hardwall_types</span><span class="p">[</span><span class="n">HARDWALL_IPI</span><span class="p">].</span><span class="n">disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;noipi&quot;</span><span class="p">,</span> <span class="n">noipi</span><span class="p">);</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> * Low-level primitives for UDN/IDN</span>
<span class="cm"> */</span>

<span class="cp">#ifdef __tilepro__</span>
<span class="cp">#define mtspr_XDN(hwt, name, val) \</span>
<span class="cp">	do { (void)(hwt); __insn_mtspr(SPR_UDN_##name, (val)); } while (0)</span>
<span class="cp">#define mtspr_MPL_XDN(hwt, name, val) \</span>
<span class="cp">	do { (void)(hwt); __insn_mtspr(SPR_MPL_UDN_##name, (val)); } while (0)</span>
<span class="cp">#define mfspr_XDN(hwt, name) \</span>
<span class="cp">	((void)(hwt), __insn_mfspr(SPR_UDN_##name))</span>
<span class="cp">#else</span>
<span class="cp">#define mtspr_XDN(hwt, name, val)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if ((hwt)-&gt;is_idn)					\</span>
<span class="cp">			__insn_mtspr(SPR_IDN_##name, (val));		\</span>
<span class="cp">		else							\</span>
<span class="cp">			__insn_mtspr(SPR_UDN_##name, (val));		\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define mtspr_MPL_XDN(hwt, name, val)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if ((hwt)-&gt;is_idn)					\</span>
<span class="cp">			__insn_mtspr(SPR_MPL_IDN_##name, (val));	\</span>
<span class="cp">		else							\</span>
<span class="cp">			__insn_mtspr(SPR_MPL_UDN_##name, (val));	\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define mfspr_XDN(hwt, name) \</span>
<span class="cp">  ((hwt)-&gt;is_idn ? __insn_mfspr(SPR_IDN_##name) : __insn_mfspr(SPR_UDN_##name))</span>
<span class="cp">#endif</span>

<span class="cm">/* Set a CPU bit if the CPU is online. */</span>
<span class="cp">#define cpu_online_set(cpu, dst) do { \</span>
<span class="cp">	if (cpu_online(cpu))          \</span>
<span class="cp">		cpumask_set_cpu(cpu, dst);    \</span>
<span class="cp">} while (0)</span>


<span class="cm">/* Does the given rectangle contain the given x,y coordinate? */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">contains</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ulhc_x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ulhc_x</span> <span class="o">+</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ulhc_y</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ulhc_y</span> <span class="o">+</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Compute the rectangle parameters and validate the cpumask. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_rectangle</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">ulhc</span><span class="p">,</span> <span class="n">lrhc</span><span class="p">;</span>

	<span class="cm">/* The first cpu is the ULHC, the last the LRHC. */</span>
	<span class="n">ulhc</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
	<span class="n">lrhc</span> <span class="o">=</span> <span class="n">find_last_bit</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>

	<span class="cm">/* Compute the rectangle attributes from the cpus. */</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">ulhc_x</span> <span class="o">=</span> <span class="n">cpu_x</span><span class="p">(</span><span class="n">ulhc</span><span class="p">);</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">ulhc_y</span> <span class="o">=</span> <span class="n">cpu_y</span><span class="p">(</span><span class="n">ulhc</span><span class="p">);</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">cpu_x</span><span class="p">(</span><span class="n">lrhc</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ulhc_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">cpu_y</span><span class="p">(</span><span class="n">lrhc</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ulhc_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Width and height must be positive */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Confirm that the cpumask is exactly the rectangle. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">smp_height</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">smp_width</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">,</span> <span class="o">++</span><span class="n">cpu</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">contains</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note that offline cpus can&#39;t be drained when this user network</span>
<span class="cm">	 * rectangle eventually closes.  We used to detect this</span>
<span class="cm">	 * situation and print a warning, but it annoyed users and</span>
<span class="cm">	 * they ignored it anyway, so now we just return without a</span>
<span class="cm">	 * warning.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hardware management of hardwall setup, teardown, trapping,</span>
<span class="cm"> * and enabling/disabling PL0 access to the networks.</span>
<span class="cm"> */</span>

<span class="cm">/* Bit field values to mask together for writes to SPR_XDN_DIRECTION_PROTECT */</span>
<span class="k">enum</span> <span class="n">direction_protect</span> <span class="p">{</span>
	<span class="n">N_PROTECT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">E_PROTECT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">S_PROTECT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">W_PROTECT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="n">C_PROTECT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xdn_which_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef __tilepro__</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">is_idn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">INT_IDN_FIREWALL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">INT_UDN_FIREWALL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_firewall_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">arch_local_irq_unmask_now</span><span class="p">(</span><span class="n">xdn_which_interrupt</span><span class="p">(</span><span class="n">hwt</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">disable_firewall_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">arch_local_irq_mask_now</span><span class="p">(</span><span class="n">xdn_which_interrupt</span><span class="p">(</span><span class="n">hwt</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Set up hardwall on this cpu based on the passed hardwall_info. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hardwall_setup_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cpu</span> <span class="o">%</span> <span class="n">smp_width</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">cpu</span> <span class="o">/</span> <span class="n">smp_width</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ulhc_x</span><span class="p">)</span>
		<span class="n">bits</span> <span class="o">|=</span> <span class="n">W_PROTECT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ulhc_x</span> <span class="o">+</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">bits</span> <span class="o">|=</span> <span class="n">E_PROTECT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ulhc_y</span><span class="p">)</span>
		<span class="n">bits</span> <span class="o">|=</span> <span class="n">N_PROTECT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ulhc_y</span> <span class="o">+</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">bits</span> <span class="o">|=</span> <span class="n">S_PROTECT</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mtspr_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">DIRECTION_PROTECT</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
	<span class="n">enable_firewall_interrupts</span><span class="p">(</span><span class="n">hwt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Set up all cpus on edge of rectangle to enable/disable hardwall SPRs. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hardwall_protect_rectangle</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="n">rect_cpus</span><span class="p">;</span>

	<span class="n">cpumask_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rect_cpus</span><span class="p">);</span>

	<span class="cm">/* First include the top and bottom edges */</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ulhc_y</span> <span class="o">*</span> <span class="n">smp_width</span> <span class="o">+</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ulhc_x</span><span class="p">;</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">smp_width</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">,</span> <span class="o">++</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_online_set</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rect_cpus</span><span class="p">);</span>
		<span class="n">cpu_online_set</span><span class="p">(</span><span class="n">cpu</span> <span class="o">+</span> <span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rect_cpus</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Then the left and right edges */</span>
	<span class="n">cpu</span> <span class="o">-=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">+=</span> <span class="n">smp_width</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_online_set</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rect_cpus</span><span class="p">);</span>
		<span class="n">cpu_online_set</span><span class="p">(</span><span class="n">cpu</span> <span class="o">+</span> <span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rect_cpus</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Then tell all the cpus to set up their protection SPR */</span>
	<span class="n">on_each_cpu_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rect_cpus</span><span class="p">,</span> <span class="n">hardwall_setup_func</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">do_hardwall_trap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span><span class="o">*</span> <span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fault_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">rect</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">found_processes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">old_regs</span> <span class="o">=</span> <span class="n">set_irq_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="n">irq_enter</span><span class="p">();</span>

	<span class="cm">/* Figure out which network trapped. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fault_num</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef __tilepro__</span>
	<span class="k">case</span> <span class="n">INT_IDN_FIREWALL</span>:
		<span class="n">hwt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hardwall_types</span><span class="p">[</span><span class="n">HARDWALL_IDN</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">INT_UDN_FIREWALL</span>:
		<span class="n">hwt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hardwall_types</span><span class="p">[</span><span class="n">HARDWALL_UDN</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">);</span>

	<span class="cm">/* This tile trapped a network access; find the rectangle. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rect</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rect</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It shouldn&#39;t be possible not to find this cpu on the</span>
<span class="cm">	 * rectangle list, since only cpus in rectangles get hardwalled.</span>
<span class="cm">	 * The hardwall is only removed after the user network is drained.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rect</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we already started teardown on this hardwall, don&#39;t worry;</span>
<span class="cm">	 * the abort signal has been sent and we are just waiting for things</span>
<span class="cm">	 * to quiesce.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rect</span><span class="o">-&gt;</span><span class="n">teardown_in_progress</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;cpu %d: detected %s hardwall violation %#lx&quot;</span>
		       <span class="s">&quot; while teardown already in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">cpu</span><span class="p">,</span> <span class="n">hwt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">mfspr_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">DIRECTION_PROTECT</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Kill off any process that is activated in this rectangle.</span>
<span class="cm">	 * We bypass security to deliver the signal, since it must be</span>
<span class="cm">	 * one of the activated processes that generated the user network</span>
<span class="cm">	 * message that caused this trap, and all the activated</span>
<span class="cm">	 * processes shared a single open file so are pretty tightly</span>
<span class="cm">	 * bound together from a security point of view to begin with.</span>
<span class="cm">	 */</span>
	<span class="n">rect</span><span class="o">-&gt;</span><span class="n">teardown_in_progress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span> <span class="cm">/* Ensure visibility of rectangle before notifying processes. */</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;cpu %d: detected %s hardwall violation %#lx...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">cpu</span><span class="p">,</span> <span class="n">hwt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">mfspr_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">DIRECTION_PROTECT</span><span class="p">));</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGILL</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">ILL_HARDWALL</span><span class="p">;</span>
	<span class="n">found_processes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rect</span><span class="o">-&gt;</span><span class="n">task_head</span><span class="p">,</span>
			    <span class="kr">thread</span><span class="p">.</span><span class="n">hardwall</span><span class="p">[</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">hardwall</span><span class="p">[</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">info</span> <span class="o">!=</span> <span class="n">rect</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">found_processes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;hardwall: killing %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
			<span class="n">do_send_sig_info</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">si_signo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found_processes</span><span class="p">)</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;hardwall: no associated processes!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

 <span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to disable firewall interrupts now, or else when we</span>
<span class="cm">	 * return from this handler, we will simply re-interrupt back to</span>
<span class="cm">	 * it.  However, we can&#39;t clear the protection bits, since we</span>
<span class="cm">	 * haven&#39;t yet drained the network, and that would allow packets</span>
<span class="cm">	 * to cross out of the hardwall region.</span>
<span class="cm">	 */</span>
	<span class="n">disable_firewall_interrupts</span><span class="p">(</span><span class="n">hwt</span><span class="p">);</span>

	<span class="n">irq_exit</span><span class="p">();</span>
	<span class="n">set_irq_regs</span><span class="p">(</span><span class="n">old_regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Allow access from user space to the user network. */</span>
<span class="kt">void</span> <span class="nf">grant_hardwall_mpls</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef __tilepro__</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">is_xdn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_IPI_0_SET_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">mtspr_MPL_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">ACCESS_SET_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mtspr_MPL_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">AVAIL_SET_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mtspr_MPL_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">COMPLETE_SET_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mtspr_MPL_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">TIMER_SET_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#if !CHIP_HAS_REV1_XDN()</span>
	<span class="n">mtspr_MPL_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">REFILL_SET_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mtspr_MPL_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">CA_SET_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Deny access from user space to the user network. */</span>
<span class="kt">void</span> <span class="nf">restrict_hardwall_mpls</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef __tilepro__</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">is_xdn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_MPL_IPI_0_SET_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">mtspr_MPL_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">ACCESS_SET_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mtspr_MPL_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">AVAIL_SET_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mtspr_MPL_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">COMPLETE_SET_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mtspr_MPL_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">TIMER_SET_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#if !CHIP_HAS_REV1_XDN()</span>
	<span class="n">mtspr_MPL_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">REFILL_SET_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mtspr_MPL_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">CA_SET_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Restrict or deny as necessary for the task we&#39;re switching to. */</span>
<span class="kt">void</span> <span class="nf">hardwall_switch_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HARDWALL_TYPES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">hardwall</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">hardwall</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">restrict_hardwall_mpls</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hardwall_types</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">hardwall</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">grant_hardwall_mpls</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hardwall_types</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Does this task have the right to IPI the given cpu? */</span>
<span class="kt">int</span> <span class="nf">hardwall_ipi_valid</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef __tilegx__</span>
	<span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">hardwall</span><span class="p">[</span><span class="n">HARDWALL_IPI</span><span class="p">].</span><span class="n">info</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">info</span> <span class="o">&amp;&amp;</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Code to create, activate, deactivate, and destroy hardwall resources.</span>
<span class="cm"> */</span>

<span class="cm">/* Create a hardwall for the given resource */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="nf">hardwall_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span><span class="p">,</span>
					     <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					     <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Reject crazy sizes out of hand, a la sys_mbind(). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="cm">/* Copy whatever fits into a cpumask. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span><span class="p">),</span> <span class="n">size</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the size was short, clear the rest of the mask;</span>
<span class="cm">	 * otherwise validate that the rest of the user mask was zero</span>
<span class="cm">	 * (we don&#39;t try hard to be efficient when validating huge masks).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mask</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span><span class="p">)</span> <span class="o">-</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
				<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate a new hardwall_info optimistically. */</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_info</span><span class="p">),</span>
			<span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">task_head</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">hwt</span><span class="p">;</span>

	<span class="cm">/* Compute the rectangle size and validate that it&#39;s plausible. */</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">is_xdn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">check_rectangle</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Confirm it doesn&#39;t overlap and add it to the list. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EBUSY</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Set up appropriate hardwalling on all affected cpus. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">is_xdn</span><span class="p">)</span>
		<span class="n">hardwall_protect_rectangle</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/* Create a /proc/tile/hardwall entry. */</span>
	<span class="n">hardwall_add_proc</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">info</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Activate a given hardwall on this cpu for this process. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hardwall_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span><span class="p">;</span>

	<span class="cm">/* Require a hardwall. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>

	<span class="cm">/* Not allowed to activate a hardwall that is being torn down. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">teardown_in_progress</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get our affinity; if we&#39;re not bound to this tile uniquely,</span>
<span class="cm">	 * we can&#39;t access the network registers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_weight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* Make sure we are bound to a cpu assigned to this resource. */</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpumask_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* If we are already bound to this hardwall, it&#39;s a no-op. */</span>
	<span class="n">hwt</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">hardwall</span><span class="p">[</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">hardwall</span><span class="p">[</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">info</span> <span class="o">!=</span> <span class="n">info</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Success!  This process gets to use the resource on this cpu. */</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">hardwall</span><span class="p">[</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">hardwall</span><span class="p">[</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">task_head</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">grant_hardwall_mpls</span><span class="p">(</span><span class="n">hwt</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Pid %d (%s) activated for %s hardwall: cpu %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">hwt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Deactivate a task&#39;s hardwall.  Must hold lock for hardwall_type.</span>
<span class="cm"> * This method may be called from free_task(), so we don&#39;t want to</span>
<span class="cm"> * rely on too many fields of struct task_struct still being valid.</span>
<span class="cm"> * We assume the cpus_allowed, pid, and comm fields are still valid.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_hardwall_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_weight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;pid %d (%s) releasing %s hardwall with&quot;</span>
		       <span class="s">&quot; an affinity mask containing %d cpus!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">task</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">hwt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		       <span class="n">cpumask_weight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">));</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">hardwall</span><span class="p">[</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">hardwall</span><span class="p">[</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">hardwall</span><span class="p">[</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span>
		<span class="n">restrict_hardwall_mpls</span><span class="p">(</span><span class="n">hwt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Deactivate a task&#39;s hardwall. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hardwall_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">activated</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">activated</span> <span class="o">=</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">hardwall</span><span class="p">[</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">activated</span><span class="p">)</span>
		<span class="n">_hardwall_deactivate</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">activated</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Pid %d (%s) deactivated for %s hardwall: cpu %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">task</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">hwt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">hardwall_deactivate_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HARDWALL_TYPES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">hardwall</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">info</span><span class="p">)</span>
			<span class="n">hardwall_deactivate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hardwall_types</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Stop the switch before draining the network. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">stop_xdn_switch</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if !CHIP_HAS_REV1_XDN()</span>
	<span class="cm">/* Freeze the switch and the demux. */</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_UDN_SP_FREEZE</span><span class="p">,</span>
		     <span class="n">SPR_UDN_SP_FREEZE__SP_FRZ_MASK</span> <span class="o">|</span>
		     <span class="n">SPR_UDN_SP_FREEZE__DEMUX_FRZ_MASK</span> <span class="o">|</span>
		     <span class="n">SPR_UDN_SP_FREEZE__NON_DEST_EXT_MASK</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * Drop all packets bound for the core or off the edge.</span>
<span class="cm">	 * We rely on the normal hardwall protection setup code</span>
<span class="cm">	 * to have set the low four bits to trigger firewall interrupts,</span>
<span class="cm">	 * and shift those bits up to trigger &quot;drop on send&quot; semantics,</span>
<span class="cm">	 * plus adding &quot;drop on send to core&quot; for all switches.</span>
<span class="cm">	 * In practice it seems the switches latch the DIRECTION_PROTECT</span>
<span class="cm">	 * SPR so they won&#39;t start dropping if they&#39;re already</span>
<span class="cm">	 * delivering the last message to the core, but it doesn&#39;t</span>
<span class="cm">	 * hurt to enable it here.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">protect</span> <span class="o">=</span> <span class="n">mfspr_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">DIRECTION_PROTECT</span><span class="p">);</span>
	<span class="n">mtspr_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">DIRECTION_PROTECT</span><span class="p">,</span> <span class="p">(</span><span class="n">protect</span> <span class="o">|</span> <span class="n">C_PROTECT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">empty_xdn_demuxes</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef __tilepro__</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">is_idn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_IDN_DATA_AVAIL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__tile_idn0_receive</span><span class="p">();</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_IDN_DATA_AVAIL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__tile_idn1_receive</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_UDN_DATA_AVAIL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__tile_udn0_receive</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_UDN_DATA_AVAIL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__tile_udn1_receive</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_UDN_DATA_AVAIL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__tile_udn2_receive</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_UDN_DATA_AVAIL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__tile_udn3_receive</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Drain all the state from a stopped switch. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">drain_xdn_switch</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

<span class="cp">#if CHIP_HAS_REV1_XDN()</span>
	<span class="cm">/*</span>
<span class="cm">	 * The switches have been configured to drop any messages</span>
<span class="cm">	 * destined for cores (or off the edge of the rectangle).</span>
<span class="cm">	 * But the current message may continue to be delivered,</span>
<span class="cm">	 * so we wait until all the cores have finished any pending</span>
<span class="cm">	 * messages before we stop draining.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">pending</span> <span class="o">=</span> <span class="n">mfspr_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">PENDING</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pending</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">empty_xdn_demuxes</span><span class="p">(</span><span class="n">hwt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">is_idn</span><span class="p">)</span>
			<span class="n">__tile_idn_send</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">__tile_udn_send</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xdn_pending_count</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xdn_pending_count</span><span class="p">))</span>
		<span class="n">empty_xdn_demuxes</span><span class="p">(</span><span class="n">hwt</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">from_tile_words</span><span class="p">,</span> <span class="n">ca_count</span><span class="p">;</span>

	<span class="cm">/* Empty out the 5 switch point fifos. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">words</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_UDN_SP_FIFO_SEL</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">words</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_UDN_SP_STATE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_UDN_SP_FIFO_DATA</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">((</span><span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_UDN_SP_STATE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Dump out the 3 word fifo at top. */</span>
	<span class="n">from_tile_words</span> <span class="o">=</span> <span class="p">(</span><span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_UDN_DEMUX_STATUS</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">from_tile_words</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_UDN_DEMUX_WRITE_FIFO</span><span class="p">);</span>

	<span class="cm">/* Empty out demuxes. */</span>
	<span class="n">empty_xdn_demuxes</span><span class="p">(</span><span class="n">hwt</span><span class="p">);</span>

	<span class="cm">/* Empty out catch all. */</span>
	<span class="n">ca_count</span> <span class="o">=</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_UDN_DEMUX_CA_COUNT</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ca_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_UDN_CA_DATA</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_UDN_DEMUX_CA_COUNT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Clear demux logic. */</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_UDN_DEMUX_CTL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write switch state; experimentation indicates that 0xc3000</span>
<span class="cm">	 * is an idle switch point.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_UDN_SP_FIFO_SEL</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_UDN_SP_STATE</span><span class="p">,</span> <span class="mh">0xc3000</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Reset random XDN state registers at boot up and during hardwall teardown. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_xdn_network_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Clear out other random registers so we have a clean slate. */</span>
	<span class="n">mtspr_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">DIRECTION_PROTECT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mtspr_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">AVAIL_EN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mtspr_XDN</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">DEADLOCK_TIMEOUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#if !CHIP_HAS_REV1_XDN()</span>
	<span class="cm">/* Reset UDN coordinates to their standard value */</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cpu</span> <span class="o">%</span> <span class="n">smp_width</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">cpu</span> <span class="o">/</span> <span class="n">smp_width</span><span class="p">;</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_UDN_TILE_COORD</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Set demux tags to predefined values and enable them. */</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_UDN_TAG_VALID</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_UDN_TAG_0</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_UDN_TAG_1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_UDN_TAG_2</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_UDN_TAG_3</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>

	<span class="cm">/* Set other rev0 random registers to a clean state. */</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_UDN_REFILL_EN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_UDN_DEMUX_QUEUE_SEL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_UDN_SP_FIFO_SEL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Start the switch and demux. */</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_UDN_SP_FREEZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reset_network_state</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reset_xdn_network_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hardwall_types</span><span class="p">[</span><span class="n">HARDWALL_UDN</span><span class="p">]);</span>
<span class="cp">#ifndef __tilepro__</span>
	<span class="n">reset_xdn_network_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hardwall_types</span><span class="p">[</span><span class="n">HARDWALL_IDN</span><span class="p">]);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Restart an XDN switch after draining. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">restart_xdn_switch</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

<span class="cp">#if CHIP_HAS_REV1_XDN()</span>
	<span class="cm">/* One last drain step to avoid races with injection and draining. */</span>
	<span class="n">empty_xdn_demuxes</span><span class="p">(</span><span class="n">hwt</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">reset_xdn_network_state</span><span class="p">(</span><span class="n">hwt</span><span class="p">);</span>

	<span class="cm">/* Disable firewall interrupts. */</span>
	<span class="n">disable_firewall_interrupts</span><span class="p">(</span><span class="n">hwt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Last reference to a hardwall is gone, so clear the network. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hardwall_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Make sure this file actually represents a hardwall. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Deactivate any remaining tasks.  It&#39;s possible to race with</span>
<span class="cm">	 * some other thread that is exiting and hasn&#39;t yet called</span>
<span class="cm">	 * deactivate (when freeing its thread_info), so we carefully</span>
<span class="cm">	 * deactivate any remaining tasks before freeing the</span>
<span class="cm">	 * hardwall_info object itself.</span>
<span class="cm">	 */</span>
	<span class="n">hwt</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">teardown_in_progress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">task_head</span><span class="p">,</span>
			    <span class="kr">thread</span><span class="p">.</span><span class="n">hardwall</span><span class="p">[</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">list</span><span class="p">)</span>
		<span class="n">_hardwall_deactivate</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">is_xdn</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Configure the switches for draining the user network. */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
		       <span class="s">&quot;Clearing %s hardwall rectangle %dx%d %d,%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">hwt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span>
		       <span class="n">info</span><span class="o">-&gt;</span><span class="n">ulhc_x</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ulhc_y</span><span class="p">);</span>
		<span class="n">on_each_cpu_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">stop_xdn_switch</span><span class="p">,</span> <span class="n">hwt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Drain the network. */</span>
<span class="cp">#if CHIP_HAS_REV1_XDN()</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xdn_pending_count</span><span class="p">,</span>
			   <span class="n">cpumask_weight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">));</span>
		<span class="n">on_each_cpu_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">drain_xdn_switch</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">on_each_cpu_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">drain_xdn_switch</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="cm">/* Restart switch and disable firewall. */</span>
		<span class="n">on_each_cpu_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">restart_xdn_switch</span><span class="p">,</span> <span class="n">hwt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Remove the /proc/tile/hardwall entry. */</span>
	<span class="n">hardwall_remove_proc</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/* Now free the hardwall from the list. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">task_head</span><span class="p">));</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">hardwall_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">cpulist_scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">rc</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
	<span class="n">seq_write</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hardwall_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">hardwall_proc_show</span><span class="p">,</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">hardwall_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">hardwall_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hardwall_add_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">proc_create_data</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">proc_dir</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">hardwall_proc_fops</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hardwall_remove_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">proc_dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">proc_pid_hardwall</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HARDWALL_TYPES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">hardwall</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">info</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="s">&quot;%s: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">proc_tile_hardwall_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HARDWALL_TYPES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hardwall_types</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hardwall_proc_dir</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">hardwall_proc_dir</span> <span class="o">=</span> <span class="n">proc_mkdir</span><span class="p">(</span><span class="s">&quot;hardwall&quot;</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">hwt</span><span class="o">-&gt;</span><span class="n">proc_dir</span> <span class="o">=</span> <span class="n">proc_mkdir</span><span class="p">(</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">hardwall_proc_dir</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Character device support via ioctl/close.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">hardwall_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hardwall_type</span><span class="o">*</span> <span class="n">hwt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_IOC_TYPE</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="n">HARDWALL_IOCTL_BASE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">HARDWALL_TYPES</span> <span class="o">!=</span> <span class="n">_HARDWALL_TYPES</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">HARDWALL_TYPES</span> <span class="o">!=</span>
		     <span class="k">sizeof</span><span class="p">(</span><span class="n">hardwall_types</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hardwall_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">minor</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">minor</span> <span class="o">&gt;=</span> <span class="n">HARDWALL_TYPES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">hwt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hardwall_types</span><span class="p">[</span><span class="n">minor</span><span class="p">];</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">info</span> <span class="o">&amp;&amp;</span> <span class="n">hwt</span> <span class="o">!=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">_IOC_NR</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">_HARDWALL_CREATE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">;</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">hardwall_create</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">_IOC_SIZE</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
				       <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">info</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">_HARDWALL_ACTIVATE</span>:
		<span class="k">return</span> <span class="n">hardwall_activate</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">_HARDWALL_DEACTIVATE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">hardwall</span><span class="p">[</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">info</span> <span class="o">!=</span> <span class="n">info</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">hardwall_deactivate</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">_HARDWALL_GET_ID</span>:
		<span class="k">return</span> <span class="n">info</span> <span class="o">?</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">hardwall_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Sign-extend the argument so it can be used as a pointer. */</span>
	<span class="k">return</span> <span class="n">hardwall_ioctl</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">compat_ptr</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* The user process closed the file; revoke access to user networks. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hardwall_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">fl_owner_t</span> <span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * NOTE: if multiple threads are activated on this hardwall</span>
<span class="cm">		 * file, the other threads will continue having access to the</span>
<span class="cm">		 * user network until they are context-switched out and back</span>
<span class="cm">		 * in again.</span>
<span class="cm">		 *</span>
<span class="cm">		 * NOTE: A NULL files pointer means the task is being torn</span>
<span class="cm">		 * down, so in that case we also deactivate it.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">hardwall_type</span> <span class="o">*</span><span class="n">hwt</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">task_head</span><span class="p">,</span>
					 <span class="kr">thread</span><span class="p">.</span><span class="n">hardwall</span><span class="p">[</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">files</span> <span class="o">==</span> <span class="n">owner</span> <span class="o">||</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">files</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">_hardwall_deactivate</span><span class="p">(</span><span class="n">hwt</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwt</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This hardwall is gone, so destroy it. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hardwall_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hardwall_destroy</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">dev_hardwall_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">nonseekable_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">hardwall_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>   <span class="o">=</span> <span class="n">hardwall_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">flush</span>          <span class="o">=</span> <span class="n">hardwall_flush</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">hardwall_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cdev</span> <span class="n">hardwall_dev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dev_hardwall_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">dev_t</span> <span class="n">dev</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">alloc_chrdev_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">HARDWALL_TYPES</span><span class="p">,</span> <span class="s">&quot;hardwall&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hardwall_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_hardwall_fops</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hardwall_dev</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">HARDWALL_TYPES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">dev_hardwall_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
