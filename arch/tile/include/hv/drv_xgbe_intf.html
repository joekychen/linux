<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › include › hv › drv_xgbe_intf.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>drv_xgbe_intf.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * @file drv_xgbe_intf.h</span>
<span class="cm"> * Interface to the hypervisor XGBE driver.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __DRV_XGBE_INTF_H__</span>
<span class="cp">#define __DRV_XGBE_INTF_H__</span>

<span class="cm">/**</span>
<span class="cm"> * An object for forwarding VAs and PAs to the hypervisor.</span>
<span class="cm"> * @ingroup types</span>
<span class="cm"> *</span>
<span class="cm"> * This allows the supervisor to specify a number of areas of memory to</span>
<span class="cm"> * store packet buffers.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="cm">/** The physical address of the memory. */</span>
  <span class="n">HV_PhysAddr</span> <span class="n">pa</span><span class="p">;</span>
  <span class="cm">/** Page table entry for the memory.  This is only used to derive the</span>
<span class="cm">   *  memory&#39;s caching mode; the PA bits are ignored. */</span>
  <span class="n">HV_PTE</span> <span class="n">pte</span><span class="p">;</span>
  <span class="cm">/** The virtual address of the memory. */</span>
  <span class="n">HV_VirtAddr</span> <span class="n">va</span><span class="p">;</span>
  <span class="cm">/** Size (in bytes) of the memory area. */</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">netio_ipp_address_t</span><span class="p">;</span>

<span class="cm">/** The various pread/pwrite offsets into the hypervisor-level driver.</span>
<span class="cm"> * @ingroup types</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span>
<span class="p">{</span>
  <span class="cm">/** Inform the Linux driver of the address of the NetIO arena memory.</span>
<span class="cm">   *  This offset is actually only used to convey information from netio</span>
<span class="cm">   *  to the Linux driver; it never makes it from there to the hypervisor.</span>
<span class="cm">   *  Write-only; takes a uint32_t specifying the VA address. */</span>
  <span class="n">NETIO_FIXED_ADDR</span>               <span class="o">=</span> <span class="mh">0x5000000000000000ULL</span><span class="p">,</span>

  <span class="cm">/** Inform the Linux driver of the size of the NetIO arena memory.</span>
<span class="cm">   *  This offset is actually only used to convey information from netio</span>
<span class="cm">   *  to the Linux driver; it never makes it from there to the hypervisor.</span>
<span class="cm">   *  Write-only; takes a uint32_t specifying the VA size. */</span>
  <span class="n">NETIO_FIXED_SIZE</span>               <span class="o">=</span> <span class="mh">0x5100000000000000ULL</span><span class="p">,</span>

  <span class="cm">/** Register current tile with IPP.  Write then read: write, takes a</span>
<span class="cm">   *  netio_input_config_t, read returns a pointer to a netio_queue_impl_t. */</span>
  <span class="n">NETIO_IPP_INPUT_REGISTER_OFF</span>   <span class="o">=</span> <span class="mh">0x6000000000000000ULL</span><span class="p">,</span>

  <span class="cm">/** Unregister current tile from IPP.  Write-only, takes a dummy argument. */</span>
  <span class="n">NETIO_IPP_INPUT_UNREGISTER_OFF</span> <span class="o">=</span> <span class="mh">0x6100000000000000ULL</span><span class="p">,</span>

  <span class="cm">/** Start packets flowing.  Write-only, takes a dummy argument. */</span>
  <span class="n">NETIO_IPP_INPUT_INIT_OFF</span>       <span class="o">=</span> <span class="mh">0x6200000000000000ULL</span><span class="p">,</span>

  <span class="cm">/** Stop packets flowing.  Write-only, takes a dummy argument. */</span>
  <span class="n">NETIO_IPP_INPUT_UNINIT_OFF</span>     <span class="o">=</span> <span class="mh">0x6300000000000000ULL</span><span class="p">,</span>

  <span class="cm">/** Configure group (typically we group on VLAN).  Write-only: takes an</span>
<span class="cm">   *  array of netio_group_t&#39;s, low 24 bits of the offset is the base group</span>
<span class="cm">   *  number times the size of a netio_group_t. */</span>
  <span class="n">NETIO_IPP_INPUT_GROUP_CFG_OFF</span>  <span class="o">=</span> <span class="mh">0x6400000000000000ULL</span><span class="p">,</span>

  <span class="cm">/** Configure bucket.  Write-only: takes an array of netio_bucket_t&#39;s, low</span>
<span class="cm">   *  24 bits of the offset is the base bucket number times the size of a</span>
<span class="cm">   *  netio_bucket_t. */</span>
  <span class="n">NETIO_IPP_INPUT_BUCKET_CFG_OFF</span> <span class="o">=</span> <span class="mh">0x6500000000000000ULL</span><span class="p">,</span>

  <span class="cm">/** Get/set a parameter.  Read or write: read or write data is the parameter</span>
<span class="cm">   *  value, low 32 bits of the offset is a __netio_getset_offset_t. */</span>
  <span class="n">NETIO_IPP_PARAM_OFF</span>            <span class="o">=</span> <span class="mh">0x6600000000000000ULL</span><span class="p">,</span>

  <span class="cm">/** Get fast I/O index.  Read-only; returns a 4-byte base index value. */</span>
  <span class="n">NETIO_IPP_GET_FASTIO_OFF</span>       <span class="o">=</span> <span class="mh">0x6700000000000000ULL</span><span class="p">,</span>

  <span class="cm">/** Configure hijack IP address.  Packets with this IPv4 dest address</span>
<span class="cm">   *  go to bucket NETIO_NUM_BUCKETS - 1.  Write-only: takes an IP address</span>
<span class="cm">   *  in some standard form.  FIXME: Define the form! */</span>
  <span class="n">NETIO_IPP_INPUT_HIJACK_CFG_OFF</span>  <span class="o">=</span> <span class="mh">0x6800000000000000ULL</span><span class="p">,</span>

  <span class="cm">/**</span>
<span class="cm">   * Offsets beyond this point are reserved for the supervisor (although that</span>
<span class="cm">   * enforcement must be done by the supervisor driver itself).</span>
<span class="cm">   */</span>
  <span class="n">NETIO_IPP_USER_MAX_OFF</span>         <span class="o">=</span> <span class="mh">0x6FFFFFFFFFFFFFFFULL</span><span class="p">,</span>

  <span class="cm">/** Register I/O memory.  Write-only, takes a netio_ipp_address_t. */</span>
  <span class="n">NETIO_IPP_IOMEM_REGISTER_OFF</span>   <span class="o">=</span> <span class="mh">0x7000000000000000ULL</span><span class="p">,</span>

  <span class="cm">/** Unregister I/O memory.  Write-only, takes a netio_ipp_address_t. */</span>
  <span class="n">NETIO_IPP_IOMEM_UNREGISTER_OFF</span> <span class="o">=</span> <span class="mh">0x7100000000000000ULL</span><span class="p">,</span>

  <span class="cm">/* Offsets greater than 0x7FFFFFFF can&#39;t be used directly from Linux</span>
<span class="cm">   * userspace code due to limitations in the pread/pwrite syscalls. */</span>

  <span class="cm">/** Drain LIPP buffers. */</span>
  <span class="n">NETIO_IPP_DRAIN_OFF</span>              <span class="o">=</span> <span class="mh">0xFA00000000000000ULL</span><span class="p">,</span>

  <span class="cm">/** Supply a netio_ipp_address_t to be used as shared memory for the</span>
<span class="cm">   *  LEPP command queue. */</span>
  <span class="n">NETIO_EPP_SHM_OFF</span>              <span class="o">=</span> <span class="mh">0xFB00000000000000ULL</span><span class="p">,</span>

  <span class="cm">/* 0xFC... is currently unused. */</span>

  <span class="cm">/** Stop IPP/EPP tiles.  Write-only, takes a dummy argument.  */</span>
  <span class="n">NETIO_IPP_STOP_SHIM_OFF</span>        <span class="o">=</span> <span class="mh">0xFD00000000000000ULL</span><span class="p">,</span>

  <span class="cm">/** Start IPP/EPP tiles.  Write-only, takes a dummy argument.  */</span>
  <span class="n">NETIO_IPP_START_SHIM_OFF</span>       <span class="o">=</span> <span class="mh">0xFE00000000000000ULL</span><span class="p">,</span>

  <span class="cm">/** Supply packet arena.  Write-only, takes an array of</span>
<span class="cm">    * netio_ipp_address_t values. */</span>
  <span class="n">NETIO_IPP_ADDRESS_OFF</span>          <span class="o">=</span> <span class="mh">0xFF00000000000000ULL</span><span class="p">,</span>
<span class="p">}</span> <span class="n">netio_hv_offset_t</span><span class="p">;</span>

<span class="cm">/** Extract the base offset from an offset */</span>
<span class="cp">#define NETIO_BASE_OFFSET(off)    ((off) &amp; 0xFF00000000000000ULL)</span>
<span class="cm">/** Extract the local offset from an offset */</span>
<span class="cp">#define NETIO_LOCAL_OFFSET(off)   ((off) &amp; 0x00FFFFFFFFFFFFFFULL)</span>


<span class="cm">/**</span>
<span class="cm"> * Get/set offset.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span>
<span class="p">{</span>
  <span class="k">struct</span>
  <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">addr</span><span class="o">:</span><span class="mi">48</span><span class="p">;</span>        <span class="cm">/**&lt; Class-specific address */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>    <span class="cm">/**&lt; Class (e.g., NETIO_PARAM) */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opcode</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>   <span class="cm">/**&lt; High 8 bits of NETIO_IPP_PARAM_OFF */</span>
  <span class="p">}</span>
  <span class="n">bits</span><span class="p">;</span>                      <span class="cm">/**&lt; Bitfields */</span>
  <span class="kt">uint64_t</span> <span class="n">word</span><span class="p">;</span>             <span class="cm">/**&lt; Aggregated value to use as the offset */</span>
<span class="p">}</span>
<span class="n">__netio_getset_offset_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Fast I/O index offsets (must be contiguous).</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span>
<span class="p">{</span>
  <span class="n">NETIO_FASTIO_ALLOCATE</span>         <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/**&lt; Get empty packet buffer */</span>
  <span class="n">NETIO_FASTIO_FREE_BUFFER</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/**&lt; Give buffer back to IPP */</span>
  <span class="n">NETIO_FASTIO_RETURN_CREDITS</span>   <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="cm">/**&lt; Give credits to IPP */</span>
  <span class="n">NETIO_FASTIO_SEND_PKT_NOCK</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="cm">/**&lt; Send a packet, no checksum */</span>
  <span class="n">NETIO_FASTIO_SEND_PKT_CK</span>      <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="cm">/**&lt; Send a packet, with checksum */</span>
  <span class="n">NETIO_FASTIO_SEND_PKT_VEC</span>     <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="cm">/**&lt; Send a vector of packets */</span>
  <span class="n">NETIO_FASTIO_SENDV_PKT</span>        <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="cm">/**&lt; Sendv one packet */</span>
  <span class="n">NETIO_FASTIO_NUM_INDEX</span>        <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="cm">/**&lt; Total number of fast I/O indices */</span>
<span class="p">}</span> <span class="n">netio_fastio_index_t</span><span class="p">;</span>

<span class="cm">/** 3-word return type for Fast I/O call. */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>            <span class="cm">/**&lt; Error code. */</span>
  <span class="kt">uint32_t</span> <span class="n">val0</span><span class="p">;</span>      <span class="cm">/**&lt; Value.  Meaning depends upon the specific call. */</span>
  <span class="kt">uint32_t</span> <span class="n">val1</span><span class="p">;</span>      <span class="cm">/**&lt; Value.  Meaning depends upon the specific call. */</span>
<span class="p">}</span> <span class="n">netio_fastio_rv3_t</span><span class="p">;</span>

<span class="cm">/** 0-argument fast I/O call */</span>
<span class="kt">int</span> <span class="n">__netio_fastio0</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">fastio_index</span><span class="p">);</span>
<span class="cm">/** 1-argument fast I/O call */</span>
<span class="kt">int</span> <span class="n">__netio_fastio1</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">fastio_index</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg0</span><span class="p">);</span>
<span class="cm">/** 3-argument fast I/O call, 2-word return value */</span>
<span class="n">netio_fastio_rv3_t</span> <span class="n">__netio_fastio3_rv3</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">fastio_index</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg0</span><span class="p">,</span>
                                       <span class="kt">uint32_t</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg2</span><span class="p">);</span>
<span class="cm">/** 4-argument fast I/O call */</span>
<span class="kt">int</span> <span class="n">__netio_fastio4</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">fastio_index</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg1</span><span class="p">,</span>
                    <span class="kt">uint32_t</span> <span class="n">arg2</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg3</span><span class="p">);</span>
<span class="cm">/** 6-argument fast I/O call */</span>
<span class="kt">int</span> <span class="n">__netio_fastio6</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">fastio_index</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg1</span><span class="p">,</span>
                    <span class="kt">uint32_t</span> <span class="n">arg2</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg3</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg4</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg5</span><span class="p">);</span>
<span class="cm">/** 9-argument fast I/O call */</span>
<span class="kt">int</span> <span class="n">__netio_fastio9</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">fastio_index</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg1</span><span class="p">,</span>
                    <span class="kt">uint32_t</span> <span class="n">arg2</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg3</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg4</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg5</span><span class="p">,</span>
                    <span class="kt">uint32_t</span> <span class="n">arg6</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg7</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">arg8</span><span class="p">);</span>

<span class="cm">/** Allocate an empty packet.</span>
<span class="cm"> * @param fastio_index Fast I/O index.</span>
<span class="cm"> * @param size Size of the packet to allocate.</span>
<span class="cm"> */</span>
<span class="cp">#define __netio_fastio_allocate(fastio_index, size) \</span>
<span class="cp">  __netio_fastio1((fastio_index) + NETIO_FASTIO_ALLOCATE, size)</span>

<span class="cm">/** Free a buffer.</span>
<span class="cm"> * @param fastio_index Fast I/O index.</span>
<span class="cm"> * @param handle Handle for the packet to free.</span>
<span class="cm"> */</span>
<span class="cp">#define __netio_fastio_free_buffer(fastio_index, handle) \</span>
<span class="cp">  __netio_fastio1((fastio_index) + NETIO_FASTIO_FREE_BUFFER, handle)</span>

<span class="cm">/** Increment our receive credits.</span>
<span class="cm"> * @param fastio_index Fast I/O index.</span>
<span class="cm"> * @param credits Number of credits to add.</span>
<span class="cm"> */</span>
<span class="cp">#define __netio_fastio_return_credits(fastio_index, credits) \</span>
<span class="cp">  __netio_fastio1((fastio_index) + NETIO_FASTIO_RETURN_CREDITS, credits)</span>

<span class="cm">/** Send packet, no checksum.</span>
<span class="cm"> * @param fastio_index Fast I/O index.</span>
<span class="cm"> * @param ackflag Nonzero if we want an ack.</span>
<span class="cm"> * @param size Size of the packet.</span>
<span class="cm"> * @param va Virtual address of start of packet.</span>
<span class="cm"> * @param handle Packet handle.</span>
<span class="cm"> */</span>
<span class="cp">#define __netio_fastio_send_pkt_nock(fastio_index, ackflag, size, va, handle) \</span>
<span class="cp">  __netio_fastio4((fastio_index) + NETIO_FASTIO_SEND_PKT_NOCK, ackflag, \</span>
<span class="cp">                  size, va, handle)</span>

<span class="cm">/** Send packet, calculate checksum.</span>
<span class="cm"> * @param fastio_index Fast I/O index.</span>
<span class="cm"> * @param ackflag Nonzero if we want an ack.</span>
<span class="cm"> * @param size Size of the packet.</span>
<span class="cm"> * @param va Virtual address of start of packet.</span>
<span class="cm"> * @param handle Packet handle.</span>
<span class="cm"> * @param csum0 Shim checksum header.</span>
<span class="cm"> * @param csum1 Checksum seed.</span>
<span class="cm"> */</span>
<span class="cp">#define __netio_fastio_send_pkt_ck(fastio_index, ackflag, size, va, handle, \</span>
<span class="cp">                                   csum0, csum1) \</span>
<span class="cp">  __netio_fastio6((fastio_index) + NETIO_FASTIO_SEND_PKT_CK, ackflag, \</span>
<span class="cp">                  size, va, handle, csum0, csum1)</span>


<span class="cm">/** Format for the &quot;csum0&quot; argument to the __netio_fastio_send routines</span>
<span class="cm"> * and LEPP.  Note that this is currently exactly identical to the</span>
<span class="cm"> * ShimProtocolOffloadHeader.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span>
<span class="p">{</span>
  <span class="k">struct</span>
  <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start_byte</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>       <span class="cm">/**&lt; The first byte to be checksummed */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>           <span class="cm">/**&lt; Number of bytes to be checksummed. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">destination_byte</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span> <span class="cm">/**&lt; The byte to write the checksum to. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reserved</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>         <span class="cm">/**&lt; Reserved. */</span>
  <span class="p">}</span> <span class="n">bits</span><span class="p">;</span>                            <span class="cm">/**&lt; Decomposed method of access. */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">word</span><span class="p">;</span>                 <span class="cm">/**&lt; To send out the IDN. */</span>
<span class="p">}</span> <span class="n">__netio_checksum_header_t</span><span class="p">;</span>


<span class="cm">/** Sendv packet with 1 or 2 segments.</span>
<span class="cm"> * @param fastio_index Fast I/O index.</span>
<span class="cm"> * @param flags Ack/csum/notify flags in low 3 bits; number of segments minus</span>
<span class="cm"> *        1 in next 2 bits; expected checksum in high 16 bits.</span>
<span class="cm"> * @param confno Confirmation number to request, if notify flag set.</span>
<span class="cm"> * @param csum0 Checksum descriptor; if zero, no checksum.</span>
<span class="cm"> * @param va_F Virtual address of first segment.</span>
<span class="cm"> * @param va_L Virtual address of last segment, if 2 segments.</span>
<span class="cm"> * @param len_F_L Length of first segment in low 16 bits; length of last</span>
<span class="cm"> *        segment, if 2 segments, in high 16 bits.</span>
<span class="cm"> */</span>
<span class="cp">#define __netio_fastio_sendv_pkt_1_2(fastio_index, flags, confno, csum0, \</span>
<span class="cp">                                     va_F, va_L, len_F_L) \</span>
<span class="cp">  __netio_fastio6((fastio_index) + NETIO_FASTIO_SENDV_PKT, flags, confno, \</span>
<span class="cp">                  csum0, va_F, va_L, len_F_L)</span>

<span class="cm">/** Send packet on PCIe interface.</span>
<span class="cm"> * @param fastio_index Fast I/O index.</span>
<span class="cm"> * @param flags Ack/csum/notify flags in low 3 bits.</span>
<span class="cm"> * @param confno Confirmation number to request, if notify flag set.</span>
<span class="cm"> * @param csum0 Checksum descriptor; Hard wired 0, not needed for PCIe.</span>
<span class="cm"> * @param va_F Virtual address of the packet buffer.</span>
<span class="cm"> * @param va_L Virtual address of last segment, if 2 segments. Hard wired 0.</span>
<span class="cm"> * @param len_F_L Length of the packet buffer in low 16 bits.</span>
<span class="cm"> */</span>
<span class="cp">#define __netio_fastio_send_pcie_pkt(fastio_index, flags, confno, csum0, \</span>
<span class="cp">                                     va_F, va_L, len_F_L) \</span>
<span class="cp">  __netio_fastio6((fastio_index) + PCIE_FASTIO_SENDV_PKT, flags, confno, \</span>
<span class="cp">                  csum0, va_F, va_L, len_F_L)</span>

<span class="cm">/** Sendv packet with 3 or 4 segments.</span>
<span class="cm"> * @param fastio_index Fast I/O index.</span>
<span class="cm"> * @param flags Ack/csum/notify flags in low 3 bits; number of segments minus</span>
<span class="cm"> *        1 in next 2 bits; expected checksum in high 16 bits.</span>
<span class="cm"> * @param confno Confirmation number to request, if notify flag set.</span>
<span class="cm"> * @param csum0 Checksum descriptor; if zero, no checksum.</span>
<span class="cm"> * @param va_F Virtual address of first segment.</span>
<span class="cm"> * @param va_L Virtual address of last segment (third segment if 3 segments,</span>
<span class="cm"> *        fourth segment if 4 segments).</span>
<span class="cm"> * @param len_F_L Length of first segment in low 16 bits; length of last</span>
<span class="cm"> *        segment in high 16 bits.</span>
<span class="cm"> * @param va_M0 Virtual address of &quot;middle 0&quot; segment; this segment is sent</span>
<span class="cm"> *        second when there are three segments, and third if there are four.</span>
<span class="cm"> * @param va_M1 Virtual address of &quot;middle 1&quot; segment; this segment is sent</span>
<span class="cm"> *        second when there are four segments.</span>
<span class="cm"> * @param len_M0_M1 Length of middle 0 segment in low 16 bits; length of middle</span>
<span class="cm"> *        1 segment, if 4 segments, in high 16 bits.</span>
<span class="cm"> */</span>
<span class="cp">#define __netio_fastio_sendv_pkt_3_4(fastio_index, flags, confno, csum0, va_F, \</span>
<span class="cp">                                     va_L, len_F_L, va_M0, va_M1, len_M0_M1) \</span>
<span class="cp">  __netio_fastio9((fastio_index) + NETIO_FASTIO_SENDV_PKT, flags, confno, \</span>
<span class="cp">                  csum0, va_F, va_L, len_F_L, va_M0, va_M1, len_M0_M1)</span>

<span class="cm">/** Send vector of packets.</span>
<span class="cm"> * @param fastio_index Fast I/O index.</span>
<span class="cm"> * @param seqno Number of packets transmitted so far on this interface;</span>
<span class="cm"> *        used to decide which packets should be acknowledged.</span>
<span class="cm"> * @param nentries Number of entries in vector.</span>
<span class="cm"> * @param va Virtual address of start of vector entry array.</span>
<span class="cm"> * @return 3-word netio_fastio_rv3_t structure.  The structure&#39;s err member</span>
<span class="cm"> *         is an error code, or zero if no error.  The val0 member is the</span>
<span class="cm"> *         updated value of seqno; it has been incremented by 1 for each</span>
<span class="cm"> *         packet sent.  That increment may be less than nentries if an</span>
<span class="cm"> *         error occurred, or if some of the entries in the vector contain</span>
<span class="cm"> *         handles equal to NETIO_PKT_HANDLE_NONE.  The val1 member is the</span>
<span class="cm"> *         updated value of nentries; it has been decremented by 1 for each</span>
<span class="cm"> *         vector entry processed.  Again, that decrement may be less than</span>
<span class="cm"> *         nentries (leaving the returned value positive) if an error</span>
<span class="cm"> *         occurred.</span>
<span class="cm"> */</span>
<span class="cp">#define __netio_fastio_send_pkt_vec(fastio_index, seqno, nentries, va) \</span>
<span class="cp">  __netio_fastio3_rv3((fastio_index) + NETIO_FASTIO_SEND_PKT_VEC, seqno, \</span>
<span class="cp">                      nentries, va)</span>


<span class="cm">/** An egress DMA command for LEPP. */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="cm">/** Is this a TSO transfer?</span>
<span class="cm">   *</span>
<span class="cm">   * NOTE: This field is always 0, to distinguish it from</span>
<span class="cm">   * lepp_tso_cmd_t.  It must come first!</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">tso</span>               <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

  <span class="cm">/** Unused padding bits. */</span>
  <span class="kt">uint8_t</span> <span class="n">_unused</span>           <span class="o">:</span> <span class="mi">3</span><span class="p">;</span>

  <span class="cm">/** Should this packet be sent directly from caches instead of DRAM,</span>
<span class="cm">   * using hash-for-home to locate the packet data?</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">hash_for_home</span>     <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

  <span class="cm">/** Should we compute a checksum? */</span>
  <span class="kt">uint8_t</span> <span class="n">compute_checksum</span>  <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

  <span class="cm">/** Is this the final buffer for this packet?</span>
<span class="cm">   *</span>
<span class="cm">   * A single packet can be split over several input buffers (a &quot;gather&quot;</span>
<span class="cm">   * operation).  This flag indicates that this is the last buffer</span>
<span class="cm">   * in a packet.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">end_of_packet</span>     <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

  <span class="cm">/** Should LEPP advance &#39;comp_busy&#39; when this DMA is fully finished? */</span>
  <span class="kt">uint8_t</span> <span class="n">send_completion</span>   <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

  <span class="cm">/** High bits of Client Physical Address of the start of the buffer</span>
<span class="cm">   *  to be egressed.</span>
<span class="cm">   *</span>
<span class="cm">   *  NOTE: Only 6 bits are actually needed here, as CPAs are</span>
<span class="cm">   *  currently 38 bits.  So two bits could be scavenged from this.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">cpa_hi</span><span class="p">;</span>

  <span class="cm">/** The number of bytes to be egressed. */</span>
  <span class="kt">uint16_t</span> <span class="n">length</span><span class="p">;</span>

  <span class="cm">/** Low 32 bits of Client Physical Address of the start of the buffer</span>
<span class="cm">   *  to be egressed.</span>
<span class="cm">   */</span>
  <span class="kt">uint32_t</span> <span class="n">cpa_lo</span><span class="p">;</span>

  <span class="cm">/** Checksum information (only used if &#39;compute_checksum&#39;). */</span>
  <span class="n">__netio_checksum_header_t</span> <span class="n">checksum_data</span><span class="p">;</span>

<span class="p">}</span> <span class="n">lepp_cmd_t</span><span class="p">;</span>


<span class="cm">/** A chunk of physical memory for a TSO egress. */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="cm">/** The low bits of the CPA. */</span>
  <span class="kt">uint32_t</span> <span class="n">cpa_lo</span><span class="p">;</span>
  <span class="cm">/** The high bits of the CPA. */</span>
  <span class="kt">uint16_t</span> <span class="n">cpa_hi</span>		<span class="o">:</span> <span class="mi">15</span><span class="p">;</span>
  <span class="cm">/** Should this packet be sent directly from caches instead of DRAM,</span>
<span class="cm">   *  using hash-for-home to locate the packet data?</span>
<span class="cm">   */</span>
  <span class="kt">uint16_t</span> <span class="n">hash_for_home</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="cm">/** The length in bytes. */</span>
  <span class="kt">uint16_t</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span> <span class="n">lepp_frag_t</span><span class="p">;</span>


<span class="cm">/** An LEPP command that handles TSO. */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="cm">/** Is this a TSO transfer?</span>
<span class="cm">   *</span>
<span class="cm">   *  NOTE: This field is always 1, to distinguish it from</span>
<span class="cm">   *  lepp_cmd_t.  It must come first!</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">tso</span>             <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

  <span class="cm">/** Unused padding bits. */</span>
  <span class="kt">uint8_t</span> <span class="n">_unused</span>         <span class="o">:</span> <span class="mi">7</span><span class="p">;</span>

  <span class="cm">/** Size of the header[] array in bytes.  It must be in the range</span>
<span class="cm">   *  [40, 127], which are the smallest header for a TCP packet over</span>
<span class="cm">   *  Ethernet and the maximum possible prepend size supported by</span>
<span class="cm">   *  hardware, respectively.  Note that the array storage must be</span>
<span class="cm">   *  padded out to a multiple of four bytes so that the following</span>
<span class="cm">   *  LEPP command is aligned properly.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">header_size</span><span class="p">;</span>

  <span class="cm">/** Byte offset of the IP header in header[]. */</span>
  <span class="kt">uint8_t</span> <span class="n">ip_offset</span><span class="p">;</span>

  <span class="cm">/** Byte offset of the TCP header in header[]. */</span>
  <span class="kt">uint8_t</span> <span class="n">tcp_offset</span><span class="p">;</span>

  <span class="cm">/** The number of bytes to use for the payload of each packet,</span>
<span class="cm">   *  except of course the last one, which may not have enough bytes.</span>
<span class="cm">   *  This means that each Ethernet packet except the last will have a</span>
<span class="cm">   *  size of header_size + payload_size.</span>
<span class="cm">   */</span>
  <span class="kt">uint16_t</span> <span class="n">payload_size</span><span class="p">;</span>

  <span class="cm">/** The length of the &#39;frags&#39; array that follows this struct. */</span>
  <span class="kt">uint16_t</span> <span class="n">num_frags</span><span class="p">;</span>

  <span class="cm">/** The actual frags. */</span>
  <span class="n">lepp_frag_t</span> <span class="n">frags</span><span class="p">[</span><span class="mi">0</span> <span class="cm">/* Variable-sized; num_frags entries. */</span><span class="p">];</span>

  <span class="cm">/*</span>
<span class="cm">   * The packet header template logically follows frags[],</span>
<span class="cm">   * but you can&#39;t declare that in C.</span>
<span class="cm">   *</span>
<span class="cm">   * uint32_t header[header_size_in_words_rounded_up];</span>
<span class="cm">   */</span>

<span class="p">}</span> <span class="n">lepp_tso_cmd_t</span><span class="p">;</span>


<span class="cm">/** An LEPP completion ring entry. */</span>
<span class="k">typedef</span> <span class="kt">void</span><span class="o">*</span> <span class="n">lepp_comp_t</span><span class="p">;</span>


<span class="cm">/** Maximum number of frags for one TSO command.  This is adapted from</span>
<span class="cm"> *  linux&#39;s &quot;MAX_SKB_FRAGS&quot;, and presumably over-estimates by one, for</span>
<span class="cm"> *  our page size of exactly 65536.  We add one for a &quot;body&quot; fragment.</span>
<span class="cm"> */</span>
<span class="cp">#define LEPP_MAX_FRAGS (65536 / HV_DEFAULT_PAGE_SIZE_SMALL + 2 + 1)</span>

<span class="cm">/** Total number of bytes needed for an lepp_tso_cmd_t. */</span>
<span class="cp">#define LEPP_TSO_CMD_SIZE(num_frags, header_size) \</span>
<span class="cp">  (sizeof(lepp_tso_cmd_t) + \</span>
<span class="cp">   (num_frags) * sizeof(lepp_frag_t) + \</span>
<span class="cp">   (((header_size) + 3) &amp; -4))</span>

<span class="cm">/** The size of the lepp &quot;cmd&quot; queue. */</span>
<span class="cp">#define LEPP_CMD_QUEUE_BYTES \</span>
<span class="cp"> (((CHIP_L2_CACHE_SIZE() - 2 * CHIP_L2_LINE_SIZE()) / \</span>
<span class="cp">  (sizeof(lepp_cmd_t) + sizeof(lepp_comp_t))) * sizeof(lepp_cmd_t))</span>

<span class="cm">/** The largest possible command that can go in lepp_queue_t::cmds[]. */</span>
<span class="cp">#define LEPP_MAX_CMD_SIZE LEPP_TSO_CMD_SIZE(LEPP_MAX_FRAGS, 128)</span>

<span class="cm">/** The largest possible value of lepp_queue_t::cmd_{head, tail} (inclusive).</span>
<span class="cm"> */</span>
<span class="cp">#define LEPP_CMD_LIMIT \</span>
<span class="cp">  (LEPP_CMD_QUEUE_BYTES - LEPP_MAX_CMD_SIZE)</span>

<span class="cm">/** The maximum number of completions in an LEPP queue. */</span>
<span class="cp">#define LEPP_COMP_QUEUE_SIZE \</span>
<span class="cp">  ((LEPP_CMD_LIMIT + sizeof(lepp_cmd_t) - 1) / sizeof(lepp_cmd_t))</span>

<span class="cm">/** Increment an index modulo the queue size. */</span>
<span class="cp">#define LEPP_QINC(var) \</span>
<span class="cp">  (var = __insn_mnz(var - (LEPP_COMP_QUEUE_SIZE - 1), var + 1))</span>

<span class="cm">/** A queue used to convey egress commands from the client to LEPP. */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="cm">/** Index of first completion not yet processed by user code.</span>
<span class="cm">   *  If this is equal to comp_busy, there are no such completions.</span>
<span class="cm">   *</span>
<span class="cm">   *  NOTE: This is only read/written by the user.</span>
<span class="cm">   */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">comp_head</span><span class="p">;</span>

  <span class="cm">/** Index of first completion record not yet completed.</span>
<span class="cm">   *  If this is equal to comp_tail, there are no such completions.</span>
<span class="cm">   *  This index gets advanced (modulo LEPP_QUEUE_SIZE) whenever</span>
<span class="cm">   *  a command with the &#39;completion&#39; bit set is finished.</span>
<span class="cm">   *</span>
<span class="cm">   *  NOTE: This is only written by LEPP, only read by the user.</span>
<span class="cm">   */</span>
  <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">comp_busy</span><span class="p">;</span>

  <span class="cm">/** Index of the first empty slot in the completion ring.</span>
<span class="cm">   *  Entries from this up to but not including comp_head (in ring order)</span>
<span class="cm">   *  can be filled in with completion data.</span>
<span class="cm">   *</span>
<span class="cm">   *  NOTE: This is only read/written by the user.</span>
<span class="cm">   */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">comp_tail</span><span class="p">;</span>

  <span class="cm">/** Byte index of first command enqueued for LEPP but not yet processed.</span>
<span class="cm">   *</span>
<span class="cm">   *  This is always divisible by sizeof(void*) and always &lt;= LEPP_CMD_LIMIT.</span>
<span class="cm">   *</span>
<span class="cm">   *  NOTE: LEPP advances this counter as soon as it no longer needs</span>
<span class="cm">   *  the cmds[] storage for this entry, but the transfer is not actually</span>
<span class="cm">   *  complete (i.e. the buffer pointed to by the command is no longer</span>
<span class="cm">   *  needed) until comp_busy advances.</span>
<span class="cm">   *</span>
<span class="cm">   *  If this is equal to cmd_tail, the ring is empty.</span>
<span class="cm">   *</span>
<span class="cm">   *  NOTE: This is only written by LEPP, only read by the user.</span>
<span class="cm">   */</span>
  <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd_head</span><span class="p">;</span>

  <span class="cm">/** Byte index of first empty slot in the command ring.  This field can</span>
<span class="cm">   *  be incremented up to but not equal to cmd_head (because that would</span>
<span class="cm">   *  mean the ring is empty).</span>
<span class="cm">   *</span>
<span class="cm">   *  This is always divisible by sizeof(void*) and always &lt;= LEPP_CMD_LIMIT.</span>
<span class="cm">   *</span>
<span class="cm">   *  NOTE: This is read/written by the user, only read by LEPP.</span>
<span class="cm">   */</span>
  <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd_tail</span><span class="p">;</span>

  <span class="cm">/** A ring of variable-sized egress DMA commands.</span>
<span class="cm">   *</span>
<span class="cm">   *  NOTE: Only written by the user, only read by LEPP.</span>
<span class="cm">   */</span>
  <span class="kt">char</span> <span class="n">cmds</span><span class="p">[</span><span class="n">LEPP_CMD_QUEUE_BYTES</span><span class="p">]</span>
    <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="n">CHIP_L2_LINE_SIZE</span><span class="p">())));</span>

  <span class="cm">/** A ring of user completion data.</span>
<span class="cm">   *  NOTE: Only read/written by the user.</span>
<span class="cm">   */</span>
  <span class="n">lepp_comp_t</span> <span class="n">comps</span><span class="p">[</span><span class="n">LEPP_COMP_QUEUE_SIZE</span><span class="p">]</span>
    <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="n">CHIP_L2_LINE_SIZE</span><span class="p">())));</span>
<span class="p">}</span> <span class="n">lepp_queue_t</span><span class="p">;</span>


<span class="cm">/** An internal helper function for determining the number of entries</span>
<span class="cm"> *  available in a ring buffer, given that there is one sentinel.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">_lepp_num_free_slots</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tail</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/*</span>
<span class="cm">   * One entry is reserved for use as a sentinel, to distinguish</span>
<span class="cm">   * &quot;empty&quot; from &quot;full&quot;.  So we compute</span>
<span class="cm">   * (head - tail - 1) % LEPP_QUEUE_SIZE, but without using a slow % operation.</span>
<span class="cm">   */</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">head</span> <span class="o">-</span> <span class="n">tail</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">head</span> <span class="o">&lt;=</span> <span class="n">tail</span><span class="p">)</span> <span class="o">?</span> <span class="n">LEPP_COMP_QUEUE_SIZE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Returns how many new comp entries can be enqueued. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">lepp_num_free_comp_slots</span><span class="p">(</span><span class="k">const</span> <span class="n">lepp_queue_t</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">_lepp_num_free_slots</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">comp_head</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">comp_tail</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">lepp_qsub</span><span class="p">(</span><span class="kt">int</span> <span class="n">v1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">-</span> <span class="n">v2</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">delta</span> <span class="o">+</span> <span class="p">((</span><span class="n">delta</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LEPP_COMP_QUEUE_SIZE</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** FIXME: Check this from linux, via a new &quot;pwrite()&quot; call. */</span>
<span class="cp">#define LIPP_VERSION 1</span>


<span class="cm">/** We use exactly two bytes of alignment padding. */</span>
<span class="cp">#define LIPP_PACKET_PADDING 2</span>

<span class="cm">/** The minimum size of a &quot;small&quot; buffer (including the padding). */</span>
<span class="cp">#define LIPP_SMALL_PACKET_SIZE 128</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE: The following two values should total to less than around</span>
<span class="cm"> * 13582, to keep the total size used for &quot;lipp_state_t&quot; below 64K.</span>
<span class="cm"> */</span>

<span class="cm">/** The maximum number of &quot;small&quot; buffers.</span>
<span class="cm"> *  This is enough for 53 network cpus with 128 credits.  Note that</span>
<span class="cm"> *  if these are exhausted, we will fall back to using large buffers.</span>
<span class="cm"> */</span>
<span class="cp">#define LIPP_SMALL_BUFFERS 6785</span>

<span class="cm">/** The maximum number of &quot;large&quot; buffers.</span>
<span class="cm"> *  This is enough for 53 network cpus with 128 credits.</span>
<span class="cm"> */</span>
<span class="cp">#define LIPP_LARGE_BUFFERS 6785</span>

<span class="cp">#endif </span><span class="cm">/* __DRV_XGBE_INTF_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
