<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › include › hv › hypervisor.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>hypervisor.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * @file hypervisor.h</span>
<span class="cm"> * The hypervisor&#39;s public API.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _HV_HV_H</span>
<span class="cp">#define _HV_HV_H</span>

<span class="cp">#include &lt;arch/chip.h&gt;</span>

<span class="cm">/* Linux builds want unsigned long constants, but assembler wants numbers */</span>
<span class="cp">#ifdef __ASSEMBLER__</span>
<span class="cm">/** One, for assembler */</span>
<span class="cp">#define __HV_SIZE_ONE 1</span>
<span class="cp">#elif !defined(__tile__) &amp;&amp; CHIP_VA_WIDTH() &gt; 32</span>
<span class="cm">/** One, for 64-bit on host */</span>
<span class="cp">#define __HV_SIZE_ONE 1ULL</span>
<span class="cp">#else</span>
<span class="cm">/** One, for Linux */</span>
<span class="cp">#define __HV_SIZE_ONE 1UL</span>
<span class="cp">#endif</span>

<span class="cm">/** The log2 of the span of a level-1 page table, in bytes.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_LOG2_L1_SPAN 32</span>

<span class="cm">/** The span of a level-1 page table, in bytes.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_L1_SPAN (__HV_SIZE_ONE &lt;&lt; HV_LOG2_L1_SPAN)</span>

<span class="cm">/** The log2 of the initial size of small pages, in bytes.</span>
<span class="cm"> * See HV_DEFAULT_PAGE_SIZE_SMALL.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_LOG2_DEFAULT_PAGE_SIZE_SMALL 16</span>

<span class="cm">/** The initial size of small pages, in bytes. This value should be verified</span>
<span class="cm"> * at runtime by calling hv_sysconf(HV_SYSCONF_PAGE_SIZE_SMALL).</span>
<span class="cm"> * It may also be modified when installing a new context.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_DEFAULT_PAGE_SIZE_SMALL \</span>
<span class="cp">  (__HV_SIZE_ONE &lt;&lt; HV_LOG2_DEFAULT_PAGE_SIZE_SMALL)</span>

<span class="cm">/** The log2 of the initial size of large pages, in bytes.</span>
<span class="cm"> * See HV_DEFAULT_PAGE_SIZE_LARGE.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_LOG2_DEFAULT_PAGE_SIZE_LARGE 24</span>

<span class="cm">/** The initial size of large pages, in bytes. This value should be verified</span>
<span class="cm"> * at runtime by calling hv_sysconf(HV_SYSCONF_PAGE_SIZE_LARGE).</span>
<span class="cm"> * It may also be modified when installing a new context.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_DEFAULT_PAGE_SIZE_LARGE \</span>
<span class="cp">  (__HV_SIZE_ONE &lt;&lt; HV_LOG2_DEFAULT_PAGE_SIZE_LARGE)</span>

<span class="cp">#if CHIP_VA_WIDTH() &gt; 32</span>

<span class="cm">/** The log2 of the initial size of jumbo pages, in bytes.</span>
<span class="cm"> * See HV_DEFAULT_PAGE_SIZE_JUMBO.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_LOG2_DEFAULT_PAGE_SIZE_JUMBO 32</span>

<span class="cm">/** The initial size of jumbo pages, in bytes. This value should</span>
<span class="cm"> * be verified at runtime by calling hv_sysconf(HV_SYSCONF_PAGE_SIZE_JUMBO).</span>
<span class="cm"> * It may also be modified when installing a new context.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_DEFAULT_PAGE_SIZE_JUMBO \</span>
<span class="cp">  (__HV_SIZE_ONE &lt;&lt; HV_LOG2_DEFAULT_PAGE_SIZE_JUMBO)</span>

<span class="cp">#endif</span>

<span class="cm">/** The log2 of the granularity at which page tables must be aligned;</span>
<span class="cm"> *  in other words, the CPA for a page table must have this many zero</span>
<span class="cm"> *  bits at the bottom of the address.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_LOG2_PAGE_TABLE_ALIGN 11</span>

<span class="cm">/** The granularity at which page tables must be aligned.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PAGE_TABLE_ALIGN (__HV_SIZE_ONE &lt;&lt; HV_LOG2_PAGE_TABLE_ALIGN)</span>

<span class="cm">/** Normal start of hypervisor glue in client physical memory. */</span>
<span class="cp">#define HV_GLUE_START_CPA 0x10000</span>

<span class="cm">/** This much space is reserved at HV_GLUE_START_CPA</span>
<span class="cm"> * for the hypervisor glue. The client program must start at</span>
<span class="cm"> * some address higher than this, and in particular the address of</span>
<span class="cm"> * its text section should be equal to zero modulo HV_PAGE_SIZE_LARGE</span>
<span class="cm"> * so that relative offsets to the HV glue are correct.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_GLUE_RESERVED_SIZE 0x10000</span>

<span class="cm">/** Each entry in the hv dispatch array takes this many bytes. */</span>
<span class="cp">#define HV_DISPATCH_ENTRY_SIZE 32</span>

<span class="cm">/** Version of the hypervisor interface defined by this file */</span>
<span class="cp">#define _HV_VERSION 11</span>

<span class="cm">/* Index into hypervisor interface dispatch code blocks.</span>
<span class="cm"> *</span>
<span class="cm"> * Hypervisor calls are invoked from user space by calling code</span>
<span class="cm"> * at an address HV_BASE_ADDRESS + (index) * HV_DISPATCH_ENTRY_SIZE,</span>
<span class="cm"> * where index is one of these enum values.</span>
<span class="cm"> *</span>
<span class="cm"> * Normally a supervisor is expected to produce a set of symbols</span>
<span class="cm"> * starting at HV_BASE_ADDRESS that obey this convention, but a user</span>
<span class="cm"> * program could call directly through function pointers if desired.</span>
<span class="cm"> *</span>
<span class="cm"> * These numbers are part of the binary API and will not be changed</span>
<span class="cm"> * without updating HV_VERSION, which should be a rare event.</span>
<span class="cm"> */</span>

<span class="cm">/** reserved. */</span>
<span class="cp">#define _HV_DISPATCH_RESERVED                     0</span>

<span class="cm">/** hv_init  */</span>
<span class="cp">#define HV_DISPATCH_INIT                          1</span>

<span class="cm">/** hv_install_context */</span>
<span class="cp">#define HV_DISPATCH_INSTALL_CONTEXT               2</span>

<span class="cm">/** hv_sysconf */</span>
<span class="cp">#define HV_DISPATCH_SYSCONF                       3</span>

<span class="cm">/** hv_get_rtc */</span>
<span class="cp">#define HV_DISPATCH_GET_RTC                       4</span>

<span class="cm">/** hv_set_rtc */</span>
<span class="cp">#define HV_DISPATCH_SET_RTC                       5</span>

<span class="cm">/** hv_flush_asid */</span>
<span class="cp">#define HV_DISPATCH_FLUSH_ASID                    6</span>

<span class="cm">/** hv_flush_page */</span>
<span class="cp">#define HV_DISPATCH_FLUSH_PAGE                    7</span>

<span class="cm">/** hv_flush_pages */</span>
<span class="cp">#define HV_DISPATCH_FLUSH_PAGES                   8</span>

<span class="cm">/** hv_restart */</span>
<span class="cp">#define HV_DISPATCH_RESTART                       9</span>

<span class="cm">/** hv_halt */</span>
<span class="cp">#define HV_DISPATCH_HALT                          10</span>

<span class="cm">/** hv_power_off */</span>
<span class="cp">#define HV_DISPATCH_POWER_OFF                     11</span>

<span class="cm">/** hv_inquire_physical */</span>
<span class="cp">#define HV_DISPATCH_INQUIRE_PHYSICAL              12</span>

<span class="cm">/** hv_inquire_memory_controller */</span>
<span class="cp">#define HV_DISPATCH_INQUIRE_MEMORY_CONTROLLER     13</span>

<span class="cm">/** hv_inquire_virtual */</span>
<span class="cp">#define HV_DISPATCH_INQUIRE_VIRTUAL               14</span>

<span class="cm">/** hv_inquire_asid */</span>
<span class="cp">#define HV_DISPATCH_INQUIRE_ASID                  15</span>

<span class="cm">/** hv_nanosleep */</span>
<span class="cp">#define HV_DISPATCH_NANOSLEEP                     16</span>

<span class="cm">/** hv_console_read_if_ready */</span>
<span class="cp">#define HV_DISPATCH_CONSOLE_READ_IF_READY         17</span>

<span class="cm">/** hv_console_write */</span>
<span class="cp">#define HV_DISPATCH_CONSOLE_WRITE                 18</span>

<span class="cm">/** hv_downcall_dispatch */</span>
<span class="cp">#define HV_DISPATCH_DOWNCALL_DISPATCH             19</span>

<span class="cm">/** hv_inquire_topology */</span>
<span class="cp">#define HV_DISPATCH_INQUIRE_TOPOLOGY              20</span>

<span class="cm">/** hv_fs_findfile */</span>
<span class="cp">#define HV_DISPATCH_FS_FINDFILE                   21</span>

<span class="cm">/** hv_fs_fstat */</span>
<span class="cp">#define HV_DISPATCH_FS_FSTAT                      22</span>

<span class="cm">/** hv_fs_pread */</span>
<span class="cp">#define HV_DISPATCH_FS_PREAD                      23</span>

<span class="cm">/** hv_physaddr_read64 */</span>
<span class="cp">#define HV_DISPATCH_PHYSADDR_READ64               24</span>

<span class="cm">/** hv_physaddr_write64 */</span>
<span class="cp">#define HV_DISPATCH_PHYSADDR_WRITE64              25</span>

<span class="cm">/** hv_get_command_line */</span>
<span class="cp">#define HV_DISPATCH_GET_COMMAND_LINE              26</span>

<span class="cm">/** hv_set_caching */</span>
<span class="cp">#define HV_DISPATCH_SET_CACHING                   27</span>

<span class="cm">/** hv_bzero_page */</span>
<span class="cp">#define HV_DISPATCH_BZERO_PAGE                    28</span>

<span class="cm">/** hv_register_message_state */</span>
<span class="cp">#define HV_DISPATCH_REGISTER_MESSAGE_STATE        29</span>

<span class="cm">/** hv_send_message */</span>
<span class="cp">#define HV_DISPATCH_SEND_MESSAGE                  30</span>

<span class="cm">/** hv_receive_message */</span>
<span class="cp">#define HV_DISPATCH_RECEIVE_MESSAGE               31</span>

<span class="cm">/** hv_inquire_context */</span>
<span class="cp">#define HV_DISPATCH_INQUIRE_CONTEXT               32</span>

<span class="cm">/** hv_start_all_tiles */</span>
<span class="cp">#define HV_DISPATCH_START_ALL_TILES               33</span>

<span class="cm">/** hv_dev_open */</span>
<span class="cp">#define HV_DISPATCH_DEV_OPEN                      34</span>

<span class="cm">/** hv_dev_close */</span>
<span class="cp">#define HV_DISPATCH_DEV_CLOSE                     35</span>

<span class="cm">/** hv_dev_pread */</span>
<span class="cp">#define HV_DISPATCH_DEV_PREAD                     36</span>

<span class="cm">/** hv_dev_pwrite */</span>
<span class="cp">#define HV_DISPATCH_DEV_PWRITE                    37</span>

<span class="cm">/** hv_dev_poll */</span>
<span class="cp">#define HV_DISPATCH_DEV_POLL                      38</span>

<span class="cm">/** hv_dev_poll_cancel */</span>
<span class="cp">#define HV_DISPATCH_DEV_POLL_CANCEL               39</span>

<span class="cm">/** hv_dev_preada */</span>
<span class="cp">#define HV_DISPATCH_DEV_PREADA                    40</span>

<span class="cm">/** hv_dev_pwritea */</span>
<span class="cp">#define HV_DISPATCH_DEV_PWRITEA                   41</span>

<span class="cm">/** hv_flush_remote */</span>
<span class="cp">#define HV_DISPATCH_FLUSH_REMOTE                  42</span>

<span class="cm">/** hv_console_putc */</span>
<span class="cp">#define HV_DISPATCH_CONSOLE_PUTC                  43</span>

<span class="cm">/** hv_inquire_tiles */</span>
<span class="cp">#define HV_DISPATCH_INQUIRE_TILES                 44</span>

<span class="cm">/** hv_confstr */</span>
<span class="cp">#define HV_DISPATCH_CONFSTR                       45</span>

<span class="cm">/** hv_reexec */</span>
<span class="cp">#define HV_DISPATCH_REEXEC                        46</span>

<span class="cm">/** hv_set_command_line */</span>
<span class="cp">#define HV_DISPATCH_SET_COMMAND_LINE              47</span>

<span class="cp">#if !CHIP_HAS_IPI()</span>

<span class="cm">/** hv_clear_intr */</span>
<span class="cp">#define HV_DISPATCH_CLEAR_INTR                    48</span>

<span class="cm">/** hv_enable_intr */</span>
<span class="cp">#define HV_DISPATCH_ENABLE_INTR                   49</span>

<span class="cm">/** hv_disable_intr */</span>
<span class="cp">#define HV_DISPATCH_DISABLE_INTR                  50</span>

<span class="cm">/** hv_raise_intr */</span>
<span class="cp">#define HV_DISPATCH_RAISE_INTR                    51</span>

<span class="cm">/** hv_trigger_ipi */</span>
<span class="cp">#define HV_DISPATCH_TRIGGER_IPI                   52</span>

<span class="cp">#endif </span><span class="cm">/* !CHIP_HAS_IPI() */</span><span class="cp"></span>

<span class="cm">/** hv_store_mapping */</span>
<span class="cp">#define HV_DISPATCH_STORE_MAPPING                 53</span>

<span class="cm">/** hv_inquire_realpa */</span>
<span class="cp">#define HV_DISPATCH_INQUIRE_REALPA                54</span>

<span class="cm">/** hv_flush_all */</span>
<span class="cp">#define HV_DISPATCH_FLUSH_ALL                     55</span>

<span class="cp">#if CHIP_HAS_IPI()</span>
<span class="cm">/** hv_get_ipi_pte */</span>
<span class="cp">#define HV_DISPATCH_GET_IPI_PTE                   56</span>
<span class="cp">#endif</span>

<span class="cm">/** hv_set_pte_super_shift */</span>
<span class="cp">#define HV_DISPATCH_SET_PTE_SUPER_SHIFT           57</span>

<span class="cm">/** One more than the largest dispatch value */</span>
<span class="cp">#define _HV_DISPATCH_END                          58</span>


<span class="cp">#ifndef __ASSEMBLER__</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="k">typedef</span> <span class="n">u32</span> <span class="n">__hv32</span><span class="p">;</span>        <span class="cm">/**&lt; 32-bit value */</span>
<span class="k">typedef</span> <span class="n">u64</span> <span class="n">__hv64</span><span class="p">;</span>        <span class="cm">/**&lt; 64-bit value */</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;stdint.h&gt;</span>
<span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">__hv32</span><span class="p">;</span>   <span class="cm">/**&lt; 32-bit value */</span>
<span class="k">typedef</span> <span class="kt">uint64_t</span> <span class="n">__hv64</span><span class="p">;</span>   <span class="cm">/**&lt; 64-bit value */</span>
<span class="cp">#endif</span>


<span class="cm">/** Hypervisor physical address. */</span>
<span class="k">typedef</span> <span class="n">__hv64</span> <span class="n">HV_PhysAddr</span><span class="p">;</span>

<span class="cp">#if CHIP_VA_WIDTH() &gt; 32</span>
<span class="cm">/** Hypervisor virtual address. */</span>
<span class="k">typedef</span> <span class="n">__hv64</span> <span class="n">HV_VirtAddr</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cm">/** Hypervisor virtual address. */</span>
<span class="k">typedef</span> <span class="n">__hv32</span> <span class="n">HV_VirtAddr</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CHIP_VA_WIDTH() &gt; 32 */</span><span class="cp"></span>

<span class="cm">/** Hypervisor ASID. */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">HV_ASID</span><span class="p">;</span>

<span class="cm">/** Hypervisor tile location for a memory access</span>
<span class="cm"> * (&quot;location overridden target&quot;).</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">HV_LOTAR</span><span class="p">;</span>

<span class="cm">/** Hypervisor size of a page. */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">HV_PageSize</span><span class="p">;</span>

<span class="cm">/** A page table entry.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="n">__hv64</span> <span class="n">val</span><span class="p">;</span>                <span class="cm">/**&lt; Value of PTE */</span>
<span class="p">}</span> <span class="n">HV_PTE</span><span class="p">;</span>

<span class="cm">/** Hypervisor error code. */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">HV_Errno</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLER__ */</span><span class="cp"></span>

<span class="cp">#define HV_OK           0    </span><span class="cm">/**&lt; No error */</span><span class="cp"></span>
<span class="cp">#define HV_EINVAL      -801  </span><span class="cm">/**&lt; Invalid argument */</span><span class="cp"></span>
<span class="cp">#define HV_ENODEV      -802  </span><span class="cm">/**&lt; No such device */</span><span class="cp"></span>
<span class="cp">#define HV_ENOENT      -803  </span><span class="cm">/**&lt; No such file or directory */</span><span class="cp"></span>
<span class="cp">#define HV_EBADF       -804  </span><span class="cm">/**&lt; Bad file number */</span><span class="cp"></span>
<span class="cp">#define HV_EFAULT      -805  </span><span class="cm">/**&lt; Bad address */</span><span class="cp"></span>
<span class="cp">#define HV_ERECIP      -806  </span><span class="cm">/**&lt; Bad recipients */</span><span class="cp"></span>
<span class="cp">#define HV_E2BIG       -807  </span><span class="cm">/**&lt; Message too big */</span><span class="cp"></span>
<span class="cp">#define HV_ENOTSUP     -808  </span><span class="cm">/**&lt; Service not supported */</span><span class="cp"></span>
<span class="cp">#define HV_EBUSY       -809  </span><span class="cm">/**&lt; Device busy */</span><span class="cp"></span>
<span class="cp">#define HV_ENOSYS      -810  </span><span class="cm">/**&lt; Invalid syscall */</span><span class="cp"></span>
<span class="cp">#define HV_EPERM       -811  </span><span class="cm">/**&lt; No permission */</span><span class="cp"></span>
<span class="cp">#define HV_ENOTREADY   -812  </span><span class="cm">/**&lt; Device not ready */</span><span class="cp"></span>
<span class="cp">#define HV_EIO         -813  </span><span class="cm">/**&lt; I/O error */</span><span class="cp"></span>
<span class="cp">#define HV_ENOMEM      -814  </span><span class="cm">/**&lt; Out of memory */</span><span class="cp"></span>
<span class="cp">#define HV_EAGAIN      -815  </span><span class="cm">/**&lt; Try again */</span><span class="cp"></span>

<span class="cp">#define HV_ERR_MAX     -801  </span><span class="cm">/**&lt; Largest HV error code */</span><span class="cp"></span>
<span class="cp">#define HV_ERR_MIN     -815  </span><span class="cm">/**&lt; Smallest HV error code */</span><span class="cp"></span>

<span class="cp">#ifndef __ASSEMBLER__</span>

<span class="cm">/** Pass HV_VERSION to hv_init to request this version of the interface. */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">HV_VERSION</span> <span class="o">=</span> <span class="n">_HV_VERSION</span> <span class="p">}</span> <span class="n">HV_VersionNumber</span><span class="p">;</span>

<span class="cm">/** Initializes the hypervisor.</span>
<span class="cm"> *</span>
<span class="cm"> * @param interface_version_number The version of the hypervisor interface</span>
<span class="cm"> * that this program expects, typically HV_VERSION.</span>
<span class="cm"> * @param chip_num Architecture number of the chip the client was built for.</span>
<span class="cm"> * @param chip_rev_num Revision number of the chip the client was built for.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">hv_init</span><span class="p">(</span><span class="n">HV_VersionNumber</span> <span class="n">interface_version_number</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">chip_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chip_rev_num</span><span class="p">);</span>


<span class="cm">/** Queries we can make for hv_sysconf().</span>
<span class="cm"> *</span>
<span class="cm"> * These numbers are part of the binary API and guaranteed not to change.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/** An invalid value; do not use. */</span>
  <span class="n">_HV_SYSCONF_RESERVED</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

  <span class="cm">/** The length of the glue section containing the hv_ procs, in bytes. */</span>
  <span class="n">HV_SYSCONF_GLUE_SIZE</span>       <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

  <span class="cm">/** The size of small pages, in bytes. */</span>
  <span class="n">HV_SYSCONF_PAGE_SIZE_SMALL</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>

  <span class="cm">/** The size of large pages, in bytes. */</span>
  <span class="n">HV_SYSCONF_PAGE_SIZE_LARGE</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>

  <span class="cm">/** Processor clock speed, in hertz. */</span>
  <span class="n">HV_SYSCONF_CPU_SPEED</span>       <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>

  <span class="cm">/** Processor temperature, in degrees Kelvin.  The value</span>
<span class="cm">   *  HV_SYSCONF_TEMP_KTOC may be subtracted from this to get degrees</span>
<span class="cm">   *  Celsius.  If that Celsius value is HV_SYSCONF_OVERTEMP, this indicates</span>
<span class="cm">   *  that the temperature has hit an upper limit and is no longer being</span>
<span class="cm">   *  accurately tracked.</span>
<span class="cm">   */</span>
  <span class="n">HV_SYSCONF_CPU_TEMP</span>        <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>

  <span class="cm">/** Board temperature, in degrees Kelvin.  The value</span>
<span class="cm">   *  HV_SYSCONF_TEMP_KTOC may be subtracted from this to get degrees</span>
<span class="cm">   *  Celsius.  If that Celsius value is HV_SYSCONF_OVERTEMP, this indicates</span>
<span class="cm">   *  that the temperature has hit an upper limit and is no longer being</span>
<span class="cm">   *  accurately tracked.</span>
<span class="cm">   */</span>
  <span class="n">HV_SYSCONF_BOARD_TEMP</span>      <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>

  <span class="cm">/** Legal page size bitmask for hv_install_context().</span>
<span class="cm">   * For example, if 16KB and 64KB small pages are supported,</span>
<span class="cm">   * it would return &quot;HV_CTX_PG_SM_16K | HV_CTX_PG_SM_64K&quot;.</span>
<span class="cm">   */</span>
  <span class="n">HV_SYSCONF_VALID_PAGE_SIZES</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>

  <span class="cm">/** The size of jumbo pages, in bytes.</span>
<span class="cm">   * If no jumbo pages are available, zero will be returned.</span>
<span class="cm">   */</span>
  <span class="n">HV_SYSCONF_PAGE_SIZE_JUMBO</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>

<span class="p">}</span> <span class="n">HV_SysconfQuery</span><span class="p">;</span>

<span class="cm">/** Offset to subtract from returned Kelvin temperature to get degrees</span>
<span class="cm">    Celsius. */</span>
<span class="cp">#define HV_SYSCONF_TEMP_KTOC 273</span>

<span class="cm">/** Pseudo-temperature value indicating that the temperature has</span>
<span class="cm"> *  pegged at its upper limit and is no longer accurate; note that this is</span>
<span class="cm"> *  the value after subtracting HV_SYSCONF_TEMP_KTOC. */</span>
<span class="cp">#define HV_SYSCONF_OVERTEMP 999</span>

<span class="cm">/** Query a configuration value from the hypervisor.</span>
<span class="cm"> * @param query Which value is requested (HV_SYSCONF_xxx).</span>
<span class="cm"> * @return The requested value, or -1 the requested value is illegal or</span>
<span class="cm"> *         unavailable.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">hv_sysconf</span><span class="p">(</span><span class="n">HV_SysconfQuery</span> <span class="n">query</span><span class="p">);</span>


<span class="cm">/** Queries we can make for hv_confstr().</span>
<span class="cm"> *</span>
<span class="cm"> * These numbers are part of the binary API and guaranteed not to change.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/** An invalid value; do not use. */</span>
  <span class="n">_HV_CONFSTR_RESERVED</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

  <span class="cm">/** Board part number. */</span>
  <span class="n">HV_CONFSTR_BOARD_PART_NUM</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

  <span class="cm">/** Board serial number. */</span>
  <span class="n">HV_CONFSTR_BOARD_SERIAL_NUM</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>

  <span class="cm">/** Chip serial number. */</span>
  <span class="n">HV_CONFSTR_CHIP_SERIAL_NUM</span>  <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>

  <span class="cm">/** Board revision level. */</span>
  <span class="n">HV_CONFSTR_BOARD_REV</span>        <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>

  <span class="cm">/** Hypervisor software version. */</span>
  <span class="n">HV_CONFSTR_HV_SW_VER</span>        <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>

  <span class="cm">/** The name for this chip model. */</span>
  <span class="n">HV_CONFSTR_CHIP_MODEL</span>       <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>

  <span class="cm">/** Human-readable board description. */</span>
  <span class="n">HV_CONFSTR_BOARD_DESC</span>       <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>

  <span class="cm">/** Human-readable description of the hypervisor configuration. */</span>
  <span class="n">HV_CONFSTR_HV_CONFIG</span>        <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>

  <span class="cm">/** Human-readable version string for the boot image (for instance,</span>
<span class="cm">   *  who built it and when, what configuration file was used). */</span>
  <span class="n">HV_CONFSTR_HV_CONFIG_VER</span>    <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>

  <span class="cm">/** Mezzanine part number. */</span>
  <span class="n">HV_CONFSTR_MEZZ_PART_NUM</span>   <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>

  <span class="cm">/** Mezzanine serial number. */</span>
  <span class="n">HV_CONFSTR_MEZZ_SERIAL_NUM</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>

  <span class="cm">/** Mezzanine revision level. */</span>
  <span class="n">HV_CONFSTR_MEZZ_REV</span>        <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>

  <span class="cm">/** Human-readable mezzanine description. */</span>
  <span class="n">HV_CONFSTR_MEZZ_DESC</span>       <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>

  <span class="cm">/** Control path for the onboard network switch. */</span>
  <span class="n">HV_CONFSTR_SWITCH_CONTROL</span>  <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>

  <span class="cm">/** Chip revision level. */</span>
  <span class="n">HV_CONFSTR_CHIP_REV</span>        <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>

  <span class="cm">/** CPU module part number. */</span>
  <span class="n">HV_CONFSTR_CPUMOD_PART_NUM</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>

  <span class="cm">/** CPU module serial number. */</span>
  <span class="n">HV_CONFSTR_CPUMOD_SERIAL_NUM</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>

  <span class="cm">/** CPU module revision level. */</span>
  <span class="n">HV_CONFSTR_CPUMOD_REV</span>      <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>

  <span class="cm">/** Human-readable CPU module description. */</span>
  <span class="n">HV_CONFSTR_CPUMOD_DESC</span>     <span class="o">=</span> <span class="mi">19</span>

<span class="p">}</span> <span class="n">HV_ConfstrQuery</span><span class="p">;</span>

<span class="cm">/** Query a configuration string from the hypervisor.</span>
<span class="cm"> *</span>
<span class="cm"> * @param query Identifier for the specific string to be retrieved</span>
<span class="cm"> *        (HV_CONFSTR_xxx).</span>
<span class="cm"> * @param buf Buffer in which to place the string.</span>
<span class="cm"> * @param len Length of the buffer.</span>
<span class="cm"> * @return If query is valid, then the length of the corresponding string,</span>
<span class="cm"> *        including the trailing null; if this is greater than len, the string</span>
<span class="cm"> *        was truncated.  If query is invalid, HV_EINVAL.  If the specified</span>
<span class="cm"> *        buffer is not writable by the client, HV_EFAULT.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_confstr</span><span class="p">(</span><span class="n">HV_ConfstrQuery</span> <span class="n">query</span><span class="p">,</span> <span class="n">HV_VirtAddr</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/** Tile coordinate */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
<span class="cp">#ifndef __BIG_ENDIAN__</span>
  <span class="cm">/** X coordinate, relative to supervisor&#39;s top-left coordinate */</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>

  <span class="cm">/** Y coordinate, relative to supervisor&#39;s top-left coordinate */</span>
  <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="cp">#else</span>
  <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span> <span class="n">HV_Coord</span><span class="p">;</span>


<span class="cp">#if CHIP_HAS_IPI()</span>

<span class="cm">/** Get the PTE for sending an IPI to a particular tile.</span>
<span class="cm"> *</span>
<span class="cm"> * @param tile Tile which will receive the IPI.</span>
<span class="cm"> * @param pl Indicates which IPI registers: 0 = IPI_0, 1 = IPI_1.</span>
<span class="cm"> * @param pte Filled with resulting PTE.</span>
<span class="cm"> * @result Zero if no error, non-zero for invalid parameters.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_get_ipi_pte</span><span class="p">(</span><span class="n">HV_Coord</span> <span class="n">tile</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pl</span><span class="p">,</span> <span class="n">HV_PTE</span><span class="o">*</span> <span class="n">pte</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* !CHIP_HAS_IPI() */</span><span class="cp"></span>

<span class="cm">/** A set of interrupts. */</span>
<span class="k">typedef</span> <span class="n">__hv32</span> <span class="n">HV_IntrMask</span><span class="p">;</span>

<span class="cm">/** The low interrupt numbers are reserved for use by the client in</span>
<span class="cm"> *  delivering IPIs.  Any interrupt numbers higher than this value are</span>
<span class="cm"> *  reserved for use by HV device drivers. */</span>
<span class="cp">#define HV_MAX_IPI_INTERRUPT 7</span>

<span class="cm">/** Enable a set of device interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * @param enab_mask Bitmap of interrupts to enable.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">hv_enable_intr</span><span class="p">(</span><span class="n">HV_IntrMask</span> <span class="n">enab_mask</span><span class="p">);</span>

<span class="cm">/** Disable a set of device interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * @param disab_mask Bitmap of interrupts to disable.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">hv_disable_intr</span><span class="p">(</span><span class="n">HV_IntrMask</span> <span class="n">disab_mask</span><span class="p">);</span>

<span class="cm">/** Clear a set of device interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * @param clear_mask Bitmap of interrupts to clear.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">hv_clear_intr</span><span class="p">(</span><span class="n">HV_IntrMask</span> <span class="n">clear_mask</span><span class="p">);</span>

<span class="cm">/** Raise a set of device interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * @param raise_mask Bitmap of interrupts to raise.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">hv_raise_intr</span><span class="p">(</span><span class="n">HV_IntrMask</span> <span class="n">raise_mask</span><span class="p">);</span>

<span class="cm">/** Trigger a one-shot interrupt on some tile</span>
<span class="cm"> *</span>
<span class="cm"> * @param tile Which tile to interrupt.</span>
<span class="cm"> * @param interrupt Interrupt number to trigger; must be between 0 and</span>
<span class="cm"> *        HV_MAX_IPI_INTERRUPT.</span>
<span class="cm"> * @return HV_OK on success, or a hypervisor error code.</span>
<span class="cm"> */</span>
<span class="n">HV_Errno</span> <span class="n">hv_trigger_ipi</span><span class="p">(</span><span class="n">HV_Coord</span> <span class="n">tile</span><span class="p">,</span> <span class="kt">int</span> <span class="n">interrupt</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* !CHIP_HAS_IPI() */</span><span class="cp"></span>

<span class="cm">/** Store memory mapping in debug memory so that external debugger can read it.</span>
<span class="cm"> * A maximum of 16 entries can be stored.</span>
<span class="cm"> *</span>
<span class="cm"> * @param va VA of memory that is mapped.</span>
<span class="cm"> * @param len Length of mapped memory.</span>
<span class="cm"> * @param pa PA of memory that is mapped.</span>
<span class="cm"> * @return 0 on success, -1 if the maximum number of mappings is exceeded.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_store_mapping</span><span class="p">(</span><span class="n">HV_VirtAddr</span> <span class="n">va</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">HV_PhysAddr</span> <span class="n">pa</span><span class="p">);</span>

<span class="cm">/** Given a client PA and a length, return its real (HV) PA.</span>
<span class="cm"> *</span>
<span class="cm"> * @param cpa Client physical address.</span>
<span class="cm"> * @param len Length of mapped memory.</span>
<span class="cm"> * @return physical address, or -1 if cpa or len is not valid.</span>
<span class="cm"> */</span>
<span class="n">HV_PhysAddr</span> <span class="n">hv_inquire_realpa</span><span class="p">(</span><span class="n">HV_PhysAddr</span> <span class="n">cpa</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/** RTC return flag for no RTC chip present.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_RTC_NO_CHIP     0x1</span>

<span class="cm">/** RTC return flag for low-voltage condition, indicating that battery had</span>
<span class="cm"> * died and time read is unreliable.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_RTC_LOW_VOLTAGE 0x2</span>

<span class="cm">/** Date/Time of day */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cp">#if CHIP_WORD_SIZE() &gt; 32</span>
  <span class="n">__hv64</span> <span class="n">tm_sec</span><span class="p">;</span>   <span class="cm">/**&lt; Seconds, 0-59 */</span>
  <span class="n">__hv64</span> <span class="n">tm_min</span><span class="p">;</span>   <span class="cm">/**&lt; Minutes, 0-59 */</span>
  <span class="n">__hv64</span> <span class="n">tm_hour</span><span class="p">;</span>  <span class="cm">/**&lt; Hours, 0-23 */</span>
  <span class="n">__hv64</span> <span class="n">tm_mday</span><span class="p">;</span>  <span class="cm">/**&lt; Day of month, 0-30 */</span>
  <span class="n">__hv64</span> <span class="n">tm_mon</span><span class="p">;</span>   <span class="cm">/**&lt; Month, 0-11 */</span>
  <span class="n">__hv64</span> <span class="n">tm_year</span><span class="p">;</span>  <span class="cm">/**&lt; Years since 1900, 0-199 */</span>
  <span class="n">__hv64</span> <span class="n">flags</span><span class="p">;</span>    <span class="cm">/**&lt; Return flags, 0 if no error */</span>
<span class="cp">#else</span>
  <span class="n">__hv32</span> <span class="n">tm_sec</span><span class="p">;</span>   <span class="cm">/**&lt; Seconds, 0-59 */</span>
  <span class="n">__hv32</span> <span class="n">tm_min</span><span class="p">;</span>   <span class="cm">/**&lt; Minutes, 0-59 */</span>
  <span class="n">__hv32</span> <span class="n">tm_hour</span><span class="p">;</span>  <span class="cm">/**&lt; Hours, 0-23 */</span>
  <span class="n">__hv32</span> <span class="n">tm_mday</span><span class="p">;</span>  <span class="cm">/**&lt; Day of month, 0-30 */</span>
  <span class="n">__hv32</span> <span class="n">tm_mon</span><span class="p">;</span>   <span class="cm">/**&lt; Month, 0-11 */</span>
  <span class="n">__hv32</span> <span class="n">tm_year</span><span class="p">;</span>  <span class="cm">/**&lt; Years since 1900, 0-199 */</span>
  <span class="n">__hv32</span> <span class="n">flags</span><span class="p">;</span>    <span class="cm">/**&lt; Return flags, 0 if no error */</span>
<span class="cp">#endif</span>
<span class="p">}</span> <span class="n">HV_RTCTime</span><span class="p">;</span>

<span class="cm">/** Read the current time-of-day clock.</span>
<span class="cm"> * @return HV_RTCTime of current time (GMT).</span>
<span class="cm"> */</span>
<span class="n">HV_RTCTime</span> <span class="n">hv_get_rtc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cm">/** Set the current time-of-day clock.</span>
<span class="cm"> * @param time time to reset time-of-day to (GMT).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">hv_set_rtc</span><span class="p">(</span><span class="n">HV_RTCTime</span> <span class="n">time</span><span class="p">);</span>

<span class="cm">/** Installs a context, comprising a page table and other attributes.</span>
<span class="cm"> *</span>
<span class="cm"> *  Once this service completes, page_table will be used to translate</span>
<span class="cm"> *  subsequent virtual address references to physical memory.</span>
<span class="cm"> *</span>
<span class="cm"> *  Installing a context does not cause an implicit TLB flush.  Before</span>
<span class="cm"> *  reusing an ASID value for a different address space, the client is</span>
<span class="cm"> *  expected to flush old references from the TLB with hv_flush_asid().</span>
<span class="cm"> *  (Alternately, hv_flush_all() may be used to flush many ASIDs at once.)</span>
<span class="cm"> *  After invalidating a page table entry, changing its attributes, or</span>
<span class="cm"> *  changing its target CPA, the client is expected to flush old references</span>
<span class="cm"> *  from the TLB with hv_flush_page() or hv_flush_pages(). Making a</span>
<span class="cm"> *  previously invalid page valid does not require a flush.</span>
<span class="cm"> *</span>
<span class="cm"> *  Specifying an invalid ASID, or an invalid CPA (client physical address)</span>
<span class="cm"> *  (either as page_table_pointer, or within the referenced table),</span>
<span class="cm"> *  or another page table data item documented as above as illegal may</span>
<span class="cm"> *  lead to client termination; since the validation of the table is</span>
<span class="cm"> *  done as needed, this may happen before the service returns, or at</span>
<span class="cm"> *  some later time, or never, depending upon the client&#39;s pattern of</span>
<span class="cm"> *  memory references.  Page table entries which supply translations for</span>
<span class="cm"> *  invalid virtual addresses may result in client termination, or may</span>
<span class="cm"> *  be silently ignored.  &quot;Invalid&quot; in this context means a value which</span>
<span class="cm"> *  was not provided to the client via the appropriate hv_inquire_* routine.</span>
<span class="cm"> *</span>
<span class="cm"> *  To support changing the instruction VAs at the same time as</span>
<span class="cm"> *  installing the new page table, this call explicitly supports</span>
<span class="cm"> *  setting the &quot;lr&quot; register to a different address and then jumping</span>
<span class="cm"> *  directly to the hv_install_context() routine.  In this case, the</span>
<span class="cm"> *  new page table does not need to contain any mapping for the</span>
<span class="cm"> *  hv_install_context address itself.</span>
<span class="cm"> *</span>
<span class="cm"> *  At most one HV_CTX_PG_SM_* flag may be specified in &quot;flags&quot;;</span>
<span class="cm"> *  if multiple flags are specified, HV_EINVAL is returned.</span>
<span class="cm"> *  Specifying none of the flags results in using the default page size.</span>
<span class="cm"> *  All cores participating in a given client must request the same</span>
<span class="cm"> *  page size, or the results are undefined.</span>
<span class="cm"> *</span>
<span class="cm"> * @param page_table Root of the page table.</span>
<span class="cm"> * @param access PTE providing info on how to read the page table.  This</span>
<span class="cm"> *   value must be consistent between multiple tiles sharing a page table,</span>
<span class="cm"> *   and must also be consistent with any virtual mappings the client</span>
<span class="cm"> *   may be using to access the page table.</span>
<span class="cm"> * @param asid HV_ASID the page table is to be used for.</span>
<span class="cm"> * @param flags Context flags, denoting attributes or privileges of the</span>
<span class="cm"> *   current context (HV_CTX_xxx).</span>
<span class="cm"> * @return Zero on success, or a hypervisor error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_install_context</span><span class="p">(</span><span class="n">HV_PhysAddr</span> <span class="n">page_table</span><span class="p">,</span> <span class="n">HV_PTE</span> <span class="n">access</span><span class="p">,</span> <span class="n">HV_ASID</span> <span class="n">asid</span><span class="p">,</span>
                       <span class="n">__hv32</span> <span class="n">flags</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLER__ */</span><span class="cp"></span>

<span class="cp">#define HV_CTX_DIRECTIO     0x1   </span><span class="cm">/**&lt; Direct I/O requests are accepted from</span>
<span class="cm">                                       PL0. */</span><span class="cp"></span>

<span class="cp">#define HV_CTX_PG_SM_4K     0x10  </span><span class="cm">/**&lt; Use 4K small pages, if available. */</span><span class="cp"></span>
<span class="cp">#define HV_CTX_PG_SM_16K    0x20  </span><span class="cm">/**&lt; Use 16K small pages, if available. */</span><span class="cp"></span>
<span class="cp">#define HV_CTX_PG_SM_64K    0x40  </span><span class="cm">/**&lt; Use 64K small pages, if available. */</span><span class="cp"></span>
<span class="cp">#define HV_CTX_PG_SM_MASK   0xf0  </span><span class="cm">/**&lt; Mask of all possible small pages. */</span><span class="cp"></span>

<span class="cp">#ifndef __ASSEMBLER__</span>


<span class="cm">/** Set the number of pages ganged together by HV_PTE_SUPER at a</span>
<span class="cm"> * particular level of the page table.</span>
<span class="cm"> *</span>
<span class="cm"> * The current TILE-Gx hardware only supports powers of four</span>
<span class="cm"> * (i.e. log2_count must be a multiple of two), and the requested</span>
<span class="cm"> * &quot;super&quot; page size must be less than the span of the next level in</span>
<span class="cm"> * the page table.  The largest size that can be requested is 64GB.</span>
<span class="cm"> *</span>
<span class="cm"> * The shift value is initially &quot;0&quot; for all page table levels,</span>
<span class="cm"> * indicating that the HV_PTE_SUPER bit is effectively ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * If you change the count from one non-zero value to another, the</span>
<span class="cm"> * hypervisor will flush the entire TLB and TSB to avoid confusion.</span>
<span class="cm"> *</span>
<span class="cm"> * @param level Page table level (0, 1, or 2)</span>
<span class="cm"> * @param log2_count Base-2 log of the number of pages to gang together,</span>
<span class="cm"> * i.e. how much to shift left the base page size for the super page size.</span>
<span class="cm"> * @return Zero on success, or a hypervisor error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_set_pte_super_shift</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">log2_count</span><span class="p">);</span>


<span class="cm">/** Value returned from hv_inquire_context(). */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="cm">/** Physical address of page table */</span>
  <span class="n">HV_PhysAddr</span> <span class="n">page_table</span><span class="p">;</span>

  <span class="cm">/** PTE which defines access method for top of page table */</span>
  <span class="n">HV_PTE</span> <span class="n">access</span><span class="p">;</span>

  <span class="cm">/** ASID associated with this page table */</span>
  <span class="n">HV_ASID</span> <span class="n">asid</span><span class="p">;</span>

  <span class="cm">/** Context flags */</span>
  <span class="n">__hv32</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">HV_Context</span><span class="p">;</span>

<span class="cm">/** Retrieve information about the currently installed context.</span>
<span class="cm"> * @return The data passed to the last successful hv_install_context call.</span>
<span class="cm"> */</span>
<span class="n">HV_Context</span> <span class="n">hv_inquire_context</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cm">/** Flushes all translations associated with the named address space</span>
<span class="cm"> *  identifier from the TLB and any other hypervisor data structures.</span>
<span class="cm"> *  Translations installed with the &quot;global&quot; bit are not flushed.</span>
<span class="cm"> *</span>
<span class="cm"> *  Specifying an invalid ASID may lead to client termination.  &quot;Invalid&quot;</span>
<span class="cm"> *  in this context means a value which was not provided to the client</span>
<span class="cm"> *  via &lt;tt&gt;hv_inquire_asid()&lt;/tt&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * @param asid HV_ASID whose entries are to be flushed.</span>
<span class="cm"> * @return Zero on success, or a hypervisor error code on failure.</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="n">hv_flush_asid</span><span class="p">(</span><span class="n">HV_ASID</span> <span class="n">asid</span><span class="p">);</span>


<span class="cm">/** Flushes all translations associated with the named virtual address</span>
<span class="cm"> *  and page size from the TLB and other hypervisor data structures. Only</span>
<span class="cm"> *  pages visible to the current ASID are affected; note that this includes</span>
<span class="cm"> *  global pages in addition to pages specific to the current ASID.</span>
<span class="cm"> *</span>
<span class="cm"> *  The supplied VA need not be aligned; it may be anywhere in the</span>
<span class="cm"> *  subject page.</span>
<span class="cm"> *</span>
<span class="cm"> *  Specifying an invalid virtual address may lead to client termination,</span>
<span class="cm"> *  or may silently succeed.  &quot;Invalid&quot; in this context means a value</span>
<span class="cm"> *  which was not provided to the client via hv_inquire_virtual.</span>
<span class="cm"> *</span>
<span class="cm"> * @param address Address of the page to flush.</span>
<span class="cm"> * @param page_size Size of pages to assume.</span>
<span class="cm"> * @return Zero on success, or a hypervisor error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_flush_page</span><span class="p">(</span><span class="n">HV_VirtAddr</span> <span class="n">address</span><span class="p">,</span> <span class="n">HV_PageSize</span> <span class="n">page_size</span><span class="p">);</span>


<span class="cm">/** Flushes all translations associated with the named virtual address range</span>
<span class="cm"> *  and page size from the TLB and other hypervisor data structures. Only</span>
<span class="cm"> *  pages visible to the current ASID are affected; note that this includes</span>
<span class="cm"> *  global pages in addition to pages specific to the current ASID.</span>
<span class="cm"> *</span>
<span class="cm"> *  The supplied VA need not be aligned; it may be anywhere in the</span>
<span class="cm"> *  subject page.</span>
<span class="cm"> *</span>
<span class="cm"> *  Specifying an invalid virtual address may lead to client termination,</span>
<span class="cm"> *  or may silently succeed.  &quot;Invalid&quot; in this context means a value</span>
<span class="cm"> *  which was not provided to the client via hv_inquire_virtual.</span>
<span class="cm"> *</span>
<span class="cm"> * @param start Address to flush.</span>
<span class="cm"> * @param page_size Size of pages to assume.</span>
<span class="cm"> * @param size The number of bytes to flush. Any page in the range</span>
<span class="cm"> *        [start, start + size) will be flushed from the TLB.</span>
<span class="cm"> * @return Zero on success, or a hypervisor error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_flush_pages</span><span class="p">(</span><span class="n">HV_VirtAddr</span> <span class="n">start</span><span class="p">,</span> <span class="n">HV_PageSize</span> <span class="n">page_size</span><span class="p">,</span>
                   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>


<span class="cm">/** Flushes all non-global translations (if preserve_global is true),</span>
<span class="cm"> *  or absolutely all translations (if preserve_global is false).</span>
<span class="cm"> *</span>
<span class="cm"> * @param preserve_global Non-zero if we want to preserve &quot;global&quot; mappings.</span>
<span class="cm"> * @return Zero on success, or a hypervisor error code on failure.</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="n">hv_flush_all</span><span class="p">(</span><span class="kt">int</span> <span class="n">preserve_global</span><span class="p">);</span>


<span class="cm">/** Restart machine with optional restart command and optional args.</span>
<span class="cm"> * @param cmd Const pointer to command to restart with, or NULL</span>
<span class="cm"> * @param args Const pointer to argument string to restart with, or NULL</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">hv_restart</span><span class="p">(</span><span class="n">HV_VirtAddr</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">HV_VirtAddr</span> <span class="n">args</span><span class="p">);</span>


<span class="cm">/** Halt machine. */</span>
<span class="kt">void</span> <span class="n">hv_halt</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cm">/** Power off machine. */</span>
<span class="kt">void</span> <span class="n">hv_power_off</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cm">/** Re-enter virtual-is-physical memory translation mode and restart</span>
<span class="cm"> *  execution at a given address.</span>
<span class="cm"> * @param entry Client physical address at which to begin execution.</span>
<span class="cm"> * @return A hypervisor error code on failure; if the operation is</span>
<span class="cm"> *         successful the call does not return.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_reexec</span><span class="p">(</span><span class="n">HV_PhysAddr</span> <span class="n">entry</span><span class="p">);</span>


<span class="cm">/** Chip topology */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="cm">/** Relative coordinates of the querying tile */</span>
  <span class="n">HV_Coord</span> <span class="n">coord</span><span class="p">;</span>

  <span class="cm">/** Width of the querying supervisor&#39;s tile rectangle. */</span>
  <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>

  <span class="cm">/** Height of the querying supervisor&#39;s tile rectangle. */</span>
  <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>

<span class="p">}</span> <span class="n">HV_Topology</span><span class="p">;</span>

<span class="cm">/** Returns information about the tile coordinate system.</span>
<span class="cm"> *</span>
<span class="cm"> * Each supervisor is given a rectangle of tiles it potentially controls.</span>
<span class="cm"> * These tiles are labeled using a relative coordinate system with (0,0) as</span>
<span class="cm"> * the upper left tile regardless of their physical location on the chip.</span>
<span class="cm"> *</span>
<span class="cm"> * This call returns both the size of that rectangle and the position</span>
<span class="cm"> * within that rectangle of the querying tile.</span>
<span class="cm"> *</span>
<span class="cm"> * Not all tiles within that rectangle may be available to the supervisor;</span>
<span class="cm"> * to get the precise set of available tiles, you must also call</span>
<span class="cm"> * hv_inquire_tiles(HV_INQ_TILES_AVAIL, ...).</span>
<span class="cm"> **/</span>
<span class="n">HV_Topology</span> <span class="n">hv_inquire_topology</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/** Sets of tiles we can retrieve with hv_inquire_tiles().</span>
<span class="cm"> *</span>
<span class="cm"> * These numbers are part of the binary API and guaranteed not to change.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/** An invalid value; do not use. */</span>
  <span class="n">_HV_INQ_TILES_RESERVED</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

  <span class="cm">/** All available tiles within the supervisor&#39;s tile rectangle. */</span>
  <span class="n">HV_INQ_TILES_AVAIL</span>           <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

  <span class="cm">/** The set of tiles used for hash-for-home caching. */</span>
  <span class="n">HV_INQ_TILES_HFH_CACHE</span>       <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>

  <span class="cm">/** The set of tiles that can be legally used as a LOTAR for a PTE. */</span>
  <span class="n">HV_INQ_TILES_LOTAR</span>           <span class="o">=</span> <span class="mi">3</span>
<span class="p">}</span> <span class="n">HV_InqTileSet</span><span class="p">;</span>

<span class="cm">/** Returns specific information about various sets of tiles within the</span>
<span class="cm"> *  supervisor&#39;s tile rectangle.</span>
<span class="cm"> *</span>
<span class="cm"> * @param set Which set of tiles to retrieve.</span>
<span class="cm"> * @param cpumask Pointer to a returned bitmask (in row-major order,</span>
<span class="cm"> *        supervisor-relative) of tiles.  The low bit of the first word</span>
<span class="cm"> *        corresponds to the tile at the upper left-hand corner of the</span>
<span class="cm"> *        supervisor&#39;s rectangle.  In order for the supervisor to know the</span>
<span class="cm"> *        buffer length to supply, it should first call hv_inquire_topology.</span>
<span class="cm"> * @param length Number of bytes available for the returned bitmask.</span>
<span class="cm"> **/</span>
<span class="n">HV_Errno</span> <span class="n">hv_inquire_tiles</span><span class="p">(</span><span class="n">HV_InqTileSet</span> <span class="n">set</span><span class="p">,</span> <span class="n">HV_VirtAddr</span> <span class="n">cpumask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>


<span class="cm">/** An identifier for a memory controller. Multiple memory controllers</span>
<span class="cm"> * may be connected to one chip, and this uniquely identifies each one.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">HV_MemoryController</span><span class="p">;</span>

<span class="cm">/** A range of physical memory. */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="n">HV_PhysAddr</span> <span class="n">start</span><span class="p">;</span>   <span class="cm">/**&lt; Starting address. */</span>
  <span class="n">__hv64</span> <span class="n">size</span><span class="p">;</span>         <span class="cm">/**&lt; Size in bytes. */</span>
  <span class="n">HV_MemoryController</span> <span class="n">controller</span><span class="p">;</span>  <span class="cm">/**&lt; Which memory controller owns this. */</span>
<span class="p">}</span> <span class="n">HV_PhysAddrRange</span><span class="p">;</span>

<span class="cm">/** Returns information about a range of physical memory.</span>
<span class="cm"> *</span>
<span class="cm"> * hv_inquire_physical() returns one of the ranges of client</span>
<span class="cm"> * physical addresses which are available to this client.</span>
<span class="cm"> *</span>
<span class="cm"> * The first range is retrieved by specifying an idx of 0, and</span>
<span class="cm"> * successive ranges are returned with subsequent idx values.  Ranges</span>
<span class="cm"> * are ordered by increasing start address (i.e., as idx increases,</span>
<span class="cm"> * so does start), do not overlap, and do not touch (i.e., the</span>
<span class="cm"> * available memory is described with the fewest possible ranges).</span>
<span class="cm"> *</span>
<span class="cm"> * If an out-of-range idx value is specified, the returned size will be zero.</span>
<span class="cm"> * A client can count the number of ranges by increasing idx until the</span>
<span class="cm"> * returned size is zero. There will always be at least one valid range.</span>
<span class="cm"> *</span>
<span class="cm"> * Some clients might not be prepared to deal with more than one</span>
<span class="cm"> * physical address range; they still ought to call this routine and</span>
<span class="cm"> * issue a warning message if they&#39;re given more than one range, on the</span>
<span class="cm"> * theory that whoever configured the hypervisor to provide that memory</span>
<span class="cm"> * should know that it&#39;s being wasted.</span>
<span class="cm"> */</span>
<span class="n">HV_PhysAddrRange</span> <span class="n">hv_inquire_physical</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>

<span class="cm">/** Possible DIMM types. */</span>
<span class="k">typedef</span> <span class="k">enum</span>
<span class="p">{</span>
  <span class="n">NO_DIMM</span>                    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>  <span class="cm">/**&lt; No DIMM */</span>
  <span class="n">DDR2</span>                       <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="cm">/**&lt; DDR2 */</span>
  <span class="n">DDR3</span>                       <span class="o">=</span> <span class="mi">2</span>   <span class="cm">/**&lt; DDR3 */</span>
<span class="p">}</span> <span class="n">HV_DIMM_Type</span><span class="p">;</span>

<span class="cp">#ifdef __tilegx__</span>

<span class="cm">/** Log2 of minimum DIMM bytes supported by the memory controller. */</span>
<span class="cp">#define HV_MSH_MIN_DIMM_SIZE_SHIFT 29</span>

<span class="cm">/** Max number of DIMMs contained by one memory controller. */</span>
<span class="cp">#define HV_MSH_MAX_DIMMS 8</span>

<span class="cp">#else</span>

<span class="cm">/** Log2 of minimum DIMM bytes supported by the memory controller. */</span>
<span class="cp">#define HV_MSH_MIN_DIMM_SIZE_SHIFT 26</span>

<span class="cm">/** Max number of DIMMs contained by one memory controller. */</span>
<span class="cp">#define HV_MSH_MAX_DIMMS 2</span>

<span class="cp">#endif</span>

<span class="cm">/** Number of bits to right-shift to get the DIMM type. */</span>
<span class="cp">#define HV_DIMM_TYPE_SHIFT 0</span>

<span class="cm">/** Bits to mask to get the DIMM type. */</span>
<span class="cp">#define HV_DIMM_TYPE_MASK 0xf</span>

<span class="cm">/** Number of bits to right-shift to get the DIMM size. */</span>
<span class="cp">#define HV_DIMM_SIZE_SHIFT 4</span>

<span class="cm">/** Bits to mask to get the DIMM size. */</span>
<span class="cp">#define HV_DIMM_SIZE_MASK 0xf</span>

<span class="cm">/** Memory controller information. */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="n">HV_Coord</span> <span class="n">coord</span><span class="p">;</span>   <span class="cm">/**&lt; Relative tile coordinates of the port used by a</span>
<span class="cm">                         specified tile to communicate with this controller. */</span>
  <span class="n">__hv64</span> <span class="n">speed</span><span class="p">;</span>     <span class="cm">/**&lt; Speed of this controller in bytes per second. */</span>
<span class="p">}</span> <span class="n">HV_MemoryControllerInfo</span><span class="p">;</span>

<span class="cm">/** Returns information about a particular memory controller.</span>
<span class="cm"> *</span>
<span class="cm"> *  hv_inquire_memory_controller(coord,idx) returns information about a</span>
<span class="cm"> *  particular controller.  Two pieces of information are returned:</span>
<span class="cm"> *  - The relative coordinates of the port on the controller that the specified</span>
<span class="cm"> *    tile would use to contact it.  The relative coordinates may lie</span>
<span class="cm"> *    outside the supervisor&#39;s rectangle, i.e. the controller may not</span>
<span class="cm"> *    be attached to a node managed by the querying node&#39;s supervisor.</span>
<span class="cm"> *    In particular note that x or y may be negative.</span>
<span class="cm"> *  - The speed of the memory controller.  (This is a not-to-exceed value</span>
<span class="cm"> *    based on the raw hardware data rate, and may not be achievable in</span>
<span class="cm"> *    practice; it is provided to give clients information on the relative</span>
<span class="cm"> *    performance of the available controllers.)</span>
<span class="cm"> *</span>
<span class="cm"> *  Clients should avoid calling this interface with invalid values.</span>
<span class="cm"> *  A client who does may be terminated.</span>
<span class="cm"> * @param coord Tile for which to calculate the relative port position.</span>
<span class="cm"> * @param controller Index of the controller; identical to value returned</span>
<span class="cm"> *        from other routines like hv_inquire_physical.</span>
<span class="cm"> * @return Information about the controller.</span>
<span class="cm"> */</span>
<span class="n">HV_MemoryControllerInfo</span> <span class="n">hv_inquire_memory_controller</span><span class="p">(</span><span class="n">HV_Coord</span> <span class="n">coord</span><span class="p">,</span>
                                                     <span class="kt">int</span> <span class="n">controller</span><span class="p">);</span>


<span class="cm">/** A range of virtual memory. */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="n">HV_VirtAddr</span> <span class="n">start</span><span class="p">;</span>   <span class="cm">/**&lt; Starting address. */</span>
  <span class="n">__hv64</span> <span class="n">size</span><span class="p">;</span>         <span class="cm">/**&lt; Size in bytes. */</span>
<span class="p">}</span> <span class="n">HV_VirtAddrRange</span><span class="p">;</span>

<span class="cm">/** Returns information about a range of virtual memory.</span>
<span class="cm"> *</span>
<span class="cm"> * hv_inquire_virtual() returns one of the ranges of client</span>
<span class="cm"> * virtual addresses which are available to this client.</span>
<span class="cm"> *</span>
<span class="cm"> * The first range is retrieved by specifying an idx of 0, and</span>
<span class="cm"> * successive ranges are returned with subsequent idx values.  Ranges</span>
<span class="cm"> * are ordered by increasing start address (i.e., as idx increases,</span>
<span class="cm"> * so does start), do not overlap, and do not touch (i.e., the</span>
<span class="cm"> * available memory is described with the fewest possible ranges).</span>
<span class="cm"> *</span>
<span class="cm"> * If an out-of-range idx value is specified, the returned size will be zero.</span>
<span class="cm"> * A client can count the number of ranges by increasing idx until the</span>
<span class="cm"> * returned size is zero. There will always be at least one valid range.</span>
<span class="cm"> *</span>
<span class="cm"> * Some clients may well have various virtual addresses hardwired</span>
<span class="cm"> * into themselves; for instance, their instruction stream may</span>
<span class="cm"> * have been compiled expecting to live at a particular address.</span>
<span class="cm"> * Such clients should use this interface to verify they&#39;ve been</span>
<span class="cm"> * given the virtual address space they expect, and issue a (potentially</span>
<span class="cm"> * fatal) warning message otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the returned size is a __hv64, not a __hv32, so it is</span>
<span class="cm"> * possible to express a single range spanning the entire 32-bit</span>
<span class="cm"> * address space.</span>
<span class="cm"> */</span>
<span class="n">HV_VirtAddrRange</span> <span class="n">hv_inquire_virtual</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>


<span class="cm">/** A range of ASID values. */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
<span class="cp">#ifndef __BIG_ENDIAN__</span>
  <span class="n">HV_ASID</span> <span class="n">start</span><span class="p">;</span>        <span class="cm">/**&lt; First ASID in the range. */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>    <span class="cm">/**&lt; Number of ASIDs. Zero for an invalid range. */</span>
<span class="cp">#else</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>    <span class="cm">/**&lt; Number of ASIDs. Zero for an invalid range. */</span>
  <span class="n">HV_ASID</span> <span class="n">start</span><span class="p">;</span>        <span class="cm">/**&lt; First ASID in the range. */</span>
<span class="cp">#endif</span>
<span class="p">}</span> <span class="n">HV_ASIDRange</span><span class="p">;</span>

<span class="cm">/** Returns information about a range of ASIDs.</span>
<span class="cm"> *</span>
<span class="cm"> * hv_inquire_asid() returns one of the ranges of address</span>
<span class="cm"> * space identifiers which are available to this client.</span>
<span class="cm"> *</span>
<span class="cm"> * The first range is retrieved by specifying an idx of 0, and</span>
<span class="cm"> * successive ranges are returned with subsequent idx values.  Ranges</span>
<span class="cm"> * are ordered by increasing start value (i.e., as idx increases,</span>
<span class="cm"> * so does start), do not overlap, and do not touch (i.e., the</span>
<span class="cm"> * available ASIDs are described with the fewest possible ranges).</span>
<span class="cm"> *</span>
<span class="cm"> * If an out-of-range idx value is specified, the returned size will be zero.</span>
<span class="cm"> * A client can count the number of ranges by increasing idx until the</span>
<span class="cm"> * returned size is zero. There will always be at least one valid range.</span>
<span class="cm"> */</span>
<span class="n">HV_ASIDRange</span> <span class="n">hv_inquire_asid</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>


<span class="cm">/** Waits for at least the specified number of nanoseconds then returns.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: this deprecated function currently assumes a 750 MHz clock,</span>
<span class="cm"> * and is thus not generally suitable for use.  New code should call</span>
<span class="cm"> * hv_sysconf(HV_SYSCONF_CPU_SPEED), compute a cycle count to wait for,</span>
<span class="cm"> * and delay by looping while checking the cycle counter SPR.</span>
<span class="cm"> *</span>
<span class="cm"> * @param nanosecs The number of nanoseconds to sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">hv_nanosleep</span><span class="p">(</span><span class="kt">int</span> <span class="n">nanosecs</span><span class="p">);</span>


<span class="cm">/** Reads a character from the console without blocking.</span>
<span class="cm"> *</span>
<span class="cm"> * @return A value from 0-255 indicates the value successfully read.</span>
<span class="cm"> * A negative value means no value was ready.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_console_read_if_ready</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cm">/** Writes a character to the console, blocking if the console is busy.</span>
<span class="cm"> *</span>
<span class="cm"> *  This call cannot fail. If the console is broken for some reason,</span>
<span class="cm"> *  output will simply vanish.</span>
<span class="cm"> * @param byte Character to write.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">hv_console_putc</span><span class="p">(</span><span class="kt">int</span> <span class="n">byte</span><span class="p">);</span>


<span class="cm">/** Writes a string to the console, blocking if the console is busy.</span>
<span class="cm"> * @param bytes Pointer to characters to write.</span>
<span class="cm"> * @param len Number of characters to write.</span>
<span class="cm"> * @return Number of characters written, or HV_EFAULT if the buffer is invalid.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_console_write</span><span class="p">(</span><span class="n">HV_VirtAddr</span> <span class="n">bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>


<span class="cm">/** Dispatch the next interrupt from the client downcall mechanism.</span>
<span class="cm"> *</span>
<span class="cm"> *  The hypervisor uses downcalls to notify the client of asynchronous</span>
<span class="cm"> *  events.  Some of these events are hypervisor-created (like incoming</span>
<span class="cm"> *  messages).  Some are regular interrupts which initially occur in</span>
<span class="cm"> *  the hypervisor, and are normally handled directly by the client;</span>
<span class="cm"> *  when these occur in a client&#39;s interrupt critical section, they must</span>
<span class="cm"> *  be delivered through the downcall mechanism.</span>
<span class="cm"> *</span>
<span class="cm"> *  A downcall is initially delivered to the client as an INTCTRL_CL</span>
<span class="cm"> *  interrupt, where CL is the client&#39;s PL.  Upon entry to the INTCTRL_CL</span>
<span class="cm"> *  vector, the client must immediately invoke the hv_downcall_dispatch</span>
<span class="cm"> *  service.  This service will not return; instead it will cause one of</span>
<span class="cm"> *  the client&#39;s actual downcall-handling interrupt vectors to be entered.</span>
<span class="cm"> *  The EX_CONTEXT registers in the client will be set so that when the</span>
<span class="cm"> *  client irets, it will return to the code which was interrupted by the</span>
<span class="cm"> *  INTCTRL_CL interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> *  Under some circumstances, the firing of INTCTRL_CL can race with</span>
<span class="cm"> *  the lowering of a device interrupt.  In such a case, the</span>
<span class="cm"> *  hv_downcall_dispatch service may issue an iret instruction instead</span>
<span class="cm"> *  of entering one of the client&#39;s actual downcall-handling interrupt</span>
<span class="cm"> *  vectors.  This will return execution to the location that was</span>
<span class="cm"> *  interrupted by INTCTRL_CL.</span>
<span class="cm"> *</span>
<span class="cm"> *  Any saving of registers should be done by the actual handling</span>
<span class="cm"> *  vectors; no registers should be changed by the INTCTRL_CL handler.</span>
<span class="cm"> *  In particular, the client should not use a jal instruction to invoke</span>
<span class="cm"> *  the hv_downcall_dispatch service, as that would overwrite the client&#39;s</span>
<span class="cm"> *  lr register.  Note that the hv_downcall_dispatch service may overwrite</span>
<span class="cm"> *  one or more of the client&#39;s system save registers.</span>
<span class="cm"> *</span>
<span class="cm"> *  The client must not modify the INTCTRL_CL_STATUS SPR.  The hypervisor</span>
<span class="cm"> *  will set this register to cause a downcall to happen, and will clear</span>
<span class="cm"> *  it when no further downcalls are pending.</span>
<span class="cm"> *</span>
<span class="cm"> *  When a downcall vector is entered, the INTCTRL_CL interrupt will be</span>
<span class="cm"> *  masked.  When the client is done processing a downcall, and is ready</span>
<span class="cm"> *  to accept another, it must unmask this interrupt; if more downcalls</span>
<span class="cm"> *  are pending, this will cause the INTCTRL_CL vector to be reentered.</span>
<span class="cm"> *  Currently the following interrupt vectors can be entered through a</span>
<span class="cm"> *  downcall:</span>
<span class="cm"> *</span>
<span class="cm"> *  INT_MESSAGE_RCV_DWNCL   (hypervisor message available)</span>
<span class="cm"> *  INT_DEV_INTR_DWNCL      (device interrupt)</span>
<span class="cm"> *  INT_DMATLB_MISS_DWNCL   (DMA TLB miss)</span>
<span class="cm"> *  INT_SNITLB_MISS_DWNCL   (SNI TLB miss)</span>
<span class="cm"> *  INT_DMATLB_ACCESS_DWNCL (DMA TLB access violation)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">hv_downcall_dispatch</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLER__ */</span><span class="cp"></span>

<span class="cm">/** We use actual interrupt vectors which never occur (they&#39;re only there</span>
<span class="cm"> *  to allow setting MPLs for related SPRs) for our downcall vectors.</span>
<span class="cm"> */</span>
<span class="cm">/** Message receive downcall interrupt vector */</span>
<span class="cp">#define INT_MESSAGE_RCV_DWNCL    INT_BOOT_ACCESS</span>
<span class="cm">/** DMA TLB miss downcall interrupt vector */</span>
<span class="cp">#define INT_DMATLB_MISS_DWNCL    INT_DMA_ASID</span>
<span class="cm">/** Static nework processor instruction TLB miss interrupt vector */</span>
<span class="cp">#define INT_SNITLB_MISS_DWNCL    INT_SNI_ASID</span>
<span class="cm">/** DMA TLB access violation downcall interrupt vector */</span>
<span class="cp">#define INT_DMATLB_ACCESS_DWNCL  INT_DMA_CPL</span>
<span class="cm">/** Device interrupt downcall interrupt vector */</span>
<span class="cp">#define INT_DEV_INTR_DWNCL       INT_WORLD_ACCESS</span>

<span class="cp">#ifndef __ASSEMBLER__</span>

<span class="cm">/** Requests the inode for a specific full pathname.</span>
<span class="cm"> *</span>
<span class="cm"> * Performs a lookup in the hypervisor filesystem for a given filename.</span>
<span class="cm"> * Multiple calls with the same filename will always return the same inode.</span>
<span class="cm"> * If there is no such filename, HV_ENOENT is returned.</span>
<span class="cm"> * A bad filename pointer may result in HV_EFAULT instead.</span>
<span class="cm"> *</span>
<span class="cm"> * @param filename Constant pointer to name of requested file</span>
<span class="cm"> * @return Inode of requested file</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_fs_findfile</span><span class="p">(</span><span class="n">HV_VirtAddr</span> <span class="n">filename</span><span class="p">);</span>


<span class="cm">/** Data returned from an fstat request.</span>
<span class="cm"> * Note that this structure should be no more than 40 bytes in size so</span>
<span class="cm"> * that it can always be returned completely in registers.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>             <span class="cm">/**&lt; Size of file (or HV_Errno on error) */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>   <span class="cm">/**&lt; Flags (see HV_FS_FSTAT_FLAGS) */</span>
<span class="p">}</span> <span class="n">HV_FS_StatInfo</span><span class="p">;</span>

<span class="cm">/** Bitmask flags for fstat request */</span>
<span class="k">typedef</span> <span class="k">enum</span>
<span class="p">{</span>
  <span class="n">HV_FS_ISDIR</span>    <span class="o">=</span> <span class="mh">0x0001</span>   <span class="cm">/**&lt; Is the entry a directory? */</span>
<span class="p">}</span> <span class="n">HV_FS_FSTAT_FLAGS</span><span class="p">;</span>

<span class="cm">/** Get stat information on a given file inode.</span>
<span class="cm"> *</span>
<span class="cm"> * Return information on the file with the given inode.</span>
<span class="cm"> *</span>
<span class="cm"> * IF the HV_FS_ISDIR bit is set, the &quot;file&quot; is a directory.  Reading</span>
<span class="cm"> * it will return NUL-separated filenames (no directory part) relative</span>
<span class="cm"> * to the path to the inode of the directory &quot;file&quot;.  These can be</span>
<span class="cm"> * appended to the path to the directory &quot;file&quot; after a forward slash</span>
<span class="cm"> * to create additional filenames.  Note that it is not required</span>
<span class="cm"> * that all valid paths be decomposable into valid parent directories;</span>
<span class="cm"> * a filesystem may validly have just a few files, none of which have</span>
<span class="cm"> * HV_FS_ISDIR set.  However, if clients may wish to enumerate the</span>
<span class="cm"> * files in the filesystem, it is recommended to include all the</span>
<span class="cm"> * appropriate parent directory &quot;files&quot; to give a consistent view.</span>
<span class="cm"> *</span>
<span class="cm"> * An invalid file inode will cause an HV_EBADF error to be returned.</span>
<span class="cm"> *</span>
<span class="cm"> * @param inode The inode number of the query</span>
<span class="cm"> * @return An HV_FS_StatInfo structure</span>
<span class="cm"> */</span>
<span class="n">HV_FS_StatInfo</span> <span class="n">hv_fs_fstat</span><span class="p">(</span><span class="kt">int</span> <span class="n">inode</span><span class="p">);</span>


<span class="cm">/** Read data from a specific hypervisor file.</span>
<span class="cm"> * On error, may return HV_EBADF for a bad inode or HV_EFAULT for a bad buf.</span>
<span class="cm"> * Reads near the end of the file will return fewer bytes than requested.</span>
<span class="cm"> * Reads at or beyond the end of a file will return zero.</span>
<span class="cm"> *</span>
<span class="cm"> * @param inode the hypervisor file to read</span>
<span class="cm"> * @param buf the buffer to read data into</span>
<span class="cm"> * @param length the number of bytes of data to read</span>
<span class="cm"> * @param offset the offset into the file to read the data from</span>
<span class="cm"> * @return number of bytes successfully read, or an HV_Errno code</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_fs_pread</span><span class="p">(</span><span class="kt">int</span> <span class="n">inode</span><span class="p">,</span> <span class="n">HV_VirtAddr</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">);</span>


<span class="cm">/** Read a 64-bit word from the specified physical address.</span>
<span class="cm"> * The address must be 8-byte aligned.</span>
<span class="cm"> * Specifying an invalid physical address will lead to client termination.</span>
<span class="cm"> * @param addr The physical address to read</span>
<span class="cm"> * @param access The PTE describing how to read the memory</span>
<span class="cm"> * @return The 64-bit value read from the given address</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">hv_physaddr_read64</span><span class="p">(</span><span class="n">HV_PhysAddr</span> <span class="n">addr</span><span class="p">,</span> <span class="n">HV_PTE</span> <span class="n">access</span><span class="p">);</span>


<span class="cm">/** Write a 64-bit word to the specified physical address.</span>
<span class="cm"> * The address must be 8-byte aligned.</span>
<span class="cm"> * Specifying an invalid physical address will lead to client termination.</span>
<span class="cm"> * @param addr The physical address to write</span>
<span class="cm"> * @param access The PTE that says how to write the memory</span>
<span class="cm"> * @param val The 64-bit value to write to the given address</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">hv_physaddr_write64</span><span class="p">(</span><span class="n">HV_PhysAddr</span> <span class="n">addr</span><span class="p">,</span> <span class="n">HV_PTE</span> <span class="n">access</span><span class="p">,</span>
                         <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">val</span><span class="p">);</span>


<span class="cm">/** Get the value of the command-line for the supervisor, if any.</span>
<span class="cm"> * This will not include the filename of the booted supervisor, but may</span>
<span class="cm"> * include configured-in boot arguments or the hv_restart() arguments.</span>
<span class="cm"> * If the buffer is not long enough the hypervisor will NUL the first</span>
<span class="cm"> * character of the buffer but not write any other data.</span>
<span class="cm"> * @param buf The virtual address to write the command-line string to.</span>
<span class="cm"> * @param length The length of buf, in characters.</span>
<span class="cm"> * @return The actual length of the command line, including the trailing NUL</span>
<span class="cm"> *         (may be larger than &quot;length&quot;).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_get_command_line</span><span class="p">(</span><span class="n">HV_VirtAddr</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>


<span class="cm">/** Set a new value for the command-line for the supervisor, which will</span>
<span class="cm"> *  be returned from subsequent invocations of hv_get_command_line() on</span>
<span class="cm"> *  this tile.</span>
<span class="cm"> * @param buf The virtual address to read the command-line string from.</span>
<span class="cm"> * @param length The length of buf, in characters; must be no more than</span>
<span class="cm"> *        HV_COMMAND_LINE_LEN.</span>
<span class="cm"> * @return Zero if successful, or a hypervisor error code.</span>
<span class="cm"> */</span>
<span class="n">HV_Errno</span> <span class="n">hv_set_command_line</span><span class="p">(</span><span class="n">HV_VirtAddr</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>

<span class="cm">/** Maximum size of a command line passed to hv_set_command_line(); note</span>
<span class="cm"> *  that a line returned from hv_get_command_line() could be larger than</span>
<span class="cm"> *  this.*/</span>
<span class="cp">#define HV_COMMAND_LINE_LEN  256</span>

<span class="cm">/** Tell the hypervisor how to cache non-priority pages</span>
<span class="cm"> * (its own as well as pages explicitly represented in page tables).</span>
<span class="cm"> * Normally these will be represented as red/black pages, but</span>
<span class="cm"> * when the supervisor starts to allocate &quot;priority&quot; pages in the PTE</span>
<span class="cm"> * the hypervisor will need to start marking those pages as (e.g.) &quot;red&quot;</span>
<span class="cm"> * and non-priority pages as either &quot;black&quot; (if they cache-alias</span>
<span class="cm"> * with the existing priority pages) or &quot;red/black&quot; (if they don&#39;t).</span>
<span class="cm"> * The bitmask provides information on which parts of the cache</span>
<span class="cm"> * have been used for pinned pages so far on this tile; if (1 &lt;&lt; N)</span>
<span class="cm"> * appears in the bitmask, that indicates that a 4KB region of the</span>
<span class="cm"> * cache starting at (N * 4KB) is in use by a &quot;priority&quot; page.</span>
<span class="cm"> * The portion of cache used by a particular page can be computed</span>
<span class="cm"> * by taking the page&#39;s PA, modulo CHIP_L2_CACHE_SIZE(), and setting</span>
<span class="cm"> * all the &quot;4KB&quot; bits corresponding to the actual page size.</span>
<span class="cm"> * @param bitmask A bitmap of priority page set values</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">hv_set_caching</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bitmask</span><span class="p">);</span>


<span class="cm">/** Zero out a specified number of pages.</span>
<span class="cm"> * The va and size must both be multiples of 4096.</span>
<span class="cm"> * Caches are bypassed and memory is directly set to zero.</span>
<span class="cm"> * This API is implemented only in the magic hypervisor and is intended</span>
<span class="cm"> * to provide a performance boost to the minimal supervisor by</span>
<span class="cm"> * giving it a fast way to zero memory pages when allocating them.</span>
<span class="cm"> * @param va Virtual address where the page has been mapped</span>
<span class="cm"> * @param size Number of bytes (must be a page size multiple)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">hv_bzero_page</span><span class="p">(</span><span class="n">HV_VirtAddr</span> <span class="n">va</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>


<span class="cm">/** State object for the hypervisor messaging subsystem. */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
<span class="cp">#if CHIP_VA_WIDTH() &gt; 32</span>
  <span class="n">__hv64</span> <span class="n">opaque</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/**&lt; No user-serviceable parts inside */</span>
<span class="cp">#else</span>
  <span class="n">__hv32</span> <span class="n">opaque</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/**&lt; No user-serviceable parts inside */</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">HV_MsgState</span><span class="p">;</span>

<span class="cm">/** Register to receive incoming messages.</span>
<span class="cm"> *</span>
<span class="cm"> *  This routine configures the current tile so that it can receive</span>
<span class="cm"> *  incoming messages.  It must be called before the client can receive</span>
<span class="cm"> *  messages with the hv_receive_message routine, and must be called on</span>
<span class="cm"> *  each tile which will receive messages.</span>
<span class="cm"> *</span>
<span class="cm"> *  msgstate is the virtual address of a state object of type HV_MsgState.</span>
<span class="cm"> *  Once the state is registered, the client must not read or write the</span>
<span class="cm"> *  state object; doing so will cause undefined results.</span>
<span class="cm"> *</span>
<span class="cm"> *  If this routine is called with msgstate set to 0, the client&#39;s message</span>
<span class="cm"> *  state will be freed and it will no longer be able to receive messages.</span>
<span class="cm"> *  Note that this may cause the loss of any as-yet-undelivered messages</span>
<span class="cm"> *  for the client.</span>
<span class="cm"> *</span>
<span class="cm"> *  If another client attempts to send a message to a client which has</span>
<span class="cm"> *  not yet called hv_register_message_state, or which has freed its</span>
<span class="cm"> *  message state, the message will not be delivered, as if the client</span>
<span class="cm"> *  had insufficient buffering.</span>
<span class="cm"> *</span>
<span class="cm"> *  This routine returns HV_OK if the registration was successful, and</span>
<span class="cm"> *  HV_EINVAL if the supplied state object is unsuitable.  Note that some</span>
<span class="cm"> *  errors may not be detected during this routine, but might be detected</span>
<span class="cm"> *  during a subsequent message delivery.</span>
<span class="cm"> * @param msgstate State object.</span>
<span class="cm"> **/</span>
<span class="n">HV_Errno</span> <span class="n">hv_register_message_state</span><span class="p">(</span><span class="n">HV_MsgState</span><span class="o">*</span> <span class="n">msgstate</span><span class="p">);</span>

<span class="cm">/** Possible message recipient states. */</span>
<span class="k">typedef</span> <span class="k">enum</span>
<span class="p">{</span>
  <span class="n">HV_TO_BE_SENT</span><span class="p">,</span>    <span class="cm">/**&lt; Not sent (not attempted, or recipient not ready) */</span>
  <span class="n">HV_SENT</span><span class="p">,</span>          <span class="cm">/**&lt; Successfully sent */</span>
  <span class="n">HV_BAD_RECIP</span>      <span class="cm">/**&lt; Bad recipient coordinates (permanent error) */</span>
<span class="p">}</span> <span class="n">HV_Recip_State</span><span class="p">;</span>

<span class="cm">/** Message recipient. */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
<span class="cp">#ifndef __BIG_ENDIAN__</span>
  <span class="cm">/** X coordinate, relative to supervisor&#39;s top-left coordinate */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>

  <span class="cm">/** Y coordinate, relative to supervisor&#39;s top-left coordinate */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">y</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>

  <span class="cm">/** Status of this recipient */</span>
  <span class="n">HV_Recip_State</span> <span class="n">state</span><span class="o">:</span><span class="mi">10</span><span class="p">;</span>
<span class="cp">#else </span><span class="c1">//__BIG_ENDIAN__</span>
  <span class="n">HV_Recip_State</span> <span class="n">state</span><span class="o">:</span><span class="mi">10</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">y</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span> <span class="n">HV_Recipient</span><span class="p">;</span>

<span class="cm">/** Send a message to a set of recipients.</span>
<span class="cm"> *</span>
<span class="cm"> *  This routine sends a message to a set of recipients.</span>
<span class="cm"> *</span>
<span class="cm"> *  recips is an array of HV_Recipient structures.  Each specifies a tile,</span>
<span class="cm"> *  and a message state; initially, it is expected that the state will</span>
<span class="cm"> *  be set to HV_TO_BE_SENT.  nrecip specifies the number of recipients</span>
<span class="cm"> *  in the recips array.</span>
<span class="cm"> *</span>
<span class="cm"> *  For each recipient whose state is HV_TO_BE_SENT, the hypervisor attempts</span>
<span class="cm"> *  to send that tile the specified message.  In order to successfully</span>
<span class="cm"> *  receive the message, the receiver must be a valid tile to which the</span>
<span class="cm"> *  sender has access, must not be the sending tile itself, and must have</span>
<span class="cm"> *  sufficient free buffer space.  (The hypervisor guarantees that each</span>
<span class="cm"> *  tile which has called hv_register_message_state() will be able to</span>
<span class="cm"> *  buffer one message from every other tile which can legally send to it;</span>
<span class="cm"> *  more space may be provided but is not guaranteed.)  If an invalid tile</span>
<span class="cm"> *  is specified, the recipient&#39;s state is set to HV_BAD_RECIP; this is a</span>
<span class="cm"> *  permanent delivery error.  If the message is successfully delivered</span>
<span class="cm"> *  to the recipient&#39;s buffer, the recipient&#39;s state is set to HV_SENT.</span>
<span class="cm"> *  Otherwise, the recipient&#39;s state is unchanged.  Message delivery is</span>
<span class="cm"> *  synchronous; all attempts to send messages are completed before this</span>
<span class="cm"> *  routine returns.</span>
<span class="cm"> *</span>
<span class="cm"> *  If no permanent delivery errors were encountered, the routine returns</span>
<span class="cm"> *  the number of messages successfully sent: that is, the number of</span>
<span class="cm"> *  recipients whose states changed from HV_TO_BE_SENT to HV_SENT during</span>
<span class="cm"> *  this operation.  If any permanent delivery errors were encountered,</span>
<span class="cm"> *  the routine returns HV_ERECIP.  In the event of permanent delivery</span>
<span class="cm"> *  errors, it may be the case that delivery was not attempted to all</span>
<span class="cm"> *  recipients; if any messages were successfully delivered, however,</span>
<span class="cm"> *  recipients&#39; state values will be updated appropriately.</span>
<span class="cm"> *</span>
<span class="cm"> *  It is explicitly legal to specify a recipient structure whose state</span>
<span class="cm"> *  is not HV_TO_BE_SENT; such a recipient is ignored.  One suggested way</span>
<span class="cm"> *  of using hv_send_message to send a message to multiple tiles is to set</span>
<span class="cm"> *  up a list of recipients, and then call the routine repeatedly with the</span>
<span class="cm"> *  same list, each time accumulating the number of messages successfully</span>
<span class="cm"> *  sent, until all messages are sent, a permanent error is encountered,</span>
<span class="cm"> *  or the desired number of attempts have been made.  When used in this</span>
<span class="cm"> *  way, the routine will deliver each message no more than once to each</span>
<span class="cm"> *  recipient.</span>
<span class="cm"> *</span>
<span class="cm"> *  Note that a message being successfully delivered to the recipient&#39;s</span>
<span class="cm"> *  buffer space does not guarantee that it is received by the recipient,</span>
<span class="cm"> *  either immediately or at any time in the future; the recipient might</span>
<span class="cm"> *  never call hv_receive_message, or could register a different state</span>
<span class="cm"> *  buffer, losing the message.</span>
<span class="cm"> *</span>
<span class="cm"> *  Specifying the same recipient more than once in the recipient list</span>
<span class="cm"> *  is an error, which will not result in an error return but which may</span>
<span class="cm"> *  or may not result in more than one message being delivered to the</span>
<span class="cm"> *  recipient tile.</span>
<span class="cm"> *</span>
<span class="cm"> *  buf and buflen specify the message to be sent.  buf is a virtual address</span>
<span class="cm"> *  which must be currently mapped in the client&#39;s page table; if not, the</span>
<span class="cm"> *  routine returns HV_EFAULT.  buflen must be greater than zero and less</span>
<span class="cm"> *  than or equal to HV_MAX_MESSAGE_SIZE, and nrecip must be less than the</span>
<span class="cm"> *  number of tiles to which the sender has access; if not, the routine</span>
<span class="cm"> *  returns HV_EINVAL.</span>
<span class="cm"> * @param recips List of recipients.</span>
<span class="cm"> * @param nrecip Number of recipients.</span>
<span class="cm"> * @param buf Address of message data.</span>
<span class="cm"> * @param buflen Length of message data.</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="n">hv_send_message</span><span class="p">(</span><span class="n">HV_Recipient</span> <span class="o">*</span><span class="n">recips</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrecip</span><span class="p">,</span>
                    <span class="n">HV_VirtAddr</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">);</span>

<span class="cm">/** Maximum hypervisor message size, in bytes */</span>
<span class="cp">#define HV_MAX_MESSAGE_SIZE 28</span>


<span class="cm">/** Return value from hv_receive_message() */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">msglen</span><span class="p">;</span>     <span class="cm">/**&lt; Message length in bytes, or an error code */</span>
  <span class="n">__hv32</span> <span class="n">source</span><span class="p">;</span>  <span class="cm">/**&lt; Code identifying message sender (HV_MSG_xxx) */</span>
<span class="p">}</span> <span class="n">HV_RcvMsgInfo</span><span class="p">;</span>

<span class="cp">#define HV_MSG_TILE 0x0         </span><span class="cm">/**&lt; Message source is another tile */</span><span class="cp"></span>
<span class="cp">#define HV_MSG_INTR 0x1         </span><span class="cm">/**&lt; Message source is a driver interrupt */</span><span class="cp"></span>

<span class="cm">/** Receive a message.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine retrieves a message from the client&#39;s incoming message</span>
<span class="cm"> * buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Multiple messages sent from a particular sending tile to a particular</span>
<span class="cm"> * receiving tile are received in the order that they were sent; however,</span>
<span class="cm"> * no ordering is guaranteed between messages sent by different tiles.</span>
<span class="cm"> *</span>
<span class="cm"> * Whenever the a client&#39;s message buffer is empty, the first message</span>
<span class="cm"> * subsequently received will cause the client&#39;s MESSAGE_RCV_DWNCL</span>
<span class="cm"> * interrupt vector to be invoked through the interrupt downcall mechanism</span>
<span class="cm"> * (see the description of the hv_downcall_dispatch() routine for details</span>
<span class="cm"> * on downcalls).</span>
<span class="cm"> *</span>
<span class="cm"> * Another message-available downcall will not occur until a call to</span>
<span class="cm"> * this routine is made when the message buffer is empty, and a message</span>
<span class="cm"> * subsequently arrives.  Note that such a downcall could occur while</span>
<span class="cm"> * this routine is executing.  If the calling code does not wish this</span>
<span class="cm"> * to happen, it is recommended that this routine be called with the</span>
<span class="cm"> * INTCTRL_1 interrupt masked, or inside an interrupt critical section.</span>
<span class="cm"> *</span>
<span class="cm"> * msgstate is the value previously passed to hv_register_message_state().</span>
<span class="cm"> * buf is the virtual address of the buffer into which the message will</span>
<span class="cm"> * be written; buflen is the length of the buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine returns an HV_RcvMsgInfo structure.  The msglen member</span>
<span class="cm"> * of that structure is the length of the message received, zero if no</span>
<span class="cm"> * message is available, or HV_E2BIG if the message is too large for the</span>
<span class="cm"> * specified buffer.  If the message is too large, it is not consumed,</span>
<span class="cm"> * and may be retrieved by a subsequent call to this routine specifying</span>
<span class="cm"> * a sufficiently large buffer.  A buffer which is HV_MAX_MESSAGE_SIZE</span>
<span class="cm"> * bytes long is guaranteed to be able to receive any possible message.</span>
<span class="cm"> *</span>
<span class="cm"> * The source member of the HV_RcvMsgInfo structure describes the sender</span>
<span class="cm"> * of the message.  For messages sent by another client tile via an</span>
<span class="cm"> * hv_send_message() call, this value is HV_MSG_TILE; for messages sent</span>
<span class="cm"> * as a result of a device interrupt, this value is HV_MSG_INTR.</span>
<span class="cm"> */</span>

<span class="n">HV_RcvMsgInfo</span> <span class="n">hv_receive_message</span><span class="p">(</span><span class="n">HV_MsgState</span> <span class="n">msgstate</span><span class="p">,</span> <span class="n">HV_VirtAddr</span> <span class="n">buf</span><span class="p">,</span>
                                 <span class="kt">int</span> <span class="n">buflen</span><span class="p">);</span>


<span class="cm">/** Start remaining tiles owned by this supervisor.  Initially, only one tile</span>
<span class="cm"> *  executes the client program; after it calls this service, the other tiles</span>
<span class="cm"> *  are started.  This allows the initial tile to do one-time configuration</span>
<span class="cm"> *  of shared data structures without having to lock them against simultaneous</span>
<span class="cm"> *  access.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">hv_start_all_tiles</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cm">/** Open a hypervisor device.</span>
<span class="cm"> *</span>
<span class="cm"> *  This service initializes an I/O device and its hypervisor driver software,</span>
<span class="cm"> *  and makes it available for use.  The open operation is per-device per-chip;</span>
<span class="cm"> *  once it has been performed, the device handle returned may be used in other</span>
<span class="cm"> *  device services calls made by any tile.</span>
<span class="cm"> *</span>
<span class="cm"> * @param name Name of the device.  A base device name is just a text string</span>
<span class="cm"> *        (say, &quot;pcie&quot;).  If there is more than one instance of a device, the</span>
<span class="cm"> *        base name is followed by a slash and a device number (say, &quot;pcie/0&quot;).</span>
<span class="cm"> *        Some devices may support further structure beneath those components;</span>
<span class="cm"> *        most notably, devices which require control operations do so by</span>
<span class="cm"> *        supporting reads and/or writes to a control device whose name</span>
<span class="cm"> *        includes a trailing &quot;/ctl&quot; (say, &quot;pcie/0/ctl&quot;).</span>
<span class="cm"> * @param flags Flags (HV_DEV_xxx).</span>
<span class="cm"> * @return A positive integer device handle, or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_dev_open</span><span class="p">(</span><span class="n">HV_VirtAddr</span> <span class="n">name</span><span class="p">,</span> <span class="n">__hv32</span> <span class="n">flags</span><span class="p">);</span>


<span class="cm">/** Close a hypervisor device.</span>
<span class="cm"> *</span>
<span class="cm"> *  This service uninitializes an I/O device and its hypervisor driver</span>
<span class="cm"> *  software, and makes it unavailable for use.  The close operation is</span>
<span class="cm"> *  per-device per-chip; once it has been performed, the device is no longer</span>
<span class="cm"> *  available.  Normally there is no need to ever call the close service.</span>
<span class="cm"> *</span>
<span class="cm"> * @param devhdl Device handle of the device to be closed.</span>
<span class="cm"> * @return Zero if the close is successful, otherwise, a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_dev_close</span><span class="p">(</span><span class="kt">int</span> <span class="n">devhdl</span><span class="p">);</span>


<span class="cm">/** Read data from a hypervisor device synchronously.</span>
<span class="cm"> *</span>
<span class="cm"> *  This service transfers data from a hypervisor device to a memory buffer.</span>
<span class="cm"> *  When the service returns, the data has been written from the memory buffer,</span>
<span class="cm"> *  and the buffer will not be further modified by the driver.</span>
<span class="cm"> *</span>
<span class="cm"> *  No ordering is guaranteed between requests issued from different tiles.</span>
<span class="cm"> *</span>
<span class="cm"> *  Devices may choose to support both the synchronous and asynchronous read</span>
<span class="cm"> *  operations, only one of them, or neither of them.</span>
<span class="cm"> *</span>
<span class="cm"> * @param devhdl Device handle of the device to be read from.</span>
<span class="cm"> * @param flags Flags (HV_DEV_xxx).</span>
<span class="cm"> * @param va Virtual address of the target data buffer.  This buffer must</span>
<span class="cm"> *        be mapped in the currently installed page table; if not, HV_EFAULT</span>
<span class="cm"> *        may be returned.</span>
<span class="cm"> * @param len Number of bytes to be transferred.</span>
<span class="cm"> * @param offset Driver-dependent offset.  For a random-access device, this is</span>
<span class="cm"> *        often a byte offset from the beginning of the device; in other cases,</span>
<span class="cm"> *        like on a control device, it may have a different meaning.</span>
<span class="cm"> * @return A non-negative value if the read was at least partially successful;</span>
<span class="cm"> *         otherwise, a negative error code.  The precise interpretation of</span>
<span class="cm"> *         the return value is driver-dependent, but many drivers will return</span>
<span class="cm"> *         the number of bytes successfully transferred.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_dev_pread</span><span class="p">(</span><span class="kt">int</span> <span class="n">devhdl</span><span class="p">,</span> <span class="n">__hv32</span> <span class="n">flags</span><span class="p">,</span> <span class="n">HV_VirtAddr</span> <span class="n">va</span><span class="p">,</span> <span class="n">__hv32</span> <span class="n">len</span><span class="p">,</span>
                 <span class="n">__hv64</span> <span class="n">offset</span><span class="p">);</span>

<span class="cp">#define HV_DEV_NB_EMPTY     0x1   </span><span class="cm">/**&lt; Don&#39;t block when no bytes of data can</span>
<span class="cm">                                       be transferred. */</span><span class="cp"></span>
<span class="cp">#define HV_DEV_NB_PARTIAL   0x2   </span><span class="cm">/**&lt; Don&#39;t block when some bytes, but not all</span>
<span class="cm">                                       of the requested bytes, can be</span>
<span class="cm">                                       transferred. */</span><span class="cp"></span>
<span class="cp">#define HV_DEV_NOCACHE      0x4   </span><span class="cm">/**&lt; The caller warrants that none of the</span>
<span class="cm">                                       cache lines which might contain data</span>
<span class="cm">                                       from the requested buffer are valid.</span>
<span class="cm">                                       Useful with asynchronous operations</span>
<span class="cm">                                       only. */</span><span class="cp"></span>

<span class="cp">#define HV_DEV_ALLFLAGS     (HV_DEV_NB_EMPTY | HV_DEV_NB_PARTIAL | \</span>
<span class="cp">                             HV_DEV_NOCACHE)   </span><span class="cm">/**&lt; All HV_DEV_xxx flags */</span><span class="cp"></span>

<span class="cm">/** Write data to a hypervisor device synchronously.</span>
<span class="cm"> *</span>
<span class="cm"> *  This service transfers data from a memory buffer to a hypervisor device.</span>
<span class="cm"> *  When the service returns, the data has been read from the memory buffer,</span>
<span class="cm"> *  and the buffer may be overwritten by the client; the data may not</span>
<span class="cm"> *  necessarily have been conveyed to the actual hardware I/O interface.</span>
<span class="cm"> *</span>
<span class="cm"> *  No ordering is guaranteed between requests issued from different tiles.</span>
<span class="cm"> *</span>
<span class="cm"> *  Devices may choose to support both the synchronous and asynchronous write</span>
<span class="cm"> *  operations, only one of them, or neither of them.</span>
<span class="cm"> *</span>
<span class="cm"> * @param devhdl Device handle of the device to be written to.</span>
<span class="cm"> * @param flags Flags (HV_DEV_xxx).</span>
<span class="cm"> * @param va Virtual address of the source data buffer.  This buffer must</span>
<span class="cm"> *        be mapped in the currently installed page table; if not, HV_EFAULT</span>
<span class="cm"> *        may be returned.</span>
<span class="cm"> * @param len Number of bytes to be transferred.</span>
<span class="cm"> * @param offset Driver-dependent offset.  For a random-access device, this is</span>
<span class="cm"> *        often a byte offset from the beginning of the device; in other cases,</span>
<span class="cm"> *        like on a control device, it may have a different meaning.</span>
<span class="cm"> * @return A non-negative value if the write was at least partially successful;</span>
<span class="cm"> *         otherwise, a negative error code.  The precise interpretation of</span>
<span class="cm"> *         the return value is driver-dependent, but many drivers will return</span>
<span class="cm"> *         the number of bytes successfully transferred.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_dev_pwrite</span><span class="p">(</span><span class="kt">int</span> <span class="n">devhdl</span><span class="p">,</span> <span class="n">__hv32</span> <span class="n">flags</span><span class="p">,</span> <span class="n">HV_VirtAddr</span> <span class="n">va</span><span class="p">,</span> <span class="n">__hv32</span> <span class="n">len</span><span class="p">,</span>
                  <span class="n">__hv64</span> <span class="n">offset</span><span class="p">);</span>


<span class="cm">/** Interrupt arguments, used in the asynchronous I/O interfaces. */</span>
<span class="cp">#if CHIP_VA_WIDTH() &gt; 32</span>
<span class="k">typedef</span> <span class="n">__hv64</span> <span class="n">HV_IntArg</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">typedef</span> <span class="n">__hv32</span> <span class="n">HV_IntArg</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/** Interrupt messages are delivered via the mechanism as normal messages,</span>
<span class="cm"> *  but have a message source of HV_DEV_INTR.  The message is formatted</span>
<span class="cm"> *  as an HV_IntrMsg structure.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="n">HV_IntArg</span> <span class="n">intarg</span><span class="p">;</span>  <span class="cm">/**&lt; Interrupt argument, passed to the poll/preada/pwritea</span>
<span class="cm">                          services */</span>
  <span class="n">HV_IntArg</span> <span class="n">intdata</span><span class="p">;</span> <span class="cm">/**&lt; Interrupt-specific interrupt data */</span>
<span class="p">}</span> <span class="n">HV_IntrMsg</span><span class="p">;</span>

<span class="cm">/** Request an interrupt message when a device condition is satisfied.</span>
<span class="cm"> *</span>
<span class="cm"> *  This service requests that an interrupt message be delivered to the</span>
<span class="cm"> *  requesting tile when a device becomes readable or writable, or when any</span>
<span class="cm"> *  data queued to the device via previous write operations from this tile</span>
<span class="cm"> *  has been actually sent out on the hardware I/O interface.  Devices may</span>
<span class="cm"> *  choose to support any, all, or none of the available conditions.</span>
<span class="cm"> *</span>
<span class="cm"> *  If multiple conditions are specified, only one message will be</span>
<span class="cm"> *  delivered.  If the event mask delivered to that interrupt handler</span>
<span class="cm"> *  indicates that some of the conditions have not yet occurred, the</span>
<span class="cm"> *  client must issue another poll() call if it wishes to wait for those</span>
<span class="cm"> *  conditions.</span>
<span class="cm"> *</span>
<span class="cm"> *  Only one poll may be outstanding per device handle per tile.  If more than</span>
<span class="cm"> *  one tile is polling on the same device and condition, they will all be</span>
<span class="cm"> *  notified when it happens.  Because of this, clients may not assume that</span>
<span class="cm"> *  the condition signaled is necessarily still true when they request a</span>
<span class="cm"> *  subsequent service; for instance, the readable data which caused the</span>
<span class="cm"> *  poll call to interrupt may have been read by another tile in the interim.</span>
<span class="cm"> *</span>
<span class="cm"> *  The notification interrupt message could come directly, or via the</span>
<span class="cm"> *  downcall (intctrl1) method, depending on what the tile is doing</span>
<span class="cm"> *  when the condition is satisfied.  Note that it is possible for the</span>
<span class="cm"> *  requested interrupt to be delivered after this service is called but</span>
<span class="cm"> *  before it returns.</span>
<span class="cm"> *</span>
<span class="cm"> * @param devhdl Device handle of the device to be polled.</span>
<span class="cm"> * @param events Flags denoting the events which will cause the interrupt to</span>
<span class="cm"> *        be delivered (HV_DEVPOLL_xxx).</span>
<span class="cm"> * @param intarg Value which will be delivered as the intarg member of the</span>
<span class="cm"> *        eventual interrupt message; the intdata member will be set to a</span>
<span class="cm"> *        mask of HV_DEVPOLL_xxx values indicating which conditions have been</span>
<span class="cm"> *        satisifed.</span>
<span class="cm"> * @return Zero if the interrupt was successfully scheduled; otherwise, a</span>
<span class="cm"> *         negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_dev_poll</span><span class="p">(</span><span class="kt">int</span> <span class="n">devhdl</span><span class="p">,</span> <span class="n">__hv32</span> <span class="n">events</span><span class="p">,</span> <span class="n">HV_IntArg</span> <span class="n">intarg</span><span class="p">);</span>

<span class="cp">#define HV_DEVPOLL_READ     0x1   </span><span class="cm">/**&lt; Test device for readability */</span><span class="cp"></span>
<span class="cp">#define HV_DEVPOLL_WRITE    0x2   </span><span class="cm">/**&lt; Test device for writability */</span><span class="cp"></span>
<span class="cp">#define HV_DEVPOLL_FLUSH    0x4   </span><span class="cm">/**&lt; Test device for output drained */</span><span class="cp"></span>


<span class="cm">/** Cancel a request for an interrupt when a device event occurs.</span>
<span class="cm"> *</span>
<span class="cm"> *  This service requests that no interrupt be delivered when the events</span>
<span class="cm"> *  noted in the last-issued poll() call happen.  Once this service returns,</span>
<span class="cm"> *  the interrupt has been canceled; however, it is possible for the interrupt</span>
<span class="cm"> *  to be delivered after this service is called but before it returns.</span>
<span class="cm"> *</span>
<span class="cm"> * @param devhdl Device handle of the device on which to cancel polling.</span>
<span class="cm"> * @return Zero if the poll was successfully canceled; otherwise, a negative</span>
<span class="cm"> *         error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_dev_poll_cancel</span><span class="p">(</span><span class="kt">int</span> <span class="n">devhdl</span><span class="p">);</span>


<span class="cm">/** Scatter-gather list for preada/pwritea calls. */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="cp">#if CHIP_VA_WIDTH() &lt;= 32</span>
<span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">,</span> <span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
<span class="cp">#endif</span>
<span class="p">{</span>
  <span class="n">HV_PhysAddr</span> <span class="n">pa</span><span class="p">;</span>  <span class="cm">/**&lt; Client physical address of the buffer segment. */</span>
  <span class="n">HV_PTE</span> <span class="n">pte</span><span class="p">;</span>      <span class="cm">/**&lt; Page table entry describing the caching and location</span>
<span class="cm">                        override characteristics of the buffer segment.  Some</span>
<span class="cm">                        drivers ignore this element and will require that</span>
<span class="cm">                        the NOCACHE flag be set on their requests. */</span>
  <span class="n">__hv32</span> <span class="n">len</span><span class="p">;</span>      <span class="cm">/**&lt; Length of the buffer segment. */</span>
<span class="p">}</span> <span class="n">HV_SGL</span><span class="p">;</span>

<span class="cp">#define HV_SGL_MAXLEN 16  </span><span class="cm">/**&lt; Maximum number of entries in a scatter-gather</span>
<span class="cm">                               list */</span><span class="cp"></span>

<span class="cm">/** Read data from a hypervisor device asynchronously.</span>
<span class="cm"> *</span>
<span class="cm"> *  This service transfers data from a hypervisor device to a memory buffer.</span>
<span class="cm"> *  When the service returns, the read has been scheduled.  When the read</span>
<span class="cm"> *  completes, an interrupt message will be delivered, and the buffer will</span>
<span class="cm"> *  not be further modified by the driver.</span>
<span class="cm"> *</span>
<span class="cm"> *  The number of possible outstanding asynchronous requests is defined by</span>
<span class="cm"> *  each driver, but it is recommended that it be at least two requests</span>
<span class="cm"> *  per tile per device.</span>
<span class="cm"> *</span>
<span class="cm"> *  No ordering is guaranteed between synchronous and asynchronous requests,</span>
<span class="cm"> *  even those issued on the same tile.</span>
<span class="cm"> *</span>
<span class="cm"> *  The completion interrupt message could come directly, or via the downcall</span>
<span class="cm"> *  (intctrl1) method, depending on what the tile is doing when the read</span>
<span class="cm"> *  completes.  Interrupts do not coalesce; one is delivered for each</span>
<span class="cm"> *  asynchronous I/O request.  Note that it is possible for the requested</span>
<span class="cm"> *  interrupt to be delivered after this service is called but before it</span>
<span class="cm"> *  returns.</span>
<span class="cm"> *</span>
<span class="cm"> *  Devices may choose to support both the synchronous and asynchronous read</span>
<span class="cm"> *  operations, only one of them, or neither of them.</span>
<span class="cm"> *</span>
<span class="cm"> * @param devhdl Device handle of the device to be read from.</span>
<span class="cm"> * @param flags Flags (HV_DEV_xxx).</span>
<span class="cm"> * @param sgl_len Number of elements in the scatter-gather list.</span>
<span class="cm"> * @param sgl Scatter-gather list describing the memory to which data will be</span>
<span class="cm"> *        written.</span>
<span class="cm"> * @param offset Driver-dependent offset.  For a random-access device, this is</span>
<span class="cm"> *        often a byte offset from the beginning of the device; in other cases,</span>
<span class="cm"> *        like on a control device, it may have a different meaning.</span>
<span class="cm"> * @param intarg Value which will be delivered as the intarg member of the</span>
<span class="cm"> *        eventual interrupt message; the intdata member will be set to the</span>
<span class="cm"> *        normal return value from the read request.</span>
<span class="cm"> * @return Zero if the read was successfully scheduled; otherwise, a negative</span>
<span class="cm"> *         error code.  Note that some drivers may choose to pre-validate</span>
<span class="cm"> *         their arguments, and may thus detect certain device error</span>
<span class="cm"> *         conditions at this time rather than when the completion notification</span>
<span class="cm"> *         occurs, but this is not required.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_dev_preada</span><span class="p">(</span><span class="kt">int</span> <span class="n">devhdl</span><span class="p">,</span> <span class="n">__hv32</span> <span class="n">flags</span><span class="p">,</span> <span class="n">__hv32</span> <span class="n">sgl_len</span><span class="p">,</span>
                  <span class="n">HV_SGL</span> <span class="n">sgl</span><span class="p">[</span><span class="cm">/* sgl_len */</span><span class="p">],</span> <span class="n">__hv64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">HV_IntArg</span> <span class="n">intarg</span><span class="p">);</span>


<span class="cm">/** Write data to a hypervisor device asynchronously.</span>
<span class="cm"> *</span>
<span class="cm"> *  This service transfers data from a memory buffer to a hypervisor</span>
<span class="cm"> *  device.  When the service returns, the write has been scheduled.</span>
<span class="cm"> *  When the write completes, an interrupt message will be delivered,</span>
<span class="cm"> *  and the buffer may be overwritten by the client; the data may not</span>
<span class="cm"> *  necessarily have been conveyed to the actual hardware I/O interface.</span>
<span class="cm"> *</span>
<span class="cm"> *  The number of possible outstanding asynchronous requests is defined by</span>
<span class="cm"> *  each driver, but it is recommended that it be at least two requests</span>
<span class="cm"> *  per tile per device.</span>
<span class="cm"> *</span>
<span class="cm"> *  No ordering is guaranteed between synchronous and asynchronous requests,</span>
<span class="cm"> *  even those issued on the same tile.</span>
<span class="cm"> *</span>
<span class="cm"> *  The completion interrupt message could come directly, or via the downcall</span>
<span class="cm"> *  (intctrl1) method, depending on what the tile is doing when the read</span>
<span class="cm"> *  completes.  Interrupts do not coalesce; one is delivered for each</span>
<span class="cm"> *  asynchronous I/O request.  Note that it is possible for the requested</span>
<span class="cm"> *  interrupt to be delivered after this service is called but before it</span>
<span class="cm"> *  returns.</span>
<span class="cm"> *</span>
<span class="cm"> *  Devices may choose to support both the synchronous and asynchronous write</span>
<span class="cm"> *  operations, only one of them, or neither of them.</span>
<span class="cm"> *</span>
<span class="cm"> * @param devhdl Device handle of the device to be read from.</span>
<span class="cm"> * @param flags Flags (HV_DEV_xxx).</span>
<span class="cm"> * @param sgl_len Number of elements in the scatter-gather list.</span>
<span class="cm"> * @param sgl Scatter-gather list describing the memory from which data will be</span>
<span class="cm"> *        read.</span>
<span class="cm"> * @param offset Driver-dependent offset.  For a random-access device, this is</span>
<span class="cm"> *        often a byte offset from the beginning of the device; in other cases,</span>
<span class="cm"> *        like on a control device, it may have a different meaning.</span>
<span class="cm"> * @param intarg Value which will be delivered as the intarg member of the</span>
<span class="cm"> *        eventual interrupt message; the intdata member will be set to the</span>
<span class="cm"> *        normal return value from the write request.</span>
<span class="cm"> * @return Zero if the write was successfully scheduled; otherwise, a negative</span>
<span class="cm"> *         error code.  Note that some drivers may choose to pre-validate</span>
<span class="cm"> *         their arguments, and may thus detect certain device error</span>
<span class="cm"> *         conditions at this time rather than when the completion notification</span>
<span class="cm"> *         occurs, but this is not required.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_dev_pwritea</span><span class="p">(</span><span class="kt">int</span> <span class="n">devhdl</span><span class="p">,</span> <span class="n">__hv32</span> <span class="n">flags</span><span class="p">,</span> <span class="n">__hv32</span> <span class="n">sgl_len</span><span class="p">,</span>
                   <span class="n">HV_SGL</span> <span class="n">sgl</span><span class="p">[</span><span class="cm">/* sgl_len */</span><span class="p">],</span> <span class="n">__hv64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">HV_IntArg</span> <span class="n">intarg</span><span class="p">);</span>


<span class="cm">/** Define a pair of tile and ASID to identify a user process context. */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="cm">/** X coordinate, relative to supervisor&#39;s top-left coordinate */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>

  <span class="cm">/** Y coordinate, relative to supervisor&#39;s top-left coordinate */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">y</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>

  <span class="cm">/** ASID of the process on this x,y tile */</span>
  <span class="n">HV_ASID</span> <span class="n">asid</span><span class="o">:</span><span class="mi">10</span><span class="p">;</span>
<span class="p">}</span> <span class="n">HV_Remote_ASID</span><span class="p">;</span>

<span class="cm">/** Flush cache and/or TLB state on remote tiles.</span>
<span class="cm"> *</span>
<span class="cm"> * @param cache_pa Client physical address to flush from cache (ignored if</span>
<span class="cm"> *        the length encoded in cache_control is zero, or if</span>
<span class="cm"> *        HV_FLUSH_EVICT_L2 is set, or if cache_cpumask is NULL).</span>
<span class="cm"> * @param cache_control This argument allows you to specify a length of</span>
<span class="cm"> *        physical address space to flush (maximum HV_FLUSH_MAX_CACHE_LEN).</span>
<span class="cm"> *        You can &quot;or&quot; in HV_FLUSH_EVICT_L2 to flush the whole L2 cache.</span>
<span class="cm"> *        You can &quot;or&quot; in HV_FLUSH_EVICT_L1I to flush the whole L1I cache.</span>
<span class="cm"> *        HV_FLUSH_ALL flushes all caches.</span>
<span class="cm"> * @param cache_cpumask Bitmask (in row-major order, supervisor-relative) of</span>
<span class="cm"> *        tile indices to perform cache flush on.  The low bit of the first</span>
<span class="cm"> *        word corresponds to the tile at the upper left-hand corner of the</span>
<span class="cm"> *        supervisor&#39;s rectangle.  If passed as a NULL pointer, equivalent</span>
<span class="cm"> *        to an empty bitmask.  On chips which support hash-for-home caching,</span>
<span class="cm"> *        if passed as -1, equivalent to a mask containing tiles which could</span>
<span class="cm"> *        be doing hash-for-home caching.</span>
<span class="cm"> * @param tlb_va Virtual address to flush from TLB (ignored if</span>
<span class="cm"> *        tlb_length is zero or tlb_cpumask is NULL).</span>
<span class="cm"> * @param tlb_length Number of bytes of data to flush from the TLB.</span>
<span class="cm"> * @param tlb_pgsize Page size to use for TLB flushes.</span>
<span class="cm"> *        tlb_va and tlb_length need not be aligned to this size.</span>
<span class="cm"> * @param tlb_cpumask Bitmask for tlb flush, like cache_cpumask.</span>
<span class="cm"> *        If passed as a NULL pointer, equivalent to an empty bitmask.</span>
<span class="cm"> * @param asids Pointer to an HV_Remote_ASID array of tile/ASID pairs to flush.</span>
<span class="cm"> * @param asidcount Number of HV_Remote_ASID entries in asids[].</span>
<span class="cm"> * @return Zero for success, or else HV_EINVAL or HV_EFAULT for errors that</span>
<span class="cm"> *        are detected while parsing the arguments.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">hv_flush_remote</span><span class="p">(</span><span class="n">HV_PhysAddr</span> <span class="n">cache_pa</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cache_control</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span> <span class="n">cache_cpumask</span><span class="p">,</span>
                    <span class="n">HV_VirtAddr</span> <span class="n">tlb_va</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tlb_length</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tlb_pgsize</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span> <span class="n">tlb_cpumask</span><span class="p">,</span>
                    <span class="n">HV_Remote_ASID</span><span class="o">*</span> <span class="n">asids</span><span class="p">,</span> <span class="kt">int</span> <span class="n">asidcount</span><span class="p">);</span>

<span class="cm">/** Include in cache_control to ensure a flush of the entire L2. */</span>
<span class="cp">#define HV_FLUSH_EVICT_L2 (1UL &lt;&lt; 31)</span>

<span class="cm">/** Include in cache_control to ensure a flush of the entire L1I. */</span>
<span class="cp">#define HV_FLUSH_EVICT_L1I (1UL &lt;&lt; 30)</span>

<span class="cm">/** Maximum legal size to use for the &quot;length&quot; component of cache_control. */</span>
<span class="cp">#define HV_FLUSH_MAX_CACHE_LEN ((1UL &lt;&lt; 30) - 1)</span>

<span class="cm">/** Use for cache_control to ensure a flush of all caches. */</span>
<span class="cp">#define HV_FLUSH_ALL -1UL</span>

<span class="cp">#else   </span><span class="cm">/* __ASSEMBLER__ */</span><span class="cp"></span>

<span class="cm">/** Include in cache_control to ensure a flush of the entire L2. */</span>
<span class="cp">#define HV_FLUSH_EVICT_L2 (1 &lt;&lt; 31)</span>

<span class="cm">/** Include in cache_control to ensure a flush of the entire L1I. */</span>
<span class="cp">#define HV_FLUSH_EVICT_L1I (1 &lt;&lt; 30)</span>

<span class="cm">/** Maximum legal size to use for the &quot;length&quot; component of cache_control. */</span>
<span class="cp">#define HV_FLUSH_MAX_CACHE_LEN ((1 &lt;&lt; 30) - 1)</span>

<span class="cm">/** Use for cache_control to ensure a flush of all caches. */</span>
<span class="cp">#define HV_FLUSH_ALL -1</span>

<span class="cp">#endif  </span><span class="cm">/* __ASSEMBLER__ */</span><span class="cp"></span>

<span class="cp">#ifndef __ASSEMBLER__</span>

<span class="cm">/** Return a 64-bit value corresponding to the PTE if needed */</span>
<span class="cp">#define hv_pte_val(pte) ((pte).val)</span>

<span class="cm">/** Cast a 64-bit value to an HV_PTE */</span>
<span class="cp">#define hv_pte(val) ((HV_PTE) { val })</span>

<span class="cp">#endif  </span><span class="cm">/* !__ASSEMBLER__ */</span><span class="cp"></span>


<span class="cm">/** Bits in the size of an HV_PTE */</span>
<span class="cp">#define HV_LOG2_PTE_SIZE 3</span>

<span class="cm">/** Size of an HV_PTE */</span>
<span class="cp">#define HV_PTE_SIZE (1 &lt;&lt; HV_LOG2_PTE_SIZE)</span>


<span class="cm">/* Bits in HV_PTE&#39;s low word. */</span>
<span class="cp">#define HV_PTE_INDEX_PRESENT          0  </span><span class="cm">/**&lt; PTE is valid */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_MIGRATING        1  </span><span class="cm">/**&lt; Page is migrating */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_CLIENT0          2  </span><span class="cm">/**&lt; Page client state 0 */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_CLIENT1          3  </span><span class="cm">/**&lt; Page client state 1 */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_NC               4  </span><span class="cm">/**&lt; L1$/L2$ incoherent with L3$ */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_NO_ALLOC_L1      5  </span><span class="cm">/**&lt; Page is uncached in local L1$ */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_NO_ALLOC_L2      6  </span><span class="cm">/**&lt; Page is uncached in local L2$ */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_CACHED_PRIORITY  7  </span><span class="cm">/**&lt; Page is priority cached */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_PAGE             8  </span><span class="cm">/**&lt; PTE describes a page */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_GLOBAL           9  </span><span class="cm">/**&lt; Page is global */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_USER            10  </span><span class="cm">/**&lt; Page is user-accessible */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_ACCESSED        11  </span><span class="cm">/**&lt; Page has been accessed */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_DIRTY           12  </span><span class="cm">/**&lt; Page has been written */</span><span class="cp"></span>
                                         <span class="cm">/*   Bits 13-14 are reserved for</span>
<span class="cm">                                              future use. */</span>
<span class="cp">#define HV_PTE_INDEX_SUPER           15  </span><span class="cm">/**&lt; Pages ganged together for TLB */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_MODE            16  </span><span class="cm">/**&lt; Page mode; see HV_PTE_MODE_xxx */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_MODE_BITS              3  </span><span class="cm">/**&lt; Number of bits in mode */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_CLIENT2         19  </span><span class="cm">/**&lt; Page client state 2 */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_LOTAR           20  </span><span class="cm">/**&lt; Page&#39;s LOTAR; must be high bits</span>
<span class="cm">                                              of word */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_LOTAR_BITS            12  </span><span class="cm">/**&lt; Number of bits in a LOTAR */</span><span class="cp"></span>

<span class="cm">/* Bits in HV_PTE&#39;s high word. */</span>
<span class="cp">#define HV_PTE_INDEX_READABLE        32  </span><span class="cm">/**&lt; Page is readable */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_WRITABLE        33  </span><span class="cm">/**&lt; Page is writable */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_EXECUTABLE      34  </span><span class="cm">/**&lt; Page is executable */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_INDEX_PTFN            35  </span><span class="cm">/**&lt; Page&#39;s PTFN; must be high bits</span>
<span class="cm">                                              of word */</span><span class="cp"></span>
<span class="cp">#define HV_PTE_PTFN_BITS             29  </span><span class="cm">/**&lt; Number of bits in a PTFN */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Legal values for the PTE&#39;s mode field</span>
<span class="cm"> */</span>
<span class="cm">/** Data is not resident in any caches; loads and stores access memory</span>
<span class="cm"> *  directly.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_MODE_UNCACHED          1</span>

<span class="cm">/** Data is resident in the tile&#39;s local L1 and/or L2 caches; if a load</span>
<span class="cm"> *  or store misses there, it goes to memory.</span>
<span class="cm"> *</span>
<span class="cm"> *  The copy in the local L1$/L2$ is not invalidated when the copy in</span>
<span class="cm"> *  memory is changed.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_MODE_CACHE_NO_L3       2</span>

<span class="cm">/** Data is resident in the tile&#39;s local L1 and/or L2 caches.  If a load</span>
<span class="cm"> *  or store misses there, it goes to an L3 cache in a designated tile;</span>
<span class="cm"> *  if it misses there, it goes to memory.</span>
<span class="cm"> *</span>
<span class="cm"> *  If the NC bit is not set, the copy in the local L1$/L2$ is invalidated</span>
<span class="cm"> *  when the copy in the remote L3$ is changed.  Otherwise, such</span>
<span class="cm"> *  invalidation will not occur.</span>
<span class="cm"> *</span>
<span class="cm"> *  Chips for which CHIP_HAS_COHERENT_LOCAL_CACHE() is 0 do not support</span>
<span class="cm"> *  invalidation from an L3$ to another tile&#39;s L1$/L2$.  If the NC bit is</span>
<span class="cm"> *  clear on such a chip, no copy is kept in the local L1$/L2$ in this mode.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_MODE_CACHE_TILE_L3     3</span>

<span class="cm">/** Data is resident in the tile&#39;s local L1 and/or L2 caches.  If a load</span>
<span class="cm"> *  or store misses there, it goes to an L3 cache in one of a set of</span>
<span class="cm"> *  designated tiles; if it misses there, it goes to memory.  Which tile</span>
<span class="cm"> *  is chosen from the set depends upon a hash function applied to the</span>
<span class="cm"> *  physical address.  This mode is not supported on chips for which</span>
<span class="cm"> *  CHIP_HAS_CBOX_HOME_MAP() is 0.</span>
<span class="cm"> *</span>
<span class="cm"> *  If the NC bit is not set, the copy in the local L1$/L2$ is invalidated</span>
<span class="cm"> *  when the copy in the remote L3$ is changed.  Otherwise, such</span>
<span class="cm"> *  invalidation will not occur.</span>
<span class="cm"> *</span>
<span class="cm"> *  Chips for which CHIP_HAS_COHERENT_LOCAL_CACHE() is 0 do not support</span>
<span class="cm"> *  invalidation from an L3$ to another tile&#39;s L1$/L2$.  If the NC bit is</span>
<span class="cm"> *  clear on such a chip, no copy is kept in the local L1$/L2$ in this mode.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_MODE_CACHE_HASH_L3     4</span>

<span class="cm">/** Data is not resident in memory; accesses are instead made to an I/O</span>
<span class="cm"> *  device, whose tile coordinates are given by the PTE&#39;s LOTAR field.</span>
<span class="cm"> *  This mode is only supported on chips for which CHIP_HAS_MMIO() is 1.</span>
<span class="cm"> *  The EXECUTABLE bit may not be set in an MMIO PTE.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_MODE_MMIO              5</span>


<span class="cm">/* C wants 1ULL so it is typed as __hv64, but the assembler needs just numbers.</span>
<span class="cm"> * The assembler can&#39;t handle shifts greater than 31, but treats them</span>
<span class="cm"> * as shifts mod 32, so assembler code must be aware of which word</span>
<span class="cm"> * the bit belongs in when using these macros.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __ASSEMBLER__</span>
<span class="cp">#define __HV_PTE_ONE 1        </span><span class="cm">/**&lt; One, for assembler */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define __HV_PTE_ONE 1ULL     </span><span class="cm">/**&lt; One, for C */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/** Is this PTE present?</span>
<span class="cm"> *</span>
<span class="cm"> * If this bit is set, this PTE represents a valid translation or level-2</span>
<span class="cm"> * page table pointer.  Otherwise, the page table does not contain a</span>
<span class="cm"> * translation for the subject virtual pages.</span>
<span class="cm"> *</span>
<span class="cm"> * If this bit is not set, the other bits in the PTE are not</span>
<span class="cm"> * interpreted by the hypervisor, and may contain any value.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_PRESENT               (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_PRESENT)</span>

<span class="cm">/** Does this PTE map a page?</span>
<span class="cm"> *</span>
<span class="cm"> * If this bit is set in a level-0 page table, the entry should be</span>
<span class="cm"> * interpreted as a level-2 page table entry mapping a jumbo page.</span>
<span class="cm"> *</span>
<span class="cm"> * If this bit is set in a level-1 page table, the entry should be</span>
<span class="cm"> * interpreted as a level-2 page table entry mapping a large page.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit should not be modified by the client while PRESENT is set, as</span>
<span class="cm"> * doing so may race with the hypervisor&#39;s update of ACCESSED and DIRTY bits.</span>
<span class="cm"> *</span>
<span class="cm"> * In a level-2 page table, this bit is ignored and must be zero.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_PAGE                  (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_PAGE)</span>

<span class="cm">/** Does this PTE implicitly reference multiple pages?</span>
<span class="cm"> *</span>
<span class="cm"> * If this bit is set in the page table (either in the level-2 page table,</span>
<span class="cm"> * or in a higher level page table in conjunction with the PAGE bit)</span>
<span class="cm"> * then the PTE specifies a range of contiguous pages, not a single page.</span>
<span class="cm"> * The hv_set_pte_super_shift() allows you to specify the count for</span>
<span class="cm"> * each level of the page table.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: this bit is not supported on TILEPro systems.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_SUPER                 (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_SUPER)</span>

<span class="cm">/** Is this a global (non-ASID) mapping?</span>
<span class="cm"> *</span>
<span class="cm"> * If this bit is set, the translations established by this PTE will</span>
<span class="cm"> * not be flushed from the TLB by the hv_flush_asid() service; they</span>
<span class="cm"> * will be flushed by the hv_flush_page() or hv_flush_pages() services.</span>
<span class="cm"> *</span>
<span class="cm"> * Setting this bit for translations which are identical in all page</span>
<span class="cm"> * tables (for instance, code and data belonging to a client OS) can</span>
<span class="cm"> * be very beneficial, as it will reduce the number of TLB misses.</span>
<span class="cm"> * Note that, while it is not an error which will be detected by the</span>
<span class="cm"> * hypervisor, it is an extremely bad idea to set this bit for</span>
<span class="cm"> * translations which are _not_ identical in all page tables.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit should not be modified by the client while PRESENT is set, as</span>
<span class="cm"> * doing so may race with the hypervisor&#39;s update of ACCESSED and DIRTY bits.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit is ignored in level-1 PTEs unless the Page bit is set.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_GLOBAL                (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_GLOBAL)</span>

<span class="cm">/** Is this mapping accessible to users?</span>
<span class="cm"> *</span>
<span class="cm"> * If this bit is set, code running at any PL will be permitted to</span>
<span class="cm"> * access the virtual addresses mapped by this PTE.  Otherwise, only</span>
<span class="cm"> * code running at PL 1 or above will be allowed to do so.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit should not be modified by the client while PRESENT is set, as</span>
<span class="cm"> * doing so may race with the hypervisor&#39;s update of ACCESSED and DIRTY bits.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit is ignored in level-1 PTEs unless the Page bit is set.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_USER                  (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_USER)</span>

<span class="cm">/** Has this mapping been accessed?</span>
<span class="cm"> *</span>
<span class="cm"> * This bit is set by the hypervisor when the memory described by the</span>
<span class="cm"> * translation is accessed for the first time.  It is never cleared by</span>
<span class="cm"> * the hypervisor, but may be cleared by the client.  After the bit</span>
<span class="cm"> * has been cleared, subsequent references are not guaranteed to set</span>
<span class="cm"> * it again until the translation has been flushed from the TLB.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit is ignored in level-1 PTEs unless the Page bit is set.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_ACCESSED              (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_ACCESSED)</span>

<span class="cm">/** Is this mapping dirty?</span>
<span class="cm"> *</span>
<span class="cm"> * This bit is set by the hypervisor when the memory described by the</span>
<span class="cm"> * translation is written for the first time.  It is never cleared by</span>
<span class="cm"> * the hypervisor, but may be cleared by the client.  After the bit</span>
<span class="cm"> * has been cleared, subsequent references are not guaranteed to set</span>
<span class="cm"> * it again until the translation has been flushed from the TLB.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit is ignored in level-1 PTEs unless the Page bit is set.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_DIRTY                 (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_DIRTY)</span>

<span class="cm">/** Migrating bit in PTE.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit is guaranteed not to be inspected or modified by the</span>
<span class="cm"> * hypervisor.  The name is indicative of the suggested use by the client</span>
<span class="cm"> * to tag pages whose L3 cache is being migrated from one cpu to another.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_MIGRATING             (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_MIGRATING)</span>

<span class="cm">/** Client-private bit in PTE.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit is guaranteed not to be inspected or modified by the</span>
<span class="cm"> * hypervisor.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_CLIENT0               (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_CLIENT0)</span>

<span class="cm">/** Client-private bit in PTE.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit is guaranteed not to be inspected or modified by the</span>
<span class="cm"> * hypervisor.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_CLIENT1               (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_CLIENT1)</span>

<span class="cm">/** Client-private bit in PTE.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit is guaranteed not to be inspected or modified by the</span>
<span class="cm"> * hypervisor.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_CLIENT2               (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_CLIENT2)</span>

<span class="cm">/** Non-coherent (NC) bit in PTE.</span>
<span class="cm"> *</span>
<span class="cm"> * If this bit is set, the mapping that is set up will be non-coherent</span>
<span class="cm"> * (also known as non-inclusive).  This means that changes to the L3</span>
<span class="cm"> * cache will not cause a local copy to be invalidated.  It is generally</span>
<span class="cm"> * recommended only for read-only mappings.</span>
<span class="cm"> *</span>
<span class="cm"> * In level-1 PTEs, if the Page bit is clear, this bit determines how the</span>
<span class="cm"> * level-2 page table is accessed.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_NC                    (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_NC)</span>

<span class="cm">/** Is this page prevented from filling the L1$?</span>
<span class="cm"> *</span>
<span class="cm"> * If this bit is set, the page described by the PTE will not be cached</span>
<span class="cm"> * the local cpu&#39;s L1 cache.</span>
<span class="cm"> *</span>
<span class="cm"> * If CHIP_HAS_NC_AND_NOALLOC_BITS() is not true in &lt;chip.h&gt; for this chip,</span>
<span class="cm"> * it is illegal to use this attribute, and may cause client termination.</span>
<span class="cm"> *</span>
<span class="cm"> * In level-1 PTEs, if the Page bit is clear, this bit</span>
<span class="cm"> * determines how the level-2 page table is accessed.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_NO_ALLOC_L1           (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_NO_ALLOC_L1)</span>

<span class="cm">/** Is this page prevented from filling the L2$?</span>
<span class="cm"> *</span>
<span class="cm"> * If this bit is set, the page described by the PTE will not be cached</span>
<span class="cm"> * the local cpu&#39;s L2 cache.</span>
<span class="cm"> *</span>
<span class="cm"> * If CHIP_HAS_NC_AND_NOALLOC_BITS() is not true in &lt;chip.h&gt; for this chip,</span>
<span class="cm"> * it is illegal to use this attribute, and may cause client termination.</span>
<span class="cm"> *</span>
<span class="cm"> * In level-1 PTEs, if the Page bit is clear, this bit determines how the</span>
<span class="cm"> * level-2 page table is accessed.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_NO_ALLOC_L2           (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_NO_ALLOC_L2)</span>

<span class="cm">/** Is this a priority page?</span>
<span class="cm"> *</span>
<span class="cm"> * If this bit is set, the page described by the PTE will be given</span>
<span class="cm"> * priority in the cache.  Normally this translates into allowing the</span>
<span class="cm"> * page to use only the &quot;red&quot; half of the cache.  The client may wish to</span>
<span class="cm"> * then use the hv_set_caching service to specify that other pages which</span>
<span class="cm"> * alias this page will use only the &quot;black&quot; half of the cache.</span>
<span class="cm"> *</span>
<span class="cm"> * If the Cached Priority bit is clear, the hypervisor uses the</span>
<span class="cm"> * current hv_set_caching() value to choose how to cache the page.</span>
<span class="cm"> *</span>
<span class="cm"> * It is illegal to set the Cached Priority bit if the Non-Cached bit</span>
<span class="cm"> * is set and the Cached Remotely bit is clear, i.e. if requests to</span>
<span class="cm"> * the page map directly to memory.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit is ignored in level-1 PTEs unless the Page bit is set.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_CACHED_PRIORITY       (__HV_PTE_ONE &lt;&lt; \</span>
<span class="cp">                                      HV_PTE_INDEX_CACHED_PRIORITY)</span>

<span class="cm">/** Is this a readable mapping?</span>
<span class="cm"> *</span>
<span class="cm"> * If this bit is set, code will be permitted to read from (e.g.,</span>
<span class="cm"> * issue load instructions against) the virtual addresses mapped by</span>
<span class="cm"> * this PTE.</span>
<span class="cm"> *</span>
<span class="cm"> * It is illegal for this bit to be clear if the Writable bit is set.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit is ignored in level-1 PTEs unless the Page bit is set.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_READABLE              (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_READABLE)</span>

<span class="cm">/** Is this a writable mapping?</span>
<span class="cm"> *</span>
<span class="cm"> * If this bit is set, code will be permitted to write to (e.g., issue</span>
<span class="cm"> * store instructions against) the virtual addresses mapped by this</span>
<span class="cm"> * PTE.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit is ignored in level-1 PTEs unless the Page bit is set.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_WRITABLE              (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_WRITABLE)</span>

<span class="cm">/** Is this an executable mapping?</span>
<span class="cm"> *</span>
<span class="cm"> * If this bit is set, code will be permitted to execute from</span>
<span class="cm"> * (e.g., jump to) the virtual addresses mapped by this PTE.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit applies to any processor on the tile, if there are more</span>
<span class="cm"> * than one.</span>
<span class="cm"> *</span>
<span class="cm"> * This bit is ignored in level-1 PTEs unless the Page bit is set.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_PTE_EXECUTABLE            (__HV_PTE_ONE &lt;&lt; HV_PTE_INDEX_EXECUTABLE)</span>

<span class="cm">/** The width of a LOTAR&#39;s x or y bitfield. */</span>
<span class="cp">#define HV_LOTAR_WIDTH 11</span>

<span class="cm">/** Converts an x,y pair to a LOTAR value. */</span>
<span class="cp">#define HV_XY_TO_LOTAR(x, y) ((HV_LOTAR)(((x) &lt;&lt; HV_LOTAR_WIDTH) | (y)))</span>

<span class="cm">/** Extracts the X component of a lotar. */</span>
<span class="cp">#define HV_LOTAR_X(lotar) ((lotar) &gt;&gt; HV_LOTAR_WIDTH)</span>

<span class="cm">/** Extracts the Y component of a lotar. */</span>
<span class="cp">#define HV_LOTAR_Y(lotar) ((lotar) &amp; ((1 &lt;&lt; HV_LOTAR_WIDTH) - 1))</span>

<span class="cp">#ifndef __ASSEMBLER__</span>

<span class="cm">/** Define accessor functions for a PTE bit. */</span>
<span class="cp">#define _HV_BIT(name, bit)                                      \</span>
<span class="cp">static __inline int                                             \</span>
<span class="cp">hv_pte_get_##name(HV_PTE pte)                                   \</span>
<span class="cp">{                                                               \</span>
<span class="cp">  return (pte.val &gt;&gt; HV_PTE_INDEX_##bit) &amp; 1;                   \</span>
<span class="cp">}                                                               \</span>
<span class="cp">                                                                \</span>
<span class="cp">static __inline HV_PTE                                          \</span>
<span class="cp">hv_pte_set_##name(HV_PTE pte)                                   \</span>
<span class="cp">{                                                               \</span>
<span class="cp">  pte.val |= 1ULL &lt;&lt; HV_PTE_INDEX_##bit;                        \</span>
<span class="cp">  return pte;                                                   \</span>
<span class="cp">}                                                               \</span>
<span class="cp">                                                                \</span>
<span class="cp">static __inline HV_PTE                                          \</span>
<span class="cp">hv_pte_clear_##name(HV_PTE pte)                                 \</span>
<span class="cp">{                                                               \</span>
<span class="cp">  pte.val &amp;= ~(1ULL &lt;&lt; HV_PTE_INDEX_##bit);                     \</span>
<span class="cp">  return pte;                                                   \</span>
<span class="cp">}</span>

<span class="cm">/* Generate accessors to get, set, and clear various PTE flags.</span>
<span class="cm"> */</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">present</span><span class="p">,</span>         <span class="n">PRESENT</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">page</span><span class="p">,</span>            <span class="n">PAGE</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">super</span><span class="p">,</span>           <span class="n">SUPER</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">client0</span><span class="p">,</span>         <span class="n">CLIENT0</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">client1</span><span class="p">,</span>         <span class="n">CLIENT1</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">client2</span><span class="p">,</span>         <span class="n">CLIENT2</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">migrating</span><span class="p">,</span>       <span class="n">MIGRATING</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span>              <span class="n">NC</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">readable</span><span class="p">,</span>        <span class="n">READABLE</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">writable</span><span class="p">,</span>        <span class="n">WRITABLE</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">executable</span><span class="p">,</span>      <span class="n">EXECUTABLE</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">accessed</span><span class="p">,</span>        <span class="n">ACCESSED</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">dirty</span><span class="p">,</span>           <span class="n">DIRTY</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">no_alloc_l1</span><span class="p">,</span>     <span class="n">NO_ALLOC_L1</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">no_alloc_l2</span><span class="p">,</span>     <span class="n">NO_ALLOC_L2</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">cached_priority</span><span class="p">,</span> <span class="n">CACHED_PRIORITY</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">global</span><span class="p">,</span>          <span class="n">GLOBAL</span><span class="p">)</span>
<span class="n">_HV_BIT</span><span class="p">(</span><span class="n">user</span><span class="p">,</span>            <span class="n">USER</span><span class="p">)</span>

<span class="cp">#undef _HV_BIT</span>

<span class="cm">/** Get the page mode from the PTE.</span>
<span class="cm"> *</span>
<span class="cm"> * This field generally determines whether and how accesses to the page</span>
<span class="cm"> * are cached; the HV_PTE_MODE_xxx symbols define the legal values for the</span>
<span class="cm"> * page mode.  The NC, NO_ALLOC_L1, and NO_ALLOC_L2 bits modify this</span>
<span class="cm"> * general policy.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="n">hv_pte_get_mode</span><span class="p">(</span><span class="k">const</span> <span class="n">HV_PTE</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(((</span><span class="n">__hv32</span><span class="p">)</span> <span class="n">pte</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">HV_PTE_INDEX_MODE</span><span class="p">)</span> <span class="o">&amp;</span>
         <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">HV_PTE_MODE_BITS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/** Set the page mode into a PTE.  See hv_pte_get_mode. */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">HV_PTE</span>
<span class="n">hv_pte_set_mode</span><span class="p">(</span><span class="n">HV_PTE</span> <span class="n">pte</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">pte</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(((</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">HV_PTE_MODE_BITS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">HV_PTE_INDEX_MODE</span><span class="p">);</span>
  <span class="n">pte</span><span class="p">.</span><span class="n">val</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">HV_PTE_INDEX_MODE</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** Get the page frame number from the PTE.</span>
<span class="cm"> *</span>
<span class="cm"> * This field contains the upper bits of the CPA (client physical</span>
<span class="cm"> * address) of the target page; the complete CPA is this field with</span>
<span class="cm"> * HV_LOG2_PAGE_TABLE_ALIGN zero bits appended to it.</span>
<span class="cm"> *</span>
<span class="cm"> * For all PTEs in the lowest-level page table, and for all PTEs with</span>
<span class="cm"> * the Page bit set in all page tables, the CPA must be aligned modulo</span>
<span class="cm"> * the relevant page size.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="n">hv_pte_get_ptfn</span><span class="p">(</span><span class="k">const</span> <span class="n">HV_PTE</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">pte</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="n">HV_PTE_INDEX_PTFN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** Set the page table frame number into a PTE.  See hv_pte_get_ptfn. */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">HV_PTE</span>
<span class="n">hv_pte_set_ptfn</span><span class="p">(</span><span class="n">HV_PTE</span> <span class="n">pte</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">pte</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(((</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">HV_PTE_PTFN_BITS</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">HV_PTE_INDEX_PTFN</span><span class="p">);</span>
  <span class="n">pte</span><span class="p">.</span><span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="n">__hv64</span><span class="p">)</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">HV_PTE_INDEX_PTFN</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** Get the client physical address from the PTE.  See hv_pte_set_ptfn. */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">HV_PhysAddr</span>
<span class="n">hv_pte_get_pa</span><span class="p">(</span><span class="k">const</span> <span class="n">HV_PTE</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">__hv64</span><span class="p">)</span> <span class="n">hv_pte_get_ptfn</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">HV_LOG2_PAGE_TABLE_ALIGN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** Set the client physical address into a PTE.  See hv_pte_get_ptfn. */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">HV_PTE</span>
<span class="n">hv_pte_set_pa</span><span class="p">(</span><span class="n">HV_PTE</span> <span class="n">pte</span><span class="p">,</span> <span class="n">HV_PhysAddr</span> <span class="n">pa</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">hv_pte_set_ptfn</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">pa</span> <span class="o">&gt;&gt;</span> <span class="n">HV_LOG2_PAGE_TABLE_ALIGN</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Get the remote tile caching this page.</span>
<span class="cm"> *</span>
<span class="cm"> * Specifies the remote tile which is providing the L3 cache for this page.</span>
<span class="cm"> *</span>
<span class="cm"> * This field is ignored unless the page mode is HV_PTE_MODE_CACHE_TILE_L3.</span>
<span class="cm"> *</span>
<span class="cm"> * In level-1 PTEs, if the Page bit is clear, this field determines how the</span>
<span class="cm"> * level-2 page table is accessed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="n">hv_pte_get_lotar</span><span class="p">(</span><span class="k">const</span> <span class="n">HV_PTE</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lotar</span> <span class="o">=</span> <span class="p">((</span><span class="n">__hv32</span><span class="p">)</span> <span class="n">pte</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">HV_PTE_INDEX_LOTAR</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">HV_XY_TO_LOTAR</span><span class="p">(</span> <span class="p">(</span><span class="n">lotar</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">HV_PTE_LOTAR_BITS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span>
                         <span class="p">(</span><span class="n">lotar</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">HV_PTE_LOTAR_BITS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Set the remote tile caching a page into a PTE.  See hv_pte_get_lotar. */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">HV_PTE</span>
<span class="n">hv_pte_set_lotar</span><span class="p">(</span><span class="n">HV_PTE</span> <span class="n">pte</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">HV_LOTAR_X</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">HV_LOTAR_Y</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>

  <span class="n">pte</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(((</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">HV_PTE_LOTAR_BITS</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">HV_PTE_INDEX_LOTAR</span><span class="p">);</span>
  <span class="n">pte</span><span class="p">.</span><span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">HV_PTE_INDEX_LOTAR</span> <span class="o">+</span> <span class="n">HV_PTE_LOTAR_BITS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span>
             <span class="p">(</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">HV_PTE_INDEX_LOTAR</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif  </span><span class="cm">/* !__ASSEMBLER__ */</span><span class="cp"></span>

<span class="cm">/** Converts a client physical address to a ptfn. */</span>
<span class="cp">#define HV_CPA_TO_PTFN(p) ((p) &gt;&gt; HV_LOG2_PAGE_TABLE_ALIGN)</span>

<span class="cm">/** Converts a ptfn to a client physical address. */</span>
<span class="cp">#define HV_PTFN_TO_CPA(p) (((HV_PhysAddr)(p)) &lt;&lt; HV_LOG2_PAGE_TABLE_ALIGN)</span>

<span class="cp">#if CHIP_VA_WIDTH() &gt; 32</span>

<span class="cm">/*</span>
<span class="cm"> * Note that we currently do not allow customizing the page size</span>
<span class="cm"> * of the L0 pages, but fix them at 4GB, so we do not use the</span>
<span class="cm"> * &quot;_HV_xxx&quot; nomenclature for the L0 macros.</span>
<span class="cm"> */</span>

<span class="cm">/** Log number of HV_PTE entries in L0 page table */</span>
<span class="cp">#define HV_LOG2_L0_ENTRIES (CHIP_VA_WIDTH() - HV_LOG2_L1_SPAN)</span>

<span class="cm">/** Number of HV_PTE entries in L0 page table */</span>
<span class="cp">#define HV_L0_ENTRIES (1 &lt;&lt; HV_LOG2_L0_ENTRIES)</span>

<span class="cm">/** Log size of L0 page table in bytes */</span>
<span class="cp">#define HV_LOG2_L0_SIZE (HV_LOG2_PTE_SIZE + HV_LOG2_L0_ENTRIES)</span>

<span class="cm">/** Size of L0 page table in bytes */</span>
<span class="cp">#define HV_L0_SIZE (1 &lt;&lt; HV_LOG2_L0_SIZE)</span>

<span class="cp">#ifdef __ASSEMBLER__</span>

<span class="cm">/** Index in L0 for a specific VA */</span>
<span class="cp">#define HV_L0_INDEX(va) \</span>
<span class="cp">  (((va) &gt;&gt; HV_LOG2_L1_SPAN) &amp; (HV_L0_ENTRIES - 1))</span>

<span class="cp">#else</span>

<span class="cm">/** Index in L1 for a specific VA */</span>
<span class="cp">#define HV_L0_INDEX(va) \</span>
<span class="cp">  (((HV_VirtAddr)(va) &gt;&gt; HV_LOG2_L1_SPAN) &amp; (HV_L0_ENTRIES - 1))</span>

<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* CHIP_VA_WIDTH() &gt; 32 */</span><span class="cp"></span>

<span class="cm">/** Log number of HV_PTE entries in L1 page table */</span>
<span class="cp">#define _HV_LOG2_L1_ENTRIES(log2_page_size_large) \</span>
<span class="cp">  (HV_LOG2_L1_SPAN - log2_page_size_large)</span>

<span class="cm">/** Number of HV_PTE entries in L1 page table */</span>
<span class="cp">#define _HV_L1_ENTRIES(log2_page_size_large) \</span>
<span class="cp">  (1 &lt;&lt; _HV_LOG2_L1_ENTRIES(log2_page_size_large))</span>

<span class="cm">/** Log size of L1 page table in bytes */</span>
<span class="cp">#define _HV_LOG2_L1_SIZE(log2_page_size_large) \</span>
<span class="cp">  (HV_LOG2_PTE_SIZE + _HV_LOG2_L1_ENTRIES(log2_page_size_large))</span>

<span class="cm">/** Size of L1 page table in bytes */</span>
<span class="cp">#define _HV_L1_SIZE(log2_page_size_large) \</span>
<span class="cp">  (1 &lt;&lt; _HV_LOG2_L1_SIZE(log2_page_size_large))</span>

<span class="cm">/** Log number of HV_PTE entries in level-2 page table */</span>
<span class="cp">#define _HV_LOG2_L2_ENTRIES(log2_page_size_large, log2_page_size_small) \</span>
<span class="cp">  (log2_page_size_large - log2_page_size_small)</span>

<span class="cm">/** Number of HV_PTE entries in level-2 page table */</span>
<span class="cp">#define _HV_L2_ENTRIES(log2_page_size_large, log2_page_size_small) \</span>
<span class="cp">  (1 &lt;&lt; _HV_LOG2_L2_ENTRIES(log2_page_size_large, log2_page_size_small))</span>

<span class="cm">/** Log size of level-2 page table in bytes */</span>
<span class="cp">#define _HV_LOG2_L2_SIZE(log2_page_size_large, log2_page_size_small) \</span>
<span class="cp">  (HV_LOG2_PTE_SIZE + \</span>
<span class="cp">   _HV_LOG2_L2_ENTRIES(log2_page_size_large, log2_page_size_small))</span>

<span class="cm">/** Size of level-2 page table in bytes */</span>
<span class="cp">#define _HV_L2_SIZE(log2_page_size_large, log2_page_size_small) \</span>
<span class="cp">  (1 &lt;&lt; _HV_LOG2_L2_SIZE(log2_page_size_large, log2_page_size_small))</span>

<span class="cp">#ifdef __ASSEMBLER__</span>

<span class="cp">#if CHIP_VA_WIDTH() &gt; 32</span>

<span class="cm">/** Index in L1 for a specific VA */</span>
<span class="cp">#define _HV_L1_INDEX(va, log2_page_size_large) \</span>
<span class="cp">  (((va) &gt;&gt; log2_page_size_large) &amp; (_HV_L1_ENTRIES(log2_page_size_large) - 1))</span>

<span class="cp">#else </span><span class="cm">/* CHIP_VA_WIDTH() &gt; 32 */</span><span class="cp"></span>

<span class="cm">/** Index in L1 for a specific VA */</span>
<span class="cp">#define _HV_L1_INDEX(va, log2_page_size_large) \</span>
<span class="cp">  (((va) &gt;&gt; log2_page_size_large))</span>

<span class="cp">#endif </span><span class="cm">/* CHIP_VA_WIDTH() &gt; 32 */</span><span class="cp"></span>

<span class="cm">/** Index in level-2 page table for a specific VA */</span>
<span class="cp">#define _HV_L2_INDEX(va, log2_page_size_large, log2_page_size_small) \</span>
<span class="cp">  (((va) &gt;&gt; log2_page_size_small) &amp; \</span>
<span class="cp">   (_HV_L2_ENTRIES(log2_page_size_large, log2_page_size_small) - 1))</span>

<span class="cp">#else </span><span class="cm">/* __ASSEMBLER __ */</span><span class="cp"></span>

<span class="cp">#if CHIP_VA_WIDTH() &gt; 32</span>

<span class="cm">/** Index in L1 for a specific VA */</span>
<span class="cp">#define _HV_L1_INDEX(va, log2_page_size_large) \</span>
<span class="cp">  (((HV_VirtAddr)(va) &gt;&gt; log2_page_size_large) &amp; \</span>
<span class="cp">   (_HV_L1_ENTRIES(log2_page_size_large) - 1))</span>

<span class="cp">#else </span><span class="cm">/* CHIP_VA_WIDTH() &gt; 32 */</span><span class="cp"></span>

<span class="cm">/** Index in L1 for a specific VA */</span>
<span class="cp">#define _HV_L1_INDEX(va, log2_page_size_large) \</span>
<span class="cp">  (((HV_VirtAddr)(va) &gt;&gt; log2_page_size_large))</span>

<span class="cp">#endif </span><span class="cm">/* CHIP_VA_WIDTH() &gt; 32 */</span><span class="cp"></span>

<span class="cm">/** Index in level-2 page table for a specific VA */</span>
<span class="cp">#define _HV_L2_INDEX(va, log2_page_size_large, log2_page_size_small) \</span>
<span class="cp">  (((HV_VirtAddr)(va) &gt;&gt; log2_page_size_small) &amp; \</span>
<span class="cp">   (_HV_L2_ENTRIES(log2_page_size_large, log2_page_size_small) - 1))</span>

<span class="cp">#endif </span><span class="cm">/* __ASSEMBLER __ */</span><span class="cp"></span>

<span class="cm">/** Position of the PFN field within the PTE (subset of the PTFN). */</span>
<span class="cp">#define _HV_PTE_INDEX_PFN(log2_page_size) \</span>
<span class="cp">  (HV_PTE_INDEX_PTFN + (log2_page_size - HV_LOG2_PAGE_TABLE_ALIGN))</span>

<span class="cm">/** Length of the PFN field within the PTE (subset of the PTFN). */</span>
<span class="cp">#define _HV_PTE_INDEX_PFN_BITS(log2_page_size) \</span>
<span class="cp">  (HV_PTE_INDEX_PTFN_BITS - (log2_page_size - HV_LOG2_PAGE_TABLE_ALIGN))</span>

<span class="cm">/** Converts a client physical address to a pfn. */</span>
<span class="cp">#define _HV_CPA_TO_PFN(p, log2_page_size) ((p) &gt;&gt; log2_page_size)</span>

<span class="cm">/** Converts a pfn to a client physical address. */</span>
<span class="cp">#define _HV_PFN_TO_CPA(p, log2_page_size) \</span>
<span class="cp">  (((HV_PhysAddr)(p)) &lt;&lt; log2_page_size)</span>

<span class="cm">/** Converts a ptfn to a pfn. */</span>
<span class="cp">#define _HV_PTFN_TO_PFN(p, log2_page_size) \</span>
<span class="cp">  ((p) &gt;&gt; (log2_page_size - HV_LOG2_PAGE_TABLE_ALIGN))</span>

<span class="cm">/** Converts a pfn to a ptfn. */</span>
<span class="cp">#define _HV_PFN_TO_PTFN(p, log2_page_size) \</span>
<span class="cp">  ((p) &lt;&lt; (log2_page_size - HV_LOG2_PAGE_TABLE_ALIGN))</span>

<span class="cp">#endif </span><span class="cm">/* _HV_HV_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
