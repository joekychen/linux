<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › include › hv › netio_intf.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>netio_intf.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * NetIO interface structures and macros.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __NETIO_INTF_H__</span>
<span class="cp">#define __NETIO_INTF_H__</span>

<span class="cp">#include &lt;hv/netio_errors.h&gt;</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;stdint.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(__HV__) &amp;&amp; !defined(__BOGUX__) &amp;&amp; !defined(__KERNEL__)</span>
<span class="cp">#include &lt;assert.h&gt;</span>
<span class="cp">#define netio_assert assert  </span><span class="cm">/**&lt; Enable assertions from macros */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define netio_assert(...) ((void)(0))  </span><span class="cm">/**&lt; Disable assertions from macros */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * If none of these symbols are defined, we&#39;re building libnetio in an</span>
<span class="cm"> * environment where we have pthreads, so we&#39;ll enable locking.</span>
<span class="cm"> */</span>
<span class="cp">#if !defined(__HV__) &amp;&amp; !defined(__BOGUX__) &amp;&amp; !defined(__KERNEL__) &amp;&amp; \</span>
<span class="cp">    !defined(__NEWLIB__)</span>
<span class="cp">#define _NETIO_PTHREAD       </span><span class="cm">/**&lt; Include a mutex in netio_queue_t below */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * If NETIO_UNLOCKED is defined, we don&#39;t do use per-cpu locks on</span>
<span class="cm"> * per-packet NetIO operations.  We still do pthread locking on things</span>
<span class="cm"> * like netio_input_register, though.  This is used for building</span>
<span class="cm"> * libnetio_unlocked.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef NETIO_UNLOCKED</span>

<span class="cm">/* Avoid PLT overhead by using our own inlined per-cpu lock. */</span>
<span class="cp">#include &lt;sched.h&gt;</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">_netio_percpu_mutex_t</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">int</span>
<span class="nf">_netio_percpu_mutex_init</span><span class="p">(</span><span class="n">_netio_percpu_mutex_t</span><span class="o">*</span> <span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">int</span>
<span class="nf">_netio_percpu_mutex_lock</span><span class="p">(</span><span class="n">_netio_percpu_mutex_t</span><span class="o">*</span> <span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">__builtin_expect</span><span class="p">(</span><span class="n">__insn_tns</span><span class="p">(</span><span class="n">lock</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">sched_yield</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">int</span>
<span class="nf">_netio_percpu_mutex_unlock</span><span class="p">(</span><span class="n">_netio_percpu_mutex_t</span><span class="o">*</span> <span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* NETIO_UNLOCKED */</span><span class="cp"></span>

<span class="cm">/* Don&#39;t do any locking for per-packet NetIO operations. */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">_netio_percpu_mutex_t</span><span class="p">;</span>
<span class="cp">#define _netio_percpu_mutex_init(L)</span>
<span class="cp">#define _netio_percpu_mutex_lock(L)</span>
<span class="cp">#define _netio_percpu_mutex_unlock(L)</span>

<span class="cp">#endif </span><span class="cm">/* NETIO_UNLOCKED */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* !__HV__, !__BOGUX, !__KERNEL__, !__NEWLIB__ */</span><span class="cp"></span>

<span class="cm">/** How many tiles can register for a given queue.</span>
<span class="cm"> *  @ingroup setup */</span>
<span class="cp">#define NETIO_MAX_TILES_PER_QUEUE  64</span>


<span class="cm">/** Largest permissible queue identifier.</span>
<span class="cm"> *  @ingroup setup  */</span>
<span class="cp">#define NETIO_MAX_QUEUE_ID        255</span>


<span class="cp">#ifndef __DOXYGEN__</span>

<span class="cm">/* Metadata packet checksum/ethertype flags. */</span>

<span class="cm">/** The L4 checksum has not been calculated. */</span>
<span class="cp">#define _NETIO_PKT_NO_L4_CSUM_SHIFT           0</span>
<span class="cp">#define _NETIO_PKT_NO_L4_CSUM_RMASK           1</span>
<span class="cp">#define _NETIO_PKT_NO_L4_CSUM_MASK \</span>
<span class="cp">         (_NETIO_PKT_NO_L4_CSUM_RMASK &lt;&lt; _NETIO_PKT_NO_L4_CSUM_SHIFT)</span>

<span class="cm">/** The L3 checksum has not been calculated. */</span>
<span class="cp">#define _NETIO_PKT_NO_L3_CSUM_SHIFT           1</span>
<span class="cp">#define _NETIO_PKT_NO_L3_CSUM_RMASK           1</span>
<span class="cp">#define _NETIO_PKT_NO_L3_CSUM_MASK \</span>
<span class="cp">         (_NETIO_PKT_NO_L3_CSUM_RMASK &lt;&lt; _NETIO_PKT_NO_L3_CSUM_SHIFT)</span>

<span class="cm">/** The L3 checksum is incorrect (or perhaps has not been calculated). */</span>
<span class="cp">#define _NETIO_PKT_BAD_L3_CSUM_SHIFT          2</span>
<span class="cp">#define _NETIO_PKT_BAD_L3_CSUM_RMASK          1</span>
<span class="cp">#define _NETIO_PKT_BAD_L3_CSUM_MASK \</span>
<span class="cp">         (_NETIO_PKT_BAD_L3_CSUM_RMASK &lt;&lt; _NETIO_PKT_BAD_L3_CSUM_SHIFT)</span>

<span class="cm">/** The Ethernet packet type is unrecognized. */</span>
<span class="cp">#define _NETIO_PKT_TYPE_UNRECOGNIZED_SHIFT    3</span>
<span class="cp">#define _NETIO_PKT_TYPE_UNRECOGNIZED_RMASK    1</span>
<span class="cp">#define _NETIO_PKT_TYPE_UNRECOGNIZED_MASK \</span>
<span class="cp">         (_NETIO_PKT_TYPE_UNRECOGNIZED_RMASK &lt;&lt; \</span>
<span class="cp">          _NETIO_PKT_TYPE_UNRECOGNIZED_SHIFT)</span>

<span class="cm">/* Metadata packet type flags. */</span>

<span class="cm">/** Where the packet type bits are; this field is the index into</span>
<span class="cm"> *  _netio_pkt_info. */</span>
<span class="cp">#define _NETIO_PKT_TYPE_SHIFT        4</span>
<span class="cp">#define _NETIO_PKT_TYPE_RMASK        0x3F</span>

<span class="cm">/** How many VLAN tags the packet has, and, if we have two, which one we</span>
<span class="cm"> *  actually grouped on.  A VLAN within a proprietary (Marvell or Broadcom)</span>
<span class="cm"> *  tag is counted here. */</span>
<span class="cp">#define _NETIO_PKT_VLAN_SHIFT        4</span>
<span class="cp">#define _NETIO_PKT_VLAN_RMASK        0x3</span>
<span class="cp">#define _NETIO_PKT_VLAN_MASK \</span>
<span class="cp">         (_NETIO_PKT_VLAN_RMASK &lt;&lt; _NETIO_PKT_VLAN_SHIFT)</span>
<span class="cp">#define _NETIO_PKT_VLAN_NONE         0   </span><span class="cm">/* No VLAN tag. */</span><span class="cp"></span>
<span class="cp">#define _NETIO_PKT_VLAN_ONE          1   </span><span class="cm">/* One VLAN tag. */</span><span class="cp"></span>
<span class="cp">#define _NETIO_PKT_VLAN_TWO_OUTER    2   </span><span class="cm">/* Two VLAN tags, outer one used. */</span><span class="cp"></span>
<span class="cp">#define _NETIO_PKT_VLAN_TWO_INNER    3   </span><span class="cm">/* Two VLAN tags, inner one used. */</span><span class="cp"></span>

<span class="cm">/** Which proprietary tags the packet has. */</span>
<span class="cp">#define _NETIO_PKT_TAG_SHIFT         6</span>
<span class="cp">#define _NETIO_PKT_TAG_RMASK         0x3</span>
<span class="cp">#define _NETIO_PKT_TAG_MASK \</span>
<span class="cp">          (_NETIO_PKT_TAG_RMASK &lt;&lt; _NETIO_PKT_TAG_SHIFT)</span>
<span class="cp">#define _NETIO_PKT_TAG_NONE          0   </span><span class="cm">/* No proprietary tags. */</span><span class="cp"></span>
<span class="cp">#define _NETIO_PKT_TAG_MRVL          1   </span><span class="cm">/* Marvell HyperG.Stack tags. */</span><span class="cp"></span>
<span class="cp">#define _NETIO_PKT_TAG_MRVL_EXT      2   </span><span class="cm">/* HyperG.Stack extended tags. */</span><span class="cp"></span>
<span class="cp">#define _NETIO_PKT_TAG_BRCM          3   </span><span class="cm">/* Broadcom HiGig tags. */</span><span class="cp"></span>

<span class="cm">/** Whether a packet has an LLC + SNAP header. */</span>
<span class="cp">#define _NETIO_PKT_SNAP_SHIFT        8</span>
<span class="cp">#define _NETIO_PKT_SNAP_RMASK        0x1</span>
<span class="cp">#define _NETIO_PKT_SNAP_MASK \</span>
<span class="cp">          (_NETIO_PKT_SNAP_RMASK &lt;&lt; _NETIO_PKT_SNAP_SHIFT)</span>

<span class="cm">/* NOTE: Bits 9 and 10 are unused. */</span>

<span class="cm">/** Length of any custom data before the L2 header, in words. */</span>
<span class="cp">#define _NETIO_PKT_CUSTOM_LEN_SHIFT  11</span>
<span class="cp">#define _NETIO_PKT_CUSTOM_LEN_RMASK  0x1F</span>
<span class="cp">#define _NETIO_PKT_CUSTOM_LEN_MASK \</span>
<span class="cp">          (_NETIO_PKT_CUSTOM_LEN_RMASK &lt;&lt; _NETIO_PKT_CUSTOM_LEN_SHIFT)</span>

<span class="cm">/** The L4 checksum is incorrect (or perhaps has not been calculated). */</span>
<span class="cp">#define _NETIO_PKT_BAD_L4_CSUM_SHIFT 16</span>
<span class="cp">#define _NETIO_PKT_BAD_L4_CSUM_RMASK 0x1</span>
<span class="cp">#define _NETIO_PKT_BAD_L4_CSUM_MASK \</span>
<span class="cp">          (_NETIO_PKT_BAD_L4_CSUM_RMASK &lt;&lt; _NETIO_PKT_BAD_L4_CSUM_SHIFT)</span>

<span class="cm">/** Length of the L2 header, in words. */</span>
<span class="cp">#define _NETIO_PKT_L2_LEN_SHIFT  17</span>
<span class="cp">#define _NETIO_PKT_L2_LEN_RMASK  0x1F</span>
<span class="cp">#define _NETIO_PKT_L2_LEN_MASK \</span>
<span class="cp">          (_NETIO_PKT_L2_LEN_RMASK &lt;&lt; _NETIO_PKT_L2_LEN_SHIFT)</span>


<span class="cm">/* Flags in minimal packet metadata. */</span>

<span class="cm">/** We need an eDMA checksum on this packet. */</span>
<span class="cp">#define _NETIO_PKT_NEED_EDMA_CSUM_SHIFT            0</span>
<span class="cp">#define _NETIO_PKT_NEED_EDMA_CSUM_RMASK            1</span>
<span class="cp">#define _NETIO_PKT_NEED_EDMA_CSUM_MASK \</span>
<span class="cp">         (_NETIO_PKT_NEED_EDMA_CSUM_RMASK &lt;&lt; _NETIO_PKT_NEED_EDMA_CSUM_SHIFT)</span>

<span class="cm">/* Data within the packet information table. */</span>

<span class="cm">/* Note that, for efficiency, code which uses these fields assumes that none</span>
<span class="cm"> * of the shift values below are zero.  See uses below for an explanation. */</span>

<span class="cm">/** Offset within the L2 header of the innermost ethertype (in halfwords). */</span>
<span class="cp">#define _NETIO_PKT_INFO_ETYPE_SHIFT       6</span>
<span class="cp">#define _NETIO_PKT_INFO_ETYPE_RMASK    0x1F</span>

<span class="cm">/** Offset within the L2 header of the VLAN tag (in halfwords). */</span>
<span class="cp">#define _NETIO_PKT_INFO_VLAN_SHIFT       11</span>
<span class="cp">#define _NETIO_PKT_INFO_VLAN_RMASK     0x1F</span>

<span class="cp">#endif</span>


<span class="cm">/** The size of a memory buffer representing a small packet.</span>
<span class="cm"> *  @ingroup egress */</span>
<span class="cp">#define SMALL_PACKET_SIZE 256</span>

<span class="cm">/** The size of a memory buffer representing a large packet.</span>
<span class="cm"> *  @ingroup egress */</span>
<span class="cp">#define LARGE_PACKET_SIZE 2048</span>

<span class="cm">/** The size of a memory buffer representing a jumbo packet.</span>
<span class="cm"> *  @ingroup egress */</span>
<span class="cp">#define JUMBO_PACKET_SIZE (12 * 1024)</span>


<span class="cm">/* Common ethertypes.</span>
<span class="cm"> * @ingroup ingress */</span>
<span class="cm">/** @{ */</span>
<span class="cm">/** The ethertype of IPv4. */</span>
<span class="cp">#define ETHERTYPE_IPv4 (0x0800)</span>
<span class="cm">/** The ethertype of ARP. */</span>
<span class="cp">#define ETHERTYPE_ARP (0x0806)</span>
<span class="cm">/** The ethertype of VLANs. */</span>
<span class="cp">#define ETHERTYPE_VLAN (0x8100)</span>
<span class="cm">/** The ethertype of a Q-in-Q header. */</span>
<span class="cp">#define ETHERTYPE_Q_IN_Q (0x9100)</span>
<span class="cm">/** The ethertype of IPv6. */</span>
<span class="cp">#define ETHERTYPE_IPv6 (0x86DD)</span>
<span class="cm">/** The ethertype of MPLS. */</span>
<span class="cp">#define ETHERTYPE_MPLS (0x8847)</span>
<span class="cm">/** @} */</span>


<span class="cm">/** The possible return values of NETIO_PKT_STATUS.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span>
<span class="p">{</span>
  <span class="cm">/** No problems were detected with this packet. */</span>
  <span class="n">NETIO_PKT_STATUS_OK</span><span class="p">,</span>
  <span class="cm">/** The packet is undersized; this is expected behavior if the packet&#39;s</span>
<span class="cm">    * ethertype is unrecognized, but otherwise the packet is likely corrupt. */</span>
  <span class="n">NETIO_PKT_STATUS_UNDERSIZE</span><span class="p">,</span>
  <span class="cm">/** The packet is oversized and some trailing bytes have been discarded.</span>
<span class="cm">      This is expected behavior for short packets, since it&#39;s impossible to</span>
<span class="cm">      precisely determine the amount of padding which may have been added to</span>
<span class="cm">      them to make them meet the minimum Ethernet packet size. */</span>
  <span class="n">NETIO_PKT_STATUS_OVERSIZE</span><span class="p">,</span>
  <span class="cm">/** The packet was judged to be corrupt by hardware (for instance, it had</span>
<span class="cm">      a bad CRC, or part of it was discarded due to lack of buffer space in</span>
<span class="cm">      the I/O shim) and should be discarded. */</span>
  <span class="n">NETIO_PKT_STATUS_BAD</span>
<span class="p">}</span> <span class="n">netio_pkt_status_t</span><span class="p">;</span>


<span class="cm">/** Log2 of how many buckets we have. */</span>
<span class="cp">#define NETIO_LOG2_NUM_BUCKETS (10)</span>

<span class="cm">/** How many buckets we have.</span>
<span class="cm"> * @ingroup ingress */</span>
<span class="cp">#define NETIO_NUM_BUCKETS (1 &lt;&lt; NETIO_LOG2_NUM_BUCKETS)</span>


<span class="cm">/**</span>
<span class="cm"> * @brief A group-to-bucket identifier.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup setup</span>
<span class="cm"> *</span>
<span class="cm"> * This tells us what to do with a given group.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
  <span class="cm">/** The header broken down into bits. */</span>
  <span class="k">struct</span> <span class="p">{</span>
    <span class="cm">/** Whether we should balance on L4, if available */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__balance_on_l4</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="cm">/** Whether we should balance on L3, if available */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__balance_on_l3</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="cm">/** Whether we should balance on L2, if available */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__balance_on_l2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="cm">/** Reserved for future use */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__reserved</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="cm">/** The base bucket to use to send traffic */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__bucket_base</span><span class="o">:</span><span class="n">NETIO_LOG2_NUM_BUCKETS</span><span class="p">;</span>
    <span class="cm">/** The mask to apply to the balancing value. This must be one less</span>
<span class="cm">     * than a power of two, e.g. 0x3 or 0xFF.</span>
<span class="cm">     */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__bucket_mask</span><span class="o">:</span><span class="n">NETIO_LOG2_NUM_BUCKETS</span><span class="p">;</span>
    <span class="cm">/** Pad to 32 bits */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__padding</span><span class="o">:</span><span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">NETIO_LOG2_NUM_BUCKETS</span><span class="p">);</span>
  <span class="p">}</span> <span class="n">bits</span><span class="p">;</span>
  <span class="cm">/** To send out the IDN. */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">word</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">netio_group_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * @brief A VLAN-to-bucket identifier.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup setup</span>
<span class="cm"> *</span>
<span class="cm"> * This tells us what to do with a given VLAN.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">netio_group_t</span> <span class="n">netio_vlan_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * A bucket-to-queue mapping.</span>
<span class="cm"> * @ingroup setup</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">netio_bucket_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * A packet size can always fit in a netio_size_t.</span>
<span class="cm"> * @ingroup setup</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">netio_size_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * @brief Ethernet standard (ingress) packet metadata.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * This is additional data associated with each packet.</span>
<span class="cm"> * This structure is opaque and accessed through the @ref ingress.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, the buffer population operation currently assumes that standard</span>
<span class="cm"> * metadata is at least as large as minimal metadata, and will need to be</span>
<span class="cm"> * modified if that is no longer the case.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
<span class="cp">#ifdef __DOXYGEN__</span>
  <span class="cm">/** This structure is opaque. */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">opaque</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
<span class="cp">#else</span>
  <span class="cm">/** The overall ordinal of the packet */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__packet_ordinal</span><span class="p">;</span>
  <span class="cm">/** The ordinal of the packet within the group */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__group_ordinal</span><span class="p">;</span>
  <span class="cm">/** The best flow hash IPP could compute. */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__flow_hash</span><span class="p">;</span>
  <span class="cm">/** Flags pertaining to checksum calculation, packet type, etc. */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
  <span class="cm">/** The first word of &quot;user data&quot;. */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user_data_0</span><span class="p">;</span>
  <span class="cm">/** The second word of &quot;user data&quot;. */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user_data_1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">netio_pkt_metadata_t</span><span class="p">;</span>


<span class="cm">/** To ensure that the L3 header is aligned mod 4, the L2 header should be</span>
<span class="cm"> * aligned mod 4 plus 2, since every supported L2 header is 4n + 2 bytes</span>
<span class="cm"> * long.  The standard way to do this is to simply add 2 bytes of padding</span>
<span class="cm"> * before the L2 header.</span>
<span class="cm"> */</span>
<span class="cp">#define NETIO_PACKET_PADDING 2</span>



<span class="cm">/**</span>
<span class="cm"> * @brief Ethernet minimal (egress) packet metadata.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * This structure represents information about packets which have</span>
<span class="cm"> * been processed by @ref netio_populate_buffer() or</span>
<span class="cm"> * @ref netio_populate_prepend_buffer().  This structure is opaque</span>
<span class="cm"> * and accessed through the @ref egress.</span>
<span class="cm"> *</span>
<span class="cm"> * @internal This structure is actually copied into the memory used by</span>
<span class="cm"> * standard metadata, which is assumed to be large enough.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
<span class="cp">#ifdef __DOXYGEN__</span>
  <span class="cm">/** This structure is opaque. */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">opaque</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>
<span class="cp">#else</span>
  <span class="cm">/** The offset of the L2 header from the start of the packet data. */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">l2_offset</span><span class="p">;</span>
  <span class="cm">/** The offset of the L3 header from the start of the packet data. */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">l3_offset</span><span class="p">;</span>
  <span class="cm">/** Where to write the checksum. */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">csum_location</span><span class="p">;</span>
  <span class="cm">/** Where to start checksumming from. */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">csum_start</span><span class="p">;</span>
  <span class="cm">/** Flags pertaining to checksum calculation etc. */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span><span class="p">;</span>
  <span class="cm">/** The L2 length of the packet. */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">l2_length</span><span class="p">;</span>
  <span class="cm">/** The checksum with which to seed the checksum generator. */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">csum_seed</span><span class="p">;</span>
  <span class="cm">/** How much to checksum. */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">csum_length</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">netio_pkt_minimal_metadata_t</span><span class="p">;</span>


<span class="cp">#ifndef __DOXYGEN__</span>

<span class="cm">/**</span>
<span class="cm"> * @brief An I/O notification header.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the first word of data received from an I/O shim in a notification</span>
<span class="cm"> * packet. It contains framing and status information.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">word</span><span class="p">;</span> <span class="cm">/**&lt; The whole word. */</span>
  <span class="cm">/** The various fields. */</span>
  <span class="k">struct</span>
  <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__channel</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>    <span class="cm">/**&lt; Resource channel. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__type</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>       <span class="cm">/**&lt; Type. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__ack</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>        <span class="cm">/**&lt; Whether an acknowledgement is needed. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__reserved</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>   <span class="cm">/**&lt; Reserved. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__protocol</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>   <span class="cm">/**&lt; A protocol-specific word is added. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__status</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>     <span class="cm">/**&lt; Status of the transfer. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__framing</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>    <span class="cm">/**&lt; Framing of the transfer. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__transfer_size</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span> <span class="cm">/**&lt; Transfer size in bytes (total). */</span>
  <span class="p">}</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__netio_pkt_notif_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * Returns the base address of the packet.</span>
<span class="cm"> */</span>
<span class="cp">#define _NETIO_PKT_HANDLE_BASE(p) \</span>
<span class="cp">  ((unsigned char*)((p).word &amp; 0xFFFFFFC0))</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the base address of the packet.</span>
<span class="cm"> */</span>
<span class="cp">#define _NETIO_PKT_BASE(p) \</span>
<span class="cp">  _NETIO_PKT_HANDLE_BASE(p-&gt;__packet)</span>

<span class="cm">/**</span>
<span class="cm"> * @brief An I/O notification packet (second word)</span>
<span class="cm"> *</span>
<span class="cm"> * This is the second word of data received from an I/O shim in a notification</span>
<span class="cm"> * packet.  This is the virtual address of the packet buffer, plus some flag</span>
<span class="cm"> * bits.  (The virtual address of the packet is always 256-byte aligned so we</span>
<span class="cm"> * have room for 8 bits&#39; worth of flags in the low 8 bits.)</span>
<span class="cm"> *</span>
<span class="cm"> * @internal</span>
<span class="cm"> * NOTE: The low two bits must contain &quot;__queue&quot;, so the &quot;packet size&quot;</span>
<span class="cm"> * (SIZE_SMALL, SIZE_LARGE, or SIZE_JUMBO) can be determined quickly.</span>
<span class="cm"> *</span>
<span class="cm"> * If __addr or __offset are moved, _NETIO_PKT_BASE</span>
<span class="cm"> * (defined right below this) must be changed.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">word</span><span class="p">;</span> <span class="cm">/**&lt; The whole word. */</span>
  <span class="cm">/** The various fields. */</span>
  <span class="k">struct</span>
  <span class="p">{</span>
    <span class="cm">/** Which queue the packet will be returned to once it is sent back to</span>
<span class="cm">        the IPP.  This is one of the SIZE_xxx values. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__queue</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>

    <span class="cm">/** The IPP handle of the sending IPP. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__ipp_handle</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>

    <span class="cm">/** Reserved for future use. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__reserved</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="cm">/** If 1, this packet has minimal (egress) metadata; otherwise, it</span>
<span class="cm">        has standard (ingress) metadata. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__minimal</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

    <span class="cm">/** Offset of the metadata within the packet.  This value is multiplied</span>
<span class="cm">     *  by 64 and added to the base packet address to get the metadata</span>
<span class="cm">     *  address.  Note that this field is aligned within the word such that</span>
<span class="cm">     *  you can easily extract the metadata address with a 26-bit mask. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__offset</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>

    <span class="cm">/** The top 24 bits of the packet&#39;s virtual address. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__addr</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__netio_pkt_handle_t</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* !__DOXYGEN__ */</span><span class="cp"></span>


<span class="cm">/**</span>
<span class="cm"> * @brief A handle for an I/O packet&#39;s storage.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * netio_pkt_handle_t encodes the concept of a ::netio_pkt_t with its</span>
<span class="cm"> * packet metadata removed.  It is a much smaller type that exists to</span>
<span class="cm"> * facilitate applications where the full ::netio_pkt_t type is too</span>
<span class="cm"> * large, such as those that cache enormous numbers of packets or wish</span>
<span class="cm"> * to transmit packet descriptors over the UDN.</span>
<span class="cm"> *</span>
<span class="cm"> * Because there is no metadata, most ::netio_pkt_t operations cannot be</span>
<span class="cm"> * performed on a netio_pkt_handle_t.  It supports only</span>
<span class="cm"> * netio_free_handle() (to free the buffer) and</span>
<span class="cm"> * NETIO_PKT_CUSTOM_DATA_H() (to access a pointer to its contents).</span>
<span class="cm"> * The application must acquire any additional metadata it wants from the</span>
<span class="cm"> * original ::netio_pkt_t and record it separately.</span>
<span class="cm"> *</span>
<span class="cm"> * A netio_pkt_handle_t can be extracted from a ::netio_pkt_t by calling</span>
<span class="cm"> * NETIO_PKT_HANDLE().  An invalid handle (analogous to NULL) can be</span>
<span class="cm"> * created by assigning the value ::NETIO_PKT_HANDLE_NONE. A handle can</span>
<span class="cm"> * be tested for validity with NETIO_PKT_HANDLE_IS_VALID().</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">word</span><span class="p">;</span> <span class="cm">/**&lt; Opaque bits. */</span>
<span class="p">}</span> <span class="n">netio_pkt_handle_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @brief A packet descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * This data structure represents a packet.  The structure is manipulated</span>
<span class="cm"> * through the @ref ingress and the @ref egress.</span>
<span class="cm"> *</span>
<span class="cm"> * While the contents of a netio_pkt_t are opaque, the structure itself is</span>
<span class="cm"> * portable.  This means that it may be shared between all tiles which have</span>
<span class="cm"> * done a netio_input_register() call for the interface on which the pkt_t</span>
<span class="cm"> * was initially received (via netio_get_packet()) or retrieved (via</span>
<span class="cm"> * netio_get_buffer()).  The contents of a netio_pkt_t can be transmitted to</span>
<span class="cm"> * another tile via shared memory, or via a UDN message, or by other means.</span>
<span class="cm"> * The destination tile may then use the pkt_t as if it had originally been</span>
<span class="cm"> * received locally; it may read or write the packet&#39;s data, read its</span>
<span class="cm"> * metadata, free the packet, send the packet, transfer the netio_pkt_t to</span>
<span class="cm"> * yet another tile, and so forth.</span>
<span class="cm"> *</span>
<span class="cm"> * Once a netio_pkt_t has been transferred to a second tile, the first tile</span>
<span class="cm"> * should not reference the original copy; in particular, if more than one</span>
<span class="cm"> * tile frees or sends the same netio_pkt_t, the IPP&#39;s packet free lists will</span>
<span class="cm"> * become corrupted.  Note also that each tile which reads or modifies</span>
<span class="cm"> * packet data must obey the memory coherency rules outlined in @ref input.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
<span class="cp">#ifdef __DOXYGEN__</span>
  <span class="cm">/** This structure is opaque. */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">opaque</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="cp">#else</span>
  <span class="cm">/** For an ingress packet (one with standard metadata), this is the</span>
<span class="cm">   *  notification header we got from the I/O shim.  For an egress packet</span>
<span class="cm">   *  (one with minimal metadata), this word is zero if the packet has not</span>
<span class="cm">   *  been populated, and nonzero if it has. */</span>
  <span class="n">__netio_pkt_notif_t</span> <span class="n">__notif_header</span><span class="p">;</span>

  <span class="cm">/** Virtual address of the packet buffer, plus state flags. */</span>
  <span class="n">__netio_pkt_handle_t</span> <span class="n">__packet</span><span class="p">;</span>

  <span class="cm">/** Metadata associated with the packet. */</span>
  <span class="n">netio_pkt_metadata_t</span> <span class="n">__metadata</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">netio_pkt_t</span><span class="p">;</span>


<span class="cp">#ifndef __DOXYGEN__</span>

<span class="cp">#define __NETIO_PKT_NOTIF_HEADER(pkt) ((pkt)-&gt;__notif_header)</span>
<span class="cp">#define __NETIO_PKT_IPP_HANDLE(pkt) ((pkt)-&gt;__packet.bits.__ipp_handle)</span>
<span class="cp">#define __NETIO_PKT_QUEUE(pkt) ((pkt)-&gt;__packet.bits.__queue)</span>
<span class="cp">#define __NETIO_PKT_NOTIF_HEADER_M(mda, pkt) ((pkt)-&gt;__notif_header)</span>
<span class="cp">#define __NETIO_PKT_IPP_HANDLE_M(mda, pkt) ((pkt)-&gt;__packet.bits.__ipp_handle)</span>
<span class="cp">#define __NETIO_PKT_MINIMAL(pkt) ((pkt)-&gt;__packet.bits.__minimal)</span>
<span class="cp">#define __NETIO_PKT_QUEUE_M(mda, pkt) ((pkt)-&gt;__packet.bits.__queue)</span>
<span class="cp">#define __NETIO_PKT_FLAGS_M(mda, pkt) ((mda)-&gt;__flags)</span>

<span class="cm">/* Packet information table, used by the attribute access functions below. */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">_netio_pkt_info</span><span class="p">[];</span>

<span class="cp">#endif </span><span class="cm">/* __DOXYGEN__ */</span><span class="cp"></span>


<span class="cp">#ifndef __DOXYGEN__</span>
<span class="cm">/* These macros are deprecated and will disappear in a future MDE release. */</span>
<span class="cp">#define NETIO_PKT_GOOD_CHECKSUM(pkt) \</span>
<span class="cp">  NETIO_PKT_L4_CSUM_CORRECT(pkt)</span>
<span class="cp">#define NETIO_PKT_GOOD_CHECKSUM_M(mda, pkt) \</span>
<span class="cp">  NETIO_PKT_L4_CSUM_CORRECT_M(mda, pkt)</span>
<span class="cp">#endif </span><span class="cm">/* __DOXYGEN__ */</span><span class="cp"></span>


<span class="cm">/* Packet attribute access functions. */</span>

<span class="cm">/** Return a pointer to the metadata for a packet.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * Calling this function once and passing the result to other retrieval</span>
<span class="cm"> * functions with a &quot;_M&quot; suffix usually improves performance.  This</span>
<span class="cm"> * function must be called on an &#39;ingress&#39; packet (i.e. one retrieved</span>
<span class="cm"> * by @ref netio_get_packet(), on which @ref netio_populate_buffer() or</span>
<span class="cm"> * @ref netio_populate_prepend_buffer have not been called). Use of this</span>
<span class="cm"> * function on an &#39;egress&#39; packet will cause an assertion failure.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return A pointer to the packet&#39;s standard metadata.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_pkt_metadata_t</span><span class="o">*</span>
<span class="nf">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_assert</span><span class="p">(</span><span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">__packet</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">__minimal</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">__metadata</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Return a pointer to the minimal metadata for a packet.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * Calling this function once and passing the result to other retrieval</span>
<span class="cm"> * functions with a &quot;_MM&quot; suffix usually improves performance.  This</span>
<span class="cm"> * function must be called on an &#39;egress&#39; packet (i.e. one on which</span>
<span class="cm"> * @ref netio_populate_buffer() or @ref netio_populate_prepend_buffer()</span>
<span class="cm"> * have been called, or one retrieved by @ref netio_get_buffer()). Use of</span>
<span class="cm"> * this function on an &#39;ingress&#39; packet will cause an assertion failure.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return A pointer to the packet&#39;s standard metadata.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span>
<span class="nf">NETIO_PKT_MINIMAL_METADATA</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_assert</span><span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">__packet</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">__minimal</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">__metadata</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Determine whether a packet has &#39;minimal&#39; metadata.</span>
<span class="cm"> * @ingroup pktfuncs</span>
<span class="cm"> *</span>
<span class="cm"> * This function will return nonzero if the packet is an &#39;egress&#39;</span>
<span class="cm"> * packet (i.e. one on which @ref netio_populate_buffer() or</span>
<span class="cm"> * @ref netio_populate_prepend_buffer() have been called, or one</span>
<span class="cm"> * retrieved by @ref netio_get_buffer()), and zero if the packet</span>
<span class="cm"> * is an &#39;ingress&#39; packet (i.e. one retrieved by @ref netio_get_packet(),</span>
<span class="cm"> * which has not been converted into an &#39;egress&#39; packet).</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Nonzero if the packet has minimal metadata.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_IS_MINIMAL</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">__packet</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">__minimal</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Return a handle for a packet&#39;s storage.</span>
<span class="cm"> * @ingroup pktfuncs</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return A handle for the packet&#39;s storage.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_pkt_handle_t</span>
<span class="nf">NETIO_PKT_HANDLE</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_handle_t</span> <span class="n">h</span><span class="p">;</span>
  <span class="n">h</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">__packet</span><span class="p">.</span><span class="n">word</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">h</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** A special reserved value indicating the absence of a packet handle.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup pktfuncs</span>
<span class="cm"> */</span>
<span class="cp">#define NETIO_PKT_HANDLE_NONE ((netio_pkt_handle_t) { 0 })</span>


<span class="cm">/** Test whether a packet handle is valid.</span>
<span class="cm"> *</span>
<span class="cm"> * Applications may wish to use the reserved value NETIO_PKT_HANDLE_NONE</span>
<span class="cm"> * to indicate no packet at all.  This function tests to see if a packet</span>
<span class="cm"> * handle is a real handle, not this special reserved value.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup pktfuncs</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] handle Handle on which to operate.</span>
<span class="cm"> * @return One if the packet handle is valid, else zero.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_HANDLE_IS_VALID</span><span class="p">(</span><span class="n">netio_pkt_handle_t</span> <span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">handle</span><span class="p">.</span><span class="n">word</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/** Return a pointer to the start of the packet&#39;s custom header.</span>
<span class="cm"> *  A custom header may or may not be present, depending upon the IPP; its</span>
<span class="cm"> *  contents and alignment are also IPP-dependent.  Currently, none of the</span>
<span class="cm"> *  standard IPPs supplied by Tilera produce a custom header.  If present,</span>
<span class="cm"> *  the custom header precedes the L2 header in the packet buffer.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] handle Handle on which to operate.</span>
<span class="cm"> * @return A pointer to start of the packet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>
<span class="nf">NETIO_PKT_CUSTOM_DATA_H</span><span class="p">(</span><span class="n">netio_pkt_handle_t</span> <span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">_NETIO_PKT_HANDLE_BASE</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span> <span class="o">+</span> <span class="n">NETIO_PACKET_PADDING</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Return the length of the packet&#39;s custom header.</span>
<span class="cm"> *  A custom header may or may not be present, depending upon the IPP; its</span>
<span class="cm"> *  contents and alignment are also IPP-dependent.  Currently, none of the</span>
<span class="cm"> *  standard IPPs supplied by Tilera produce a custom header.  If present,</span>
<span class="cm"> *  the custom header precedes the L2 header in the packet buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The length of the packet&#39;s custom header, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_size_t</span>
<span class="nf">NETIO_PKT_CUSTOM_HEADER_LENGTH_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/*</span>
<span class="cm">   * Note that we effectively need to extract a quantity from the flags word</span>
<span class="cm">   * which is measured in words, and then turn it into bytes by shifting</span>
<span class="cm">   * it left by 2.  We do this all at once by just shifting right two less</span>
<span class="cm">   * bits, and shifting the mask up two bits.</span>
<span class="cm">   */</span>
  <span class="k">return</span> <span class="p">((</span><span class="n">mda</span><span class="o">-&gt;</span><span class="n">__flags</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">_NETIO_PKT_CUSTOM_LEN_SHIFT</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&amp;</span>
          <span class="p">(</span><span class="n">_NETIO_PKT_CUSTOM_LEN_RMASK</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/** Return the length of the packet, starting with the custom header.</span>
<span class="cm"> *  A custom header may or may not be present, depending upon the IPP; its</span>
<span class="cm"> *  contents and alignment are also IPP-dependent.  Currently, none of the</span>
<span class="cm"> *  standard IPPs supplied by Tilera produce a custom header.  If present,</span>
<span class="cm"> *  the custom header precedes the L2 header in the packet buffer.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The length of the packet, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_size_t</span>
<span class="nf">NETIO_PKT_CUSTOM_LENGTH_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">__NETIO_PKT_NOTIF_HEADER</span><span class="p">(</span><span class="n">pkt</span><span class="p">).</span><span class="n">bits</span><span class="p">.</span><span class="n">__transfer_size</span> <span class="o">-</span>
          <span class="n">NETIO_PACKET_PADDING</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Return a pointer to the start of the packet&#39;s custom header.</span>
<span class="cm"> *  A custom header may or may not be present, depending upon the IPP; its</span>
<span class="cm"> *  contents and alignment are also IPP-dependent.  Currently, none of the</span>
<span class="cm"> *  standard IPPs supplied by Tilera produce a custom header.  If present,</span>
<span class="cm"> *  the custom header precedes the L2 header in the packet buffer.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return A pointer to start of the packet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>
<span class="nf">NETIO_PKT_CUSTOM_DATA_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">NETIO_PKT_CUSTOM_DATA_H</span><span class="p">(</span><span class="n">NETIO_PKT_HANDLE</span><span class="p">(</span><span class="n">pkt</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/** Return the length of the packet&#39;s L2 (Ethernet plus VLAN or SNAP) header.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The length of the packet&#39;s L2 header, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_size_t</span>
<span class="nf">NETIO_PKT_L2_HEADER_LENGTH_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/*</span>
<span class="cm">   * Note that we effectively need to extract a quantity from the flags word</span>
<span class="cm">   * which is measured in words, and then turn it into bytes by shifting</span>
<span class="cm">   * it left by 2.  We do this all at once by just shifting right two less</span>
<span class="cm">   * bits, and shifting the mask up two bits.  We then add two bytes.</span>
<span class="cm">   */</span>
  <span class="k">return</span> <span class="p">((</span><span class="n">mda</span><span class="o">-&gt;</span><span class="n">__flags</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">_NETIO_PKT_L2_LEN_SHIFT</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&amp;</span>
          <span class="p">(</span><span class="n">_NETIO_PKT_L2_LEN_RMASK</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Return the length of the packet, starting with the L2 (Ethernet) header.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The length of the packet, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_size_t</span>
<span class="nf">NETIO_PKT_L2_LENGTH_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">NETIO_PKT_CUSTOM_LENGTH_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">)</span> <span class="o">-</span>
          <span class="n">NETIO_PKT_CUSTOM_HEADER_LENGTH_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span><span class="n">pkt</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/** Return a pointer to the start of the packet&#39;s L2 (Ethernet) header.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return A pointer to start of the packet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>
<span class="nf">NETIO_PKT_L2_DATA_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">NETIO_PKT_CUSTOM_DATA_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">)</span> <span class="o">+</span>
          <span class="n">NETIO_PKT_CUSTOM_HEADER_LENGTH_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/** Retrieve the length of the packet, starting with the L3 (generally,</span>
<span class="cm"> *  the IP) header.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Length of the packet&#39;s L3 header and data, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_size_t</span>
<span class="nf">NETIO_PKT_L3_LENGTH_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">NETIO_PKT_L2_LENGTH_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">)</span> <span class="o">-</span>
          <span class="n">NETIO_PKT_L2_HEADER_LENGTH_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span><span class="n">pkt</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/** Return a pointer to the packet&#39;s L3 (generally, the IP) header.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we guarantee word alignment of the L3 header.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return A pointer to the packet&#39;s L3 header.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>
<span class="nf">NETIO_PKT_L3_DATA_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">NETIO_PKT_L2_DATA_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">)</span> <span class="o">+</span>
          <span class="n">NETIO_PKT_L2_HEADER_LENGTH_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/** Return the ordinal of the packet.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * Each packet is given an ordinal number when it is delivered by the IPP.</span>
<span class="cm"> * In the medium term, the ordinal is unique and monotonically increasing,</span>
<span class="cm"> * being incremented by 1 for each packet; the ordinal of the first packet</span>
<span class="cm"> * delivered after the IPP starts is zero.  (Since the ordinal is of finite</span>
<span class="cm"> * size, given enough input packets, it will eventually wrap around to zero;</span>
<span class="cm"> * in the long term, therefore, ordinals are not unique.)  The ordinals</span>
<span class="cm"> * handed out by different IPPs are not disjoint, so two packets from</span>
<span class="cm"> * different IPPs may have identical ordinals.  Packets dropped by the</span>
<span class="cm"> * IPP or by the I/O shim are not assigned ordinals.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s per-IPP packet ordinal.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_ORDINAL_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">mda</span><span class="o">-&gt;</span><span class="n">__packet_ordinal</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Return the per-group ordinal of the packet.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * Each packet is given a per-group ordinal number when it is</span>
<span class="cm"> * delivered by the IPP. By default, the group is the packet&#39;s VLAN,</span>
<span class="cm"> * although IPP can be recompiled to use different values.  In</span>
<span class="cm"> * the medium term, the ordinal is unique and monotonically</span>
<span class="cm"> * increasing, being incremented by 1 for each packet; the ordinal of</span>
<span class="cm"> * the first packet distributed to a particular group is zero.</span>
<span class="cm"> * (Since the ordinal is of finite size, given enough input packets,</span>
<span class="cm"> * it will eventually wrap around to zero; in the long term,</span>
<span class="cm"> * therefore, ordinals are not unique.)  The ordinals handed out by</span>
<span class="cm"> * different IPPs are not disjoint, so two packets from different IPPs</span>
<span class="cm"> * may have identical ordinals; similarly, packets distributed to</span>
<span class="cm"> * different groups may have identical ordinals.  Packets dropped by</span>
<span class="cm"> * the IPP or by the I/O shim are not assigned ordinals.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s per-IPP, per-group ordinal.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_GROUP_ORDINAL_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">mda</span><span class="o">-&gt;</span><span class="n">__group_ordinal</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Return the VLAN ID assigned to the packet.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * This value is usually contained within the packet header.</span>
<span class="cm"> *</span>
<span class="cm"> * This value will be zero if the packet does not have a VLAN tag, or if</span>
<span class="cm"> * this value was not extracted from the packet.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s VLAN ID.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">short</span>
<span class="nf">NETIO_PKT_VLAN_ID_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">vl</span> <span class="o">=</span> <span class="p">(</span><span class="n">mda</span><span class="o">-&gt;</span><span class="n">__flags</span> <span class="o">&gt;&gt;</span> <span class="n">_NETIO_PKT_VLAN_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_NETIO_PKT_VLAN_RMASK</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">short</span><span class="o">*</span> <span class="n">pkt_p</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">val</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">vl</span> <span class="o">==</span> <span class="n">_NETIO_PKT_VLAN_NONE</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">pkt_p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="o">*</span><span class="p">)</span> <span class="n">NETIO_PKT_L2_DATA_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
  <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">mda</span><span class="o">-&gt;</span><span class="n">__flags</span> <span class="o">&gt;&gt;</span> <span class="n">_NETIO_PKT_TYPE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_NETIO_PKT_TYPE_RMASK</span><span class="p">;</span>

  <span class="n">val</span> <span class="o">=</span> <span class="n">pkt_p</span><span class="p">[(</span><span class="n">_netio_pkt_info</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">_NETIO_PKT_INFO_VLAN_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
              <span class="n">_NETIO_PKT_INFO_VLAN_RMASK</span><span class="p">];</span>

<span class="cp">#ifdef __TILECC__</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">__insn_bytex</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">;</span>
<span class="cp">#else</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">__builtin_bswap32</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cm">/** Return the ethertype of the packet.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * This value is usually contained within the packet header.</span>
<span class="cm"> *</span>
<span class="cm"> * This value is reliable if @ref NETIO_PKT_ETHERTYPE_RECOGNIZED_M()</span>
<span class="cm"> * returns true, and otherwise, may not be well defined.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s ethertype.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">short</span>
<span class="nf">NETIO_PKT_ETHERTYPE_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">short</span><span class="o">*</span> <span class="n">pkt_p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="o">*</span><span class="p">)</span> <span class="n">NETIO_PKT_L2_DATA_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">mda</span><span class="o">-&gt;</span><span class="n">__flags</span> <span class="o">&gt;&gt;</span> <span class="n">_NETIO_PKT_TYPE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_NETIO_PKT_TYPE_RMASK</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">val</span> <span class="o">=</span>
    <span class="n">pkt_p</span><span class="p">[(</span><span class="n">_netio_pkt_info</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">_NETIO_PKT_INFO_ETYPE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
          <span class="n">_NETIO_PKT_INFO_ETYPE_RMASK</span><span class="p">];</span>

  <span class="k">return</span> <span class="n">__builtin_bswap32</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Return the flow hash computed on the packet.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * For TCP and UDP packets, this hash is calculated by hashing together</span>
<span class="cm"> * the &quot;5-tuple&quot; values, specifically the source IP address, destination</span>
<span class="cm"> * IP address, protocol type, source port and destination port.</span>
<span class="cm"> * The hash value is intended to be helpful for millions of distinct</span>
<span class="cm"> * flows.</span>
<span class="cm"> *</span>
<span class="cm"> * For IPv4 or IPv6 packets which are neither TCP nor UDP, the flow hash is</span>
<span class="cm"> * derived by hashing together the source and destination IP addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * For MPLS-encapsulated packets, the flow hash is derived by hashing</span>
<span class="cm"> * the first MPLS label.</span>
<span class="cm"> *</span>
<span class="cm"> * For all other packets the flow hash is computed from the source</span>
<span class="cm"> * and destination Ethernet addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * The hash is symmetric, meaning it produces the same value if the</span>
<span class="cm"> * source and destination are swapped. The only exceptions are</span>
<span class="cm"> * tunneling protocols 0x04 (IP in IP Encapsulation), 0x29 (Simple</span>
<span class="cm"> * Internet Protocol), 0x2F (General Routing Encapsulation) and 0x32</span>
<span class="cm"> * (Encap Security Payload), which use only the destination address</span>
<span class="cm"> * since the source address is not meaningful.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s 32-bit flow hash.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_FLOW_HASH_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">mda</span><span class="o">-&gt;</span><span class="n">__flow_hash</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Return the first word of &quot;user data&quot; for the packet.</span>
<span class="cm"> *</span>
<span class="cm"> * The contents of the user data words depend on the IPP.</span>
<span class="cm"> *</span>
<span class="cm"> * When using the standard ipp1, ipp2, or ipp4 sub-drivers, the first</span>
<span class="cm"> * word of user data contains the least significant bits of the 64-bit</span>
<span class="cm"> * arrival cycle count (see @c get_cycle_count_low()).</span>
<span class="cm"> *</span>
<span class="cm"> * See the &lt;em&gt;System Programmer&#39;s Guide&lt;/em&gt; for details.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s first word of &quot;user data&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_USER_DATA_0_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">mda</span><span class="o">-&gt;</span><span class="n">__user_data_0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Return the second word of &quot;user data&quot; for the packet.</span>
<span class="cm"> *</span>
<span class="cm"> * The contents of the user data words depend on the IPP.</span>
<span class="cm"> *</span>
<span class="cm"> * When using the standard ipp1, ipp2, or ipp4 sub-drivers, the second</span>
<span class="cm"> * word of user data contains the most significant bits of the 64-bit</span>
<span class="cm"> * arrival cycle count (see @c get_cycle_count_high()).</span>
<span class="cm"> *</span>
<span class="cm"> * See the &lt;em&gt;System Programmer&#39;s Guide&lt;/em&gt; for details.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s second word of &quot;user data&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_USER_DATA_1_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">mda</span><span class="o">-&gt;</span><span class="n">__user_data_1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Determine whether the L4 (TCP/UDP) checksum was calculated.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Nonzero if the L4 checksum was calculated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_L4_CSUM_CALCULATED_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">mda</span><span class="o">-&gt;</span><span class="n">__flags</span> <span class="o">&amp;</span> <span class="n">_NETIO_PKT_NO_L4_CSUM_MASK</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Determine whether the L4 (TCP/UDP) checksum was calculated and found to</span>
<span class="cm"> *  be correct.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Nonzero if the checksum was calculated and is correct.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_L4_CSUM_CORRECT_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">mda</span><span class="o">-&gt;</span><span class="n">__flags</span> <span class="o">&amp;</span>
           <span class="p">(</span><span class="n">_NETIO_PKT_BAD_L4_CSUM_MASK</span> <span class="o">|</span> <span class="n">_NETIO_PKT_NO_L4_CSUM_MASK</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/** Determine whether the L3 (IP) checksum was calculated.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Nonzero if the L3 (IP) checksum was calculated.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_L3_CSUM_CALCULATED_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">mda</span><span class="o">-&gt;</span><span class="n">__flags</span> <span class="o">&amp;</span> <span class="n">_NETIO_PKT_NO_L3_CSUM_MASK</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Determine whether the L3 (IP) checksum was calculated and found to be</span>
<span class="cm"> *  correct.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Nonzero if the checksum was calculated and is correct.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_L3_CSUM_CORRECT_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">mda</span><span class="o">-&gt;</span><span class="n">__flags</span> <span class="o">&amp;</span>
           <span class="p">(</span><span class="n">_NETIO_PKT_BAD_L3_CSUM_MASK</span> <span class="o">|</span> <span class="n">_NETIO_PKT_NO_L3_CSUM_MASK</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/** Determine whether the ethertype was recognized and L3 packet data was</span>
<span class="cm"> *  processed.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Nonzero if the ethertype was recognized and L3 packet data was</span>
<span class="cm"> *   processed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_ETHERTYPE_RECOGNIZED_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">mda</span><span class="o">-&gt;</span><span class="n">__flags</span> <span class="o">&amp;</span> <span class="n">_NETIO_PKT_TYPE_UNRECOGNIZED_MASK</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Retrieve the status of a packet and any errors that may have occurred</span>
<span class="cm"> * during ingress processing (length mismatches, CRC errors, etc.).</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * Note that packets for which @ref NETIO_PKT_ETHERTYPE_RECOGNIZED()</span>
<span class="cm"> * returns zero are always reported as underlength, as there is no a priori</span>
<span class="cm"> * means to determine their length.  Normally, applications should use</span>
<span class="cm"> * @ref NETIO_PKT_BAD_M() instead of explicitly checking status with this</span>
<span class="cm"> * function.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s status.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_pkt_status_t</span>
<span class="nf">NETIO_PKT_STATUS_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">netio_pkt_status_t</span><span class="p">)</span> <span class="n">__NETIO_PKT_NOTIF_HEADER</span><span class="p">(</span><span class="n">pkt</span><span class="p">).</span><span class="n">bits</span><span class="p">.</span><span class="n">__status</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Report whether a packet is bad (i.e., was shorter than expected based on</span>
<span class="cm"> *  its headers, or had a bad CRC).</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function does not verify L3 or L4 checksums.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Nonzero if the packet is bad and should be discarded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_BAD_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">((</span><span class="n">NETIO_PKT_STATUS_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
          <span class="p">(</span><span class="n">NETIO_PKT_ETHERTYPE_RECOGNIZED_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">)</span> <span class="o">||</span>
           <span class="n">NETIO_PKT_STATUS_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">)</span> <span class="o">==</span> <span class="n">NETIO_PKT_STATUS_BAD</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/** Return the length of the packet, starting with the L2 (Ethernet) header.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mmd Pointer to packet&#39;s minimal metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The length of the packet, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_size_t</span>
<span class="nf">NETIO_PKT_L2_LENGTH_MM</span><span class="p">(</span><span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">mmd</span><span class="o">-&gt;</span><span class="n">l2_length</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Return the length of the L2 (Ethernet) header.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mmd Pointer to packet&#39;s minimal metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The length of the packet&#39;s L2 header, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_size_t</span>
<span class="nf">NETIO_PKT_L2_HEADER_LENGTH_MM</span><span class="p">(</span><span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span><span class="p">,</span>
                              <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">mmd</span><span class="o">-&gt;</span><span class="n">l3_offset</span> <span class="o">-</span> <span class="n">mmd</span><span class="o">-&gt;</span><span class="n">l2_offset</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Return the length of the packet, starting with the L3 (IP) header.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mmd Pointer to packet&#39;s minimal metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Length of the packet&#39;s L3 header and data, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_size_t</span>
<span class="nf">NETIO_PKT_L3_LENGTH_MM</span><span class="p">(</span><span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">NETIO_PKT_L2_LENGTH_MM</span><span class="p">(</span><span class="n">mmd</span><span class="p">,</span> <span class="n">pkt</span><span class="p">)</span> <span class="o">-</span>
          <span class="n">NETIO_PKT_L2_HEADER_LENGTH_MM</span><span class="p">(</span><span class="n">mmd</span><span class="p">,</span> <span class="n">pkt</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/** Return a pointer to the packet&#39;s L3 (generally, the IP) header.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we guarantee word alignment of the L3 header.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mmd Pointer to packet&#39;s minimal metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return A pointer to the packet&#39;s L3 header.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>
<span class="nf">NETIO_PKT_L3_DATA_MM</span><span class="p">(</span><span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">_NETIO_PKT_BASE</span><span class="p">(</span><span class="n">pkt</span><span class="p">)</span> <span class="o">+</span> <span class="n">mmd</span><span class="o">-&gt;</span><span class="n">l3_offset</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Return a pointer to the packet&#39;s L2 (Ethernet) header.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mmd Pointer to packet&#39;s minimal metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return A pointer to start of the packet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>
<span class="nf">NETIO_PKT_L2_DATA_MM</span><span class="p">(</span><span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">_NETIO_PKT_BASE</span><span class="p">(</span><span class="n">pkt</span><span class="p">)</span> <span class="o">+</span> <span class="n">mmd</span><span class="o">-&gt;</span><span class="n">l2_offset</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Retrieve the status of a packet and any errors that may have occurred</span>
<span class="cm"> * during ingress processing (length mismatches, CRC errors, etc.).</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * Note that packets for which @ref NETIO_PKT_ETHERTYPE_RECOGNIZED()</span>
<span class="cm"> * returns zero are always reported as underlength, as there is no a priori</span>
<span class="cm"> * means to determine their length.  Normally, applications should use</span>
<span class="cm"> * @ref NETIO_PKT_BAD() instead of explicitly checking status with this</span>
<span class="cm"> * function.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s status.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_pkt_status_t</span>
<span class="nf">NETIO_PKT_STATUS</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_assert</span><span class="p">(</span><span class="o">!</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">__packet</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">__minimal</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">netio_pkt_status_t</span><span class="p">)</span> <span class="n">__NETIO_PKT_NOTIF_HEADER</span><span class="p">(</span><span class="n">pkt</span><span class="p">).</span><span class="n">bits</span><span class="p">.</span><span class="n">__status</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Report whether a packet is bad (i.e., was shorter than expected based on</span>
<span class="cm"> *  its headers, or had a bad CRC).</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function does not verify L3 or L4 checksums.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Nonzero if the packet is bad and should be discarded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_BAD</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_BAD_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Return the length of the packet&#39;s custom header.</span>
<span class="cm"> *  A custom header may or may not be present, depending upon the IPP; its</span>
<span class="cm"> *  contents and alignment are also IPP-dependent.  Currently, none of the</span>
<span class="cm"> *  standard IPPs supplied by Tilera produce a custom header.  If present,</span>
<span class="cm"> *  the custom header precedes the L2 header in the packet buffer.</span>
<span class="cm"> * @ingroup pktfuncs</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The length of the packet&#39;s custom header, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_size_t</span>
<span class="nf">NETIO_PKT_CUSTOM_HEADER_LENGTH</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_CUSTOM_HEADER_LENGTH_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Return the length of the packet, starting with the custom header.</span>
<span class="cm"> *  A custom header may or may not be present, depending upon the IPP; its</span>
<span class="cm"> *  contents and alignment are also IPP-dependent.  Currently, none of the</span>
<span class="cm"> *  standard IPPs supplied by Tilera produce a custom header.  If present,</span>
<span class="cm"> *  the custom header precedes the L2 header in the packet buffer.</span>
<span class="cm"> * @ingroup pktfuncs</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return  The length of the packet, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_size_t</span>
<span class="nf">NETIO_PKT_CUSTOM_LENGTH</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_CUSTOM_LENGTH_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Return a pointer to the packet&#39;s custom header.</span>
<span class="cm"> *  A custom header may or may not be present, depending upon the IPP; its</span>
<span class="cm"> *  contents and alignment are also IPP-dependent.  Currently, none of the</span>
<span class="cm"> *  standard IPPs supplied by Tilera produce a custom header.  If present,</span>
<span class="cm"> *  the custom header precedes the L2 header in the packet buffer.</span>
<span class="cm"> * @ingroup pktfuncs</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return A pointer to start of the packet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>
<span class="nf">NETIO_PKT_CUSTOM_DATA</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_CUSTOM_DATA_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Return the length of the packet&#39;s L2 (Ethernet plus VLAN or SNAP) header.</span>
<span class="cm"> * @ingroup pktfuncs</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The length of the packet&#39;s L2 header, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_size_t</span>
<span class="nf">NETIO_PKT_L2_HEADER_LENGTH</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">NETIO_PKT_IS_MINIMAL</span><span class="p">(</span><span class="n">pkt</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span> <span class="o">=</span> <span class="n">NETIO_PKT_MINIMAL_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">NETIO_PKT_L2_HEADER_LENGTH_MM</span><span class="p">(</span><span class="n">mmd</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">NETIO_PKT_L2_HEADER_LENGTH_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/** Return the length of the packet, starting with the L2 (Ethernet) header.</span>
<span class="cm"> * @ingroup pktfuncs</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return  The length of the packet, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_size_t</span>
<span class="nf">NETIO_PKT_L2_LENGTH</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">NETIO_PKT_IS_MINIMAL</span><span class="p">(</span><span class="n">pkt</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span> <span class="o">=</span> <span class="n">NETIO_PKT_MINIMAL_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">NETIO_PKT_L2_LENGTH_MM</span><span class="p">(</span><span class="n">mmd</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">NETIO_PKT_L2_LENGTH_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/** Return a pointer to the packet&#39;s L2 (Ethernet) header.</span>
<span class="cm"> * @ingroup pktfuncs</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return A pointer to start of the packet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>
<span class="nf">NETIO_PKT_L2_DATA</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">NETIO_PKT_IS_MINIMAL</span><span class="p">(</span><span class="n">pkt</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span> <span class="o">=</span> <span class="n">NETIO_PKT_MINIMAL_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">NETIO_PKT_L2_DATA_MM</span><span class="p">(</span><span class="n">mmd</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">NETIO_PKT_L2_DATA_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/** Retrieve the length of the packet, starting with the L3 (generally, the IP)</span>
<span class="cm"> * header.</span>
<span class="cm"> * @ingroup pktfuncs</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Length of the packet&#39;s L3 header and data, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="n">netio_size_t</span>
<span class="nf">NETIO_PKT_L3_LENGTH</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">NETIO_PKT_IS_MINIMAL</span><span class="p">(</span><span class="n">pkt</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span> <span class="o">=</span> <span class="n">NETIO_PKT_MINIMAL_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">NETIO_PKT_L3_LENGTH_MM</span><span class="p">(</span><span class="n">mmd</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">NETIO_PKT_L3_LENGTH_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/** Return a pointer to the packet&#39;s L3 (generally, the IP) header.</span>
<span class="cm"> * @ingroup pktfuncs</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we guarantee word alignment of the L3 header.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return A pointer to the packet&#39;s L3 header.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>
<span class="nf">NETIO_PKT_L3_DATA</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">NETIO_PKT_IS_MINIMAL</span><span class="p">(</span><span class="n">pkt</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span> <span class="o">=</span> <span class="n">NETIO_PKT_MINIMAL_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">NETIO_PKT_L3_DATA_MM</span><span class="p">(</span><span class="n">mmd</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">NETIO_PKT_L3_DATA_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/** Return the ordinal of the packet.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * Each packet is given an ordinal number when it is delivered by the IPP.</span>
<span class="cm"> * In the medium term, the ordinal is unique and monotonically increasing,</span>
<span class="cm"> * being incremented by 1 for each packet; the ordinal of the first packet</span>
<span class="cm"> * delivered after the IPP starts is zero.  (Since the ordinal is of finite</span>
<span class="cm"> * size, given enough input packets, it will eventually wrap around to zero;</span>
<span class="cm"> * in the long term, therefore, ordinals are not unique.)  The ordinals</span>
<span class="cm"> * handed out by different IPPs are not disjoint, so two packets from</span>
<span class="cm"> * different IPPs may have identical ordinals.  Packets dropped by the</span>
<span class="cm"> * IPP or by the I/O shim are not assigned ordinals.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s per-IPP packet ordinal.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_ORDINAL</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_ORDINAL_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Return the per-group ordinal of the packet.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * Each packet is given a per-group ordinal number when it is</span>
<span class="cm"> * delivered by the IPP. By default, the group is the packet&#39;s VLAN,</span>
<span class="cm"> * although IPP can be recompiled to use different values.  In</span>
<span class="cm"> * the medium term, the ordinal is unique and monotonically</span>
<span class="cm"> * increasing, being incremented by 1 for each packet; the ordinal of</span>
<span class="cm"> * the first packet distributed to a particular group is zero.</span>
<span class="cm"> * (Since the ordinal is of finite size, given enough input packets,</span>
<span class="cm"> * it will eventually wrap around to zero; in the long term,</span>
<span class="cm"> * therefore, ordinals are not unique.)  The ordinals handed out by</span>
<span class="cm"> * different IPPs are not disjoint, so two packets from different IPPs</span>
<span class="cm"> * may have identical ordinals; similarly, packets distributed to</span>
<span class="cm"> * different groups may have identical ordinals.  Packets dropped by</span>
<span class="cm"> * the IPP or by the I/O shim are not assigned ordinals.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s per-IPP, per-group ordinal.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_GROUP_ORDINAL</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_GROUP_ORDINAL_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Return the VLAN ID assigned to the packet.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * This is usually also contained within the packet header.  If the packet</span>
<span class="cm"> * does not have a VLAN tag, the VLAN ID returned by this function is zero.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s VLAN ID.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">short</span>
<span class="nf">NETIO_PKT_VLAN_ID</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_VLAN_ID_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Return the ethertype of the packet.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * This value is reliable if @ref NETIO_PKT_ETHERTYPE_RECOGNIZED()</span>
<span class="cm"> * returns true, and otherwise, may not be well defined.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s ethertype.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">short</span>
<span class="nf">NETIO_PKT_ETHERTYPE</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_ETHERTYPE_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Return the flow hash computed on the packet.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * For TCP and UDP packets, this hash is calculated by hashing together</span>
<span class="cm"> * the &quot;5-tuple&quot; values, specifically the source IP address, destination</span>
<span class="cm"> * IP address, protocol type, source port and destination port.</span>
<span class="cm"> * The hash value is intended to be helpful for millions of distinct</span>
<span class="cm"> * flows.</span>
<span class="cm"> *</span>
<span class="cm"> * For IPv4 or IPv6 packets which are neither TCP nor UDP, the flow hash is</span>
<span class="cm"> * derived by hashing together the source and destination IP addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * For MPLS-encapsulated packets, the flow hash is derived by hashing</span>
<span class="cm"> * the first MPLS label.</span>
<span class="cm"> *</span>
<span class="cm"> * For all other packets the flow hash is computed from the source</span>
<span class="cm"> * and destination Ethernet addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * The hash is symmetric, meaning it produces the same value if the</span>
<span class="cm"> * source and destination are swapped. The only exceptions are</span>
<span class="cm"> * tunneling protocols 0x04 (IP in IP Encapsulation), 0x29 (Simple</span>
<span class="cm"> * Internet Protocol), 0x2F (General Routing Encapsulation) and 0x32</span>
<span class="cm"> * (Encap Security Payload), which use only the destination address</span>
<span class="cm"> * since the source address is not meaningful.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s 32-bit flow hash.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_FLOW_HASH</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_FLOW_HASH_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Return the first word of &quot;user data&quot; for the packet.</span>
<span class="cm"> *</span>
<span class="cm"> * The contents of the user data words depend on the IPP.</span>
<span class="cm"> *</span>
<span class="cm"> * When using the standard ipp1, ipp2, or ipp4 sub-drivers, the first</span>
<span class="cm"> * word of user data contains the least significant bits of the 64-bit</span>
<span class="cm"> * arrival cycle count (see @c get_cycle_count_low()).</span>
<span class="cm"> *</span>
<span class="cm"> * See the &lt;em&gt;System Programmer&#39;s Guide&lt;/em&gt; for details.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s first word of &quot;user data&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_USER_DATA_0</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_USER_DATA_0_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Return the second word of &quot;user data&quot; for the packet.</span>
<span class="cm"> *</span>
<span class="cm"> * The contents of the user data words depend on the IPP.</span>
<span class="cm"> *</span>
<span class="cm"> * When using the standard ipp1, ipp2, or ipp4 sub-drivers, the second</span>
<span class="cm"> * word of user data contains the most significant bits of the 64-bit</span>
<span class="cm"> * arrival cycle count (see @c get_cycle_count_high()).</span>
<span class="cm"> *</span>
<span class="cm"> * See the &lt;em&gt;System Programmer&#39;s Guide&lt;/em&gt; for details.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return The packet&#39;s second word of &quot;user data&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_USER_DATA_1</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_USER_DATA_1_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Determine whether the L4 (TCP/UDP) checksum was calculated.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Nonzero if the L4 checksum was calculated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_L4_CSUM_CALCULATED</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_L4_CSUM_CALCULATED_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Determine whether the L4 (TCP/UDP) checksum was calculated and found to</span>
<span class="cm"> *  be correct.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Nonzero if the checksum was calculated and is correct.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_L4_CSUM_CORRECT</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_L4_CSUM_CORRECT_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Determine whether the L3 (IP) checksum was calculated.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Nonzero if the L3 (IP) checksum was calculated.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_L3_CSUM_CALCULATED</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_L3_CSUM_CALCULATED_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Determine whether the L3 (IP) checksum was calculated and found to be</span>
<span class="cm"> *  correct.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Nonzero if the checksum was calculated and is correct.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_L3_CSUM_CORRECT</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_L3_CSUM_CORRECT_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Determine whether the Ethertype was recognized and L3 packet data was</span>
<span class="cm"> *  processed.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @return Nonzero if the Ethertype was recognized and L3 packet data was</span>
<span class="cm"> *   processed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_ETHERTYPE_RECOGNIZED</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">NETIO_PKT_ETHERTYPE_RECOGNIZED_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Set an egress packet&#39;s L2 length, using a metadata pointer to speed the</span>
<span class="cm"> * computation.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in,out] mmd Pointer to packet&#39;s minimal metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @param[in] len Packet L2 length, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_SET_L2_LENGTH_MM</span><span class="p">(</span><span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">,</span>
                           <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">mmd</span><span class="o">-&gt;</span><span class="n">l2_length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Set an egress packet&#39;s L2 length.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in,out] pkt Packet on which to operate.</span>
<span class="cm"> * @param[in] len Packet L2 length, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_SET_L2_LENGTH</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span> <span class="o">=</span> <span class="n">NETIO_PKT_MINIMAL_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="n">NETIO_PKT_SET_L2_LENGTH_MM</span><span class="p">(</span><span class="n">mmd</span><span class="p">,</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Set an egress packet&#39;s L2 header length, using a metadata pointer to</span>
<span class="cm"> *  speed the computation.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * It is not normally necessary to call this routine; only the L2 length,</span>
<span class="cm"> * not the header length, is needed to transmit a packet.  It may be useful if</span>
<span class="cm"> * the egress packet will later be processed by code which expects to use</span>
<span class="cm"> * functions like @ref NETIO_PKT_L3_DATA() to get a pointer to the L3 payload.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in,out] mmd Pointer to packet&#39;s minimal metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @param[in] len Packet L2 header length, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_SET_L2_HEADER_LENGTH_MM</span><span class="p">(</span><span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span><span class="p">,</span>
                                  <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">mmd</span><span class="o">-&gt;</span><span class="n">l3_offset</span> <span class="o">=</span> <span class="n">mmd</span><span class="o">-&gt;</span><span class="n">l2_offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Set an egress packet&#39;s L2 header length.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * It is not normally necessary to call this routine; only the L2 length,</span>
<span class="cm"> * not the header length, is needed to transmit a packet.  It may be useful if</span>
<span class="cm"> * the egress packet will later be processed by code which expects to use</span>
<span class="cm"> * functions like @ref NETIO_PKT_L3_DATA() to get a pointer to the L3 payload.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in,out] pkt Packet on which to operate.</span>
<span class="cm"> * @param[in] len Packet L2 header length, in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_SET_L2_HEADER_LENGTH</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span> <span class="o">=</span> <span class="n">NETIO_PKT_MINIMAL_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="n">NETIO_PKT_SET_L2_HEADER_LENGTH_MM</span><span class="p">(</span><span class="n">mmd</span><span class="p">,</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Set up an egress packet for hardware checksum computation, using a</span>
<span class="cm"> *  metadata pointer to speed the operation.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> *  NetIO provides the ability to automatically calculate a standard</span>
<span class="cm"> *  16-bit Internet checksum on transmitted packets.  The application</span>
<span class="cm"> *  may specify the point in the packet where the checksum starts, the</span>
<span class="cm"> *  number of bytes to be checksummed, and the two bytes in the packet</span>
<span class="cm"> *  which will be replaced with the completed checksum.  (If the range</span>
<span class="cm"> *  of bytes to be checksummed includes the bytes to be replaced, the</span>
<span class="cm"> *  initial values of those bytes will be included in the checksum.)</span>
<span class="cm"> *</span>
<span class="cm"> *  For some protocols, the packet checksum covers data which is not present</span>
<span class="cm"> *  in the packet, or is at least not contiguous to the main data payload.</span>
<span class="cm"> *  For instance, the TCP checksum includes a &quot;pseudo-header&quot; which includes</span>
<span class="cm"> *  the source and destination IP addresses of the packet.  To accommodate</span>
<span class="cm"> *  this, the checksum engine may be &quot;seeded&quot; with an initial value, which</span>
<span class="cm"> *  the application would need to compute based on the specific protocol&#39;s</span>
<span class="cm"> *  requirements.  Note that the seed is given in host byte order (little-</span>
<span class="cm"> *  endian), not network byte order (big-endian); code written to compute a</span>
<span class="cm"> *  pseudo-header checksum in network byte order will need to byte-swap it</span>
<span class="cm"> *  before use as the seed.</span>
<span class="cm"> *</span>
<span class="cm"> *  Note that the checksum is computed as part of the transmission process,</span>
<span class="cm"> *  so it will not be present in the packet upon completion of this routine.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in,out] mmd Pointer to packet&#39;s minimal metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> * @param[in] start Offset within L2 packet of the first byte to include in</span>
<span class="cm"> *   the checksum.</span>
<span class="cm"> * @param[in] length Number of bytes to include in the checksum.</span>
<span class="cm"> *   the checksum.</span>
<span class="cm"> * @param[in] location Offset within L2 packet of the first of the two bytes</span>
<span class="cm"> *   to be replaced with the calculated checksum.</span>
<span class="cm"> * @param[in] seed Initial value of the running checksum before any of the</span>
<span class="cm"> *   packet data is added.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_DO_EGRESS_CSUM_MM</span><span class="p">(</span><span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span><span class="p">,</span>
                            <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span>
                            <span class="kt">int</span> <span class="n">location</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">seed</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">mmd</span><span class="o">-&gt;</span><span class="n">csum_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
  <span class="n">mmd</span><span class="o">-&gt;</span><span class="n">csum_length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
  <span class="n">mmd</span><span class="o">-&gt;</span><span class="n">csum_location</span> <span class="o">=</span> <span class="n">location</span><span class="p">;</span>
  <span class="n">mmd</span><span class="o">-&gt;</span><span class="n">csum_seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">;</span>
  <span class="n">mmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">_NETIO_PKT_NEED_EDMA_CSUM_MASK</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Set up an egress packet for hardware checksum computation.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> *  NetIO provides the ability to automatically calculate a standard</span>
<span class="cm"> *  16-bit Internet checksum on transmitted packets.  The application</span>
<span class="cm"> *  may specify the point in the packet where the checksum starts, the</span>
<span class="cm"> *  number of bytes to be checksummed, and the two bytes in the packet</span>
<span class="cm"> *  which will be replaced with the completed checksum.  (If the range</span>
<span class="cm"> *  of bytes to be checksummed includes the bytes to be replaced, the</span>
<span class="cm"> *  initial values of those bytes will be included in the checksum.)</span>
<span class="cm"> *</span>
<span class="cm"> *  For some protocols, the packet checksum covers data which is not present</span>
<span class="cm"> *  in the packet, or is at least not contiguous to the main data payload.</span>
<span class="cm"> *  For instance, the TCP checksum includes a &quot;pseudo-header&quot; which includes</span>
<span class="cm"> *  the source and destination IP addresses of the packet.  To accommodate</span>
<span class="cm"> *  this, the checksum engine may be &quot;seeded&quot; with an initial value, which</span>
<span class="cm"> *  the application would need to compute based on the specific protocol&#39;s</span>
<span class="cm"> *  requirements.  Note that the seed is given in host byte order (little-</span>
<span class="cm"> *  endian), not network byte order (big-endian); code written to compute a</span>
<span class="cm"> *  pseudo-header checksum in network byte order will need to byte-swap it</span>
<span class="cm"> *  before use as the seed.</span>
<span class="cm"> *</span>
<span class="cm"> *  Note that the checksum is computed as part of the transmission process,</span>
<span class="cm"> *  so it will not be present in the packet upon completion of this routine.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in,out] pkt Packet on which to operate.</span>
<span class="cm"> * @param[in] start Offset within L2 packet of the first byte to include in</span>
<span class="cm"> *   the checksum.</span>
<span class="cm"> * @param[in] length Number of bytes to include in the checksum.</span>
<span class="cm"> *   the checksum.</span>
<span class="cm"> * @param[in] location Offset within L2 packet of the first of the two bytes</span>
<span class="cm"> *   to be replaced with the calculated checksum.</span>
<span class="cm"> * @param[in] seed Initial value of the running checksum before any of the</span>
<span class="cm"> *   packet data is added.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_DO_EGRESS_CSUM</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span>
                         <span class="kt">int</span> <span class="n">location</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">seed</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span> <span class="o">=</span> <span class="n">NETIO_PKT_MINIMAL_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

  <span class="n">NETIO_PKT_DO_EGRESS_CSUM_MM</span><span class="p">(</span><span class="n">mmd</span><span class="p">,</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">seed</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Return the number of bytes which could be prepended to a packet, using a</span>
<span class="cm"> *  metadata pointer to speed the operation.</span>
<span class="cm"> *  See @ref netio_populate_prepend_buffer() to get a full description of</span>
<span class="cm"> *  prepending.</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in,out] mda Pointer to packet&#39;s standard metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_PREPEND_AVAIL_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">__packet</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">__offset</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span>
         <span class="n">NETIO_PKT_CUSTOM_HEADER_LENGTH_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/** Return the number of bytes which could be prepended to a packet, using a</span>
<span class="cm"> *  metadata pointer to speed the operation.</span>
<span class="cm"> *  See @ref netio_populate_prepend_buffer() to get a full description of</span>
<span class="cm"> *  prepending.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in,out] mmd Pointer to packet&#39;s minimal metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_PREPEND_AVAIL_MM</span><span class="p">(</span><span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">__packet</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">__offset</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="n">mmd</span><span class="o">-&gt;</span><span class="n">l2_offset</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** Return the number of bytes which could be prepended to a packet.</span>
<span class="cm"> *  See @ref netio_populate_prepend_buffer() to get a full description of</span>
<span class="cm"> *  prepending.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">int</span>
<span class="nf">NETIO_PKT_PREPEND_AVAIL</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">NETIO_PKT_IS_MINIMAL</span><span class="p">(</span><span class="n">pkt</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span> <span class="o">=</span> <span class="n">NETIO_PKT_MINIMAL_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">NETIO_PKT_PREPEND_AVAIL_MM</span><span class="p">(</span><span class="n">mmd</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="n">NETIO_PKT_METADATA</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">NETIO_PKT_PREPEND_AVAIL_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/** Flush a packet&#39;s minimal metadata from the cache, using a metadata pointer</span>
<span class="cm"> *  to speed the operation.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mmd Pointer to packet&#39;s minimal metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_FLUSH_MINIMAL_METADATA_MM</span><span class="p">(</span><span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span><span class="p">,</span>
                                    <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="cm">/** Invalidate a packet&#39;s minimal metadata from the cache, using a metadata</span>
<span class="cm"> *  pointer to speed the operation.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mmd Pointer to packet&#39;s minimal metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_INV_MINIMAL_METADATA_MM</span><span class="p">(</span><span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span><span class="p">,</span>
                                  <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="cm">/** Flush and then invalidate a packet&#39;s minimal metadata from the cache,</span>
<span class="cm"> *  using a metadata pointer to speed the operation.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mmd Pointer to packet&#39;s minimal metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_FLUSH_INV_MINIMAL_METADATA_MM</span><span class="p">(</span><span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span><span class="p">,</span>
                                        <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="cm">/** Flush a packet&#39;s metadata from the cache, using a metadata pointer</span>
<span class="cm"> *  to speed the operation.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s minimal metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_FLUSH_METADATA_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="cm">/** Invalidate a packet&#39;s metadata from the cache, using a metadata</span>
<span class="cm"> *  pointer to speed the operation.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_INV_METADATA_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="cm">/** Flush and then invalidate a packet&#39;s metadata from the cache,</span>
<span class="cm"> *  using a metadata pointer to speed the operation.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] mda Pointer to packet&#39;s metadata.</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_FLUSH_INV_METADATA_M</span><span class="p">(</span><span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="cm">/** Flush a packet&#39;s minimal metadata from the cache.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_FLUSH_MINIMAL_METADATA</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="cm">/** Invalidate a packet&#39;s minimal metadata from the cache.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_INV_MINIMAL_METADATA</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="cm">/** Flush and then invalidate a packet&#39;s minimal metadata from the cache.</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_FLUSH_INV_MINIMAL_METADATA</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="cm">/** Flush a packet&#39;s metadata from the cache.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_FLUSH_METADATA</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="cm">/** Invalidate a packet&#39;s metadata from the cache.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_INV_METADATA</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>


<span class="cm">/** Flush and then invalidate a packet&#39;s metadata from the cache.</span>
<span class="cm"> * @ingroup ingress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[in] pkt Packet on which to operate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">NETIO_PKT_FLUSH_INV_METADATA</span><span class="p">(</span><span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/** Number of NUMA nodes we can distribute buffers to.</span>
<span class="cm"> * @ingroup setup */</span>
<span class="cp">#define NETIO_NUM_NODE_WEIGHTS  16</span>

<span class="cm">/**</span>
<span class="cm"> * @brief An object for specifying the characteristics of NetIO communication</span>
<span class="cm"> * endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup setup</span>
<span class="cm"> *</span>
<span class="cm"> * The @ref netio_input_register() function uses this structure to define</span>
<span class="cm"> * how an application tile will communicate with an IPP.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Future updates to NetIO may add new members to this structure,</span>
<span class="cm"> * which can affect the success of the registration operation.  Thus,</span>
<span class="cm"> * if dynamically initializing the structure, applications are urged to</span>
<span class="cm"> * zero it out first, for example:</span>
<span class="cm"> *</span>
<span class="cm"> * @code</span>
<span class="cm"> * netio_input_config_t config;</span>
<span class="cm"> * memset(&amp;config, 0, sizeof (config));</span>
<span class="cm"> * config.flags = NETIO_RECV | NETIO_XMIT_CSUM | NETIO_TAG_NONE;</span>
<span class="cm"> * config.num_receive_packets = NETIO_MAX_RECEIVE_PKTS;</span>
<span class="cm"> * config.queue_id = 0;</span>
<span class="cm"> *     .</span>
<span class="cm"> *     .</span>
<span class="cm"> *     .</span>
<span class="cm"> * @endcode</span>
<span class="cm"> *</span>
<span class="cm"> * since that guarantees that any unused structure members, including</span>
<span class="cm"> * members which did not exist when the application was first developed,</span>
<span class="cm"> * will not have unexpected values.</span>
<span class="cm"> *</span>
<span class="cm"> * If statically initializing the structure, we strongly recommend use of</span>
<span class="cm"> * C99-style named initializers, for example:</span>
<span class="cm"> *</span>
<span class="cm"> * @code</span>
<span class="cm"> * netio_input_config_t config = {</span>
<span class="cm"> *    .flags = NETIO_RECV | NETIO_XMIT_CSUM | NETIO_TAG_NONE,</span>
<span class="cm"> *    .num_receive_packets = NETIO_MAX_RECEIVE_PKTS,</span>
<span class="cm"> *    .queue_id = 0,</span>
<span class="cm"> * },</span>
<span class="cm"> * @endcode</span>
<span class="cm"> *</span>
<span class="cm"> * instead of the old-style structure initialization:</span>
<span class="cm"> *</span>
<span class="cm"> * @code</span>
<span class="cm"> * // Bad example! Currently equivalent to the above, but don&#39;t do this.</span>
<span class="cm"> * netio_input_config_t config = {</span>
<span class="cm"> *    NETIO_RECV | NETIO_XMIT_CSUM | NETIO_TAG_NONE, NETIO_MAX_RECEIVE_PKTS, 0</span>
<span class="cm"> * },</span>
<span class="cm"> * @endcode</span>
<span class="cm"> *</span>
<span class="cm"> * since the C99 style requires no changes to the code if elements of the</span>
<span class="cm"> * config structure are rearranged.  (It also makes the initialization much</span>
<span class="cm"> * easier to understand.)</span>
<span class="cm"> *</span>
<span class="cm"> * Except for items which address a particular tile&#39;s transmit or receive</span>
<span class="cm"> * characteristics, such as the ::NETIO_RECV flag, applications are advised</span>
<span class="cm"> * to specify the same set of configuration data on all registrations.</span>
<span class="cm"> * This prevents differing results if multiple tiles happen to do their</span>
<span class="cm"> * registration operations in a different order on different invocations of</span>
<span class="cm"> * the application.  This is particularly important for things like link</span>
<span class="cm"> * management flags, and buffer size and homing specifications.</span>
<span class="cm"> *</span>
<span class="cm"> * Unless the ::NETIO_FIXED_BUFFER_VA flag is specified in flags, the NetIO</span>
<span class="cm"> * buffer pool is automatically created and mapped into the application&#39;s</span>
<span class="cm"> * virtual address space at an address chosen by the operating system,</span>
<span class="cm"> * using the common memory (cmem) facility in the Tilera Multicore</span>
<span class="cm"> * Components library.  The cmem facility allows multiple processes to gain</span>
<span class="cm"> * access to shared memory which is mapped into each process at an</span>
<span class="cm"> * identical virtual address.  In order for this to work, the processes</span>
<span class="cm"> * must have a common ancestor, which must create the common memory using</span>
<span class="cm"> * tmc_cmem_init().</span>
<span class="cm"> *</span>
<span class="cm"> * In programs using the iLib process creation API, or in programs which use</span>
<span class="cm"> * only one process (which include programs using the pthreads library),</span>
<span class="cm"> * tmc_cmem_init() is called automatically.  All other applications</span>
<span class="cm"> * must call it explicitly, before any child processes which might call</span>
<span class="cm"> * netio_input_register() are created.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="cm">/** Registration characteristics.</span>

<span class="cm">      This value determines several characteristics of the registration;</span>
<span class="cm">      flags for different types of behavior are ORed together to make the</span>
<span class="cm">      final flag value.  Generally applications should specify exactly</span>
<span class="cm">      one flag from each of the following categories:</span>

<span class="cm">      - Whether the application will be receiving packets on this queue</span>
<span class="cm">        (::NETIO_RECV or ::NETIO_NO_RECV).</span>

<span class="cm">      - Whether the application will be transmitting packets on this queue,</span>
<span class="cm">        and if so, whether it will request egress checksum calculation</span>
<span class="cm">        (::NETIO_XMIT, ::NETIO_XMIT_CSUM, or ::NETIO_NO_XMIT).  It is</span>
<span class="cm">        legal to call netio_get_buffer() without one of the XMIT flags,</span>
<span class="cm">        as long as ::NETIO_RECV is specified; in this case, the retrieved</span>
<span class="cm">        buffers must be passed to another tile for transmission.</span>

<span class="cm">      - Whether the application expects any vendor-specific tags in</span>
<span class="cm">        its packets&#39; L2 headers (::NETIO_TAG_NONE, ::NETIO_TAG_BRCM,</span>
<span class="cm">        or ::NETIO_TAG_MRVL).  This must match the configuration of the</span>
<span class="cm">        target IPP.</span>

<span class="cm">      To accommodate applications written to previous versions of the NetIO</span>
<span class="cm">      interface, none of the flags above are currently required; if omitted,</span>
<span class="cm">      NetIO behaves more or less as if ::NETIO_RECV | ::NETIO_XMIT_CSUM |</span>
<span class="cm">      ::NETIO_TAG_NONE were used.  However, explicit specification of</span>
<span class="cm">      the relevant flags allows NetIO to do a better job of resource</span>
<span class="cm">      allocation, allows earlier detection of certain configuration errors,</span>
<span class="cm">      and may enable advanced features or higher performance in the future,</span>
<span class="cm">      so their use is strongly recommended.</span>

<span class="cm">      Note that specifying ::NETIO_NO_RECV along with ::NETIO_NO_XMIT</span>
<span class="cm">      is a special case, intended primarily for use by programs which</span>
<span class="cm">      retrieve network statistics or do link management operations.</span>
<span class="cm">      When these flags are both specified, the resulting queue may not</span>
<span class="cm">      be used with NetIO routines other than netio_get(), netio_set(),</span>
<span class="cm">      and netio_input_unregister().  See @ref link for more information</span>
<span class="cm">      on link management.</span>

<span class="cm">      Other flags are optional; their use is described below.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

  <span class="cm">/** Interface name.  This is a string which identifies the specific</span>
<span class="cm">      Ethernet controller hardware to be used.  The format of the string</span>
<span class="cm">      is a device type and a device index, separated by a slash; so,</span>
<span class="cm">      the first 10 Gigabit Ethernet controller is named &quot;xgbe/0&quot;, while</span>
<span class="cm">      the second 10/100/1000 Megabit Ethernet controller is named &quot;gbe/1&quot;.</span>
<span class="cm">   */</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">interface</span><span class="p">;</span>

  <span class="cm">/** Receive packet queue size.  This specifies the maximum number</span>
<span class="cm">      of ingress packets that can be received on this queue without</span>
<span class="cm">      being retrieved by @ref netio_get_packet().  If the IPP&#39;s distribution</span>
<span class="cm">      algorithm calls for a packet to be sent to this queue, and this</span>
<span class="cm">      number of packets are already pending there, the new packet</span>
<span class="cm">      will either be discarded, or sent to another tile registered</span>
<span class="cm">      for the same queue_id (see @ref drops).  This value must</span>
<span class="cm">      be at least ::NETIO_MIN_RECEIVE_PKTS, can always be at least</span>
<span class="cm">      ::NETIO_MAX_RECEIVE_PKTS, and may be larger than that on certain</span>
<span class="cm">      interfaces.</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">num_receive_packets</span><span class="p">;</span>

  <span class="cm">/** The queue ID being requested.  Legal values for this range from 0</span>
<span class="cm">      to ::NETIO_MAX_QUEUE_ID, inclusive.  ::NETIO_MAX_QUEUE_ID is always</span>
<span class="cm">      greater than or equal to the number of tiles; this allows one queue</span>
<span class="cm">      for each tile, plus at least one additional queue.  Some applications</span>
<span class="cm">      may wish to use the additional queue as a destination for unwanted</span>
<span class="cm">      packets, since packets delivered to queues for which no tiles have</span>
<span class="cm">      registered are discarded.</span>
<span class="cm">   */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">queue_id</span><span class="p">;</span>

  <span class="cm">/** Maximum number of small send buffers to be held in the local empty</span>
<span class="cm">      buffer cache.  This specifies the size of the area which holds</span>
<span class="cm">      empty small egress buffers requested from the IPP but not yet</span>
<span class="cm">      retrieved via @ref netio_get_buffer().  This value must be greater</span>
<span class="cm">      than zero if the application will ever use @ref netio_get_buffer()</span>
<span class="cm">      to allocate empty small egress buffers; it may be no larger than</span>
<span class="cm">      ::NETIO_MAX_SEND_BUFFERS.  See @ref epp for more details on empty</span>
<span class="cm">      buffer caching.</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">num_send_buffers_small_total</span><span class="p">;</span>

  <span class="cm">/** Number of small send buffers to be preallocated at registration.</span>
<span class="cm">      If this value is nonzero, the specified number of empty small egress</span>
<span class="cm">      buffers will be requested from the IPP during the netio_input_register</span>
<span class="cm">      operation; this may speed the execution of @ref netio_get_buffer().</span>
<span class="cm">      This may be no larger than @ref num_send_buffers_small_total.  See @ref</span>
<span class="cm">      epp for more details on empty buffer caching.</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">num_send_buffers_small_prealloc</span><span class="p">;</span>

  <span class="cm">/** Maximum number of large send buffers to be held in the local empty</span>
<span class="cm">      buffer cache.  This specifies the size of the area which holds empty</span>
<span class="cm">      large egress buffers requested from the IPP but not yet retrieved via</span>
<span class="cm">      @ref netio_get_buffer().  This value must be greater than zero if the</span>
<span class="cm">      application will ever use @ref netio_get_buffer() to allocate empty</span>
<span class="cm">      large egress buffers; it may be no larger than ::NETIO_MAX_SEND_BUFFERS.</span>
<span class="cm">      See @ref epp for more details on empty buffer caching.</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">num_send_buffers_large_total</span><span class="p">;</span>

  <span class="cm">/** Number of large send buffers to be preallocated at registration.</span>
<span class="cm">      If this value is nonzero, the specified number of empty large egress</span>
<span class="cm">      buffers will be requested from the IPP during the netio_input_register</span>
<span class="cm">      operation; this may speed the execution of @ref netio_get_buffer().</span>
<span class="cm">      This may be no larger than @ref num_send_buffers_large_total.  See @ref</span>
<span class="cm">      epp for more details on empty buffer caching.</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">num_send_buffers_large_prealloc</span><span class="p">;</span>

  <span class="cm">/** Maximum number of jumbo send buffers to be held in the local empty</span>
<span class="cm">      buffer cache.  This specifies the size of the area which holds empty</span>
<span class="cm">      jumbo egress buffers requested from the IPP but not yet retrieved via</span>
<span class="cm">      @ref netio_get_buffer().  This value must be greater than zero if the</span>
<span class="cm">      application will ever use @ref netio_get_buffer() to allocate empty</span>
<span class="cm">      jumbo egress buffers; it may be no larger than ::NETIO_MAX_SEND_BUFFERS.</span>
<span class="cm">      See @ref epp for more details on empty buffer caching.</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">num_send_buffers_jumbo_total</span><span class="p">;</span>

  <span class="cm">/** Number of jumbo send buffers to be preallocated at registration.</span>
<span class="cm">      If this value is nonzero, the specified number of empty jumbo egress</span>
<span class="cm">      buffers will be requested from the IPP during the netio_input_register</span>
<span class="cm">      operation; this may speed the execution of @ref netio_get_buffer().</span>
<span class="cm">      This may be no larger than @ref num_send_buffers_jumbo_total.  See @ref</span>
<span class="cm">      epp for more details on empty buffer caching.</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">num_send_buffers_jumbo_prealloc</span><span class="p">;</span>

  <span class="cm">/** Total packet buffer size.  This determines the total size, in bytes,</span>
<span class="cm">      of the NetIO buffer pool.  Note that the maximum number of available</span>
<span class="cm">      buffers of each size is determined during hypervisor configuration</span>
<span class="cm">      (see the &lt;em&gt;System Programmer&#39;s Guide&lt;/em&gt; for details); this just</span>
<span class="cm">      influences how much host memory is allocated for those buffers.</span>

<span class="cm">      The buffer pool is allocated from common memory, which will be</span>
<span class="cm">      automatically initialized if needed.  If your buffer pool is larger</span>
<span class="cm">      than 240 MB, you might need to explicitly call @c tmc_cmem_init(),</span>
<span class="cm">      as described in the Application Libraries Reference Manual (UG227).</span>

<span class="cm">      Packet buffers are currently allocated in chunks of 16 MB; this</span>
<span class="cm">      value will be rounded up to the next larger multiple of 16 MB.</span>
<span class="cm">      If this value is zero, a default of 32 MB will be used; this was</span>
<span class="cm">      the value used by previous versions of NetIO.  Note that taking this</span>
<span class="cm">      default also affects the placement of buffers on Linux NUMA nodes.</span>
<span class="cm">      See @ref buffer_node_weights for an explanation of buffer placement.</span>

<span class="cm">      In order to successfully allocate packet buffers, Linux must have</span>
<span class="cm">      available huge pages on the relevant Linux NUMA nodes.  See the</span>
<span class="cm">      &lt;em&gt;System Programmer&#39;s Guide&lt;/em&gt; for information on configuring</span>
<span class="cm">      huge page support in Linux.</span>
<span class="cm">   */</span>
  <span class="kt">uint64_t</span> <span class="n">total_buffer_size</span><span class="p">;</span>

  <span class="cm">/** Buffer placement weighting factors.</span>

<span class="cm">      This array specifies the relative amount of buffering to place</span>
<span class="cm">      on each of the available Linux NUMA nodes.  This array is</span>
<span class="cm">      indexed by the NUMA node, and the values in the array are</span>
<span class="cm">      proportional to the amount of buffer space to allocate on that</span>
<span class="cm">      node.</span>

<span class="cm">      If memory striping is enabled in the Hypervisor, then there is</span>
<span class="cm">      only one logical NUMA node (node 0). In that case, NetIO will by</span>
<span class="cm">      default ignore the suggested buffer node weights, and buffers</span>
<span class="cm">      will be striped across the physical memory controllers. See</span>
<span class="cm">      UG209 System Programmer&#39;s Guide for a description of the</span>
<span class="cm">      hypervisor option that controls memory striping.</span>

<span class="cm">      If memory striping is disabled, then there are up to four NUMA</span>
<span class="cm">      nodes, corresponding to the four DDRAM controllers in the TILE</span>
<span class="cm">      processor architecture.  See UG100 Tile Processor Architecture</span>
<span class="cm">      Overview for a diagram showing the location of each of the DDRAM</span>
<span class="cm">      controllers relative to the tile array.</span>

<span class="cm">      For instance, if memory striping is disabled, the following</span>
<span class="cm">      configuration strucure:</span>

<span class="cm">      @code</span>
<span class="cm">      netio_input_config_t config = {</span>
<span class="cm">            .</span>
<span class="cm">            .</span>
<span class="cm">            .</span>
<span class="cm">        .total_buffer_size = 4 * 16 * 1024 * 1024;</span>
<span class="cm">        .buffer_node_weights = { 1, 0, 1, 0 },</span>
<span class="cm">      },</span>
<span class="cm">      @endcode</span>

<span class="cm">      would result in 32 MB of buffers being placed on controller 0, and</span>
<span class="cm">      32 MB on controller 2.  (Since buffers are allocated in units of</span>
<span class="cm">      16 MB, some sets of weights will not be able to be matched exactly.)</span>

<span class="cm">      For the weights to be effective, @ref total_buffer_size must be</span>
<span class="cm">      nonzero.  If @ref total_buffer_size is zero, causing the default</span>
<span class="cm">      32 MB of buffer space to be used, then any specified weights will</span>
<span class="cm">      be ignored, and buffers will positioned as they were in previous</span>
<span class="cm">      versions of NetIO:</span>

<span class="cm">      - For xgbe/0 and gbe/0, 16 MB of buffers will be placed on controller 1,</span>
<span class="cm">        and the other 16 MB will be placed on controller 2.</span>

<span class="cm">      - For xgbe/1 and gbe/1, 16 MB of buffers will be placed on controller 2,</span>
<span class="cm">        and the other 16 MB will be placed on controller 3.</span>

<span class="cm">      If @ref total_buffer_size is nonzero, but all weights are zero,</span>
<span class="cm">      then all buffer space will be allocated on Linux NUMA node zero.</span>

<span class="cm">      By default, the specified buffer placement is treated as a hint;</span>
<span class="cm">      if sufficient free memory is not available on the specified</span>
<span class="cm">      controllers, the buffers will be allocated elsewhere.  However,</span>
<span class="cm">      if the ::NETIO_STRICT_HOMING flag is specified in @ref flags, then a</span>
<span class="cm">      failure to allocate buffer space exactly as requested will cause the</span>
<span class="cm">      registration operation to fail with an error of ::NETIO_CANNOT_HOME.</span>

<span class="cm">      Note that maximal network performance cannot be achieved with</span>
<span class="cm">      only one memory controller.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">buffer_node_weights</span><span class="p">[</span><span class="n">NETIO_NUM_NODE_WEIGHTS</span><span class="p">];</span>

  <span class="cm">/** Fixed virtual address for packet buffers.  Only valid when</span>
<span class="cm">      ::NETIO_FIXED_BUFFER_VA is specified in @ref flags; see the</span>
<span class="cm">      description of that flag for details.</span>
<span class="cm">   */</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">fixed_buffer_va</span><span class="p">;</span>

  <span class="cm">/**</span>
<span class="cm">      Maximum number of outstanding send packet requests.  This value is</span>
<span class="cm">      only relevant when an EPP is in use; it determines the number of</span>
<span class="cm">      slots in the EPP&#39;s outgoing packet queue which this tile is allowed</span>
<span class="cm">      to consume, and thus the number of packets which may be sent before</span>
<span class="cm">      the sending tile must wait for an acknowledgment from the EPP.</span>
<span class="cm">      Modifying this value is generally only helpful when using @ref</span>
<span class="cm">      netio_send_packet_vector(), where it can help improve performance by</span>
<span class="cm">      allowing a single vector send operation to process more packets.</span>
<span class="cm">      Typically it is not specified, and the default, which divides the</span>
<span class="cm">      outgoing packet slots evenly between all tiles on the chip, is used.</span>

<span class="cm">      If a registration asks for more outgoing packet queue slots than are</span>
<span class="cm">      available, ::NETIO_TOOMANY_XMIT will be returned.  The total number</span>
<span class="cm">      of packet queue slots which are available for all tiles for each EPP</span>
<span class="cm">      is subject to change, but is currently ::NETIO_TOTAL_SENDS_OUTSTANDING.</span>


<span class="cm">      This value is ignored if ::NETIO_XMIT is not specified in flags.</span>
<span class="cm">      If you want to specify a large value here for a specific tile, you are</span>
<span class="cm">      advised to specify NETIO_NO_XMIT on other, non-transmitting tiles so</span>
<span class="cm">      that they do not consume a default number of packet slots.  Any tile</span>
<span class="cm">      transmitting is required to have at least ::NETIO_MIN_SENDS_OUTSTANDING</span>
<span class="cm">      slots allocated to it; values less than that will be silently</span>
<span class="cm">      increased by the NetIO library.</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">num_sends_outstanding</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">netio_input_config_t</span><span class="p">;</span>


<span class="cm">/** Registration flags; used in the @ref netio_input_config_t structure.</span>
<span class="cm"> * @addtogroup setup</span>
<span class="cm"> */</span>
<span class="cm">/** @{ */</span>

<span class="cm">/** Fail a registration request if we can&#39;t put packet buffers</span>
<span class="cm">    on the specified memory controllers. */</span>
<span class="cp">#define NETIO_STRICT_HOMING   0x00000002</span>

<span class="cm">/** This application expects no tags on its L2 headers. */</span>
<span class="cp">#define NETIO_TAG_NONE        0x00000004</span>

<span class="cm">/** This application expects Marvell extended tags on its L2 headers. */</span>
<span class="cp">#define NETIO_TAG_MRVL        0x00000008</span>

<span class="cm">/** This application expects Broadcom tags on its L2 headers. */</span>
<span class="cp">#define NETIO_TAG_BRCM        0x00000010</span>

<span class="cm">/** This registration may call routines which receive packets. */</span>
<span class="cp">#define NETIO_RECV            0x00000020</span>

<span class="cm">/** This registration may not call routines which receive packets. */</span>
<span class="cp">#define NETIO_NO_RECV         0x00000040</span>

<span class="cm">/** This registration may call routines which transmit packets. */</span>
<span class="cp">#define NETIO_XMIT            0x00000080</span>

<span class="cm">/** This registration may call routines which transmit packets with</span>
<span class="cm">    checksum acceleration. */</span>
<span class="cp">#define NETIO_XMIT_CSUM       0x00000100</span>

<span class="cm">/** This registration may not call routines which transmit packets. */</span>
<span class="cp">#define NETIO_NO_XMIT         0x00000200</span>

<span class="cm">/** This registration wants NetIO buffers mapped at an application-specified</span>
<span class="cm">    virtual address.</span>

<span class="cm">    NetIO buffers are by default created by the TMC common memory facility,</span>
<span class="cm">    which must be configured by a common ancestor of all processes sharing</span>
<span class="cm">    a network interface.  When this flag is specified, NetIO buffers are</span>
<span class="cm">    instead mapped at an address chosen by the application (and specified</span>
<span class="cm">    in @ref netio_input_config_t::fixed_buffer_va).  This allows multiple</span>
<span class="cm">    unrelated but cooperating processes to share a NetIO interface.</span>
<span class="cm">    All processes sharing the same interface must specify this flag,</span>
<span class="cm">    and all must specify the same fixed virtual address.</span>

<span class="cm">    @ref netio_input_config_t::fixed_buffer_va must be a</span>
<span class="cm">    multiple of 16 MB, and the packet buffers will occupy @ref</span>
<span class="cm">    netio_input_config_t::total_buffer_size bytes of virtual address</span>
<span class="cm">    space, beginning at that address.  If any of those virtual addresses</span>
<span class="cm">    are currently occupied by other memory objects, like application or</span>
<span class="cm">    shared library code or data, @ref netio_input_register() will return</span>
<span class="cm">    ::NETIO_FAULT.  While it is impossible to provide a fixed_buffer_va</span>
<span class="cm">    which will work for all applications, a good first guess might be to</span>
<span class="cm">    use 0xb0000000 minus @ref netio_input_config_t::total_buffer_size.</span>
<span class="cm">    If that fails, it might be helpful to consult the running application&#39;s</span>
<span class="cm">    virtual address description file (/proc/&lt;em&gt;pid&lt;/em&gt;/maps) to see</span>
<span class="cm">    which regions of virtual address space are available.</span>
<span class="cm"> */</span>
<span class="cp">#define NETIO_FIXED_BUFFER_VA 0x00000400</span>

<span class="cm">/** This registration call will not complete unless the network link</span>
<span class="cm">    is up.  The process will wait several seconds for this to happen (the</span>
<span class="cm">    precise interval is link-dependent), but if the link does not come up,</span>
<span class="cm">    ::NETIO_LINK_DOWN will be returned.  This flag is the default if</span>
<span class="cm">    ::NETIO_NOREQUIRE_LINK_UP is not specified.  Note that this flag by</span>
<span class="cm">    itself does not request that the link be brought up; that can be done</span>
<span class="cm">    with the ::NETIO_AUTO_LINK_UPDN or ::NETIO_AUTO_LINK_UP flags (the</span>
<span class="cm">    latter is the default if no NETIO_AUTO_LINK_xxx flags are specified),</span>
<span class="cm">    or by explicitly setting the link&#39;s desired state via netio_set().</span>
<span class="cm">    If the link is not brought up by one of those methods, and this flag</span>
<span class="cm">    is specified, the registration operation will return ::NETIO_LINK_DOWN.</span>
<span class="cm">    This flag is ignored if it is specified along with ::NETIO_NO_XMIT and</span>
<span class="cm">    ::NETIO_NO_RECV.  See @ref link for more information on link</span>
<span class="cm">    management.</span>
<span class="cm"> */</span>
<span class="cp">#define NETIO_REQUIRE_LINK_UP    0x00000800</span>

<span class="cm">/** This registration call will complete even if the network link is not up.</span>
<span class="cm">    Whenever the link is not up, packets will not be sent or received:</span>
<span class="cm">    netio_get_packet() will return ::NETIO_NOPKT once all queued packets</span>
<span class="cm">    have been drained, and netio_send_packet() and similar routines will</span>
<span class="cm">    return NETIO_QUEUE_FULL once the outgoing packet queue in the EPP</span>
<span class="cm">    or the I/O shim is full.  See @ref link for more information on link</span>
<span class="cm">    management.</span>
<span class="cm"> */</span>
<span class="cp">#define NETIO_NOREQUIRE_LINK_UP  0x00001000</span>

<span class="cp">#ifndef __DOXYGEN__</span>
<span class="cm">/*</span>
<span class="cm"> * These are part of the implementation of the NETIO_AUTO_LINK_xxx flags,</span>
<span class="cm"> * but should not be used directly by applications, and are thus not</span>
<span class="cm"> * documented.</span>
<span class="cm"> */</span>
<span class="cp">#define _NETIO_AUTO_UP        0x00002000</span>
<span class="cp">#define _NETIO_AUTO_DN        0x00004000</span>
<span class="cp">#define _NETIO_AUTO_PRESENT   0x00008000</span>
<span class="cp">#endif</span>

<span class="cm">/** Set the desired state of the link to up, allowing any speeds which are</span>
<span class="cm">    supported by the link hardware, as part of this registration operation.</span>
<span class="cm">    Do not take down the link automatically.  This is the default if</span>
<span class="cm">    no other NETIO_AUTO_LINK_xxx flags are specified.  This flag is ignored</span>
<span class="cm">    if it is specified along with ::NETIO_NO_XMIT and ::NETIO_NO_RECV.</span>
<span class="cm">    See @ref link for more information on link management.</span>
<span class="cm"> */</span>
<span class="cp">#define NETIO_AUTO_LINK_UP     (_NETIO_AUTO_PRESENT | _NETIO_AUTO_UP)</span>

<span class="cm">/** Set the desired state of the link to up, allowing any speeds which are</span>
<span class="cm">    supported by the link hardware, as part of this registration operation.</span>
<span class="cm">    Set the desired state of the link to down the next time no tiles are</span>
<span class="cm">    registered for packet reception or transmission.  This flag is ignored</span>
<span class="cm">    if it is specified along with ::NETIO_NO_XMIT and ::NETIO_NO_RECV.</span>
<span class="cm">    See @ref link for more information on link management.</span>
<span class="cm"> */</span>
<span class="cp">#define NETIO_AUTO_LINK_UPDN   (_NETIO_AUTO_PRESENT | _NETIO_AUTO_UP | \</span>
<span class="cp">                                _NETIO_AUTO_DN)</span>

<span class="cm">/** Set the desired state of the link to down the next time no tiles are</span>
<span class="cm">    registered for packet reception or transmission.  This flag is ignored</span>
<span class="cm">    if it is specified along with ::NETIO_NO_XMIT and ::NETIO_NO_RECV.</span>
<span class="cm">    See @ref link for more information on link management.</span>
<span class="cm"> */</span>
<span class="cp">#define NETIO_AUTO_LINK_DN     (_NETIO_AUTO_PRESENT | _NETIO_AUTO_DN)</span>

<span class="cm">/** Do not bring up the link automatically as part of this registration</span>
<span class="cm">    operation.  Do not take down the link automatically.  This flag</span>
<span class="cm">    is ignored if it is specified along with ::NETIO_NO_XMIT and</span>
<span class="cm">    ::NETIO_NO_RECV.  See @ref link for more information on link management.</span>
<span class="cm">  */</span>
<span class="cp">#define NETIO_AUTO_LINK_NONE   _NETIO_AUTO_PRESENT</span>


<span class="cm">/** Minimum number of receive packets. */</span>
<span class="cp">#define NETIO_MIN_RECEIVE_PKTS            16</span>

<span class="cm">/** Lower bound on the maximum number of receive packets; may be higher</span>
<span class="cm">    than this on some interfaces. */</span>
<span class="cp">#define NETIO_MAX_RECEIVE_PKTS           128</span>

<span class="cm">/** Maximum number of send buffers, per packet size. */</span>
<span class="cp">#define NETIO_MAX_SEND_BUFFERS            16</span>

<span class="cm">/** Number of EPP queue slots, and thus outstanding sends, per EPP. */</span>
<span class="cp">#define NETIO_TOTAL_SENDS_OUTSTANDING   2015</span>

<span class="cm">/** Minimum number of EPP queue slots, and thus outstanding sends, per</span>
<span class="cm"> *  transmitting tile. */</span>
<span class="cp">#define NETIO_MIN_SENDS_OUTSTANDING       16</span>


<span class="cm">/**@}*/</span>

<span class="cp">#ifndef __DOXYGEN__</span>

<span class="cm">/**</span>
<span class="cm"> * An object for providing Ethernet packets to a process.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__netio_queue_impl_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * An object for managing the user end of a NetIO queue.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__netio_queue_user_impl_t</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* !__DOXYGEN__ */</span><span class="cp"></span>


<span class="cm">/** A netio_queue_t describes a NetIO communications endpoint.</span>
<span class="cm"> * @ingroup setup</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
<span class="cp">#ifdef __DOXYGEN__</span>
  <span class="kt">uint8_t</span> <span class="n">opaque</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>                 <span class="cm">/**&lt; This is an opaque structure. */</span>
<span class="cp">#else</span>
  <span class="k">struct</span> <span class="n">__netio_queue_impl_t</span><span class="o">*</span> <span class="n">__system_part</span><span class="p">;</span>    <span class="cm">/**&lt; The system part. */</span>
  <span class="k">struct</span> <span class="n">__netio_queue_user_impl_t</span><span class="o">*</span> <span class="n">__user_part</span><span class="p">;</span> <span class="cm">/**&lt; The user part. */</span>
<span class="cp">#ifdef _NETIO_PTHREAD</span>
  <span class="n">_netio_percpu_mutex_t</span> <span class="n">lock</span><span class="p">;</span>                    <span class="cm">/**&lt; Queue lock. */</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">netio_queue_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * @brief Packet send context.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * Packet send context for use with netio_send_packet_prepare and _commit.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
<span class="cp">#ifdef __DOXYGEN__</span>
  <span class="kt">uint8_t</span> <span class="n">opaque</span><span class="p">[</span><span class="mi">44</span><span class="p">];</span>   <span class="cm">/**&lt; This is an opaque structure. */</span>
<span class="cp">#else</span>
  <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">;</span>        <span class="cm">/**&lt; Defined below */</span>
  <span class="kt">uint8_t</span> <span class="n">datalen</span><span class="p">;</span>      <span class="cm">/**&lt; Number of valid words pointed to by data. */</span>
  <span class="kt">uint32_t</span> <span class="n">request</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>  <span class="cm">/**&lt; Request to be sent to the EPP or shim.  Note</span>
<span class="cm">                             that this is smaller than the 11-word maximum</span>
<span class="cm">                             request size, since some constant values are</span>
<span class="cm">                             not saved in the context. */</span>
  <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>       <span class="cm">/**&lt; Data to be sent to the EPP or shim via IDN. */</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">netio_send_pkt_context_t</span><span class="p">;</span>


<span class="cp">#ifndef __DOXYGEN__</span>
<span class="cp">#define SEND_PKT_CTX_USE_EPP   1  </span><span class="cm">/**&lt; We&#39;re sending to an EPP. */</span><span class="cp"></span>
<span class="cp">#define SEND_PKT_CTX_SEND_CSUM 2  </span><span class="cm">/**&lt; Request includes a checksum. */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * @brief Packet vector entry.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * This data structure is used with netio_send_packet_vector() to send multiple</span>
<span class="cm"> * packets with one NetIO call.  The structure should be initialized by</span>
<span class="cm"> * calling netio_pkt_vector_set(), rather than by setting the fields</span>
<span class="cm"> * directly.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is guaranteed to be a power of two in size, no</span>
<span class="cm"> * bigger than one L2 cache line, and to be aligned modulo its size.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="cp">#ifndef __DOXYGEN__</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)))</span>
<span class="cp">#endif</span>
<span class="p">{</span>
  <span class="cm">/** Reserved for use by the user application.  When initialized with</span>
<span class="cm">   *  the netio_set_pkt_vector_entry() function, this field is guaranteed</span>
<span class="cm">   *  to be visible to readers only after all other fields are already</span>
<span class="cm">   *  visible.  This way it can be used as a valid flag or generation</span>
<span class="cm">   *  counter. */</span>
  <span class="kt">uint8_t</span> <span class="n">user_data</span><span class="p">;</span>

  <span class="cm">/* Structure members below this point should not be accessed directly by</span>
<span class="cm">   * applications, as they may change in the future. */</span>

  <span class="cm">/** Low 8 bits of the packet address to send.  The high bits are</span>
<span class="cm">   *  acquired from the &#39;handle&#39; field. */</span>
  <span class="kt">uint8_t</span> <span class="n">buffer_address_low</span><span class="p">;</span>

  <span class="cm">/** Number of bytes to transmit. */</span>
  <span class="kt">uint16_t</span> <span class="n">size</span><span class="p">;</span>

  <span class="cm">/** The raw handle from a netio_pkt_t.  If this is NETIO_PKT_HANDLE_NONE,</span>
<span class="cm">   *  this vector entry will be skipped and no packet will be transmitted. */</span>
  <span class="n">netio_pkt_handle_t</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">netio_pkt_vector_entry_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * @brief Initialize fields in a packet vector entry.</span>
<span class="cm"> *</span>
<span class="cm"> * @ingroup egress</span>
<span class="cm"> *</span>
<span class="cm"> * @param[out] v Pointer to the vector entry to be initialized.</span>
<span class="cm"> * @param[in] pkt Packet to be transmitted when the vector entry is passed to</span>
<span class="cm"> *        netio_send_packet_vector().  Note that the packet&#39;s attributes</span>
<span class="cm"> *        (e.g., its L2 offset and length) are captured at the time this</span>
<span class="cm"> *        routine is called; subsequent changes in those attributes will not</span>
<span class="cm"> *        be reflected in the packet which is actually transmitted.</span>
<span class="cm"> *        Changes in the packet&#39;s contents, however, will be so reflected.</span>
<span class="cm"> *        If this is NULL, no packet will be transmitted.</span>
<span class="cm"> * @param[in] user_data User data to be set in the vector entry.</span>
<span class="cm"> *        This function guarantees that the &quot;user_data&quot; field will become</span>
<span class="cm"> *        visible to a reader only after all other fields have become visible.</span>
<span class="cm"> *        This allows a structure in a ring buffer to be written and read</span>
<span class="cm"> *        by a polling reader without any locks or other synchronization.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">__inline</span> <span class="kt">void</span>
<span class="nf">netio_pkt_vector_set</span><span class="p">(</span><span class="k">volatile</span> <span class="n">netio_pkt_vector_entry_t</span><span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">netio_pkt_t</span><span class="o">*</span> <span class="n">pkt</span><span class="p">,</span>
                     <span class="kt">uint8_t</span> <span class="n">user_data</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NETIO_PKT_IS_MINIMAL</span><span class="p">(</span><span class="n">pkt</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span> <span class="n">mmd</span> <span class="o">=</span>
        <span class="p">(</span><span class="n">netio_pkt_minimal_metadata_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">__metadata</span><span class="p">;</span>
      <span class="n">v</span><span class="o">-&gt;</span><span class="n">buffer_address_low</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">NETIO_PKT_L2_DATA_MM</span><span class="p">(</span><span class="n">mmd</span><span class="p">,</span> <span class="n">pkt</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
      <span class="n">v</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">NETIO_PKT_L2_LENGTH_MM</span><span class="p">(</span><span class="n">mmd</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">netio_pkt_metadata_t</span><span class="o">*</span> <span class="n">mda</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pkt</span><span class="o">-&gt;</span><span class="n">__metadata</span><span class="p">;</span>
      <span class="n">v</span><span class="o">-&gt;</span><span class="n">buffer_address_low</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">NETIO_PKT_L2_DATA_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
      <span class="n">v</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">NETIO_PKT_L2_LENGTH_M</span><span class="p">(</span><span class="n">mda</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">v</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">__packet</span><span class="p">.</span><span class="n">word</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">v</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="cm">/* Set handle to NETIO_PKT_HANDLE_NONE. */</span>
  <span class="p">}</span>

  <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>

  <span class="n">v</span><span class="o">-&gt;</span><span class="n">user_data</span> <span class="o">=</span> <span class="n">user_data</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Flags and structures for @ref netio_get() and @ref netio_set().</span>
<span class="cm"> * @ingroup config</span>
<span class="cm"> */</span>

<span class="cm">/** @{ */</span>
<span class="cm">/** Parameter class; addr is a NETIO_PARAM_xxx value. */</span>
<span class="cp">#define NETIO_PARAM       0</span>
<span class="cm">/** Interface MAC address. This address is only valid with @ref netio_get().</span>
<span class="cm"> *  The value is a 6-byte MAC address.  Depending upon the overall system</span>
<span class="cm"> *  design, a MAC address may or may not be available for each interface. */</span>
<span class="cp">#define NETIO_PARAM_MAC        0</span>

<span class="cm">/** Determine whether to suspend output on the receipt of pause frames.</span>
<span class="cm"> *  If the value is nonzero, the I/O shim will suspend output when a pause</span>
<span class="cm"> *  frame is received.  If the value is zero, pause frames will be ignored. */</span>
<span class="cp">#define NETIO_PARAM_PAUSE_IN   1</span>

<span class="cm">/** Determine whether to send pause frames if the I/O shim packet FIFOs are</span>
<span class="cm"> *  nearly full.  If the value is zero, pause frames are not sent.  If</span>
<span class="cm"> *  the value is nonzero, it is the delay value which will be sent in any</span>
<span class="cm"> *  pause frames which are output, in units of 512 bit times. */</span>
<span class="cp">#define NETIO_PARAM_PAUSE_OUT  2</span>

<span class="cm">/** Jumbo frame support.  The value is a 4-byte integer.  If the value is</span>
<span class="cm"> *  nonzero, the MAC will accept frames of up to 10240 bytes.  If the value</span>
<span class="cm"> *  is zero, the MAC will only accept frames of up to 1544 bytes. */</span>
<span class="cp">#define NETIO_PARAM_JUMBO      3</span>

<span class="cm">/** I/O shim&#39;s overflow statistics register.  The value is two 16-bit integers.</span>
<span class="cm"> *  The first 16-bit value (or the low 16 bits, if the value is treated as a</span>
<span class="cm"> *  32-bit number) is the count of packets which were completely dropped and</span>
<span class="cm"> *  not delivered by the shim.  The second 16-bit value (or the high 16 bits,</span>
<span class="cm"> *  if the value is treated as a 32-bit number) is the count of packets</span>
<span class="cm"> *  which were truncated and thus only partially delivered by the shim.  This</span>
<span class="cm"> *  register is automatically reset to zero after it has been read.</span>
<span class="cm"> */</span>
<span class="cp">#define NETIO_PARAM_OVERFLOW   4</span>

<span class="cm">/** IPP statistics.  This address is only valid with @ref netio_get().  The</span>
<span class="cm"> *  value is a netio_stat_t structure.  Unlike the I/O shim statistics, the</span>
<span class="cm"> *  IPP statistics are not all reset to zero on read; see the description</span>
<span class="cm"> *  of the netio_stat_t for details. */</span>
<span class="cp">#define NETIO_PARAM_STAT 5</span>

<span class="cm">/** Possible link state.  The value is a combination of &quot;NETIO_LINK_xxx&quot;</span>
<span class="cm"> *  flags.  With @ref netio_get(), this will indicate which flags are</span>
<span class="cm"> *  actually supported by the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> *  For historical reasons, specifying this value to netio_set() will have</span>
<span class="cm"> *  the same behavior as using ::NETIO_PARAM_LINK_CONFIG, but this usage is</span>
<span class="cm"> *  discouraged.</span>
<span class="cm"> */</span>
<span class="cp">#define NETIO_PARAM_LINK_POSSIBLE_STATE 6</span>

<span class="cm">/** Link configuration. The value is a combination of &quot;NETIO_LINK_xxx&quot; flags.</span>
<span class="cm"> *  With @ref netio_set(), this will attempt to immediately bring up the</span>
<span class="cm"> *  link using whichever of the requested flags are supported by the</span>
<span class="cm"> *  hardware, or take down the link if the flags are zero; if this is</span>
<span class="cm"> *  not possible, an error will be returned.  Many programs will want</span>
<span class="cm"> *  to use ::NETIO_PARAM_LINK_DESIRED_STATE instead.</span>
<span class="cm"> *</span>
<span class="cm"> *  For historical reasons, specifying this value to netio_get() will</span>
<span class="cm"> *  have the same behavior as using ::NETIO_PARAM_LINK_POSSIBLE_STATE,</span>
<span class="cm"> *  but this usage is discouraged.</span>
<span class="cm"> */</span>
<span class="cp">#define NETIO_PARAM_LINK_CONFIG NETIO_PARAM_LINK_POSSIBLE_STATE</span>

<span class="cm">/** Current link state. This address is only valid with @ref netio_get().</span>
<span class="cm"> *  The value is zero or more of the &quot;NETIO_LINK_xxx&quot; flags, ORed together.</span>
<span class="cm"> *  If the link is down, the value ANDed with NETIO_LINK_SPEED will be</span>
<span class="cm"> *  zero; if the link is up, the value ANDed with NETIO_LINK_SPEED will</span>
<span class="cm"> *  result in exactly one of the NETIO_LINK_xxx values, indicating the</span>
<span class="cm"> *  current speed. */</span>
<span class="cp">#define NETIO_PARAM_LINK_CURRENT_STATE 7</span>

<span class="cm">/** Variant symbol for current state, retained for compatibility with</span>
<span class="cm"> *  pre-MDE-2.1 programs. */</span>
<span class="cp">#define NETIO_PARAM_LINK_STATUS NETIO_PARAM_LINK_CURRENT_STATE</span>

<span class="cm">/** Packet Coherence protocol. This address is only valid with @ref netio_get().</span>
<span class="cm"> *  The value is nonzero if the interface is configured for cache-coherent DMA.</span>
<span class="cm"> */</span>
<span class="cp">#define NETIO_PARAM_COHERENT 8</span>

<span class="cm">/** Desired link state. The value is a conbination of &quot;NETIO_LINK_xxx&quot;</span>
<span class="cm"> *  flags, which specify the desired state for the link.  With @ref</span>
<span class="cm"> *  netio_set(), this will, in the background, attempt to bring up the link</span>
<span class="cm"> *  using whichever of the requested flags are reasonable, or take down the</span>
<span class="cm"> *  link if the flags are zero.  The actual link up or down operation may</span>
<span class="cm"> *  happen after this call completes.  If the link state changes in the</span>
<span class="cm"> *  future, the system will continue to try to get back to the desired link</span>
<span class="cm"> *  state; for instance, if the link is brought up successfully, and then</span>
<span class="cm"> *  the network cable is disconnected, the link will go down.  However, the</span>
<span class="cm"> *  desired state of the link is still up, so if the cable is reconnected,</span>
<span class="cm"> *  the link will be brought up again.</span>
<span class="cm"> *</span>
<span class="cm"> *  With @ref netio_get(), this will indicate the desired state for the</span>
<span class="cm"> *  link, as set with a previous netio_set() call, or implicitly by a</span>
<span class="cm"> *  netio_input_register() or netio_input_unregister() operation.  This may</span>
<span class="cm"> *  not reflect the current state of the link; to get that, use</span>
<span class="cm"> *  ::NETIO_PARAM_LINK_CURRENT_STATE. */</span>
<span class="cp">#define NETIO_PARAM_LINK_DESIRED_STATE 9</span>

<span class="cm">/** NetIO statistics structure.  Retrieved using the ::NETIO_PARAM_STAT</span>
<span class="cm"> *  address passed to @ref netio_get(). */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="cm">/** Number of packets which have been received by the IPP and forwarded</span>
<span class="cm">   *  to a tile&#39;s receive queue for processing.  This value wraps at its</span>
<span class="cm">   *  maximum, and is not cleared upon read. */</span>
  <span class="kt">uint32_t</span> <span class="n">packets_received</span><span class="p">;</span>

  <span class="cm">/** Number of packets which have been dropped by the IPP, because they could</span>
<span class="cm">   *  not be received, or could not be forwarded to a tile.  The former happens</span>
<span class="cm">   *  when the IPP does not have a free packet buffer of suitable size for an</span>
<span class="cm">   *  incoming frame.  The latter happens when all potential destination tiles</span>
<span class="cm">   *  for a packet, as defined by the group, bucket, and queue configuration,</span>
<span class="cm">   *  have full receive queues.   This value wraps at its maximum, and is not</span>
<span class="cm">   *  cleared upon read. */</span>
  <span class="kt">uint32_t</span> <span class="n">packets_dropped</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">   * Note: the #defines after each of the following four one-byte values</span>
<span class="cm">   * denote their location within the third word of the netio_stat_t.  They</span>
<span class="cm">   * are intended for use only by the IPP implementation and are thus omitted</span>
<span class="cm">   * from the Doxygen output.</span>
<span class="cm">   */</span>

  <span class="cm">/** Number of packets dropped because no worker was able to accept a new</span>
<span class="cm">   *  packet.  This value saturates at its maximum, and is cleared upon</span>
<span class="cm">   *  read. */</span>
  <span class="kt">uint8_t</span> <span class="n">drops_no_worker</span><span class="p">;</span>
<span class="cp">#ifndef __DOXYGEN__</span>
<span class="cp">#define NETIO_STAT_DROPS_NO_WORKER   0</span>
<span class="cp">#endif</span>

  <span class="cm">/** Number of packets dropped because no small buffers were available.</span>
<span class="cm">   *  This value saturates at its maximum, and is cleared upon read. */</span>
  <span class="kt">uint8_t</span> <span class="n">drops_no_smallbuf</span><span class="p">;</span>
<span class="cp">#ifndef __DOXYGEN__</span>
<span class="cp">#define NETIO_STAT_DROPS_NO_SMALLBUF 1</span>
<span class="cp">#endif</span>

  <span class="cm">/** Number of packets dropped because no large buffers were available.</span>
<span class="cm">   *  This value saturates at its maximum, and is cleared upon read. */</span>
  <span class="kt">uint8_t</span> <span class="n">drops_no_largebuf</span><span class="p">;</span>
<span class="cp">#ifndef __DOXYGEN__</span>
<span class="cp">#define NETIO_STAT_DROPS_NO_LARGEBUF 2</span>
<span class="cp">#endif</span>

  <span class="cm">/** Number of packets dropped because no jumbo buffers were available.</span>
<span class="cm">   *  This value saturates at its maximum, and is cleared upon read. */</span>
  <span class="kt">uint8_t</span> <span class="n">drops_no_jumbobuf</span><span class="p">;</span>
<span class="cp">#ifndef __DOXYGEN__</span>
<span class="cp">#define NETIO_STAT_DROPS_NO_JUMBOBUF 3</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">netio_stat_t</span><span class="p">;</span>


<span class="cm">/** Link can run, should run, or is running at 10 Mbps. */</span>
<span class="cp">#define NETIO_LINK_10M         0x01</span>

<span class="cm">/** Link can run, should run, or is running at 100 Mbps. */</span>
<span class="cp">#define NETIO_LINK_100M        0x02</span>

<span class="cm">/** Link can run, should run, or is running at 1 Gbps. */</span>
<span class="cp">#define NETIO_LINK_1G          0x04</span>

<span class="cm">/** Link can run, should run, or is running at 10 Gbps. */</span>
<span class="cp">#define NETIO_LINK_10G         0x08</span>

<span class="cm">/** Link should run at the highest speed supported by the link and by</span>
<span class="cm"> *  the device connected to the link.  Only usable as a value for</span>
<span class="cm"> *  the link&#39;s desired state; never returned as a value for the current</span>
<span class="cm"> *  or possible states. */</span>
<span class="cp">#define NETIO_LINK_ANYSPEED    0x10</span>

<span class="cm">/** All legal link speeds. */</span>
<span class="cp">#define NETIO_LINK_SPEED  (NETIO_LINK_10M  | \</span>
<span class="cp">                           NETIO_LINK_100M | \</span>
<span class="cp">                           NETIO_LINK_1G   | \</span>
<span class="cp">                           NETIO_LINK_10G  | \</span>
<span class="cp">                           NETIO_LINK_ANYSPEED)</span>


<span class="cm">/** MAC register class.  Addr is a register offset within the MAC.</span>
<span class="cm"> *  Registers within the XGbE and GbE MACs are documented in the Tile</span>
<span class="cm"> *  Processor I/O Device Guide (UG104). MAC registers start at address</span>
<span class="cm"> *  0x4000, and do not include the MAC_INTERFACE registers. */</span>
<span class="cp">#define NETIO_MAC             1</span>

<span class="cm">/** MDIO register class (IEEE 802.3 clause 22 format).  Addr is the &quot;addr&quot;</span>
<span class="cm"> *  member of a netio_mdio_addr_t structure. */</span>
<span class="cp">#define NETIO_MDIO            2</span>

<span class="cm">/** MDIO register class (IEEE 802.3 clause 45 format).  Addr is the &quot;addr&quot;</span>
<span class="cm"> *  member of a netio_mdio_addr_t structure. */</span>
<span class="cp">#define NETIO_MDIO_CLAUSE45   3</span>

<span class="cm">/** NetIO MDIO address type.  Retrieved or provided using the ::NETIO_MDIO</span>
<span class="cm"> *  address passed to @ref netio_get() or @ref netio_set(). */</span>
<span class="k">typedef</span> <span class="k">union</span>
<span class="p">{</span>
  <span class="k">struct</span>
  <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span>  <span class="cm">/**&lt; MDIO register offset.  For clause 22 access,</span>
<span class="cm">                               must be less than 32. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">phy</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>   <span class="cm">/**&lt; Which MDIO PHY to access. */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dev</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>   <span class="cm">/**&lt; Which MDIO device to access within that PHY.</span>
<span class="cm">                               Applicable for clause 45 access only; ignored</span>
<span class="cm">                               for clause 22 access. */</span>
  <span class="p">}</span>
  <span class="n">bits</span><span class="p">;</span>                   <span class="cm">/**&lt; Container for bitfields. */</span>
  <span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">;</span>          <span class="cm">/**&lt; Value to pass to @ref netio_get() or</span>
<span class="cm">                           *   @ref netio_set(). */</span>
<span class="p">}</span>
<span class="n">netio_mdio_addr_t</span><span class="p">;</span>

<span class="cm">/** @} */</span>

<span class="cp">#endif </span><span class="cm">/* __NETIO_INTF_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
