<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › include › hv › drv_xgbe_impl.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>drv_xgbe_impl.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * @file drivers/xgbe/impl.h</span>
<span class="cm"> * Implementation details for the NetIO library.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __DRV_XGBE_IMPL_H__</span>
<span class="cp">#define __DRV_XGBE_IMPL_H__</span>

<span class="cp">#include &lt;hv/netio_errors.h&gt;</span>
<span class="cp">#include &lt;hv/netio_intf.h&gt;</span>
<span class="cp">#include &lt;hv/drv_xgbe_intf.h&gt;</span>


<span class="cm">/** How many groups we have (log2). */</span>
<span class="cp">#define LOG2_NUM_GROUPS (12)</span>
<span class="cm">/** How many groups we have. */</span>
<span class="cp">#define NUM_GROUPS (1 &lt;&lt; LOG2_NUM_GROUPS)</span>

<span class="cm">/** Number of output requests we&#39;ll buffer per tile. */</span>
<span class="cp">#define EPP_REQS_PER_TILE (32)</span>

<span class="cm">/** Words used in an eDMA command without checksum acceleration. */</span>
<span class="cp">#define EDMA_WDS_NO_CSUM      8</span>
<span class="cm">/** Words used in an eDMA command with checksum acceleration. */</span>
<span class="cp">#define EDMA_WDS_CSUM        10</span>
<span class="cm">/** Total available words in the eDMA command FIFO. */</span>
<span class="cp">#define EDMA_WDS_TOTAL      128</span>


<span class="cm">/*</span>
<span class="cm"> * FIXME: These definitions are internal and should have underscores!</span>
<span class="cm"> * NOTE: The actual numeric values here are intentional and allow us to</span>
<span class="cm"> * optimize the concept &quot;if small ... else if large ... else ...&quot;, by</span>
<span class="cm"> * checking for the low bit being set, and then for non-zero.</span>
<span class="cm"> * These are used as array indices, so they must have the values (0, 1, 2)</span>
<span class="cm"> * in some order.</span>
<span class="cm"> */</span>
<span class="cp">#define SIZE_SMALL (1)       </span><span class="cm">/**&lt; Small packet queue. */</span><span class="cp"></span>
<span class="cp">#define SIZE_LARGE (2)       </span><span class="cm">/**&lt; Large packet queue. */</span><span class="cp"></span>
<span class="cp">#define SIZE_JUMBO (0)       </span><span class="cm">/**&lt; Jumbo packet queue. */</span><span class="cp"></span>

<span class="cm">/** The number of &quot;SIZE_xxx&quot; values. */</span>
<span class="cp">#define NETIO_NUM_SIZES 3</span>


<span class="cm">/*</span>
<span class="cm"> * Default numbers of packets for IPP drivers.  These values are chosen</span>
<span class="cm"> * such that CIPP1 will not overflow its L2 cache.</span>
<span class="cm"> */</span>

<span class="cm">/** The default number of small packets. */</span>
<span class="cp">#define NETIO_DEFAULT_SMALL_PACKETS 2750</span>
<span class="cm">/** The default number of large packets. */</span>
<span class="cp">#define NETIO_DEFAULT_LARGE_PACKETS 2500</span>
<span class="cm">/** The default number of jumbo packets. */</span>
<span class="cp">#define NETIO_DEFAULT_JUMBO_PACKETS 250</span>


<span class="cm">/** Log2 of the size of a memory arena. */</span>
<span class="cp">#define NETIO_ARENA_SHIFT      24      </span><span class="cm">/* 16 MB */</span><span class="cp"></span>
<span class="cm">/** Size of a memory arena. */</span>
<span class="cp">#define NETIO_ARENA_SIZE       (1 &lt;&lt; NETIO_ARENA_SHIFT)</span>


<span class="cm">/** A queue of packets.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure partially defines a queue of packets waiting to be</span>
<span class="cm"> * processed.  The queue as a whole is written to by an interrupt handler and</span>
<span class="cm"> * read by non-interrupt code; this data structure is what&#39;s touched by the</span>
<span class="cm"> * interrupt handler.  The other part of the queue state, the read offset, is</span>
<span class="cm"> * kept in user space, not in hypervisor space, so it is in a separate data</span>
<span class="cm"> * structure.</span>
<span class="cm"> *</span>
<span class="cm"> * The read offset (__packet_receive_read in the user part of the queue</span>
<span class="cm"> * structure) points to the next packet to be read. When the read offset is</span>
<span class="cm"> * equal to the write offset, the queue is empty; therefore the queue must</span>
<span class="cm"> * contain one more slot than the required maximum queue size.</span>
<span class="cm"> *</span>
<span class="cm"> * Here&#39;s an example of all 3 state variables and what they mean.  All</span>
<span class="cm"> * pointers move left to right.</span>
<span class="cm"> *</span>
<span class="cm"> * @code</span>
<span class="cm"> *   I   I   V   V   V   V   I   I   I   I</span>
<span class="cm"> *   0   1   2   3   4   5   6   7   8   9  10</span>
<span class="cm"> *           ^       ^       ^               ^</span>
<span class="cm"> *           |               |               |</span>
<span class="cm"> *           |               |               __last_packet_plus_one</span>
<span class="cm"> *           |               __buffer_write</span>
<span class="cm"> *           __packet_receive_read</span>
<span class="cm"> * @endcode</span>
<span class="cm"> *</span>
<span class="cm"> * This queue has 10 slots, and thus can hold 9 packets (_last_packet_plus_one</span>
<span class="cm"> * = 10).  The read pointer is at 2, and the write pointer is at 6; thus,</span>
<span class="cm"> * there are valid, unread packets in slots 2, 3, 4, and 5.  The remaining</span>
<span class="cm"> * slots are invalid (do not contain a packet).</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/** Byte offset of the next notify packet to be written: zero for the first</span>
<span class="cm">   *  packet on the queue, sizeof (netio_pkt_t) for the second packet on the</span>
<span class="cm">   *  queue, etc. */</span>
  <span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">__packet_write</span><span class="p">;</span>

  <span class="cm">/** Offset of the packet after the last valid packet (i.e., when any</span>
<span class="cm">   *  pointer is incremented to this value, it wraps back to zero). */</span>
  <span class="kt">uint32_t</span> <span class="n">__last_packet_plus_one</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__netio_packet_queue_t</span><span class="p">;</span>


<span class="cm">/** A queue of buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure partially defines a queue of empty buffers which have been</span>
<span class="cm"> * obtained via requests to the IPP.  (The elements of the queue are packet</span>
<span class="cm"> * handles, which are transformed into a full netio_pkt_t when the buffer is</span>
<span class="cm"> * retrieved.)  The queue as a whole is written to by an interrupt handler and</span>
<span class="cm"> * read by non-interrupt code; this data structure is what&#39;s touched by the</span>
<span class="cm"> * interrupt handler.  The other parts of the queue state, the read offset and</span>
<span class="cm"> * requested write offset, are kept in user space, not in hypervisor space, so</span>
<span class="cm"> * they are in a separate data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * The read offset (__buffer_read in the user part of the queue structure)</span>
<span class="cm"> * points to the next buffer to be read. When the read offset is equal to the</span>
<span class="cm"> * write offset, the queue is empty; therefore the queue must contain one more</span>
<span class="cm"> * slot than the required maximum queue size.</span>
<span class="cm"> *</span>
<span class="cm"> * The requested write offset (__buffer_requested_write in the user part of</span>
<span class="cm"> * the queue structure) points to the slot which will hold the next buffer we</span>
<span class="cm"> * request from the IPP, once we get around to sending such a request.  When</span>
<span class="cm"> * the requested write offset is equal to the write offset, no requests for</span>
<span class="cm"> * new buffers are outstanding; when the requested write offset is one greater</span>
<span class="cm"> * than the read offset, no more requests may be sent.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, unlike the packet_queue, the buffer_queue places incoming</span>
<span class="cm"> * buffers at decreasing addresses.  This makes the check for &quot;is it time to</span>
<span class="cm"> * wrap the buffer pointer&quot; cheaper in the assembly code which receives new</span>
<span class="cm"> * buffers, and means that the value which defines the queue size,</span>
<span class="cm"> * __last_buffer, is different than in the packet queue.  Also, the offset</span>
<span class="cm"> * used in the packet_queue is already scaled by the size of a packet; here we</span>
<span class="cm"> * use unscaled slot indices for the offsets.  (These differences are</span>
<span class="cm"> * historical, and in the future it&#39;s possible that the packet_queue will look</span>
<span class="cm"> * more like this queue.)</span>
<span class="cm"> *</span>
<span class="cm"> * @code</span>
<span class="cm"> * Here&#39;s an example of all 4 state variables and what they mean.  Remember:</span>
<span class="cm"> * all pointers move right to left.</span>
<span class="cm"> *</span>
<span class="cm"> *   V   V   V   I   I   R   R   V   V   V</span>
<span class="cm"> *   0   1   2   3   4   5   6   7   8   9</span>
<span class="cm"> *           ^       ^       ^           ^</span>
<span class="cm"> *           |       |       |           |</span>
<span class="cm"> *           |       |       |           __last_buffer</span>
<span class="cm"> *           |       |       __buffer_write</span>
<span class="cm"> *           |       __buffer_requested_write</span>
<span class="cm"> *           __buffer_read</span>
<span class="cm"> * @endcode</span>
<span class="cm"> *</span>
<span class="cm"> * This queue has 10 slots, and thus can hold 9 buffers (_last_buffer = 9).</span>
<span class="cm"> * The read pointer is at 2, and the write pointer is at 6; thus, there are</span>
<span class="cm"> * valid, unread buffers in slots 2, 1, 0, 9, 8, and 7.  The requested write</span>
<span class="cm"> * pointer is at 4; thus, requests have been made to the IPP for buffers which</span>
<span class="cm"> * will be placed in slots 6 and 5 when they arrive.  Finally, the remaining</span>
<span class="cm"> * slots are invalid (do not contain a buffer).</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="cm">/** Ordinal number of the next buffer to be written: 0 for the first slot in</span>
<span class="cm">   *  the queue, 1 for the second slot in the queue, etc. */</span>
  <span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">__buffer_write</span><span class="p">;</span>

  <span class="cm">/** Ordinal number of the last buffer (i.e., when any pointer is decremented</span>
<span class="cm">   *  below zero, it is reloaded with this value). */</span>
  <span class="kt">uint32_t</span> <span class="n">__last_buffer</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__netio_buffer_queue_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * An object for providing Ethernet packets to a process.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">__netio_queue_impl_t</span>
<span class="p">{</span>
  <span class="cm">/** The queue of packets waiting to be received. */</span>
  <span class="n">__netio_packet_queue_t</span> <span class="n">__packet_receive_queue</span><span class="p">;</span>
  <span class="cm">/** The intr bit mask that IDs this device. */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__intr_id</span><span class="p">;</span>
  <span class="cm">/** Offset to queues of empty buffers, one per size. */</span>
  <span class="kt">uint32_t</span> <span class="n">__buffer_queue</span><span class="p">[</span><span class="n">NETIO_NUM_SIZES</span><span class="p">];</span>
  <span class="cm">/** The address of the first EPP tile, or -1 if no EPP. */</span>
  <span class="cm">/* ISSUE: Actually this is always &quot;0&quot; or &quot;~0&quot;. */</span>
  <span class="kt">uint32_t</span> <span class="n">__epp_location</span><span class="p">;</span>
  <span class="cm">/** The queue ID that this queue represents. */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__queue_id</span><span class="p">;</span>
  <span class="cm">/** Number of acknowledgements received. */</span>
  <span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">__acks_received</span><span class="p">;</span>
  <span class="cm">/** Last completion number received for packet_sendv. */</span>
  <span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">__last_completion_rcv</span><span class="p">;</span>
  <span class="cm">/** Number of packets allowed to be outstanding. */</span>
  <span class="kt">uint32_t</span> <span class="n">__max_outstanding</span><span class="p">;</span>
  <span class="cm">/** First VA available for packets. */</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">__va_0</span><span class="p">;</span>
  <span class="cm">/** First VA in second range available for packets. */</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">__va_1</span><span class="p">;</span>
  <span class="cm">/** Padding to align the &quot;__packets&quot; field to the size of a netio_pkt_t. */</span>
  <span class="kt">uint32_t</span> <span class="n">__padding</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="cm">/** The packets themselves. */</span>
  <span class="n">netio_pkt_t</span> <span class="n">__packets</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">netio_queue_impl_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * An object for managing the user end of a NetIO queue.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">__netio_queue_user_impl_t</span>
<span class="p">{</span>
  <span class="cm">/** The next incoming packet to be read. */</span>
  <span class="kt">uint32_t</span> <span class="n">__packet_receive_read</span><span class="p">;</span>
  <span class="cm">/** The next empty buffers to be read, one index per size. */</span>
  <span class="kt">uint8_t</span> <span class="n">__buffer_read</span><span class="p">[</span><span class="n">NETIO_NUM_SIZES</span><span class="p">];</span>
  <span class="cm">/** Where the empty buffer we next request from the IPP will go, one index</span>
<span class="cm">   * per size. */</span>
  <span class="kt">uint8_t</span> <span class="n">__buffer_requested_write</span><span class="p">[</span><span class="n">NETIO_NUM_SIZES</span><span class="p">];</span>
  <span class="cm">/** PCIe interface flag. */</span>
  <span class="kt">uint8_t</span> <span class="n">__pcie</span><span class="p">;</span>
  <span class="cm">/** Number of packets left to be received before we send a credit update. */</span>
  <span class="kt">uint32_t</span> <span class="n">__receive_credit_remaining</span><span class="p">;</span>
  <span class="cm">/** Value placed in __receive_credit_remaining when it reaches zero. */</span>
  <span class="kt">uint32_t</span> <span class="n">__receive_credit_interval</span><span class="p">;</span>
  <span class="cm">/** First fast I/O routine index. */</span>
  <span class="kt">uint32_t</span> <span class="n">__fastio_index</span><span class="p">;</span>
  <span class="cm">/** Number of acknowledgements expected. */</span>
  <span class="kt">uint32_t</span> <span class="n">__acks_outstanding</span><span class="p">;</span>
  <span class="cm">/** Last completion number requested. */</span>
  <span class="kt">uint32_t</span> <span class="n">__last_completion_req</span><span class="p">;</span>
  <span class="cm">/** File descriptor for driver. */</span>
  <span class="kt">int</span> <span class="n">__fd</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">netio_queue_user_impl_t</span><span class="p">;</span>


<span class="cp">#define NETIO_GROUP_CHUNK_SIZE   64   </span><span class="cm">/**&lt; Max # groups in one IPP request */</span><span class="cp"></span>
<span class="cp">#define NETIO_BUCKET_CHUNK_SIZE  64   </span><span class="cm">/**&lt; Max # buckets in one IPP request */</span><span class="cp"></span>


<span class="cm">/** Internal structure used to convey packet send information to the</span>
<span class="cm"> * hypervisor.  FIXME: Actually, it&#39;s not used for that anymore, but</span>
<span class="cm"> * netio_packet_send() still uses it internally.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="kt">uint16_t</span> <span class="n">flags</span><span class="p">;</span>              <span class="cm">/**&lt; Packet flags (__NETIO_SEND_FLG_xxx) */</span>
  <span class="kt">uint16_t</span> <span class="n">transfer_size</span><span class="p">;</span>      <span class="cm">/**&lt; Size of packet */</span>
  <span class="kt">uint32_t</span> <span class="n">va</span><span class="p">;</span>                 <span class="cm">/**&lt; VA of start of packet */</span>
  <span class="n">__netio_pkt_handle_t</span> <span class="n">handle</span><span class="p">;</span> <span class="cm">/**&lt; Packet handle */</span>
  <span class="kt">uint32_t</span> <span class="n">csum0</span><span class="p">;</span>              <span class="cm">/**&lt; First checksum word */</span>
  <span class="kt">uint32_t</span> <span class="n">csum1</span><span class="p">;</span>              <span class="cm">/**&lt; Second checksum word */</span>
<span class="p">}</span>
<span class="n">__netio_send_cmd_t</span><span class="p">;</span>


<span class="cm">/** Flags used in two contexts:</span>
<span class="cm"> *  - As the &quot;flags&quot; member in the __netio_send_cmd_t, above; used only</span>
<span class="cm"> *    for netio_pkt_send_{prepare,commit}.</span>
<span class="cm"> *  - As part of the flags passed to the various send packet fast I/O calls.</span>
<span class="cm"> */</span>

<span class="cm">/** Need acknowledgement on this packet.  Note that some code in the</span>
<span class="cm"> *  normal send_pkt fast I/O handler assumes that this is equal to 1. */</span>
<span class="cp">#define __NETIO_SEND_FLG_ACK    0x1</span>

<span class="cm">/** Do checksum on this packet.  (Only used with the __netio_send_cmd_t;</span>
<span class="cm"> *  normal packet sends use a special fast I/O index to denote checksumming,</span>
<span class="cm"> *  and multi-segment sends test the checksum descriptor.) */</span>
<span class="cp">#define __NETIO_SEND_FLG_CSUM   0x2</span>

<span class="cm">/** Get a completion on this packet.  Only used with multi-segment sends.  */</span>
<span class="cp">#define __NETIO_SEND_FLG_COMPLETION 0x4</span>

<span class="cm">/** Position of the number-of-extra-segments value in the flags word.</span>
<span class="cm">    Only used with multi-segment sends. */</span>
<span class="cp">#define __NETIO_SEND_FLG_XSEG_SHIFT 3</span>

<span class="cm">/** Width of the number-of-extra-segments value in the flags word. */</span>
<span class="cp">#define __NETIO_SEND_FLG_XSEG_WIDTH 2</span>

<span class="cp">#endif </span><span class="cm">/* __DRV_XGBE_IMPL_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
