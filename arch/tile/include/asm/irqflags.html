<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › include › asm › irqflags.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>irqflags.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_TILE_IRQFLAGS_H</span>
<span class="cp">#define _ASM_TILE_IRQFLAGS_H</span>

<span class="cp">#include &lt;arch/interrupts.h&gt;</span>
<span class="cp">#include &lt;arch/chip.h&gt;</span>

<span class="cp">#if !defined(__tilegx__) &amp;&amp; defined(__ASSEMBLY__)</span>

<span class="cm">/*</span>
<span class="cm"> * The set of interrupts we want to allow when interrupts are nominally</span>
<span class="cm"> * disabled.  The remainder are effectively &quot;NMI&quot; interrupts from</span>
<span class="cm"> * the point of view of the generic Linux code.  Note that synchronous</span>
<span class="cm"> * interrupts (aka &quot;non-queued&quot;) are not blocked by the mask in any case.</span>
<span class="cm"> */</span>
<span class="cp">#if CHIP_HAS_AUX_PERF_COUNTERS()</span>
<span class="cp">#define LINUX_MASKABLE_INTERRUPTS_HI \</span>
<span class="cp">	(~(INT_MASK_HI(INT_PERF_COUNT) | INT_MASK_HI(INT_AUX_PERF_COUNT)))</span>
<span class="cp">#else</span>
<span class="cp">#define LINUX_MASKABLE_INTERRUPTS_HI \</span>
<span class="cp">	(~(INT_MASK_HI(INT_PERF_COUNT)))</span>
<span class="cp">#endif</span>

<span class="cp">#else</span>

<span class="cp">#if CHIP_HAS_AUX_PERF_COUNTERS()</span>
<span class="cp">#define LINUX_MASKABLE_INTERRUPTS \</span>
<span class="cp">	(~(INT_MASK(INT_PERF_COUNT) | INT_MASK(INT_AUX_PERF_COUNT)))</span>
<span class="cp">#else</span>
<span class="cp">#define LINUX_MASKABLE_INTERRUPTS \</span>
<span class="cp">	(~(INT_MASK(INT_PERF_COUNT)))</span>
<span class="cp">#endif</span>

<span class="cp">#endif</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cm">/* NOTE: we can&#39;t include &lt;linux/percpu.h&gt; due to #include dependencies. */</span>
<span class="cp">#include &lt;asm/percpu.h&gt;</span>
<span class="cp">#include &lt;arch/spr_def.h&gt;</span>

<span class="cm">/* Set and clear kernel interrupt masks. */</span>
<span class="cp">#if CHIP_HAS_SPLIT_INTR_MASK()</span>
<span class="cp">#if INT_PERF_COUNT &lt; 32 || INT_AUX_PERF_COUNT &lt; 32 || INT_MEM_ERROR &gt;= 32</span>
<span class="cp"># error Fix assumptions about which word various interrupts are in</span>
<span class="cp">#endif</span>
<span class="cp">#define interrupt_mask_set(n) do { \</span>
<span class="cp">	int __n = (n); \</span>
<span class="cp">	int __mask = 1 &lt;&lt; (__n &amp; 0x1f); \</span>
<span class="cp">	if (__n &lt; 32) \</span>
<span class="cp">		__insn_mtspr(SPR_INTERRUPT_MASK_SET_K_0, __mask); \</span>
<span class="cp">	else \</span>
<span class="cp">		__insn_mtspr(SPR_INTERRUPT_MASK_SET_K_1, __mask); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define interrupt_mask_reset(n) do { \</span>
<span class="cp">	int __n = (n); \</span>
<span class="cp">	int __mask = 1 &lt;&lt; (__n &amp; 0x1f); \</span>
<span class="cp">	if (__n &lt; 32) \</span>
<span class="cp">		__insn_mtspr(SPR_INTERRUPT_MASK_RESET_K_0, __mask); \</span>
<span class="cp">	else \</span>
<span class="cp">		__insn_mtspr(SPR_INTERRUPT_MASK_RESET_K_1, __mask); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define interrupt_mask_check(n) ({ \</span>
<span class="cp">	int __n = (n); \</span>
<span class="cp">	(((__n &lt; 32) ? \</span>
<span class="cp">	 __insn_mfspr(SPR_INTERRUPT_MASK_K_0) : \</span>
<span class="cp">	 __insn_mfspr(SPR_INTERRUPT_MASK_K_1)) \</span>
<span class="cp">	  &gt;&gt; (__n &amp; 0x1f)) &amp; 1; \</span>
<span class="cp">})</span>
<span class="cp">#define interrupt_mask_set_mask(mask) do { \</span>
<span class="cp">	unsigned long long __m = (mask); \</span>
<span class="cp">	__insn_mtspr(SPR_INTERRUPT_MASK_SET_K_0, (unsigned long)(__m)); \</span>
<span class="cp">	__insn_mtspr(SPR_INTERRUPT_MASK_SET_K_1, (unsigned long)(__m&gt;&gt;32)); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define interrupt_mask_reset_mask(mask) do { \</span>
<span class="cp">	unsigned long long __m = (mask); \</span>
<span class="cp">	__insn_mtspr(SPR_INTERRUPT_MASK_RESET_K_0, (unsigned long)(__m)); \</span>
<span class="cp">	__insn_mtspr(SPR_INTERRUPT_MASK_RESET_K_1, (unsigned long)(__m&gt;&gt;32)); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define interrupt_mask_save_mask() \</span>
<span class="cp">	(__insn_mfspr(SPR_INTERRUPT_MASK_SET_K_0) | \</span>
<span class="cp">	 (((unsigned long long)__insn_mfspr(SPR_INTERRUPT_MASK_SET_K_1))&lt;&lt;32))</span>
<span class="cp">#define interrupt_mask_restore_mask(mask) do { \</span>
<span class="cp">	unsigned long long __m = (mask); \</span>
<span class="cp">	__insn_mtspr(SPR_INTERRUPT_MASK_K_0, (unsigned long)(__m)); \</span>
<span class="cp">	__insn_mtspr(SPR_INTERRUPT_MASK_K_1, (unsigned long)(__m&gt;&gt;32)); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define interrupt_mask_set(n) \</span>
<span class="cp">	__insn_mtspr(SPR_INTERRUPT_MASK_SET_K, (1UL &lt;&lt; (n)))</span>
<span class="cp">#define interrupt_mask_reset(n) \</span>
<span class="cp">	__insn_mtspr(SPR_INTERRUPT_MASK_RESET_K, (1UL &lt;&lt; (n)))</span>
<span class="cp">#define interrupt_mask_check(n) \</span>
<span class="cp">	((__insn_mfspr(SPR_INTERRUPT_MASK_K) &gt;&gt; (n)) &amp; 1)</span>
<span class="cp">#define interrupt_mask_set_mask(mask) \</span>
<span class="cp">	__insn_mtspr(SPR_INTERRUPT_MASK_SET_K, (mask))</span>
<span class="cp">#define interrupt_mask_reset_mask(mask) \</span>
<span class="cp">	__insn_mtspr(SPR_INTERRUPT_MASK_RESET_K, (mask))</span>
<span class="cp">#define interrupt_mask_save_mask() \</span>
<span class="cp">	__insn_mfspr(SPR_INTERRUPT_MASK_K)</span>
<span class="cp">#define interrupt_mask_restore_mask(mask) \</span>
<span class="cp">	__insn_mtspr(SPR_INTERRUPT_MASK_K, (mask))</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The set of interrupts we want active if irqs are enabled.</span>
<span class="cm"> * Note that in particular, the tile timer interrupt comes and goes</span>
<span class="cm"> * from this set, since we have no other way to turn off the timer.</span>
<span class="cm"> * Likewise, INTCTRL_K is removed and re-added during device</span>
<span class="cm"> * interrupts, as is the the hardwall UDN_FIREWALL interrupt.</span>
<span class="cm"> * We use a low bit (MEM_ERROR) as our sentinel value and make sure it</span>
<span class="cm"> * is always claimed as an &quot;active interrupt&quot; so we can query that bit</span>
<span class="cm"> * to know our current state.</span>
<span class="cm"> */</span>
<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="n">interrupts_enabled_mask</span><span class="p">);</span>
<span class="cp">#define INITIAL_INTERRUPTS_ENABLED INT_MASK(INT_MEM_ERROR)</span>

<span class="cm">/* Disable interrupts. */</span>
<span class="cp">#define arch_local_irq_disable() \</span>
<span class="cp">	interrupt_mask_set_mask(LINUX_MASKABLE_INTERRUPTS)</span>

<span class="cm">/* Disable all interrupts, including NMIs. */</span>
<span class="cp">#define arch_local_irq_disable_all() \</span>
<span class="cp">	interrupt_mask_set_mask(-1ULL)</span>

<span class="cm">/* Re-enable all maskable interrupts. */</span>
<span class="cp">#define arch_local_irq_enable() \</span>
<span class="cp">	interrupt_mask_reset_mask(__get_cpu_var(interrupts_enabled_mask))</span>

<span class="cm">/* Disable or enable interrupts based on flag argument. */</span>
<span class="cp">#define arch_local_irq_restore(disabled) do { \</span>
<span class="cp">	if (disabled) \</span>
<span class="cp">		arch_local_irq_disable(); \</span>
<span class="cp">	else \</span>
<span class="cp">		arch_local_irq_enable(); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/* Return true if &quot;flags&quot; argument means interrupts are disabled. */</span>
<span class="cp">#define arch_irqs_disabled_flags(flags) ((flags) != 0)</span>

<span class="cm">/* Return true if interrupts are currently disabled. */</span>
<span class="cp">#define arch_irqs_disabled() interrupt_mask_check(INT_MEM_ERROR)</span>

<span class="cm">/* Save whether interrupts are currently disabled. */</span>
<span class="cp">#define arch_local_save_flags() arch_irqs_disabled()</span>

<span class="cm">/* Save whether interrupts are currently disabled, then disable them. */</span>
<span class="cp">#define arch_local_irq_save() ({ \</span>
<span class="cp">	unsigned long __flags = arch_local_save_flags(); \</span>
<span class="cp">	arch_local_irq_disable(); \</span>
<span class="cp">	__flags; })</span>

<span class="cm">/* Prevent the given interrupt from being enabled next time we enable irqs. */</span>
<span class="cp">#define arch_local_irq_mask(interrupt) \</span>
<span class="cp">	(__get_cpu_var(interrupts_enabled_mask) &amp;= ~INT_MASK(interrupt))</span>

<span class="cm">/* Prevent the given interrupt from being enabled immediately. */</span>
<span class="cp">#define arch_local_irq_mask_now(interrupt) do { \</span>
<span class="cp">	arch_local_irq_mask(interrupt); \</span>
<span class="cp">	interrupt_mask_set(interrupt); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/* Allow the given interrupt to be enabled next time we enable irqs. */</span>
<span class="cp">#define arch_local_irq_unmask(interrupt) \</span>
<span class="cp">	(__get_cpu_var(interrupts_enabled_mask) |= INT_MASK(interrupt))</span>

<span class="cm">/* Allow the given interrupt to be enabled immediately, if !irqs_disabled. */</span>
<span class="cp">#define arch_local_irq_unmask_now(interrupt) do { \</span>
<span class="cp">	arch_local_irq_unmask(interrupt); \</span>
<span class="cp">	if (!irqs_disabled()) \</span>
<span class="cp">		interrupt_mask_reset(interrupt); \</span>
<span class="cp">} while (0)</span>

<span class="cp">#else </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cm">/* We provide a somewhat more restricted set for assembly. */</span>

<span class="cp">#ifdef __tilegx__</span>

<span class="cp">#if INT_MEM_ERROR != 0</span>
<span class="cp"># error Fix IRQS_DISABLED() macro</span>
<span class="cp">#endif</span>

<span class="cm">/* Return 0 or 1 to indicate whether interrupts are currently disabled. */</span>
<span class="cp">#define IRQS_DISABLED(tmp)					\</span>
<span class="cp">	mfspr   tmp, SPR_INTERRUPT_MASK_K;			\</span>
<span class="cp">	andi    tmp, tmp, 1</span>

<span class="cm">/* Load up a pointer to &amp;interrupts_enabled_mask. */</span>
<span class="cp">#define GET_INTERRUPTS_ENABLED_MASK_PTR(reg)			\</span>
<span class="cp">	moveli reg, hw2_last(interrupts_enabled_mask);		\</span>
<span class="cp">	shl16insli reg, reg, hw1(interrupts_enabled_mask);	\</span>
<span class="cp">	shl16insli reg, reg, hw0(interrupts_enabled_mask);	\</span>
<span class="cp">	add     reg, reg, tp</span>

<span class="cm">/* Disable interrupts. */</span>
<span class="cp">#define IRQ_DISABLE(tmp0, tmp1)					\</span>
<span class="cp">	moveli  tmp0, hw2_last(LINUX_MASKABLE_INTERRUPTS);	\</span>
<span class="cp">	shl16insli tmp0, tmp0, hw1(LINUX_MASKABLE_INTERRUPTS);	\</span>
<span class="cp">	shl16insli tmp0, tmp0, hw0(LINUX_MASKABLE_INTERRUPTS);	\</span>
<span class="cp">	mtspr   SPR_INTERRUPT_MASK_SET_K, tmp0</span>

<span class="cm">/* Disable ALL synchronous interrupts (used by NMI entry). */</span>
<span class="cp">#define IRQ_DISABLE_ALL(tmp)					\</span>
<span class="cp">	movei   tmp, -1;					\</span>
<span class="cp">	mtspr   SPR_INTERRUPT_MASK_SET_K, tmp</span>

<span class="cm">/* Enable interrupts. */</span>
<span class="cp">#define IRQ_ENABLE_LOAD(tmp0, tmp1)				\</span>
<span class="cp">	GET_INTERRUPTS_ENABLED_MASK_PTR(tmp0);			\</span>
<span class="cp">	ld      tmp0, tmp0</span>
<span class="cp">#define IRQ_ENABLE_APPLY(tmp0, tmp1)				\</span>
<span class="cp">	mtspr   SPR_INTERRUPT_MASK_RESET_K, tmp0</span>

<span class="cp">#else </span><span class="cm">/* !__tilegx__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Return 0 or 1 to indicate whether interrupts are currently disabled.</span>
<span class="cm"> * Note that it&#39;s important that we use a bit from the &quot;low&quot; mask word,</span>
<span class="cm"> * since when we are enabling, that is the word we write first, so if we</span>
<span class="cm"> * are interrupted after only writing half of the mask, the interrupt</span>
<span class="cm"> * handler will correctly observe that we have interrupts enabled, and</span>
<span class="cm"> * will enable interrupts itself on return from the interrupt handler</span>
<span class="cm"> * (making the original code&#39;s write of the &quot;high&quot; mask word idempotent).</span>
<span class="cm"> */</span>
<span class="cp">#define IRQS_DISABLED(tmp)					\</span>
<span class="cp">	mfspr   tmp, SPR_INTERRUPT_MASK_K_0;			\</span>
<span class="cp">	shri    tmp, tmp, INT_MEM_ERROR;			\</span>
<span class="cp">	andi    tmp, tmp, 1</span>

<span class="cm">/* Load up a pointer to &amp;interrupts_enabled_mask. */</span>
<span class="cp">#define GET_INTERRUPTS_ENABLED_MASK_PTR(reg)			\</span>
<span class="cp">	moveli  reg, lo16(interrupts_enabled_mask);		\</span>
<span class="cp">	auli    reg, reg, ha16(interrupts_enabled_mask);	\</span>
<span class="cp">	add     reg, reg, tp</span>

<span class="cm">/* Disable interrupts. */</span>
<span class="cp">#define IRQ_DISABLE(tmp0, tmp1)					\</span>
<span class="cp">	{							\</span>
<span class="cp">	 movei  tmp0, -1;					\</span>
<span class="cp">	 moveli tmp1, lo16(LINUX_MASKABLE_INTERRUPTS_HI)	\</span>
<span class="cp">	};							\</span>
<span class="cp">	{							\</span>
<span class="cp">	 mtspr  SPR_INTERRUPT_MASK_SET_K_0, tmp0;		\</span>
<span class="cp">	 auli   tmp1, tmp1, ha16(LINUX_MASKABLE_INTERRUPTS_HI)	\</span>
<span class="cp">	};							\</span>
<span class="cp">	mtspr   SPR_INTERRUPT_MASK_SET_K_1, tmp1</span>

<span class="cm">/* Disable ALL synchronous interrupts (used by NMI entry). */</span>
<span class="cp">#define IRQ_DISABLE_ALL(tmp)					\</span>
<span class="cp">	movei   tmp, -1;					\</span>
<span class="cp">	mtspr   SPR_INTERRUPT_MASK_SET_K_0, tmp;		\</span>
<span class="cp">	mtspr   SPR_INTERRUPT_MASK_SET_K_1, tmp</span>

<span class="cm">/* Enable interrupts. */</span>
<span class="cp">#define IRQ_ENABLE_LOAD(tmp0, tmp1)				\</span>
<span class="cp">	GET_INTERRUPTS_ENABLED_MASK_PTR(tmp0);			\</span>
<span class="cp">	{							\</span>
<span class="cp">	 lw     tmp0, tmp0;					\</span>
<span class="cp">	 addi   tmp1, tmp0, 4					\</span>
<span class="cp">	};							\</span>
<span class="cp">	lw      tmp1, tmp1</span>
<span class="cp">#define IRQ_ENABLE_APPLY(tmp0, tmp1)				\</span>
<span class="cp">	mtspr   SPR_INTERRUPT_MASK_RESET_K_0, tmp0;		\</span>
<span class="cp">	mtspr   SPR_INTERRUPT_MASK_RESET_K_1, tmp1</span>
<span class="cp">#endif</span>

<span class="cp">#define IRQ_ENABLE(tmp0, tmp1)					\</span>
<span class="cp">	IRQ_ENABLE_LOAD(tmp0, tmp1);				\</span>
<span class="cp">	IRQ_ENABLE_APPLY(tmp0, tmp1)</span>

<span class="cm">/*</span>
<span class="cm"> * Do the CPU&#39;s IRQ-state tracing from assembly code. We call a</span>
<span class="cm"> * C function, but almost everywhere we do, we don&#39;t mind clobbering</span>
<span class="cm"> * all the caller-saved registers.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_TRACE_IRQFLAGS</span>
<span class="cp"># define TRACE_IRQS_ON  jal trace_hardirqs_on</span>
<span class="cp"># define TRACE_IRQS_OFF jal trace_hardirqs_off</span>
<span class="cp">#else</span>
<span class="cp"># define TRACE_IRQS_ON</span>
<span class="cp"># define TRACE_IRQS_OFF</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_TILE_IRQFLAGS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
