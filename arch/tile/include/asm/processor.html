<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › include › asm › processor.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>processor.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_TILE_PROCESSOR_H</span>
<span class="cp">#define _ASM_TILE_PROCESSOR_H</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE: we don&#39;t include &lt;linux/ptrace.h&gt; or &lt;linux/percpu.h&gt; as one</span>
<span class="cm"> * normally would, due to #include dependencies.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/percpu.h&gt;</span>

<span class="cp">#include &lt;arch/chip.h&gt;</span>
<span class="cp">#include &lt;arch/spr_def.h&gt;</span>

<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">thread_struct</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seg</span><span class="p">;</span>
<span class="p">}</span> <span class="n">mm_segment_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Default implementation of macro that returns current</span>
<span class="cm"> * instruction pointer (&quot;program counter&quot;).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">current_text_addr</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#if CHIP_HAS_TILE_DMA()</span>
<span class="cm">/* Capture the state of a suspended DMA. */</span>
<span class="k">struct</span> <span class="n">tile_dma_state</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">enabled</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">src</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dest</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">strides</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">chunk_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">src_chunk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dest_chunk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">byte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * A mask of the DMA status register for selecting only the &#39;running&#39;</span>
<span class="cm"> * and &#39;done&#39; bits.</span>
<span class="cm"> */</span>
<span class="cp">#define DMA_STATUS_MASK \</span>
<span class="cp">  (SPR_DMA_STATUS__RUNNING_MASK | SPR_DMA_STATUS__DONE_MASK)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Track asynchronous TLB events (faults and access violations)</span>
<span class="cm"> * that occur while we are in kernel mode from DMA or the SN processor.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">async_tlb</span> <span class="p">{</span>
	<span class="kt">short</span> <span class="n">fault_num</span><span class="p">;</span>         <span class="cm">/* original fault number; 0 if none */</span>
	<span class="kt">char</span> <span class="n">is_fault</span><span class="p">;</span>           <span class="cm">/* was it a fault (vs an access violation) */</span>
	<span class="kt">char</span> <span class="n">is_write</span><span class="p">;</span>           <span class="cm">/* for fault: was it caused by a write? */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>   <span class="cm">/* what address faulted? */</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_HARDWALL</span>
<span class="k">struct</span> <span class="n">hardwall_info</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">hardwall_task</span> <span class="p">{</span>
	<span class="cm">/* Which hardwall is this task tied to? (or NULL if none) */</span>
	<span class="k">struct</span> <span class="n">hardwall_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="cm">/* Chains this task into the list at info-&gt;task_head. */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#ifdef __tilepro__</span>
<span class="cp">#define HARDWALL_TYPES 1   </span><span class="cm">/* udn */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define HARDWALL_TYPES 3   </span><span class="cm">/* udn, idn, and ipi */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">thread_struct</span> <span class="p">{</span>
	<span class="cm">/* kernel stack pointer */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">ksp</span><span class="p">;</span>
	<span class="cm">/* kernel PC */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">pc</span><span class="p">;</span>
	<span class="cm">/* starting user stack pointer (for page migration) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">usp0</span><span class="p">;</span>
	<span class="cm">/* pid of process that created this one */</span>
	<span class="n">pid_t</span> <span class="n">creator_pid</span><span class="p">;</span>
<span class="cp">#if CHIP_HAS_TILE_DMA()</span>
	<span class="cm">/* DMA info for suspended threads (byte == 0 means no DMA state) */</span>
	<span class="k">struct</span> <span class="n">tile_dma_state</span> <span class="n">tile_dma_state</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* User EX_CONTEXT registers */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ex_context</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="cm">/* User SYSTEM_SAVE registers */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">system_save</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="cm">/* User interrupt mask */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">interrupt_mask</span><span class="p">;</span>
	<span class="cm">/* User interrupt-control 0 state */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">intctrl_0</span><span class="p">;</span>
<span class="cp">#if CHIP_HAS_PROC_STATUS_SPR()</span>
	<span class="cm">/* Any other miscellaneous processor state bits */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">proc_status</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if !CHIP_HAS_FIXED_INTVEC_BASE()</span>
	<span class="cm">/* Interrupt base for PL0 interrupts */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interrupt_vector_base</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_TILE_RTF_HWM()</span>
	<span class="cm">/* Tile cache retry fifo high-water mark */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tile_rtf_hwm</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_DSTREAM_PF()</span>
	<span class="cm">/* Data stream prefetch control */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dstream_pf</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_HARDWALL</span>
	<span class="cm">/* Hardwall information for various resources. */</span>
	<span class="k">struct</span> <span class="n">hardwall_task</span> <span class="n">hardwall</span><span class="p">[</span><span class="n">HARDWALL_TYPES</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_TILE_DMA()</span>
	<span class="cm">/* Async DMA TLB fault information */</span>
	<span class="k">struct</span> <span class="n">async_tlb</span> <span class="n">dma_async_tlb</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_SN_PROC()</span>
	<span class="cm">/* Was static network processor when we were switched out? */</span>
	<span class="kt">int</span> <span class="n">sn_proc_running</span><span class="p">;</span>
	<span class="cm">/* Async SNI TLB fault information */</span>
	<span class="k">struct</span> <span class="n">async_tlb</span> <span class="n">sn_async_tlb</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Start with &quot;sp&quot; this many bytes below the top of the kernel stack.</span>
<span class="cm"> * This preserves the invariant that a called function may write to *sp.</span>
<span class="cm"> */</span>
<span class="cp">#define STACK_TOP_DELTA 8</span>

<span class="cm">/*</span>
<span class="cm"> * When entering the kernel via a fault, start with the top of the</span>
<span class="cm"> * pt_regs structure this many bytes below the top of the page.</span>
<span class="cm"> * This aligns the pt_regs structure optimally for cache-line access.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __tilegx__</span>
<span class="cp">#define KSTK_PTREGS_GAP  48</span>
<span class="cp">#else</span>
<span class="cp">#define KSTK_PTREGS_GAP  56</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#ifdef __tilegx__</span>
<span class="cp">#define TASK_SIZE_MAX		(MEM_LOW_END + 1)</span>
<span class="cp">#else</span>
<span class="cp">#define TASK_SIZE_MAX		PAGE_OFFSET</span>
<span class="cp">#endif</span>

<span class="cm">/* TASK_SIZE and related variables are always checked in &quot;current&quot; context. */</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="cp">#define COMPAT_TASK_SIZE	(1UL &lt;&lt; 31)</span>
<span class="cp">#define TASK_SIZE		((current_thread_info()-&gt;status &amp; TS_COMPAT) ?\</span>
<span class="cp">				 COMPAT_TASK_SIZE : TASK_SIZE_MAX)</span>
<span class="cp">#else</span>
<span class="cp">#define TASK_SIZE		TASK_SIZE_MAX</span>
<span class="cp">#endif</span>

<span class="cm">/* We provide a minimal &quot;vdso&quot; a la x86; just the sigreturn code for now. */</span>
<span class="cp">#define VDSO_BASE		(TASK_SIZE - PAGE_SIZE)</span>

<span class="cp">#define STACK_TOP		VDSO_BASE</span>

<span class="cm">/* STACK_TOP_MAX is used temporarily in execve and should not check COMPAT. */</span>
<span class="cp">#define STACK_TOP_MAX		TASK_SIZE_MAX</span>

<span class="cm">/*</span>
<span class="cm"> * This decides where the kernel will search for a free chunk of vm</span>
<span class="cm"> * space during mmap&#39;s, if it is using bottom-up mapping.</span>
<span class="cm"> */</span>
<span class="cp">#define TASK_UNMAPPED_BASE	(PAGE_ALIGN(TASK_SIZE / 3))</span>

<span class="cp">#define HAVE_ARCH_PICK_MMAP_LAYOUT</span>

<span class="cp">#define INIT_THREAD {                                                   \</span>
<span class="cp">	.ksp = (unsigned long)init_stack + THREAD_SIZE - STACK_TOP_DELTA, \</span>
<span class="cp">	.interrupt_mask = -1ULL                                         \</span>
<span class="cp">}</span>

<span class="cm">/* Kernel stack top for the task that first boots on this cpu. */</span>
<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">boot_sp</span><span class="p">);</span>

<span class="cm">/* PC to boot from on this cpu. */</span>
<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">boot_pc</span><span class="p">);</span>

<span class="cm">/* Do necessary setup to start up a newly executed thread. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">start_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">usp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">=</span> <span class="n">pc</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">=</span> <span class="n">usp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free all resources held by a thread. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">release_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">dead_task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Nothing for now */</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">kernel_thread</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_work_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Return saved (kernel) PC of a blocked thread.</span>
<span class="cm"> * Only used in a printk() in kernel/sched.c, so don&#39;t work too hard.</span>
<span class="cm"> */</span>
<span class="cp">#define thread_saved_pc(t)   ((t)-&gt;thread.pc)</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_wchan</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cm">/* Return initial ksp value for given task. */</span>
<span class="cp">#define task_ksp0(task) ((unsigned long)(task)-&gt;stack + THREAD_SIZE)</span>

<span class="cm">/* Return some info about the user process TASK. */</span>
<span class="cp">#define KSTK_TOP(task)	(task_ksp0(task) - STACK_TOP_DELTA)</span>
<span class="cp">#define task_pt_regs(task) \</span>
<span class="cp">  ((struct pt_regs *)(task_ksp0(task) - KSTK_PTREGS_GAP) - 1)</span>
<span class="cp">#define task_sp(task)	(task_pt_regs(task)-&gt;sp)</span>
<span class="cp">#define task_pc(task)	(task_pt_regs(task)-&gt;pc)</span>
<span class="cm">/* Aliases for pc and sp (used in fs/proc/array.c) */</span>
<span class="cp">#define KSTK_EIP(task)	task_pc(task)</span>
<span class="cp">#define KSTK_ESP(task)	task_sp(task)</span>

<span class="cm">/* Standard format for printing registers and other word-size data. */</span>
<span class="cp">#ifdef __tilegx__</span>
<span class="cp"># define REGFMT &quot;0x%016lx&quot;</span>
<span class="cp">#else</span>
<span class="cp"># define REGFMT &quot;0x%08lx&quot;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Do some slow action (e.g. read a slow SPR).</span>
<span class="cm"> * Note that this must also have compiler-barrier semantics since</span>
<span class="cm"> * it may be used in a busy loop reading memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpu_relax</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_PASS</span><span class="p">);</span>
	<span class="n">barrier</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Info on this processor (see fs/proc/cpuinfo.c) */</span>
<span class="k">struct</span> <span class="n">seq_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">cpuinfo_op</span><span class="p">;</span>

<span class="cm">/* Provide information about the chip model. */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">chip_model</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

<span class="cm">/* Data on which physical memory controller corresponds to which NUMA node. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">node_controller</span><span class="p">[];</span>

<span class="cp">#if CHIP_HAS_CBOX_HOME_MAP()</span>
<span class="cm">/* Does the heap allocator return hash-for-home pages by default? */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hash_default</span><span class="p">;</span>

<span class="cm">/* Should kernel stack pages be hash-for-home? */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">kstack_hash</span><span class="p">;</span>

<span class="cm">/* Does MAP_ANONYMOUS return hash-for-home pages by default? */</span>
<span class="cp">#define uheap_hash hash_default</span>

<span class="cp">#else</span>
<span class="cp">#define hash_default 0</span>
<span class="cp">#define kstack_hash 0</span>
<span class="cp">#define uheap_hash 0</span>
<span class="cp">#endif</span>

<span class="cm">/* Are we using huge pages in the TLB for kernel data? */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">kdata_huge</span><span class="p">;</span>

<span class="cm">/* Support standard Linux prefetching. */</span>
<span class="cp">#define ARCH_HAS_PREFETCH</span>
<span class="cp">#define prefetch(x) __builtin_prefetch(x)</span>
<span class="cp">#define PREFETCH_STRIDE CHIP_L2_LINE_SIZE()</span>

<span class="cm">/* Bring a value into the L1D, faulting the TLB if necessary. */</span>
<span class="cp">#ifdef __tilegx__</span>
<span class="cp">#define prefetch_L1(x) __insn_prefetch_l1_fault((void *)(x))</span>
<span class="cp">#else</span>
<span class="cp">#define prefetch_L1(x) __insn_prefetch_L1((void *)(x))</span>
<span class="cp">#endif</span>

<span class="cp">#else </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cm">/* Do some slow action (e.g. read a slow SPR). */</span>
<span class="cp">#define CPU_RELAX       mfspr zero, SPR_PASS</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cm">/* Assembly code assumes that the PL is in the low bits. */</span>
<span class="cp">#if SPR_EX_CONTEXT_1_1__PL_SHIFT != 0</span>
<span class="cp"># error Fix assembly assumptions about PL</span>
<span class="cp">#endif</span>

<span class="cm">/* We sometimes use these macros for EX_CONTEXT_0_1 as well. */</span>
<span class="cp">#if SPR_EX_CONTEXT_1_1__PL_SHIFT != SPR_EX_CONTEXT_0_1__PL_SHIFT || \</span>
<span class="cp">    SPR_EX_CONTEXT_1_1__PL_RMASK != SPR_EX_CONTEXT_0_1__PL_RMASK || \</span>
<span class="cp">    SPR_EX_CONTEXT_1_1__ICS_SHIFT != SPR_EX_CONTEXT_0_1__ICS_SHIFT || \</span>
<span class="cp">    SPR_EX_CONTEXT_1_1__ICS_RMASK != SPR_EX_CONTEXT_0_1__ICS_RMASK</span>
<span class="cp"># error Fix assumptions that EX1 macros work for both PL0 and PL1</span>
<span class="cp">#endif</span>

<span class="cm">/* Allow pulling apart and recombining the PL and ICS bits in EX_CONTEXT. */</span>
<span class="cp">#define EX1_PL(ex1) \</span>
<span class="cp">  (((ex1) &gt;&gt; SPR_EX_CONTEXT_1_1__PL_SHIFT) &amp; SPR_EX_CONTEXT_1_1__PL_RMASK)</span>
<span class="cp">#define EX1_ICS(ex1) \</span>
<span class="cp">  (((ex1) &gt;&gt; SPR_EX_CONTEXT_1_1__ICS_SHIFT) &amp; SPR_EX_CONTEXT_1_1__ICS_RMASK)</span>
<span class="cp">#define PL_ICS_EX1(pl, ics) \</span>
<span class="cp">  (((pl) &lt;&lt; SPR_EX_CONTEXT_1_1__PL_SHIFT) | \</span>
<span class="cp">   ((ics) &lt;&lt; SPR_EX_CONTEXT_1_1__ICS_SHIFT))</span>

<span class="cm">/*</span>
<span class="cm"> * Provide symbolic constants for PLs.</span>
<span class="cm"> * Note that assembly code assumes that USER_PL is zero.</span>
<span class="cm"> */</span>
<span class="cp">#define USER_PL 0</span>
<span class="cp">#if CONFIG_KERNEL_PL == 2</span>
<span class="cp">#define GUEST_PL 1</span>
<span class="cp">#endif</span>
<span class="cp">#define KERNEL_PL CONFIG_KERNEL_PL</span>

<span class="cm">/* SYSTEM_SAVE_K_0 holds the current cpu number ORed with ksp0. */</span>
<span class="cp">#define CPU_LOG_MASK_VALUE 12</span>
<span class="cp">#define CPU_MASK_VALUE ((1 &lt;&lt; CPU_LOG_MASK_VALUE) - 1)</span>
<span class="cp">#if CONFIG_NR_CPUS &gt; CPU_MASK_VALUE</span>
<span class="cp"># error Too many cpus!</span>
<span class="cp">#endif</span>
<span class="cp">#define raw_smp_processor_id() \</span>
<span class="cp">	((int)__insn_mfspr(SPR_SYSTEM_SAVE_K_0) &amp; CPU_MASK_VALUE)</span>
<span class="cp">#define get_current_ksp0() \</span>
<span class="cp">	(__insn_mfspr(SPR_SYSTEM_SAVE_K_0) &amp; ~CPU_MASK_VALUE)</span>
<span class="cp">#define next_current_ksp0(task) ({ \</span>
<span class="cp">	unsigned long __ksp0 = task_ksp0(task); \</span>
<span class="cp">	int __cpu = raw_smp_processor_id(); \</span>
<span class="cp">	BUG_ON(__ksp0 &amp; CPU_MASK_VALUE); \</span>
<span class="cp">	__ksp0 | __cpu; \</span>
<span class="cp">})</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_TILE_PROCESSOR_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
