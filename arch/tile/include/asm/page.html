<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › include › asm › page.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>page.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_TILE_PAGE_H</span>
<span class="cp">#define _ASM_TILE_PAGE_H</span>

<span class="cp">#include &lt;linux/const.h&gt;</span>
<span class="cp">#include &lt;hv/hypervisor.h&gt;</span>
<span class="cp">#include &lt;arch/chip.h&gt;</span>

<span class="cm">/* PAGE_SHIFT and HPAGE_SHIFT determine the page sizes. */</span>
<span class="cp">#if defined(CONFIG_PAGE_SIZE_16KB)</span>
<span class="cp">#define PAGE_SHIFT	14</span>
<span class="cp">#define CTX_PAGE_FLAG	HV_CTX_PG_SM_16K</span>
<span class="cp">#elif defined(CONFIG_PAGE_SIZE_64KB)</span>
<span class="cp">#define PAGE_SHIFT	16</span>
<span class="cp">#define CTX_PAGE_FLAG	HV_CTX_PG_SM_64K</span>
<span class="cp">#else</span>
<span class="cp">#define PAGE_SHIFT	HV_LOG2_DEFAULT_PAGE_SIZE_SMALL</span>
<span class="cp">#define CTX_PAGE_FLAG	0</span>
<span class="cp">#endif</span>
<span class="cp">#define HPAGE_SHIFT	HV_LOG2_DEFAULT_PAGE_SIZE_LARGE</span>

<span class="cp">#define PAGE_SIZE	(_AC(1, UL) &lt;&lt; PAGE_SHIFT)</span>
<span class="cp">#define HPAGE_SIZE	(_AC(1, UL) &lt;&lt; HPAGE_SHIFT)</span>

<span class="cp">#define PAGE_MASK	(~(PAGE_SIZE - 1))</span>
<span class="cp">#define HPAGE_MASK	(~(HPAGE_SIZE - 1))</span>

<span class="cm">/*</span>
<span class="cm"> * If the Kconfig doesn&#39;t specify, set a maximum zone order that</span>
<span class="cm"> * is enough so that we can create huge pages from small pages given</span>
<span class="cm"> * the respective sizes of the two page types.  See &lt;linux/mmzone.h&gt;.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_FORCE_MAX_ZONEORDER</span>
<span class="cp">#define CONFIG_FORCE_MAX_ZONEORDER (HPAGE_SHIFT - PAGE_SHIFT + 1)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>

<span class="k">struct</span> <span class="n">page</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">copy_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_user_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">copy_user_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">topage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">copy_page</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hypervisor page tables are made of the same basic structure.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="n">HV_PTE</span> <span class="n">pte_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">HV_PTE</span> <span class="n">pgd_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">HV_PTE</span> <span class="n">pgprot_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * User L2 page tables are managed as one L2 page table per page,</span>
<span class="cm"> * because we use the page allocator for them.  This keeps the allocation</span>
<span class="cm"> * simple, but it&#39;s also inefficient, since L2 page tables are much smaller</span>
<span class="cm"> * than pages (currently 2KB vs 64KB).  So we should revisit this.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pgtable_t</span><span class="p">;</span>

<span class="cm">/* Must be a macro since it is used to create constants. */</span>
<span class="cp">#define __pgprot(val) hv_pte(val)</span>

<span class="cm">/* Rarely-used initializers, typically with a &quot;zero&quot; value. */</span>
<span class="cp">#define __pte(x) hv_pte(x)</span>
<span class="cp">#define __pgd(x) hv_pte(x)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">pgprot_val</span><span class="p">(</span><span class="n">pgprot_t</span> <span class="n">pgprot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hv_pte_val</span><span class="p">(</span><span class="n">pgprot</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">pte_val</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hv_pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">pgd_val</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hv_pte_val</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef __tilegx__</span>

<span class="k">typedef</span> <span class="n">HV_PTE</span> <span class="n">pmd_t</span><span class="p">;</span>

<span class="cp">#define __pmd(x) hv_pte(x)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">pmd_val</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hv_pte_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__attribute_const__</span> <span class="kt">int</span> <span class="nf">get_order</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="n">__builtin_clzl</span><span class="p">((</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)</span>

<span class="cp">#define HUGE_MAX_HSTATE		6</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
<span class="cp">#define HAVE_ARCH_HUGETLB_UNMAPPED_AREA</span>
<span class="cp">#endif</span>

<span class="cm">/* Each memory controller has PAs distinct in their high bits. */</span>
<span class="cp">#define NR_PA_HIGHBIT_SHIFT (CHIP_PA_WIDTH() - CHIP_LOG_NUM_MSHIMS())</span>
<span class="cp">#define NR_PA_HIGHBIT_VALUES (1 &lt;&lt; CHIP_LOG_NUM_MSHIMS())</span>
<span class="cp">#define __pa_to_highbits(pa) ((phys_addr_t)(pa) &gt;&gt; NR_PA_HIGHBIT_SHIFT)</span>
<span class="cp">#define __pfn_to_highbits(pfn) ((pfn) &gt;&gt; (NR_PA_HIGHBIT_SHIFT - PAGE_SHIFT))</span>

<span class="cp">#ifdef __tilegx__</span>

<span class="cm">/*</span>
<span class="cm"> * We reserve the lower half of memory for user-space programs, and the</span>
<span class="cm"> * upper half for system code.  We re-map all of physical memory in the</span>
<span class="cm"> * upper half, which takes a quarter of our VA space.  Then we have</span>
<span class="cm"> * the vmalloc regions.  The supervisor code lives at 0xfffffff700000000,</span>
<span class="cm"> * with the hypervisor above that.</span>
<span class="cm"> *</span>
<span class="cm"> * Loadable kernel modules are placed immediately after the static</span>
<span class="cm"> * supervisor code, with each being allocated a 256MB region of</span>
<span class="cm"> * address space, so we don&#39;t have to worry about the range of &quot;jal&quot;</span>
<span class="cm"> * and other branch instructions.</span>
<span class="cm"> *</span>
<span class="cm"> * For now we keep life simple and just allocate one pmd (4GB) for vmalloc.</span>
<span class="cm"> * Similarly, for now we don&#39;t play any struct page mapping games.</span>
<span class="cm"> */</span>

<span class="cp">#if CHIP_PA_WIDTH() + 2 &gt; CHIP_VA_WIDTH()</span>
<span class="cp"># error Too much PA to map with the VA available!</span>
<span class="cp">#endif</span>
<span class="cp">#define HALF_VA_SPACE           (_AC(1, UL) &lt;&lt; (CHIP_VA_WIDTH() - 1))</span>

<span class="cp">#define MEM_LOW_END		(HALF_VA_SPACE - 1)         </span><span class="cm">/* low half */</span><span class="cp"></span>
<span class="cp">#define MEM_HIGH_START		(-HALF_VA_SPACE)            </span><span class="cm">/* high half */</span><span class="cp"></span>
<span class="cp">#define PAGE_OFFSET		MEM_HIGH_START</span>
<span class="cp">#define _VMALLOC_START		_AC(0xfffffff500000000, UL) </span><span class="cm">/* 4 GB */</span><span class="cp"></span>
<span class="cp">#define HUGE_VMAP_BASE		_AC(0xfffffff600000000, UL) </span><span class="cm">/* 4 GB */</span><span class="cp"></span>
<span class="cp">#define MEM_SV_START		_AC(0xfffffff700000000, UL) </span><span class="cm">/* 256 MB */</span><span class="cp"></span>
<span class="cp">#define MEM_SV_INTRPT		MEM_SV_START</span>
<span class="cp">#define MEM_MODULE_START	_AC(0xfffffff710000000, UL) </span><span class="cm">/* 256 MB */</span><span class="cp"></span>
<span class="cp">#define MEM_MODULE_END		(MEM_MODULE_START + (256*1024*1024))</span>
<span class="cp">#define MEM_HV_START		_AC(0xfffffff800000000, UL) </span><span class="cm">/* 32 GB */</span><span class="cp"></span>

<span class="cm">/* Highest DTLB address we will use */</span>
<span class="cp">#define KERNEL_HIGH_VADDR	MEM_SV_START</span>

<span class="cm">/* Since we don&#39;t currently provide any fixmaps, we use an impossible VA. */</span>
<span class="cp">#define FIXADDR_TOP             MEM_HV_START</span>

<span class="cp">#else </span><span class="cm">/* !__tilegx__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * A PAGE_OFFSET of 0xC0000000 means that the kernel has</span>
<span class="cm"> * a virtual address space of one gigabyte, which limits the</span>
<span class="cm"> * amount of physical memory you can use to about 768MB.</span>
<span class="cm"> * If you want more physical memory than this then see the CONFIG_HIGHMEM</span>
<span class="cm"> * option in the kernel configuration.</span>
<span class="cm"> *</span>
<span class="cm"> * The top 16MB chunk in the table below is unavailable to Linux.  Since</span>
<span class="cm"> * the kernel interrupt vectors must live at ether 0xfe000000 or 0xfd000000</span>
<span class="cm"> * (depending on whether the kernel is at PL2 or Pl1), we map all of the</span>
<span class="cm"> * bottom of RAM at this address with a huge page table entry to minimize</span>
<span class="cm"> * its ITLB footprint (as well as at PAGE_OFFSET).  The last architected</span>
<span class="cm"> * requirement is that user interrupt vectors live at 0xfc000000, so we</span>
<span class="cm"> * make that range of memory available to user processes.  The remaining</span>
<span class="cm"> * regions are sized as shown; the first four addresses use the PL 1</span>
<span class="cm"> * values, and after that, we show &quot;typical&quot; values, since the actual</span>
<span class="cm"> * addresses depend on kernel #defines.</span>
<span class="cm"> *</span>
<span class="cm"> * MEM_HV_INTRPT                   0xfe000000</span>
<span class="cm"> * MEM_SV_INTRPT (kernel code)     0xfd000000</span>
<span class="cm"> * MEM_USER_INTRPT (user vector)   0xfc000000</span>
<span class="cm"> * FIX_KMAP_xxx                    0xf8000000 (via NR_CPUS * KM_TYPE_NR)</span>
<span class="cm"> * PKMAP_BASE                      0xf7000000 (via LAST_PKMAP)</span>
<span class="cm"> * HUGE_VMAP                       0xf3000000 (via CONFIG_NR_HUGE_VMAPS)</span>
<span class="cm"> * VMALLOC_START                   0xf0000000 (via __VMALLOC_RESERVE)</span>
<span class="cm"> * mapped LOWMEM                   0xc0000000</span>
<span class="cm"> */</span>

<span class="cp">#define MEM_USER_INTRPT		_AC(0xfc000000, UL)</span>
<span class="cp">#if CONFIG_KERNEL_PL == 1</span>
<span class="cp">#define MEM_SV_INTRPT		_AC(0xfd000000, UL)</span>
<span class="cp">#define MEM_HV_INTRPT		_AC(0xfe000000, UL)</span>
<span class="cp">#else</span>
<span class="cp">#define MEM_GUEST_INTRPT	_AC(0xfd000000, UL)</span>
<span class="cp">#define MEM_SV_INTRPT		_AC(0xfe000000, UL)</span>
<span class="cp">#define MEM_HV_INTRPT		_AC(0xff000000, UL)</span>
<span class="cp">#endif</span>

<span class="cp">#define INTRPT_SIZE		0x4000</span>

<span class="cm">/* Tolerate page size larger than the architecture interrupt region size. */</span>
<span class="cp">#if PAGE_SIZE &gt; INTRPT_SIZE</span>
<span class="cp">#undef INTRPT_SIZE</span>
<span class="cp">#define INTRPT_SIZE PAGE_SIZE</span>
<span class="cp">#endif</span>

<span class="cp">#define KERNEL_HIGH_VADDR	MEM_USER_INTRPT</span>
<span class="cp">#define FIXADDR_TOP		(KERNEL_HIGH_VADDR - PAGE_SIZE)</span>

<span class="cp">#define PAGE_OFFSET		_AC(CONFIG_PAGE_OFFSET, UL)</span>

<span class="cm">/* On 32-bit architectures we mix kernel modules in with other vmaps. */</span>
<span class="cp">#define MEM_MODULE_START	VMALLOC_START</span>
<span class="cp">#define MEM_MODULE_END		VMALLOC_END</span>

<span class="cp">#endif </span><span class="cm">/* __tilegx__ */</span><span class="cp"></span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>

<span class="cm">/* Map kernel virtual addresses to page frames, in HPAGE_SIZE chunks. */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pbase_map</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vbase_map</span><span class="p">[];</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">kaddr_to_pfn</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_kaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_kaddr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pbase_map</span><span class="p">[</span><span class="n">kaddr</span> <span class="o">&gt;&gt;</span> <span class="n">HPAGE_SHIFT</span><span class="p">]</span> <span class="o">+</span>
		<span class="p">((</span><span class="n">kaddr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HPAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">pfn_to_kaddr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vbase_map</span><span class="p">[</span><span class="n">__pfn_to_highbits</span><span class="p">(</span><span class="n">pfn</span><span class="p">)]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">phys_addr_t</span> <span class="nf">virt_to_phys</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">kaddr_to_pfn</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">phys_addr_t</span><span class="p">)</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">kaddr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">phys_to_virt</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">paddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">paddr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* With HIGHMEM, we pack PAGE_OFFSET through high_memory with all valid VAs. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">virt_addr_valid</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">high_memory</span><span class="p">;</span>  <span class="cm">/* copied from &lt;linux/mm.h&gt; */</span>
	<span class="k">return</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">kaddr</span> <span class="o">&gt;=</span> <span class="n">PAGE_OFFSET</span> <span class="o">&amp;&amp;</span> <span class="n">kaddr</span> <span class="o">&lt;</span> <span class="n">high_memory</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_HIGHMEM */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">kaddr_to_pfn</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">kaddr</span> <span class="o">-</span> <span class="n">PAGE_OFFSET</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">pfn_to_kaddr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">phys_addr_t</span> <span class="nf">virt_to_phys</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">phys_addr_t</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">kaddr</span> <span class="o">-</span> <span class="n">PAGE_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">phys_to_virt</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">paddr</span> <span class="o">+</span> <span class="n">PAGE_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check that the given address is within some mapped range of PAs. */</span>
<span class="cp">#define virt_addr_valid(kaddr) pfn_valid(kaddr_to_pfn(kaddr))</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_HIGHMEM */</span><span class="cp"></span>

<span class="cm">/* All callers are not consistent in how they call these functions. */</span>
<span class="cp">#define __pa(kaddr) virt_to_phys((void *)(unsigned long)(kaddr))</span>
<span class="cp">#define __va(paddr) phys_to_virt((phys_addr_t)(paddr))</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">devmem_is_allowed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pagenr</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_FLATMEM</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pfn_valid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">max_mapnr</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Provide as macros since these require some other headers included. */</span>
<span class="cp">#define page_to_pa(page) ((phys_addr_t)(page_to_pfn(page)) &lt;&lt; PAGE_SHIFT)</span>
<span class="cp">#define virt_to_page(kaddr) pfn_to_page(kaddr_to_pfn((void *)(kaddr)))</span>
<span class="cp">#define page_to_virt(page) pfn_to_kaddr(page_to_pfn(page))</span>

<span class="k">struct</span> <span class="n">mm_struct</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">virt_to_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#define VM_DATA_DEFAULT_FLAGS \</span>
<span class="cp">	(VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)</span>

<span class="cp">#include &lt;asm-generic/memory_model.h&gt;</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_TILE_PAGE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
