<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › lib › spinlock_32.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>spinlock_32.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;arch/spr_def.h&gt;</span>

<span class="cp">#include &quot;spinlock_common.h&quot;</span>

<span class="kt">void</span> <span class="nf">arch_spin_lock</span><span class="p">(</span><span class="n">arch_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">my_ticket</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">delta</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">my_ticket</span> <span class="o">=</span> <span class="n">__insn_tns</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">next_ticket</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">delay_backoff</span><span class="p">(</span><span class="n">iterations</span><span class="o">++</span><span class="p">);</span>

	<span class="cm">/* Increment the next ticket number, implicitly releasing tns lock. */</span>
	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">next_ticket</span> <span class="o">=</span> <span class="n">my_ticket</span> <span class="o">+</span> <span class="n">TICKET_QUANTUM</span><span class="p">;</span>

	<span class="cm">/* Wait until it&#39;s our turn. */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">delta</span> <span class="o">=</span> <span class="n">my_ticket</span> <span class="o">-</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">current_ticket</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">relax</span><span class="p">((</span><span class="mi">128</span> <span class="o">/</span> <span class="n">CYCLES_PER_RELAX_LOOP</span><span class="p">)</span> <span class="o">*</span> <span class="n">delta</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arch_spin_lock</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">arch_spin_trylock</span><span class="p">(</span><span class="n">arch_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Grab a ticket; no need to retry if it&#39;s busy, we&#39;ll just</span>
<span class="cm">	 * treat that the same as &quot;locked&quot;, since someone else</span>
<span class="cm">	 * will lock it momentarily anyway.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">my_ticket</span> <span class="o">=</span> <span class="n">__insn_tns</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">next_ticket</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">my_ticket</span> <span class="o">==</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">current_ticket</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Not currently locked, so lock it by keeping this ticket. */</span>
		<span class="n">lock</span><span class="o">-&gt;</span><span class="n">next_ticket</span> <span class="o">=</span> <span class="n">my_ticket</span> <span class="o">+</span> <span class="n">TICKET_QUANTUM</span><span class="p">;</span>
		<span class="cm">/* Success! */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">my_ticket</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Release next_ticket. */</span>
		<span class="n">lock</span><span class="o">-&gt;</span><span class="n">next_ticket</span> <span class="o">=</span> <span class="n">my_ticket</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arch_spin_trylock</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">arch_spin_unlock_wait</span><span class="p">(</span><span class="n">arch_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">arch_spin_is_locked</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span>
		<span class="n">delay_backoff</span><span class="p">(</span><span class="n">iterations</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arch_spin_unlock_wait</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The low byte is always reserved to be the marker for a &quot;tns&quot; operation</span>
<span class="cm"> * since the low bit is set to &quot;1&quot; by a tns.  The next seven bits are</span>
<span class="cm"> * zeroes.  The next byte holds the &quot;next&quot; writer value, i.e. the ticket</span>
<span class="cm"> * available for the next task that wants to write.  The third byte holds</span>
<span class="cm"> * the current writer value, i.e. the writer who holds the current ticket.</span>
<span class="cm"> * If current == next == 0, there are no interested writers.</span>
<span class="cm"> */</span>
<span class="cp">#define WR_NEXT_SHIFT   _WR_NEXT_SHIFT</span>
<span class="cp">#define WR_CURR_SHIFT   _WR_CURR_SHIFT</span>
<span class="cp">#define WR_WIDTH        _WR_WIDTH</span>
<span class="cp">#define WR_MASK         ((1 &lt;&lt; WR_WIDTH) - 1)</span>

<span class="cm">/*</span>
<span class="cm"> * The last eight bits hold the active reader count.  This has to be</span>
<span class="cm"> * zero before a writer can start to write.</span>
<span class="cm"> */</span>
<span class="cp">#define RD_COUNT_SHIFT  _RD_COUNT_SHIFT</span>
<span class="cp">#define RD_COUNT_WIDTH  _RD_COUNT_WIDTH</span>
<span class="cp">#define RD_COUNT_MASK   ((1 &lt;&lt; RD_COUNT_WIDTH) - 1)</span>


<span class="cm">/*</span>
<span class="cm"> * We can get the read lock if everything but the reader bits (which</span>
<span class="cm"> * are in the high part of the word) is zero, i.e. no active or</span>
<span class="cm"> * waiting writers, no tns.</span>
<span class="cm"> *</span>
<span class="cm"> * We guard the tns/store-back with an interrupt critical section to</span>
<span class="cm"> * preserve the semantic that the same read lock can be acquired in an</span>
<span class="cm"> * interrupt context.</span>
<span class="cm"> */</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">arch_read_trylock</span><span class="p">(</span><span class="n">arch_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_INTERRUPT_CRITICAL_SECTION</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">__insn_tns</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">_RD_COUNT_WIDTH</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">RD_COUNT_SHIFT</span><span class="p">;</span>
		<span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_INTERRUPT_CRITICAL_SECTION</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>  <span class="cm">/* we don&#39;t expect wraparound */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_INTERRUPT_CRITICAL_SECTION</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arch_read_trylock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Spin doing arch_read_trylock() until we acquire the lock.</span>
<span class="cm"> * ISSUE: This approach can permanently starve readers.  A reader who sees</span>
<span class="cm"> * a writer could instead take a ticket lock (just like a writer would),</span>
<span class="cm"> * and atomically enter read mode (with 1 reader) when it gets the ticket.</span>
<span class="cm"> * This way both readers and writers would always make forward progress</span>
<span class="cm"> * in a finite time.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">arch_read_lock</span><span class="p">(</span><span class="n">arch_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">arch_read_trylock</span><span class="p">(</span><span class="n">rwlock</span><span class="p">)))</span>
		<span class="n">delay_backoff</span><span class="p">(</span><span class="n">iterations</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arch_read_lock</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">arch_read_unlock</span><span class="p">(</span><span class="n">arch_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mb</span><span class="p">();</span>  <span class="cm">/* guarantee anything modified under the lock is visible */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_INTERRUPT_CRITICAL_SECTION</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">__insn_tns</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="n">val</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">_RD_COUNT_SHIFT</span><span class="p">);</span>
			<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_INTERRUPT_CRITICAL_SECTION</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_INTERRUPT_CRITICAL_SECTION</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">delay_backoff</span><span class="p">(</span><span class="n">iterations</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arch_read_unlock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We don&#39;t need an interrupt critical section here (unlike for</span>
<span class="cm"> * arch_read_lock) since we should never use a bare write lock where</span>
<span class="cm"> * it could be interrupted by code that could try to re-acquire it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">arch_write_lock</span><span class="p">(</span><span class="n">arch_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The trailing underscore on this variable (and curr_ below)</span>
<span class="cm">	 * reminds us that the high bits are garbage; we mask them out</span>
<span class="cm">	 * when we compare them.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">my_ticket_</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="n">__insn_tns</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">_WR_NEXT_SHIFT</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait until there are no readers, then bump up the next</span>
<span class="cm">	 * field and capture the ticket value.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="n">RD_COUNT_SHIFT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">delay_backoff</span><span class="p">(</span><span class="n">iterations</span><span class="o">++</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">__insn_tns</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Take out the next ticket and extract my ticket value. */</span>
	<span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="n">__insn_addb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">WR_NEXT_SHIFT</span><span class="p">);</span>
	<span class="n">my_ticket_</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="n">WR_NEXT_SHIFT</span><span class="p">;</span>

	<span class="cm">/* Wait until the &quot;current&quot; field matches our ticket. */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">curr_</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="n">WR_CURR_SHIFT</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">((</span><span class="n">my_ticket_</span> <span class="o">-</span> <span class="n">curr_</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">WR_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">delta</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Delay based on how many lock-holders are still out there. */</span>
		<span class="n">relax</span><span class="p">((</span><span class="mi">256</span> <span class="o">/</span> <span class="n">CYCLES_PER_RELAX_LOOP</span><span class="p">)</span> <span class="o">*</span> <span class="n">delta</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get a non-tns value to check; we don&#39;t need to tns</span>
<span class="cm">		 * it ourselves.  Since we&#39;re not tns&#39;ing, we retry</span>
<span class="cm">		 * more rapidly to get a valid value.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">val</span> <span class="o">=</span> <span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">relax</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arch_write_lock</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">arch_write_trylock</span><span class="p">(</span><span class="n">arch_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="n">__insn_tns</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a tns is in progress, or there&#39;s a waiting or active locker,</span>
<span class="cm">	 * or active readers, we can&#39;t take the lock, so give up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the &quot;next&quot; field to mark it locked. */</span>
	<span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">_WR_NEXT_SHIFT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arch_write_trylock</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">arch_write_unlock</span><span class="p">(</span><span class="n">arch_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="n">eq</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">mb</span><span class="p">();</span>  <span class="cm">/* guarantee anything modified under the lock is visible */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">__insn_tns</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">_WR_NEXT_SHIFT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Limited backoff since we are the highest-priority task. */</span>
		<span class="n">relax</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">__insn_tns</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">WR_CURR_SHIFT</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">__insn_addb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">eq</span> <span class="o">=</span> <span class="n">__insn_seqb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">WR_CURR_SHIFT</span> <span class="o">-</span> <span class="n">WR_NEXT_SHIFT</span><span class="p">));</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">__insn_mz</span><span class="p">(</span><span class="n">eq</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">rwlock</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">arch_write_unlock</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
