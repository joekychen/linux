<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › mm › fault.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fault.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> *</span>
<span class="cm"> * From i386 code copyright (C) 1995  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/vt_kern.h&gt;		</span><span class="cm">/* For unblank_screen() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>

<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/traps.h&gt;</span>
<span class="cp">#include &lt;asm/syscalls.h&gt;</span>

<span class="cp">#include &lt;arch/interrupts.h&gt;</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">force_sig_info_fault</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">si_signo</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">si_code</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">fault_num</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">siginfo_t</span> <span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Signal %d (code %d) at %#lx sent to %s!&quot;</span><span class="p">,</span>
		      <span class="n">si_signo</span><span class="p">,</span> <span class="n">si_code</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
		      <span class="n">is_idle_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;the idle task&quot;</span> <span class="o">:</span> <span class="s">&quot;init&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">si_signo</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">si_code</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_trapno</span> <span class="o">=</span> <span class="n">fault_num</span><span class="p">;</span>
	<span class="n">trace_unhandled_signal</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">si_signo</span><span class="p">);</span>
	<span class="n">force_sig_info</span><span class="p">(</span><span class="n">si_signo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef __tilegx__</span>
<span class="cm">/*</span>
<span class="cm"> * Synthesize the fault a PL0 process would get by doing a word-load of</span>
<span class="cm"> * an unaligned address or a high kernel address.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">cmpxchg_badaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">,</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="n">PAGE_OFFSET</span><span class="p">)</span>
		<span class="n">force_sig_info_fault</span><span class="p">(</span><span class="s">&quot;atomic segfault&quot;</span><span class="p">,</span> <span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">SEGV_MAPERR</span><span class="p">,</span>
				     <span class="n">address</span><span class="p">,</span> <span class="n">INT_DTLB_MISS</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">force_sig_info_fault</span><span class="p">(</span><span class="s">&quot;atomic alignment fault&quot;</span><span class="p">,</span> <span class="n">SIGBUS</span><span class="p">,</span>
				     <span class="n">BUS_ADRALN</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
				     <span class="n">INT_UNALIGN_DATA</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Adjust pc to point at the actual instruction, which is unusual</span>
<span class="cm">	 * for syscalls normally, but is appropriate when we are claiming</span>
<span class="cm">	 * that a syscall swint1 caused a page fault or bus error.</span>
<span class="cm">	 */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mark this as a caller-save interrupt, like a normal page fault,</span>
<span class="cm">	 * so that when we go through the signal handler path we will</span>
<span class="cm">	 * properly restore r0, r1, and r2 for the signal handler arguments.</span>
<span class="cm">	 */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PT_FLAGS_CALLER_SAVES</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">vmalloc_sync_one</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">index</span> <span class="o">=</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd_k</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span> <span class="o">*</span><span class="n">pud_k</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="o">*</span><span class="n">pmd_k</span><span class="p">;</span>

	<span class="n">pgd</span> <span class="o">+=</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">pgd_k</span> <span class="o">=</span> <span class="n">init_mm</span><span class="p">.</span><span class="n">pgd</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pgd_k</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="n">pud_k</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd_k</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud_present</span><span class="p">(</span><span class="o">*</span><span class="n">pud_k</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="n">pmd_k</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud_k</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pmd_k</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_pmd</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="o">*</span><span class="n">pmd_k</span><span class="p">);</span>
		<span class="n">arch_flush_lazy_mmu_mode</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pmd_ptfn</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pmd_ptfn</span><span class="p">(</span><span class="o">*</span><span class="n">pmd_k</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">pmd_k</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a fault on the vmalloc area.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">vmalloc_fault</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd_k</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte_k</span><span class="p">;</span>

	<span class="cm">/* Make sure we are in vmalloc area */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="n">VMALLOC_START</span> <span class="o">&amp;&amp;</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="n">VMALLOC_END</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Synchronize this task&#39;s top level page-table</span>
<span class="cm">	 * with the &#39;reference&#39; page table.</span>
<span class="cm">	 */</span>
	<span class="n">pmd_k</span> <span class="o">=</span> <span class="n">vmalloc_sync_one</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_k</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd_k</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   <span class="cm">/* support TILE huge_vmap() API */</span>
	<span class="n">pte_k</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd_k</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="o">*</span><span class="n">pte_k</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Wait until this PTE has completed migration. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">wait_for_migration</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_migrating</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Wait until the migrater fixes up this pte.</span>
<span class="cm">		 * We scale the loop count by the clock rate so we&#39;ll wait for</span>
<span class="cm">		 * a few seconds here.</span>
<span class="cm">		 */</span>
		<span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">bound</span> <span class="o">=</span> <span class="n">get_clock_rate</span><span class="p">();</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">pte_migrating</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">barrier</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">retries</span> <span class="o">&gt;</span> <span class="n">bound</span><span class="p">)</span>
				<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Hit migrating PTE (%#llx) and&quot;</span>
				      <span class="s">&quot; page PFN %#lx still migrating&quot;</span><span class="p">,</span>
				      <span class="n">pte</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * It&#39;s not generally safe to use &quot;current&quot; to get the page table pointer,</span>
<span class="cm"> * since we might be running an oprofile interrupt in the middle of a</span>
<span class="cm"> * task switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">get_current_pgd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">HV_Context</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">hv_inquire_context</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgd_pfn</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">page_table</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pgd_page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pgd_pfn</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">pgd_page</span><span class="p">));</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">__va</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">page_table</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We can receive a page fault from a migrating PTE at any time.</span>
<span class="cm"> * Handle it by just waiting until the fault resolves.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s also possible to get a migrating kernel PTE that resolves</span>
<span class="cm"> * itself during the downcall from hypervisor to Linux.  We just check</span>
<span class="cm"> * here to see if the PTE seems valid, and if so we retry it.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE! We MUST NOT take any locks for this case.  We may be in an</span>
<span class="cm"> * interrupt or a critical region, and must do as little as possible.</span>
<span class="cm"> * Similarly, we can&#39;t use atomic ops here, since we may be handling a</span>
<span class="cm"> * fault caused by an atomic op access.</span>
<span class="cm"> *</span>
<span class="cm"> * If we find a migrating PTE while we&#39;re in an NMI context, and we&#39;re</span>
<span class="cm"> * at a PC that has a registered exception handler, we don&#39;t wait,</span>
<span class="cm"> * since this thread may (e.g.) have been interrupted while migrating</span>
<span class="cm"> * its own stack, which would then cause us to self-deadlock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">handle_migrating_pte</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fault_num</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">is_kernel_mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pteval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_addr_invalid</span><span class="p">(</span><span class="n">address</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pgd</span> <span class="o">+=</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud</span> <span class="o">||</span> <span class="o">!</span><span class="n">pud_present</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd</span> <span class="o">||</span> <span class="o">!</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">pmd_huge_page</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">)</span> <span class="o">?</span> <span class="p">((</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pmd</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="n">pteval</span> <span class="o">=</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_migrating</span><span class="p">(</span><span class="n">pteval</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_nmi</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">search_exception_tables</span><span class="p">(</span><span class="n">pc</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wait_for_migration</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_kernel_mode</span> <span class="o">||</span> <span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="n">pteval</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fault_num</span> <span class="o">==</span> <span class="n">INT_ITLB_MISS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_exec</span><span class="p">(</span><span class="n">pteval</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_write</span><span class="p">(</span><span class="n">pteval</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_read</span><span class="p">(</span><span class="n">pteval</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine is responsible for faulting in user pages.</span>
<span class="cm"> * It passes the work off to one of the appropriate routines.</span>
<span class="cm"> * It returns true if the fault was successfully handled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">handle_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">fault_num</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">is_page_fault</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fault</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">si_code</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_kernel_mode</span><span class="p">;</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* on TILE, protection faults are always writes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_page_fault</span><span class="p">)</span>
		<span class="n">write</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">FAULT_FLAG_ALLOW_RETRY</span> <span class="o">|</span> <span class="n">FAULT_FLAG_KILLABLE</span> <span class="o">|</span>
		 <span class="p">(</span><span class="n">write</span> <span class="o">?</span> <span class="n">FAULT_FLAG_WRITE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>

	<span class="n">is_kernel_mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">EX1_PL</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ex1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">USER_PL</span><span class="p">);</span>

	<span class="n">tsk</span> <span class="o">=</span> <span class="n">validate_current</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check to see if we might be overwriting the stack, and bail</span>
<span class="cm">	 * out if so.  The page fault code is a relatively likely</span>
<span class="cm">	 * place to get trapped in an infinite regress, and once we</span>
<span class="cm">	 * overwrite the whole stack, it becomes very hard to recover.</span>
<span class="cm">	 */</span>
	<span class="n">stack_offset</span> <span class="o">=</span> <span class="n">stack_pointer</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">THREAD_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stack_offset</span> <span class="o">&lt;</span> <span class="n">THREAD_SIZE</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_alert</span><span class="p">(</span><span class="s">&quot;Potential stack overrun: sp %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">stack_pointer</span><span class="p">);</span>
		<span class="n">show_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="n">pr_alert</span><span class="p">(</span><span class="s">&quot;Killing current process %d/%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
		<span class="n">do_group_exit</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Early on, we need to check for migrating PTE entries;</span>
<span class="cm">	 * see homecache.c.  If we find a migrating PTE, we wait until</span>
<span class="cm">	 * the backing page claims to be done migrating, then we proceed.</span>
<span class="cm">	 * For kernel PTEs, we rewrite the PTE and return and retry.</span>
<span class="cm">	 * Otherwise, we treat the fault like a normal &quot;no PTE&quot; fault,</span>
<span class="cm">	 * rather than trying to patch up the existing PTE.</span>
<span class="cm">	 */</span>
	<span class="n">pgd</span> <span class="o">=</span> <span class="n">get_current_pgd</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handle_migrating_pte</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">fault_num</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">,</span>
				 <span class="n">is_kernel_mode</span><span class="p">,</span> <span class="n">write</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">si_code</span> <span class="o">=</span> <span class="n">SEGV_MAPERR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We fault-in kernel-space virtual memory on-demand. The</span>
<span class="cm">	 * &#39;reference&#39; page table is init_mm.pgd.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE! We MUST NOT take any locks for this case. We may</span>
<span class="cm">	 * be in an interrupt or a critical region, and should</span>
<span class="cm">	 * only copy the information from the master page table,</span>
<span class="cm">	 * nothing more.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This verifies that the fault happens in kernel space</span>
<span class="cm">	 * and that the fault was not a protection fault.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="n">TASK_SIZE</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="n">is_arch_mappable_range</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_kernel_mode</span> <span class="o">&amp;&amp;</span> <span class="n">is_page_fault</span> <span class="o">&amp;&amp;</span>
		    <span class="n">vmalloc_fault</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t take the mm semaphore here. If we fixup a prefetch</span>
<span class="cm">		 * fault we could otherwise deadlock.</span>
<span class="cm">		 */</span>
		<span class="n">mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="cm">/* happy compiler */</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_area_nosemaphore</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re trying to touch user-space addresses, we must</span>
<span class="cm">	 * be either at PL0, or else with interrupts enabled in the</span>
<span class="cm">	 * kernel, so either way we can re-enable interrupts here</span>
<span class="cm">	 * unless we are doing atomic access to user space with</span>
<span class="cm">	 * interrupts disabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PT_FLAGS_DISABLE_IRQ</span><span class="p">))</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re in an interrupt, have no user context or are running in an</span>
<span class="cm">	 * atomic region then we must not take the fault.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_atomic</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="cm">/* happy compiler */</span>
		<span class="k">goto</span> <span class="n">bad_area_nosemaphore</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * When running in the kernel we expect faults to occur only to</span>
<span class="cm">	 * addresses in user space.  All other faults represent errors in the</span>
<span class="cm">	 * kernel and should generate an OOPS.  Unfortunately, in the case of an</span>
<span class="cm">	 * erroneous fault occurring in a code path which already holds mmap_sem</span>
<span class="cm">	 * we will deadlock attempting to validate the fault against the</span>
<span class="cm">	 * address space.  Luckily the kernel only validly references user</span>
<span class="cm">	 * space from well defined areas of code, which are listed in the</span>
<span class="cm">	 * exceptions table.</span>
<span class="cm">	 *</span>
<span class="cm">	 * As the vast majority of faults will be valid we will only perform</span>
<span class="cm">	 * the source reference check when there is a possibility of a deadlock.</span>
<span class="cm">	 * Attempt to lock the address space, if we cannot we then validate the</span>
<span class="cm">	 * source.  If this is invalid we can skip the address space check,</span>
<span class="cm">	 * thus avoiding the deadlock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">down_read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_kernel_mode</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">search_exception_tables</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="cm">/* happy compiler */</span>
			<span class="k">goto</span> <span class="n">bad_area_nosemaphore</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">retry:</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_area</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;=</span> <span class="n">address</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">good_area</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_GROWSDOWN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad_area</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">&lt;</span> <span class="n">PAGE_OFFSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * accessing the stack below sp is always a bug.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bad_area</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expand_stack</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad_area</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Ok, we have a good vm_area for this memory access, so</span>
<span class="cm"> * we can handle it..</span>
<span class="cm"> */</span>
<span class="nl">good_area:</span>
	<span class="n">si_code</span> <span class="o">=</span> <span class="n">SEGV_ACCERR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fault_num</span> <span class="o">==</span> <span class="n">INT_ITLB_MISS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXEC</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">bad_area</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef TEST_VERIFY_AREA</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_page_fault</span> <span class="o">&amp;&amp;</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cs</span> <span class="o">==</span> <span class="n">KERNEL_CS</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;WP fault at &quot;</span><span class="n">REGFMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">eip</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">bad_area</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_page_fault</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_READ</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">bad_area</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">survive:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If for any reason at all we couldn&#39;t handle the fault,</span>
<span class="cm">	 * make sure we exit gracefully rather than endlessly redo</span>
<span class="cm">	 * the fault.</span>
<span class="cm">	 */</span>
	<span class="n">fault</span> <span class="o">=</span> <span class="n">handle_mm_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fault</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_RETRY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fault</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_ERROR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fault</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_OOM</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_of_memory</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fault</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">do_sigbus</span><span class="p">;</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_ALLOW_RETRY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fault</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_MAJOR</span><span class="p">)</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">maj_flt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">min_flt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fault</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_RETRY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FAULT_FLAG_ALLOW_RETRY</span><span class="p">;</span>

			 <span class="cm">/*</span>
<span class="cm">			  * No need to up_read(&amp;mm-&gt;mmap_sem) as we would</span>
<span class="cm">			  * have already released it in __lock_page_or_retry</span>
<span class="cm">			  * in mm/filemap.c.</span>
<span class="cm">			  */</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#if CHIP_HAS_TILE_DMA() || CHIP_HAS_SN_PROC()</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this was an asynchronous fault,</span>
<span class="cm">	 * restart the appropriate engine.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fault_num</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if CHIP_HAS_TILE_DMA()</span>
	<span class="k">case</span> <span class="n">INT_DMATLB_MISS</span>:
	<span class="k">case</span> <span class="n">INT_DMATLB_MISS_DWNCL</span>:
	<span class="k">case</span> <span class="n">INT_DMATLB_ACCESS</span>:
	<span class="k">case</span> <span class="n">INT_DMATLB_ACCESS_DWNCL</span>:
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_DMA_CTR</span><span class="p">,</span> <span class="n">SPR_DMA_CTR__REQUEST_MASK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_SN_PROC()</span>
	<span class="k">case</span> <span class="n">INT_SNITLB_MISS</span>:
	<span class="k">case</span> <span class="n">INT_SNITLB_MISS_DWNCL</span>:
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_SNCTL</span><span class="p">,</span>
			     <span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_SNCTL</span><span class="p">)</span> <span class="o">&amp;</span>
			     <span class="o">~</span><span class="n">SPR_SNCTL__FRZPROC_MASK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Something tried to access memory that isn&#39;t in our memory map..</span>
<span class="cm"> * Fix it, but check if it&#39;s kernel or user first..</span>
<span class="cm"> */</span>
<span class="nl">bad_area:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

<span class="nl">bad_area_nosemaphore:</span>
	<span class="cm">/* User mode accesses just cause a SIGSEGV */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_kernel_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s possible to have interrupts off here.</span>
<span class="cm">		 */</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>

		<span class="n">force_sig_info_fault</span><span class="p">(</span><span class="s">&quot;segfault&quot;</span><span class="p">,</span> <span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">si_code</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
				     <span class="n">fault_num</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">no_context:</span>
	<span class="cm">/* Are we prepared to handle this kernel fault?  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fixup_exception</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Oops. The kernel tried to access some bad page. We&#39;ll have to</span>
<span class="cm"> * terminate things with extreme prejudice.</span>
<span class="cm"> */</span>

	<span class="n">bust_spinlocks</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* FIXME: no lookup_address() yet */</span>
<span class="cp">#ifdef SUPPORT_LOOKUP_ADDRESS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fault_num</span> <span class="o">==</span> <span class="n">INT_ITLB_MISS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">lookup_address</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">&amp;&amp;</span> <span class="n">pte_present</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pte_exec_kernel</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span>
			<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;kernel tried to execute&quot;</span>
			       <span class="s">&quot; non-executable page - exploit attempt?&quot;</span>
			       <span class="s">&quot; (uid: %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">pr_alert</span><span class="p">(</span><span class="s">&quot;Unable to handle kernel NULL pointer dereference</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pr_alert</span><span class="p">(</span><span class="s">&quot;Unable to handle kernel paging request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_alert</span><span class="p">(</span><span class="s">&quot; at virtual address &quot;</span><span class="n">REGFMT</span><span class="s">&quot;, pc &quot;</span><span class="n">REGFMT</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">address</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">);</span>

	<span class="n">show_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Kernel page fault running %s!&quot;</span><span class="p">,</span>
		      <span class="n">is_idle_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;the idle task&quot;</span> <span class="o">:</span> <span class="s">&quot;init&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * More FIXME: we should probably copy the i386 here and</span>
<span class="cm">	 * implement a generic die() routine.  Not today.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef SUPPORT_DIE</span>
	<span class="n">die</span><span class="p">(</span><span class="s">&quot;Oops&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">bust_spinlocks</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">do_group_exit</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We ran out of memory, or some other thing happened to us that made</span>
<span class="cm"> * us unable to handle the page fault gracefully.</span>
<span class="cm"> */</span>
<span class="nl">out_of_memory:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_global_init</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">yield</span><span class="p">();</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">survive</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_alert</span><span class="p">(</span><span class="s">&quot;VM: killing process %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_kernel_mode</span><span class="p">)</span>
		<span class="n">do_group_exit</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">no_context</span><span class="p">;</span>

<span class="nl">do_sigbus:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="cm">/* Kernel mode? Handle exceptions or die */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_kernel_mode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_context</span><span class="p">;</span>

	<span class="n">force_sig_info_fault</span><span class="p">(</span><span class="s">&quot;bus error&quot;</span><span class="p">,</span> <span class="n">SIGBUS</span><span class="p">,</span> <span class="n">BUS_ADRERR</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
			     <span class="n">fault_num</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef __tilegx__</span>

<span class="cm">/* We must release ICS before panicking or we won&#39;t get anywhere. */</span>
<span class="cp">#define ics_panic(fmt, ...) do { \</span>
<span class="cp">	__insn_mtspr(SPR_INTERRUPT_CRITICAL_SECTION, 0); \</span>
<span class="cp">	panic(fmt, __VA_ARGS__); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * When we take an ITLB or DTLB fault or access violation in the</span>
<span class="cm"> * supervisor while the critical section bit is set, the hypervisor is</span>
<span class="cm"> * reluctant to write new values into the EX_CONTEXT_K_x registers,</span>
<span class="cm"> * since that might indicate we have not yet squirreled the SPR</span>
<span class="cm"> * contents away and can thus safely take a recursive interrupt.</span>
<span class="cm"> * Accordingly, the hypervisor passes us the PC via SYSTEM_SAVE_K_2.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this routine is called before homecache_tlb_defer_enter(),</span>
<span class="cm"> * which means that we can properly unlock any atomics that might</span>
<span class="cm"> * be used there (good), but also means we must be very sensitive</span>
<span class="cm"> * to not touch any data structures that might be located in memory</span>
<span class="cm"> * that could migrate, as we could be entering the kernel on a dataplane</span>
<span class="cm"> * cpu that has been deferring kernel TLB updates.  This means, for</span>
<span class="cm"> * example, that we can&#39;t migrate init_mm or its pgd.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">intvec_state</span> <span class="n">do_page_fault_ics</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fault_num</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">info</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write</span> <span class="o">=</span> <span class="n">info</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">get_current_pgd</span><span class="p">();</span>

	<span class="cm">/* Retval is 1 at first since we will handle the fault fully. */</span>
	<span class="k">struct</span> <span class="n">intvec_state</span> <span class="n">state</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">do_page_fault</span><span class="p">,</span> <span class="n">fault_num</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="mi">1</span>
	<span class="p">};</span>

	<span class="cm">/* Validate that we are plausibly in the right routine. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pc</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pc</span> <span class="o">&lt;</span> <span class="n">PAGE_OFFSET</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">fault_num</span> <span class="o">!=</span> <span class="n">INT_DTLB_MISS</span> <span class="o">&amp;&amp;</span>
	     <span class="n">fault_num</span> <span class="o">!=</span> <span class="n">INT_DTLB_ACCESS</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_pc</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">=</span> <span class="n">pc</span><span class="p">;</span>
		<span class="n">ics_panic</span><span class="p">(</span><span class="s">&quot;Bad ICS page fault args:&quot;</span>
			  <span class="s">&quot; old PC %#lx, fault %d/%d at %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">old_pc</span><span class="p">,</span> <span class="n">fault_num</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* We might be faulting on a vmalloc page, so check that first. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fault_num</span> <span class="o">!=</span> <span class="n">INT_DTLB_ACCESS</span> <span class="o">&amp;&amp;</span> <span class="n">vmalloc_fault</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we faulted with ICS set in sys_cmpxchg, we are providing</span>
<span class="cm">	 * a user syscall service that should generate a signal on</span>
<span class="cm">	 * fault.  We didn&#39;t set up a kernel stack on initial entry to</span>
<span class="cm">	 * sys_cmpxchg, but instead had one set up by the fault, which</span>
<span class="cm">	 * (because sys_cmpxchg never releases ICS) came to us via the</span>
<span class="cm">	 * SYSTEM_SAVE_K_2 mechanism, and thus EX_CONTEXT_K_[01] are</span>
<span class="cm">	 * still referencing the original user code.  We release the</span>
<span class="cm">	 * atomic lock and rewrite pt_regs so that it appears that we</span>
<span class="cm">	 * came from user-space directly, and after we finish the</span>
<span class="cm">	 * fault we&#39;ll go back to user space and re-issue the swint.</span>
<span class="cm">	 * This way the backtrace information is correct if we need to</span>
<span class="cm">	 * emit a stack dump at any point while handling this.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Must match register use in sys_cmpxchg().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pc</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">sys_cmpxchg</span> <span class="o">&amp;&amp;</span>
	    <span class="n">pc</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__sys_cmpxchg_end</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
		<span class="cm">/* Don&#39;t unlock before we could have locked. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pc</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__sys_cmpxchg_grab_lock</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">lock_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">ATOMIC_LOCK_REG</span><span class="p">]);</span>
			<span class="n">__atomic_fault_unlock</span><span class="p">(</span><span class="n">lock_ptr</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">27</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can also fault in the atomic assembly, in which</span>
<span class="cm">	 * case we use the exception table to do the first-level fixup.</span>
<span class="cm">	 * We may re-fixup again in the real fault handler if it</span>
<span class="cm">	 * turns out the faulting address is just bad, and not,</span>
<span class="cm">	 * for example, migrating.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pc</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__start_atomic_asm_code</span> <span class="o">&amp;&amp;</span>
		   <span class="n">pc</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__end_atomic_asm_code</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">fixup</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
		<span class="cm">/* Unlock the atomic lock. */</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">lock_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">ATOMIC_LOCK_REG</span><span class="p">]);</span>
		<span class="n">__atomic_fault_unlock</span><span class="p">(</span><span class="n">lock_ptr</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">fixup</span> <span class="o">=</span> <span class="n">search_exception_tables</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fixup</span><span class="p">)</span>
			<span class="n">ics_panic</span><span class="p">(</span><span class="s">&quot;ICS atomic fault not in table:&quot;</span>
				  <span class="s">&quot; PC %#lx, fault %d&quot;</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">fault_num</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">=</span> <span class="n">fixup</span><span class="o">-&gt;</span><span class="n">fixup</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ex1</span> <span class="o">=</span> <span class="n">PL_ICS_EX1</span><span class="p">(</span><span class="n">KERNEL_PL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that we have released the atomic lock (if necessary),</span>
<span class="cm">	 * it&#39;s safe to spin if the PTE that caused the fault was migrating.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fault_num</span> <span class="o">==</span> <span class="n">INT_DTLB_ACCESS</span><span class="p">)</span>
		<span class="n">write</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handle_migrating_pte</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">fault_num</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">write</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/* Return zero so that we continue on with normal fault handling. */</span>
	<span class="n">state</span><span class="p">.</span><span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !__tilegx__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * This routine handles page faults.  It determines the address, and the</span>
<span class="cm"> * problem, and then passes it handle_page_fault() for normal DTLB and</span>
<span class="cm"> * ITLB issues, and for DMA or SN processor faults when we are in user</span>
<span class="cm"> * space.  For the latter, if we&#39;re in kernel mode, we just save the</span>
<span class="cm"> * interrupt away appropriately and return immediately.  We can&#39;t do</span>
<span class="cm"> * page faults for user code while in kernel mode.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">do_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fault_num</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">is_page_fault</span><span class="p">;</span>

	<span class="cm">/* This case should have been handled by do_page_fault_ics(). */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">write</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">);</span>

<span class="cp">#if CHIP_HAS_TILE_DMA()</span>
	<span class="cm">/*</span>
<span class="cm">	 * If it&#39;s a DMA fault, suspend the transfer while we&#39;re</span>
<span class="cm">	 * handling the miss; we&#39;ll restart after it&#39;s handled.  If we</span>
<span class="cm">	 * don&#39;t suspend, it&#39;s possible that this process could swap</span>
<span class="cm">	 * out and back in, and restart the engine since the DMA is</span>
<span class="cm">	 * still &#39;running&#39;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fault_num</span> <span class="o">==</span> <span class="n">INT_DMATLB_MISS</span> <span class="o">||</span>
	    <span class="n">fault_num</span> <span class="o">==</span> <span class="n">INT_DMATLB_ACCESS</span> <span class="o">||</span>
	    <span class="n">fault_num</span> <span class="o">==</span> <span class="n">INT_DMATLB_MISS_DWNCL</span> <span class="o">||</span>
	    <span class="n">fault_num</span> <span class="o">==</span> <span class="n">INT_DMATLB_ACCESS_DWNCL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__insn_mtspr</span><span class="p">(</span><span class="n">SPR_DMA_CTR</span><span class="p">,</span> <span class="n">SPR_DMA_CTR__SUSPEND_MASK</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">__insn_mfspr</span><span class="p">(</span><span class="n">SPR_DMA_USER_STATUS</span><span class="p">)</span> <span class="o">&amp;</span>
		       <span class="n">SPR_DMA_STATUS__BUSY_MASK</span><span class="p">)</span>
			<span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Validate fault num and decide if this is a first-time page fault. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fault_num</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">INT_ITLB_MISS</span>:
	<span class="k">case</span> <span class="n">INT_DTLB_MISS</span>:
<span class="cp">#if CHIP_HAS_TILE_DMA()</span>
	<span class="k">case</span> <span class="n">INT_DMATLB_MISS</span>:
	<span class="k">case</span> <span class="n">INT_DMATLB_MISS_DWNCL</span>:
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_SN_PROC()</span>
	<span class="k">case</span> <span class="n">INT_SNITLB_MISS</span>:
	<span class="k">case</span> <span class="n">INT_SNITLB_MISS_DWNCL</span>:
<span class="cp">#endif</span>
		<span class="n">is_page_fault</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">INT_DTLB_ACCESS</span>:
<span class="cp">#if CHIP_HAS_TILE_DMA()</span>
	<span class="k">case</span> <span class="n">INT_DMATLB_ACCESS</span>:
	<span class="k">case</span> <span class="n">INT_DMATLB_ACCESS_DWNCL</span>:
<span class="cp">#endif</span>
		<span class="n">is_page_fault</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Bad fault number %d in do_page_fault&quot;</span><span class="p">,</span> <span class="n">fault_num</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#if CHIP_HAS_TILE_DMA() || CHIP_HAS_SN_PROC()</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EX1_PL</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ex1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">USER_PL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">async_tlb</span> <span class="o">*</span><span class="n">async</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">fault_num</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if CHIP_HAS_TILE_DMA()</span>
		<span class="k">case</span> <span class="n">INT_DMATLB_MISS</span>:
		<span class="k">case</span> <span class="n">INT_DMATLB_ACCESS</span>:
		<span class="k">case</span> <span class="n">INT_DMATLB_MISS_DWNCL</span>:
		<span class="k">case</span> <span class="n">INT_DMATLB_ACCESS_DWNCL</span>:
			<span class="n">async</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dma_async_tlb</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_SN_PROC()</span>
		<span class="k">case</span> <span class="n">INT_SNITLB_MISS</span>:
		<span class="k">case</span> <span class="n">INT_SNITLB_MISS_DWNCL</span>:
			<span class="n">async</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sn_async_tlb</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="nl">default:</span>
			<span class="n">async</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">async</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * No vmalloc check required, so we can allow</span>
<span class="cm">			 * interrupts immediately at this point.</span>
<span class="cm">			 */</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>

			<span class="n">set_thread_flag</span><span class="p">(</span><span class="n">TIF_ASYNC_TLB</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">fault_num</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Second async fault %d;&quot;</span>
				      <span class="s">&quot; old fault was %d (%#lx/%ld)&quot;</span><span class="p">,</span>
				      <span class="n">fault_num</span><span class="p">,</span> <span class="n">async</span><span class="o">-&gt;</span><span class="n">fault_num</span><span class="p">,</span>
				      <span class="n">address</span><span class="p">,</span> <span class="n">write</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">fault_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">async</span><span class="o">-&gt;</span><span class="n">fault_num</span> <span class="o">=</span> <span class="n">fault_num</span><span class="p">;</span>
			<span class="n">async</span><span class="o">-&gt;</span><span class="n">is_fault</span> <span class="o">=</span> <span class="n">is_page_fault</span><span class="p">;</span>
			<span class="n">async</span><span class="o">-&gt;</span><span class="n">is_write</span> <span class="o">=</span> <span class="n">write</span><span class="p">;</span>
			<span class="n">async</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">handle_page_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">fault_num</span><span class="p">,</span> <span class="n">is_page_fault</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">write</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#if CHIP_HAS_TILE_DMA() || CHIP_HAS_SN_PROC()</span>
<span class="cm">/*</span>
<span class="cm"> * Check an async_tlb structure to see if a deferred fault is waiting,</span>
<span class="cm"> * and if so pass it to the page-fault code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">handle_async_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">async_tlb</span> <span class="o">*</span><span class="n">async</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">async</span><span class="o">-&gt;</span><span class="n">fault_num</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear async-&gt;fault_num before calling the page-fault</span>
<span class="cm">		 * handler so that if we re-interrupt before returning</span>
<span class="cm">		 * from the function we have somewhere to put the</span>
<span class="cm">		 * information from the new interrupt.</span>
<span class="cm">		 */</span>
		<span class="kt">int</span> <span class="n">fault_num</span> <span class="o">=</span> <span class="n">async</span><span class="o">-&gt;</span><span class="n">fault_num</span><span class="p">;</span>
		<span class="n">async</span><span class="o">-&gt;</span><span class="n">fault_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">handle_page_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">fault_num</span><span class="p">,</span> <span class="n">async</span><span class="o">-&gt;</span><span class="n">is_fault</span><span class="p">,</span>
				  <span class="n">async</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">async</span><span class="o">-&gt;</span><span class="n">is_write</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine effectively re-issues asynchronous page faults</span>
<span class="cm"> * when we are returning to user space.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">do_async_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clear thread flag early.  If we re-interrupt while processing</span>
<span class="cm">	 * code here, we will reset it and recall this routine before</span>
<span class="cm">	 * returning to user space.</span>
<span class="cm">	 */</span>
	<span class="n">clear_thread_flag</span><span class="p">(</span><span class="n">TIF_ASYNC_TLB</span><span class="p">);</span>

<span class="cp">#if CHIP_HAS_TILE_DMA()</span>
	<span class="n">handle_async_page_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dma_async_tlb</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if CHIP_HAS_SN_PROC()</span>
	<span class="n">handle_async_page_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sn_async_tlb</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CHIP_HAS_TILE_DMA() || CHIP_HAS_SN_PROC() */</span><span class="cp"></span>


<span class="kt">void</span> <span class="n">vmalloc_sync_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef __tilegx__</span>
	<span class="cm">/* Currently all L1 kernel pmd&#39;s are static and shared. */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pgd_index</span><span class="p">(</span><span class="n">VMALLOC_END</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">VMALLOC_START</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note that races in the updates of insync and start aren&#39;t</span>
<span class="cm">	 * problematic: insync can only get set bits added, and updates to</span>
<span class="cm">	 * start are only improving performance (without affecting correctness</span>
<span class="cm">	 * if undone).</span>
<span class="cm">	 */</span>
	<span class="k">static</span> <span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">insync</span><span class="p">,</span> <span class="n">PTRS_PER_PGD</span><span class="p">);</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">PAGE_OFFSET</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PGDIR_MASK</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">address</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">address</span> <span class="o">&gt;=</span> <span class="n">PAGE_OFFSET</span><span class="p">;</span> <span class="n">address</span> <span class="o">+=</span> <span class="n">PGDIR_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">pgd_index</span><span class="p">(</span><span class="n">address</span><span class="p">),</span> <span class="n">insync</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pgd_list</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmalloc_sync_one</span><span class="p">(</span><span class="n">list_to_pgd</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span>
								<span class="n">address</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* Must be at first entry in list. */</span>
					<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">pgd_list</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">pgd_list</span><span class="p">.</span><span class="n">next</span><span class="p">)</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">pgd_index</span><span class="p">(</span><span class="n">address</span><span class="p">),</span> <span class="n">insync</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">==</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">pgd_index</span><span class="p">(</span><span class="n">address</span><span class="p">),</span> <span class="n">insync</span><span class="p">))</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">address</span> <span class="o">+</span> <span class="n">PGDIR_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
