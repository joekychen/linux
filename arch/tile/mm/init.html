<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › tile › mm › init.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>init.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 1995  Linus Torvalds</span>
<span class="cm"> * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="cm"> *   more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/poison.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/efi.h&gt;</span>
<span class="cp">#include &lt;linux/memory_hotplug.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/fixmap.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/homecache.h&gt;</span>
<span class="cp">#include &lt;hv/hypervisor.h&gt;</span>
<span class="cp">#include &lt;arch/chip.h&gt;</span>

<span class="cp">#include &quot;migrate.h&quot;</span>

<span class="cp">#define clear_pgd(pmdptr) (*(pmdptr) = hv_pte(0))</span>

<span class="cp">#ifndef __tilegx__</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">VMALLOC_RESERVE</span> <span class="o">=</span> <span class="n">CONFIG_VMALLOC_RESERVE</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">VMALLOC_RESERVE</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Create an L2 page table */</span>
<span class="k">static</span> <span class="n">pte_t</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">alloc_pte</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">L2_KERNEL_PGTABLE_SIZE</span><span class="p">,</span> <span class="n">HV_PAGE_TABLE_ALIGN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * L2 page tables per controller.  We allocate these all at once from</span>
<span class="cm"> * the bootmem allocator and store them here.  This saves on kernel L2</span>
<span class="cm"> * page table memory, compared to allocating a full 64K page per L2</span>
<span class="cm"> * page table, and also means that in cases where we use huge pages,</span>
<span class="cm"> * we are guaranteed to later be able to shatter those huge pages and</span>
<span class="cm"> * switch to using these page tables instead, without requiring</span>
<span class="cm"> * further allocation.  Each l2_ptes[] entry points to the first page</span>
<span class="cm"> * table for the first hugepage-size piece of memory on the</span>
<span class="cm"> * controller; other page tables are just indexed directly, i.e. the</span>
<span class="cm"> * L2 page tables are contiguous in memory for each controller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">l2_ptes</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">num_l2_ptes</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_prealloc_ptes</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pages</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PTRS_PER_PTE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num_l2_ptes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>
		<span class="n">l2_ptes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">pages</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">),</span>
						<span class="n">HV_PAGE_TABLE_ALIGN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">pte_t</span> <span class="o">*</span><span class="nf">get_prealloc_pte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">pfn_to_nid</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="n">pfn</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="o">-</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">NR_PA_HIGHBIT_SHIFT</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">node</span> <span class="o">&gt;=</span> <span class="n">MAX_NUMNODES</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pfn</span> <span class="o">&gt;=</span> <span class="n">num_l2_ptes</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">l2_ptes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">pfn</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * What caching do we expect pages from the heap to have when</span>
<span class="cm"> * they are allocated during bootup?  (Once we&#39;ve installed the</span>
<span class="cm"> * &quot;real&quot; swapper_pg_dir.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">initial_heap_home</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if CHIP_HAS_CBOX_HOME_MAP()</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hash_default</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PAGE_HOME_HASH</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">smp_processor_id</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Place a pointer to an L2 page table in a middle page</span>
<span class="cm"> * directory entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">assign_pte</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">page_table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phys_addr_t</span> <span class="n">pa</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">page_table</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">l2_ptfn</span> <span class="o">=</span> <span class="n">pa</span> <span class="o">&gt;&gt;</span> <span class="n">HV_LOG2_PAGE_TABLE_ALIGN</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pteval</span> <span class="o">=</span> <span class="n">hv_pte_set_ptfn</span><span class="p">(</span><span class="n">__pgprot</span><span class="p">(</span><span class="n">_PAGE_TABLE</span><span class="p">),</span> <span class="n">l2_ptfn</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">pa</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HV_PAGE_TABLE_ALIGN</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pteval</span> <span class="o">=</span> <span class="n">pte_set_home</span><span class="p">(</span><span class="n">pteval</span><span class="p">,</span> <span class="n">initial_heap_home</span><span class="p">());</span>
	<span class="o">*</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pmd</span> <span class="o">=</span> <span class="n">pteval</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_table</span> <span class="o">!=</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pmd_page_vaddr</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef __tilegx__</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="nf">alloc_pmd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">L1_KERNEL_PGTABLE_SIZE</span><span class="p">,</span> <span class="n">HV_PAGE_TABLE_ALIGN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">assign_pmd</span><span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assign_pte</span><span class="p">((</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pud</span><span class="p">,</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __tilegx__ */</span><span class="cp"></span>

<span class="cm">/* Replace the given pmd with a full PTE table. */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">shatter_pmd</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">get_prealloc_pte</span><span class="p">(</span><span class="n">pte_pfn</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pmd</span><span class="p">));</span>
	<span class="n">assign_pte</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
<span class="cm">/*</span>
<span class="cm"> * This function initializes a certain range of kernel virtual memory</span>
<span class="cm"> * with new bootmem page tables, everywhere page tables are missing in</span>
<span class="cm"> * the given range.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE: The pagetables are allocated contiguous on the physical space</span>
<span class="cm"> * so we can cache the place of the first one and move around without</span>
<span class="cm"> * checking the pgd every time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">page_table_range_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pgd_idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">;</span>

	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">pgd_idx</span> <span class="o">=</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_base</span> <span class="o">+</span> <span class="n">pgd_idx</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">(</span><span class="n">pgd_idx</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PGD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span> <span class="n">pgd</span><span class="o">++</span><span class="p">,</span> <span class="n">pgd_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">),</span> <span class="n">vaddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
			<span class="n">assign_pte</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">alloc_pte</span><span class="p">());</span>
		<span class="n">vaddr</span> <span class="o">+=</span> <span class="n">PMD_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HIGHMEM */</span><span class="cp"></span>


<span class="cp">#if CHIP_HAS_CBOX_HOME_MAP()</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">ktext_hash</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* .text pages */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">kdata_hash</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* .data and .bss pages */</span>
<span class="kt">int</span> <span class="n">__write_once</span> <span class="n">hash_default</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>     <span class="cm">/* kernel allocator pages */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">hash_default</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__write_once</span> <span class="n">kstack_hash</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="cm">/* if no homecaching, use h4h */</span>
<span class="cp">#endif </span><span class="cm">/* CHIP_HAS_CBOX_HOME_MAP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * CPUs to use to for striping the pages of kernel data.  If hash-for-home</span>
<span class="cm"> * is available, this is only relevant if kcache_hash sets up the</span>
<span class="cm"> * .data and .bss to be page-homed, and we don&#39;t want the default mode</span>
<span class="cm"> * of using the full set of kernel cpus for the striping.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__initdata</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="n">kdata_mask</span><span class="p">;</span>
<span class="k">static</span> <span class="n">__initdata</span> <span class="kt">int</span> <span class="n">kdata_arg_seen</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">__write_once</span> <span class="n">kdata_huge</span><span class="p">;</span>       <span class="cm">/* if no homecaching, small pages */</span>


<span class="cm">/* Combine a generic pgprot_t with cache home to get a cache-aware pgprot. */</span>
<span class="k">static</span> <span class="n">pgprot_t</span> <span class="n">__init</span> <span class="nf">construct_pgprot</span><span class="p">(</span><span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">home</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">prot</span> <span class="o">=</span> <span class="n">pte_set_home</span><span class="p">(</span><span class="n">prot</span><span class="p">,</span> <span class="n">home</span><span class="p">);</span>
<span class="cp">#if CHIP_HAS_CBOX_HOME_MAP()</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">home</span> <span class="o">==</span> <span class="n">PAGE_HOME_IMMUTABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ktext_hash</span><span class="p">)</span>
			<span class="n">prot</span> <span class="o">=</span> <span class="n">hv_pte_set_mode</span><span class="p">(</span><span class="n">prot</span><span class="p">,</span> <span class="n">HV_PTE_MODE_CACHE_HASH_L3</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">prot</span> <span class="o">=</span> <span class="n">hv_pte_set_mode</span><span class="p">(</span><span class="n">prot</span><span class="p">,</span> <span class="n">HV_PTE_MODE_CACHE_NO_L3</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">prot</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For a given kernel data VA, how should it be cached?</span>
<span class="cm"> * We return the complete pgprot_t with caching bits set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pgprot_t</span> <span class="n">__init</span> <span class="nf">init_pgprot</span><span class="p">(</span><span class="n">ulong</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span> <span class="n">CODE_DELTA</span> <span class="o">=</span> <span class="n">MEM_SV_INTRPT</span> <span class="o">-</span> <span class="n">PAGE_OFFSET</span> <span class="p">};</span>

<span class="cp">#if CHIP_HAS_CBOX_HOME_MAP()</span>
	<span class="cm">/* For kdata=huge, everything is just hash-for-home. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kdata_huge</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">construct_pgprot</span><span class="p">(</span><span class="n">PAGE_KERNEL</span><span class="p">,</span> <span class="n">PAGE_HOME_HASH</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* We map the aliased pages of permanent text inaccessible. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">_sinittext</span> <span class="o">-</span> <span class="n">CODE_DELTA</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PAGE_NONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We map read-only data non-coherent for performance.  We could</span>
<span class="cm">	 * use neighborhood caching on TILE64, but it&#39;s not clear it&#39;s a win.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">__start_rodata</span> <span class="o">&amp;&amp;</span>
	     <span class="n">address</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">__end_rodata</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">address</span> <span class="o">==</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">empty_zero_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">construct_pgprot</span><span class="p">(</span><span class="n">PAGE_KERNEL_RO</span><span class="p">,</span> <span class="n">PAGE_HOME_IMMUTABLE</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifndef __tilegx__</span>
<span class="cp">#if !ATOMIC_LOCKS_FOUND_VIA_TABLE()</span>
	<span class="cm">/* Force the atomic_locks[] array page to be hash-for-home. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">==</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">atomic_locks</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">construct_pgprot</span><span class="p">(</span><span class="n">PAGE_KERNEL</span><span class="p">,</span> <span class="n">PAGE_HOME_HASH</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Everything else that isn&#39;t data or bss is heap, so mark it</span>
<span class="cm">	 * with the initial heap home (hash-for-home, or this cpu).  This</span>
<span class="cm">	 * includes any addresses after the loaded image and any address before</span>
<span class="cm">	 * _einitdata, since we already captured the case of text before</span>
<span class="cm">	 * _sinittext, and __pa(einittext) is approximately __pa(sinitdata).</span>
<span class="cm">	 *</span>
<span class="cm">	 * All the LOWMEM pages that we mark this way will get their</span>
<span class="cm">	 * struct page homecache properly marked later, in set_page_homes().</span>
<span class="cm">	 * The HIGHMEM pages we leave with a default zero for their</span>
<span class="cm">	 * homes, but with a zero free_time we don&#39;t have to actually</span>
<span class="cm">	 * do a flush action the first time we use them, either.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">_end</span> <span class="o">||</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">_einitdata</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">construct_pgprot</span><span class="p">(</span><span class="n">PAGE_KERNEL</span><span class="p">,</span> <span class="n">initial_heap_home</span><span class="p">());</span>

<span class="cp">#if CHIP_HAS_CBOX_HOME_MAP()</span>
	<span class="cm">/* Use hash-for-home if requested for data/bss. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kdata_hash</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">construct_pgprot</span><span class="p">(</span><span class="n">PAGE_KERNEL</span><span class="p">,</span> <span class="n">PAGE_HOME_HASH</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make the w1data homed like heap to start with, to avoid</span>
<span class="cm">	 * making it part of the page-striped data area when we&#39;re just</span>
<span class="cm">	 * going to convert it to read-only soon anyway.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">__w1data_begin</span> <span class="o">&amp;&amp;</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">__w1data_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">construct_pgprot</span><span class="p">(</span><span class="n">PAGE_KERNEL</span><span class="p">,</span> <span class="n">initial_heap_home</span><span class="p">());</span>

	<span class="cm">/*</span>
<span class="cm">	 * Otherwise we just hand out consecutive cpus.  To avoid</span>
<span class="cm">	 * requiring this function to hold state, we just walk forward from</span>
<span class="cm">	 * _sdata by PAGE_SIZE, skipping the readonly and init data, to reach</span>
<span class="cm">	 * the requested address, while walking cpu home around kdata_mask.</span>
<span class="cm">	 * This is typically no more than a dozen or so iterations.</span>
<span class="cm">	 */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="p">(((</span><span class="n">ulong</span><span class="p">)</span><span class="n">__w1data_end</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">page</span> <span class="o">||</span> <span class="n">address</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">_end</span><span class="p">);</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kdata_mask</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">page</span> <span class="o">&lt;</span> <span class="n">address</span><span class="p">;</span> <span class="n">page</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="o">&amp;</span><span class="n">init_thread_union</span> <span class="o">&amp;&amp;</span>
		    <span class="n">page</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="o">&amp;</span><span class="n">init_thread_union</span> <span class="o">+</span> <span class="n">THREAD_SIZE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">empty_zero_page</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
<span class="cp">#ifndef __tilegx__</span>
<span class="cp">#if !ATOMIC_LOCKS_FOUND_VIA_TABLE()</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">atomic_locks</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_next</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kdata_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">NR_CPUS</span><span class="p">)</span>
			<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kdata_mask</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">construct_pgprot</span><span class="p">(</span><span class="n">PAGE_KERNEL</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function sets up how we cache the kernel text.  If we have</span>
<span class="cm"> * hash-for-home support, normally that is used instead (see the</span>
<span class="cm"> * kcache_hash boot flag for more information).  But if we end up</span>
<span class="cm"> * using a page-based caching technique, this option sets up the</span>
<span class="cm"> * details of that.  In addition, the &quot;ktext=nocache&quot; option may</span>
<span class="cm"> * always be used to disable local caching of text pages, if desired.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">ktext_arg_seen</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">ktext_small</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">ktext_local</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">ktext_all</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">ktext_nondataplane</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">ktext_nocache</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="n">__initdata</span> <span class="n">ktext_mask</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_ktext</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* If you have a leading &quot;nocache&quot;, turn off ktext caching */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;nocache&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ktext_nocache</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ktext: disabling local caching of kernel text</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">str</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
			<span class="o">++</span><span class="n">str</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ktext_arg_seen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Default setting on Tile64: use a huge page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;huge&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ktext: using one huge locally cached page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Pay TLB cost but get no cache benefit: cache small pages locally */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;local&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ktext_small</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ktext_local</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ktext: using small pages with local caching</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Neighborhood cache ktext pages on all cpus. */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;all&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ktext_small</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ktext_all</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ktext: using maximal caching neighborhood</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="cm">/* Neighborhood ktext pages on specified mask */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpulist_parse</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ktext_mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">NR_CPUS</span> <span class="o">*</span> <span class="mi">5</span><span class="p">];</span>
		<span class="n">cpulist_scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ktext_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_weight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ktext_mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ktext_small</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ktext: using caching neighborhood %s &quot;</span>
			       <span class="s">&quot;with small pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ktext: caching on cpu %s with one huge page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;ktext&quot;</span><span class="p">,</span> <span class="n">setup_ktext</span><span class="p">);</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="n">pgprot_t</span> <span class="nf">ktext_set_nocache</span><span class="p">(</span><span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ktext_nocache</span><span class="p">)</span>
		<span class="n">prot</span> <span class="o">=</span> <span class="n">hv_pte_set_nc</span><span class="p">(</span><span class="n">prot</span><span class="p">);</span>
<span class="cp">#if CHIP_HAS_NC_AND_NOALLOC_BITS()</span>
	<span class="k">else</span>
		<span class="n">prot</span> <span class="o">=</span> <span class="n">hv_pte_set_no_alloc_l2</span><span class="p">(</span><span class="n">prot</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">prot</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef __tilegx__</span>
<span class="k">static</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">__init</span> <span class="nf">get_pmd</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgtables</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgtables</span><span class="p">[</span><span class="n">pgd_index</span><span class="p">(</span><span class="n">va</span><span class="p">)],</span> <span class="n">va</span><span class="p">),</span> <span class="n">va</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">__init</span> <span class="nf">get_pmd</span><span class="p">(</span><span class="n">pgd_t</span> <span class="n">pgtables</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgtables</span><span class="p">[</span><span class="n">pgd_index</span><span class="p">(</span><span class="n">va</span><span class="p">)],</span> <span class="n">va</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="n">assign_pmd</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">alloc_pmd</span><span class="p">());</span>
	<span class="k">return</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">va</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Temporary page table we use for staging. */</span>
<span class="k">static</span> <span class="n">pgd_t</span> <span class="n">pgtables</span><span class="p">[</span><span class="n">PTRS_PER_PGD</span><span class="p">]</span>
 <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="n">HV_PAGE_TABLE_ALIGN</span><span class="p">)));</span>

<span class="cm">/*</span>
<span class="cm"> * This maps the physical memory to kernel virtual address space, a total</span>
<span class="cm"> * of max_low_pfn pages, by creating page tables starting from address</span>
<span class="cm"> * PAGE_OFFSET.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine transitions us from using a set of compiled-in large</span>
<span class="cm"> * pages to using some more precise caching, including removing access</span>
<span class="cm"> * to code pages mapped at PAGE_OFFSET (executed only at MEM_SV_START)</span>
<span class="cm"> * marking read-only data as locally cacheable, striping the remaining</span>
<span class="cm"> * .data and .bss across all the available tiles, and removing access</span>
<span class="cm"> * to pages above the top of RAM (thus ensuring a page fault from a bad</span>
<span class="cm"> * virtual address rather than a hypervisor shoot down for accessing</span>
<span class="cm"> * memory outside the assigned limits).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">kernel_physical_mapping_init</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">irqmask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pte_ofs</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">my_cpu_mask</span> <span class="o">=</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="n">kstripe_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

<span class="cp">#if CHIP_HAS_CBOX_HOME_MAP()</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ktext_arg_seen</span> <span class="o">&amp;&amp;</span> <span class="n">ktext_hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;warning: </span><span class="se">\&quot;</span><span class="s">ktext</span><span class="se">\&quot;</span><span class="s"> boot argument ignored&quot;</span>
			   <span class="s">&quot; if </span><span class="se">\&quot;</span><span class="s">kcache_hash</span><span class="se">\&quot;</span><span class="s"> sets up text hash-for-home</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ktext_small</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kdata_arg_seen</span> <span class="o">&amp;&amp;</span> <span class="n">kdata_hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;warning: </span><span class="se">\&quot;</span><span class="s">kdata</span><span class="se">\&quot;</span><span class="s"> boot argument ignored&quot;</span>
			   <span class="s">&quot; if </span><span class="se">\&quot;</span><span class="s">kcache_hash</span><span class="se">\&quot;</span><span class="s"> sets up data hash-for-home</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kdata_huge</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hash_default</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;warning: disabling </span><span class="se">\&quot;</span><span class="s">kdata=huge</span><span class="se">\&quot;</span><span class="s">; requires&quot;</span>
			  <span class="s">&quot; kcache_hash=all or =allbutstack</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kdata_huge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up a mask for cpus to use for kernel striping.</span>
<span class="cm">	 * This is normally all cpus, but minus dataplane cpus if any.</span>
<span class="cm">	 * If the dataplane covers the whole chip, we stripe over</span>
<span class="cm">	 * the whole chip too.</span>
<span class="cm">	 */</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kstripe_mask</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kdata_arg_seen</span><span class="p">)</span>
		<span class="n">kdata_mask</span> <span class="o">=</span> <span class="n">kstripe_mask</span><span class="p">;</span>

	<span class="cm">/* Allocate and fill in L2 page tables */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span> <span class="o">=</span> <span class="n">node_lowmem_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cp">#else</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span> <span class="o">=</span> <span class="n">node_end_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cp">#endif</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_huge_pfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Pre-shatter the last huge page to allow per-cpu pages. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kdata_huge</span><span class="p">)</span>
			<span class="n">end_huge_pfn</span> <span class="o">=</span> <span class="n">end_pfn</span> <span class="o">-</span> <span class="p">(</span><span class="n">HPAGE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

		<span class="n">pfn</span> <span class="o">=</span> <span class="n">node_start_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/* Allocate enough memory to hold L2 page tables for node. */</span>
		<span class="n">init_prealloc_ptes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end_pfn</span> <span class="o">-</span> <span class="n">pfn</span><span class="p">);</span>

		<span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">end_pfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">address</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HPAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
			<span class="n">pmd</span> <span class="o">=</span> <span class="n">get_pmd</span><span class="p">(</span><span class="n">pgtables</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
			<span class="n">pte</span> <span class="o">=</span> <span class="n">get_prealloc_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">end_huge_pfn</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pgprot_t</span> <span class="n">prot</span> <span class="o">=</span> <span class="n">init_pgprot</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
				<span class="o">*</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pmd</span> <span class="o">=</span> <span class="n">pte_mkhuge</span><span class="p">(</span><span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">prot</span><span class="p">));</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">pte_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pte_ofs</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PTE</span><span class="p">;</span>
				     <span class="n">pfn</span><span class="o">++</span><span class="p">,</span> <span class="n">pte_ofs</span><span class="o">++</span><span class="p">,</span> <span class="n">address</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
					<span class="n">pte</span><span class="p">[</span><span class="n">pte_ofs</span><span class="p">]</span> <span class="o">=</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">kdata_huge</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;pre-shattered huge&quot;</span>
					       <span class="s">&quot; page at %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">pte_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pte_ofs</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PTE</span><span class="p">;</span>
				     <span class="n">pfn</span><span class="o">++</span><span class="p">,</span> <span class="n">pte_ofs</span><span class="o">++</span><span class="p">,</span> <span class="n">address</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pgprot_t</span> <span class="n">prot</span> <span class="o">=</span> <span class="n">init_pgprot</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
					<span class="n">pte</span><span class="p">[</span><span class="n">pte_ofs</span><span class="p">]</span> <span class="o">=</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">assign_pte</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set or check ktext_map now that we have cpu_possible_mask</span>
<span class="cm">	 * and kstripe_mask to work with.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ktext_all</span><span class="p">)</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ktext_mask</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ktext_nondataplane</span><span class="p">)</span>
		<span class="n">ktext_mask</span> <span class="o">=</span> <span class="n">kstripe_mask</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ktext_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Sanity-check any mask that was requested */</span>
		<span class="k">struct</span> <span class="n">cpumask</span> <span class="n">bad</span><span class="p">;</span>
		<span class="n">cpumask_andnot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bad</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ktext_mask</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">);</span>
		<span class="n">cpumask_and</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ktext_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ktext_mask</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bad</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">NR_CPUS</span> <span class="o">*</span> <span class="mi">5</span><span class="p">];</span>
			<span class="n">cpulist_scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">bad</span><span class="p">);</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ktext: not using unavailable cpus %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ktext_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;ktext: no valid cpus; caching on %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">smp_processor_id</span><span class="p">());</span>
			<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ktext_mask</span><span class="p">,</span>
				     <span class="n">cpumask_of</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">address</span> <span class="o">=</span> <span class="n">MEM_SV_INTRPT</span><span class="p">;</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="n">get_pmd</span><span class="p">(</span><span class="n">pgtables</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="n">pfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* code starts at PA 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ktext_small</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Allocate an L2 PTE for the kernel text */</span>
		<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pgprot_t</span> <span class="n">prot</span> <span class="o">=</span> <span class="n">construct_pgprot</span><span class="p">(</span><span class="n">PAGE_KERNEL_EXEC</span><span class="p">,</span>
						 <span class="n">PAGE_HOME_IMMUTABLE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ktext_local</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ktext_nocache</span><span class="p">)</span>
				<span class="n">prot</span> <span class="o">=</span> <span class="n">hv_pte_set_mode</span><span class="p">(</span><span class="n">prot</span><span class="p">,</span>
						       <span class="n">HV_PTE_MODE_UNCACHED</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">prot</span> <span class="o">=</span> <span class="n">hv_pte_set_mode</span><span class="p">(</span><span class="n">prot</span><span class="p">,</span>
						       <span class="n">HV_PTE_MODE_CACHE_NO_L3</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">prot</span> <span class="o">=</span> <span class="n">hv_pte_set_mode</span><span class="p">(</span><span class="n">prot</span><span class="p">,</span>
					       <span class="n">HV_PTE_MODE_CACHE_TILE_L3</span><span class="p">);</span>
			<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ktext_mask</span><span class="p">);</span>

			<span class="n">prot</span> <span class="o">=</span> <span class="n">ktext_set_nocache</span><span class="p">(</span><span class="n">prot</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">address</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_stext</span><span class="p">);</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_einittext</span><span class="p">;</span>
		     <span class="n">pfn</span><span class="o">++</span><span class="p">,</span> <span class="n">address</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pte_ofs</span> <span class="o">=</span> <span class="n">pte_index</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pte_ofs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pte</span><span class="p">)</span>
					<span class="n">assign_pte</span><span class="p">(</span><span class="n">pmd</span><span class="o">++</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
				<span class="n">pte</span> <span class="o">=</span> <span class="n">alloc_pte</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ktext_local</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">prot</span> <span class="o">=</span> <span class="n">set_remote_cache_cpu</span><span class="p">(</span><span class="n">prot</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
				<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_next</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ktext_mask</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">NR_CPUS</span><span class="p">)</span>
					<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ktext_mask</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">pte</span><span class="p">[</span><span class="n">pte_ofs</span><span class="p">]</span> <span class="o">=</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte</span><span class="p">)</span>
			<span class="n">assign_pte</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="n">pteval</span> <span class="o">=</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_KERNEL_EXEC</span><span class="p">);</span>
		<span class="n">pteval</span> <span class="o">=</span> <span class="n">pte_mkhuge</span><span class="p">(</span><span class="n">pteval</span><span class="p">);</span>
<span class="cp">#if CHIP_HAS_CBOX_HOME_MAP()</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ktext_hash</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pteval</span> <span class="o">=</span> <span class="n">hv_pte_set_mode</span><span class="p">(</span><span class="n">pteval</span><span class="p">,</span>
						 <span class="n">HV_PTE_MODE_CACHE_HASH_L3</span><span class="p">);</span>
			<span class="n">pteval</span> <span class="o">=</span> <span class="n">ktext_set_nocache</span><span class="p">(</span><span class="n">pteval</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif </span><span class="cm">/* CHIP_HAS_CBOX_HOME_MAP() */</span><span class="cp"></span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_weight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ktext_mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pteval</span> <span class="o">=</span> <span class="n">set_remote_cache_cpu</span><span class="p">(</span><span class="n">pteval</span><span class="p">,</span>
					      <span class="n">cpumask_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ktext_mask</span><span class="p">));</span>
			<span class="n">pteval</span> <span class="o">=</span> <span class="n">hv_pte_set_mode</span><span class="p">(</span><span class="n">pteval</span><span class="p">,</span>
						 <span class="n">HV_PTE_MODE_CACHE_TILE_L3</span><span class="p">);</span>
			<span class="n">pteval</span> <span class="o">=</span> <span class="n">ktext_set_nocache</span><span class="p">(</span><span class="n">pteval</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ktext_nocache</span><span class="p">)</span>
			<span class="n">pteval</span> <span class="o">=</span> <span class="n">hv_pte_set_mode</span><span class="p">(</span><span class="n">pteval</span><span class="p">,</span>
						 <span class="n">HV_PTE_MODE_UNCACHED</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pteval</span> <span class="o">=</span> <span class="n">hv_pte_set_mode</span><span class="p">(</span><span class="n">pteval</span><span class="p">,</span>
						 <span class="n">HV_PTE_MODE_CACHE_NO_L3</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_einittext</span><span class="p">;</span>
		     <span class="n">pfn</span> <span class="o">+=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">HPAGE_SIZE</span><span class="p">),</span> <span class="n">address</span> <span class="o">+=</span> <span class="n">HPAGE_SIZE</span><span class="p">)</span>
			<span class="o">*</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">pmd</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">pteval</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set swapper_pgprot here so it is flushed to memory right away. */</span>
	<span class="n">swapper_pgprot</span> <span class="o">=</span> <span class="n">init_pgprot</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">swapper_pg_dir</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we may be changing the caching of the stack and page</span>
<span class="cm">	 * table itself, we invoke an assembly helper to do the</span>
<span class="cm">	 * following steps:</span>
<span class="cm">	 *</span>
<span class="cm">	 *  - flush the cache so we start with an empty slate</span>
<span class="cm">	 *  - install pgtables[] as the real page table</span>
<span class="cm">	 *  - flush the TLB so the new page table takes effect</span>
<span class="cm">	 */</span>
	<span class="n">irqmask</span> <span class="o">=</span> <span class="n">interrupt_mask_save_mask</span><span class="p">();</span>
	<span class="n">interrupt_mask_set_mask</span><span class="p">(</span><span class="o">-</span><span class="mi">1ULL</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">flush_and_install_context</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pgtables</span><span class="p">),</span>
				       <span class="n">init_pgprot</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pgtables</span><span class="p">),</span>
				       <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">current_asid</span><span class="p">),</span>
				       <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">my_cpu_mask</span><span class="p">));</span>
	<span class="n">interrupt_mask_restore_mask</span><span class="p">(</span><span class="n">irqmask</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Copy the page table back to the normal swapper_pg_dir. */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pgd_base</span><span class="p">,</span> <span class="n">pgtables</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pgtables</span><span class="p">));</span>
	<span class="n">__install_page_table</span><span class="p">(</span><span class="n">pgd_base</span><span class="p">,</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">current_asid</span><span class="p">),</span>
			     <span class="n">swapper_pgprot</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We just read swapper_pgprot and thus brought it into the cache,</span>
<span class="cm">	 * with its new home &amp; caching mode.  When we start the other CPUs,</span>
<span class="cm">	 * they&#39;re going to reference swapper_pgprot via their initial fake</span>
<span class="cm">	 * VA-is-PA mappings, which cache everything locally.  At that</span>
<span class="cm">	 * time, if it&#39;s in our cache with a conflicting home, the</span>
<span class="cm">	 * simulator&#39;s coherence checker will complain.  So, flush it out</span>
<span class="cm">	 * of our cache; we&#39;re not going to ever use it again anyway.</span>
<span class="cm">	 */</span>
	<span class="n">__insn_finv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swapper_pgprot</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * devmem_is_allowed() checks to see if /dev/mem access to a certain address</span>
<span class="cm"> * is valid. The argument is a physical page number.</span>
<span class="cm"> *</span>
<span class="cm"> * On Tile, the only valid things for which we can just hand out unchecked</span>
<span class="cm"> * PTEs are the kernel code and data.  Anything else might change its</span>
<span class="cm"> * homing with time, and we wouldn&#39;t know to adjust the /dev/mem PTEs.</span>
<span class="cm"> * Note that init_thread_union is released to heap soon after boot,</span>
<span class="cm"> * so we include it in the init data.</span>
<span class="cm"> *</span>
<span class="cm"> * For TILE-Gx, we might want to consider allowing access to PA</span>
<span class="cm"> * regions corresponding to PCI space, etc.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">devmem_is_allowed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pagenr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pagenr</span> <span class="o">&lt;</span> <span class="n">kaddr_to_pfn</span><span class="p">(</span><span class="n">_end</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">pagenr</span> <span class="o">&gt;=</span> <span class="n">kaddr_to_pfn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_thread_union</span><span class="p">)</span> <span class="o">||</span>
		  <span class="n">pagenr</span> <span class="o">&lt;</span> <span class="n">kaddr_to_pfn</span><span class="p">(</span><span class="n">_einitdata</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">pagenr</span> <span class="o">&gt;=</span> <span class="n">kaddr_to_pfn</span><span class="p">(</span><span class="n">_sinittext</span><span class="p">)</span> <span class="o">||</span>
		  <span class="n">pagenr</span> <span class="o">&lt;=</span> <span class="n">kaddr_to_pfn</span><span class="p">(</span><span class="n">_einittext</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">permanent_kmaps_init</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">;</span>

	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">PKMAP_BASE</span><span class="p">;</span>
	<span class="n">page_table_range_init</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="o">*</span><span class="n">LAST_PKMAP</span><span class="p">,</span> <span class="n">pgd_base</span><span class="p">);</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">swapper_pg_dir</span> <span class="o">+</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
	<span class="n">pkmap_page_table</span> <span class="o">=</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HIGHMEM */</span><span class="cp"></span>


<span class="cp">#ifndef CONFIG_64BIT</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_free_pfn_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Optimize by freeing pages in large batches */</span>
		<span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">MAX_ORDER</span><span class="p">)</span>
			<span class="n">order</span> <span class="o">=</span> <span class="n">MAX_ORDER</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">count</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="o">--</span><span class="n">order</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">page</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__ClearPageReserved</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Hacky direct set to avoid unnecessary</span>
<span class="cm">			 * lock take/release for EVERY page here.</span>
<span class="cm">			 */</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">.</span><span class="n">counter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">init_page_count</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">__free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>

		<span class="n">page</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">pfn</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">set_non_bootmem_pages_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
	<span class="n">for_each_zone</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">zone_pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">zone_idx</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

		<span class="n">start</span> <span class="o">=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">zone_start_pfn</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>  <span class="cm">/* bootmem */</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">spanned_pages</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">ZONE_NORMAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="n">node_start_pfn</span><span class="p">[</span><span class="n">nid</span><span class="p">]);</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">node_free_pfn</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>
		<span class="p">}</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">ZONE_HIGHMEM</span><span class="p">)</span>
			<span class="n">totalhigh_pages</span> <span class="o">+=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">spanned_pages</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kdata_huge</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">percpu_pfn</span> <span class="o">=</span> <span class="n">node_percpu_pfn</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">percpu_pfn</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">percpu_pfn</span><span class="p">)</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">percpu_pfn</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#ifdef CONFIG_PCI</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">pci_reserve_start_pfn</span> <span class="o">&amp;&amp;</span>
		    <span class="n">end</span> <span class="o">&gt;</span> <span class="n">pci_reserve_start_pfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">pci_reserve_end_pfn</span><span class="p">)</span>
				<span class="n">init_free_pfn_range</span><span class="p">(</span><span class="n">pci_reserve_end_pfn</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">pci_reserve_start_pfn</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">init_free_pfn_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * paging_init() sets up the page tables - note that all of lowmem is</span>
<span class="cm"> * already mapped by head.S.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">paging_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef __tilegx__</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd_base</span> <span class="o">=</span> <span class="n">swapper_pg_dir</span><span class="p">;</span>

	<span class="n">kernel_physical_mapping_init</span><span class="p">(</span><span class="n">pgd_base</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fixed mappings, only the page table structure has to be</span>
<span class="cm">	 * created - mappings will be set by set_fixmap():</span>
<span class="cm">	 */</span>
	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">__end_of_fixed_addresses</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PMD_MASK</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">FIXADDR_TOP</span> <span class="o">+</span> <span class="n">PMD_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PMD_MASK</span><span class="p">;</span>
	<span class="n">page_table_range_init</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">pgd_base</span><span class="p">);</span>
	<span class="n">permanent_kmaps_init</span><span class="p">(</span><span class="n">pgd_base</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef __tilegx__</span>
	<span class="cm">/*</span>
<span class="cm">	 * Since GX allocates just one pmd_t array worth of vmalloc space,</span>
<span class="cm">	 * we go ahead and allocate it statically here, then share it</span>
<span class="cm">	 * globally.  As a result we don&#39;t have to worry about any task</span>
<span class="cm">	 * changing init_mm once we get up and running, and there&#39;s no</span>
<span class="cm">	 * need for e.g. vmalloc_sync_all().</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">pgd_index</span><span class="p">(</span><span class="n">VMALLOC_START</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">VMALLOC_END</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd_base</span> <span class="o">+</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">VMALLOC_START</span><span class="p">),</span> <span class="n">VMALLOC_START</span><span class="p">);</span>
	<span class="n">assign_pmd</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">alloc_pmd</span><span class="p">());</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Walk the kernel page tables and derive the page_home() from</span>
<span class="cm"> * the PTEs, so that set_pte() can properly validate the caching</span>
<span class="cm"> * of all PTEs it sees.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">set_page_homes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">set_max_mapnr_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_FLATMEM</span>
	<span class="n">max_mapnr</span> <span class="o">=</span> <span class="n">max_low_pfn</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">mem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">codesize</span><span class="p">,</span> <span class="n">datasize</span><span class="p">,</span> <span class="n">initsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#ifndef __tilegx__</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_FLATMEM</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mem_map</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="cm">/* check that fixmap and pkmap do not overlap */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PKMAP_ADDR</span><span class="p">(</span><span class="n">LAST_PKMAP</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">FIXADDR_START</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;fixmap and kmap areas overlap&quot;</span>
		       <span class="s">&quot; - this will crash</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;pkstart: %lxh pkend: %lxh fixstart %lxh</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">PKMAP_BASE</span><span class="p">,</span> <span class="n">PKMAP_ADDR</span><span class="p">(</span><span class="n">LAST_PKMAP</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
		       <span class="n">FIXADDR_START</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">set_max_mapnr_init</span><span class="p">();</span>

	<span class="cm">/* this will put all bootmem onto the freelists */</span>
	<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="n">free_all_bootmem</span><span class="p">();</span>

<span class="cp">#ifndef CONFIG_64BIT</span>
	<span class="cm">/* count all remaining LOWMEM and give all HIGHMEM to page allocator */</span>
	<span class="n">set_non_bootmem_pages_init</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="n">codesize</span> <span class="o">=</span>  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_etext</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_text</span><span class="p">;</span>
	<span class="n">datasize</span> <span class="o">=</span>  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_end</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_sdata</span><span class="p">;</span>
	<span class="n">initsize</span> <span class="o">=</span>  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_einittext</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_sinittext</span><span class="p">;</span>
	<span class="n">initsize</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_einitdata</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_sinitdata</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Memory: %luk/%luk available (%dk kernel code, %dk data, %dk init, %ldk highmem)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">nr_free_pages</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="n">num_physpages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="n">codesize</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">datasize</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">initsize</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">totalhigh_pages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">))</span>
	       <span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In debug mode, dump some interesting memory mappings.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  KMAP    %#lx - %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">FIXADDR_START</span><span class="p">,</span> <span class="n">FIXADDR_TOP</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  PKMAP   %#lx - %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">PKMAP_BASE</span><span class="p">,</span> <span class="n">PKMAP_ADDR</span><span class="p">(</span><span class="n">LAST_PKMAP</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_HUGEVMAP</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  HUGEMAP %#lx - %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">HUGE_VMAP_BASE</span><span class="p">,</span> <span class="n">HUGE_VMAP_END</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  VMALLOC %#lx - %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">_VMALLOC_START</span><span class="p">,</span> <span class="n">_VMALLOC_END</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#ifdef __tilegx__</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">MAX_NUMNODES</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">node_present_pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
				<span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span><span class="p">);</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">node_present_pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  MEM%d    %#lx - %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">i</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">high_memory</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">MAX_NUMNODES</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vbase_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1UL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  LOWMEM%d %#lx - %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">vbase_map</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">last</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
			<span class="n">last</span> <span class="o">=</span> <span class="n">vbase_map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __tilegx__</span>
	<span class="cm">/*</span>
<span class="cm">	 * Convert from using one lock for all atomic operations to</span>
<span class="cm">	 * one per cpu.</span>
<span class="cm">	 */</span>
	<span class="n">__init_atomic_per_cpu</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this is for the non-NUMA, single node SMP system case.</span>
<span class="cm"> * Specifically, in the case of x86, we will always add</span>
<span class="cm"> * memory to the highmem for now.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_NEED_MULTIPLE_NODES</span>
<span class="kt">int</span> <span class="nf">arch_add_memory</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">pgdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">contig_page_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">pgdata</span><span class="o">-&gt;</span><span class="n">node_zones</span> <span class="o">+</span> <span class="n">MAX_NR_ZONES</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__add_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">remove_memory</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">pgd_cache</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">pgtable_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;pgd&quot;</span><span class="p">,</span> <span class="n">SIZEOF_PGD</span><span class="p">,</span> <span class="n">SIZEOF_PGD</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgd_cache</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;pgtable_cache_init(): Cannot create pgd cache&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if !CHIP_HAS_COHERENT_LOCAL_CACHE()</span>
<span class="cm">/*</span>
<span class="cm"> * The __w1data area holds data that is only written during initialization,</span>
<span class="cm"> * and is read-only and thus freely cacheable thereafter.  Fix the page</span>
<span class="cm"> * table entries that cover that region accordingly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mark_w1data_ro</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Loop over page table entries */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__w1data_begin</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">addr</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__w1data_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">kaddr_to_pfn</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">virt_to_pte</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pte_huge</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">));</span>   <span class="cm">/* not relevant for kdata_huge */</span>
		<span class="n">set_pte_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">PAGE_KERNEL_RO</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">__write_once</span> <span class="n">initfree</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">__write_once</span> <span class="n">initfree</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/* Select whether to free (1) or mark unusable (0) the __init pages. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_initfree</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strict_strtol</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">initfree</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;initfree: %s free init pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">initfree</span> <span class="o">?</span> <span class="s">&quot;will&quot;</span> <span class="o">:</span> <span class="s">&quot;won&#39;t&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;initfree=&quot;</span><span class="p">,</span> <span class="n">set_initfree</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_init_pages</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">what</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">begin</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">begin</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kdata_huge</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">initfree</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: ignoring initfree=0:&quot;</span>
			   <span class="s">&quot; incompatible with kdata=huge</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">initfree</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">local_flush_tlb_pages</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note we just reset the home here directly in the</span>
<span class="cm">		 * page table.  We know this is safe because our caller</span>
<span class="cm">		 * just flushed the caches on all the other cpus,</span>
<span class="cm">		 * and they won&#39;t be touching any of these pages.</span>
<span class="cm">		 */</span>
		<span class="kt">int</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">kaddr_to_pfn</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">virt_to_pte</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">initfree</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If debugging page accesses then do not free</span>
<span class="cm">			 * this memory but mark them not present - any</span>
<span class="cm">			 * buggy init-section access will create a</span>
<span class="cm">			 * kernel page fault:</span>
<span class="cm">			 */</span>
			<span class="n">pte_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__ClearPageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">init_page_count</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_huge</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">))</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">kdata_huge</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">set_pte_at</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span>
				   <span class="n">pfn_pte</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">));</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">POISON_FREE_INITMEM</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">free_page</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">totalram_pages</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Freeing %s: %ldk freed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_initmem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">text_delta</span> <span class="o">=</span> <span class="n">MEM_SV_INTRPT</span> <span class="o">-</span> <span class="n">PAGE_OFFSET</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Evict the dirty initdata on the boot cpu, evict the w1data</span>
<span class="cm">	 * wherever it&#39;s homed, and evict all the init code everywhere.</span>
<span class="cm">	 * We are guaranteed that no one will touch the init pages any</span>
<span class="cm">	 * more, and although other cpus may be touching the w1data,</span>
<span class="cm">	 * we only actually change the caching on tile64, which won&#39;t</span>
<span class="cm">	 * be keeping local copies in the other tiles&#39; caches anyway.</span>
<span class="cm">	 */</span>
	<span class="n">homecache_evict</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_cacheable_map</span><span class="p">);</span>

	<span class="cm">/* Free the data pages that we won&#39;t use again after init. */</span>
	<span class="n">free_init_pages</span><span class="p">(</span><span class="s">&quot;unused kernel data&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_sinitdata</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_einitdata</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Free the pages mapped from 0xc0000000 that correspond to code</span>
<span class="cm">	 * pages from MEM_SV_INTRPT that we won&#39;t use again after init.</span>
<span class="cm">	 */</span>
	<span class="n">free_init_pages</span><span class="p">(</span><span class="s">&quot;unused kernel text&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_sinittext</span> <span class="o">-</span> <span class="n">text_delta</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_einittext</span> <span class="o">-</span> <span class="n">text_delta</span><span class="p">);</span>

<span class="cp">#if !CHIP_HAS_COHERENT_LOCAL_CACHE()</span>
	<span class="cm">/*</span>
<span class="cm">	 * Upgrade the .w1data section to globally cached.</span>
<span class="cm">	 * We don&#39;t do this on tilepro, since the cache architecture</span>
<span class="cm">	 * pretty much makes it irrelevant, and in any case we end</span>
<span class="cm">	 * up having racing issues with other tiles that may touch</span>
<span class="cm">	 * the data after we flush the cache but before we update</span>
<span class="cm">	 * the PTEs and flush the TLBs, causing sharer shootdowns</span>
<span class="cm">	 * later.  Even though this is to clean data, it seems like</span>
<span class="cm">	 * an unnecessary complication.</span>
<span class="cm">	 */</span>
	<span class="n">mark_w1data_ro</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/* Do a global TLB flush so everyone sees the changes. */</span>
	<span class="n">flush_tlb_all</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
