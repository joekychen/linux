<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › spu.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>spu.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SPU core / file system interface and HW structures</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright IBM Deutschland Entwicklung GmbH 2005</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Arnd Bergmann &lt;arndb@de.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _SPU_H</span>
<span class="cp">#define _SPU_H</span>
<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cp">#define LS_SIZE (256 * 1024)</span>
<span class="cp">#define LS_ADDR_MASK (LS_SIZE - 1)</span>

<span class="cp">#define MFC_PUT_CMD             0x20</span>
<span class="cp">#define MFC_PUTS_CMD            0x28</span>
<span class="cp">#define MFC_PUTR_CMD            0x30</span>
<span class="cp">#define MFC_PUTF_CMD            0x22</span>
<span class="cp">#define MFC_PUTB_CMD            0x21</span>
<span class="cp">#define MFC_PUTFS_CMD           0x2A</span>
<span class="cp">#define MFC_PUTBS_CMD           0x29</span>
<span class="cp">#define MFC_PUTRF_CMD           0x32</span>
<span class="cp">#define MFC_PUTRB_CMD           0x31</span>
<span class="cp">#define MFC_PUTL_CMD            0x24</span>
<span class="cp">#define MFC_PUTRL_CMD           0x34</span>
<span class="cp">#define MFC_PUTLF_CMD           0x26</span>
<span class="cp">#define MFC_PUTLB_CMD           0x25</span>
<span class="cp">#define MFC_PUTRLF_CMD          0x36</span>
<span class="cp">#define MFC_PUTRLB_CMD          0x35</span>

<span class="cp">#define MFC_GET_CMD             0x40</span>
<span class="cp">#define MFC_GETS_CMD            0x48</span>
<span class="cp">#define MFC_GETF_CMD            0x42</span>
<span class="cp">#define MFC_GETB_CMD            0x41</span>
<span class="cp">#define MFC_GETFS_CMD           0x4A</span>
<span class="cp">#define MFC_GETBS_CMD           0x49</span>
<span class="cp">#define MFC_GETL_CMD            0x44</span>
<span class="cp">#define MFC_GETLF_CMD           0x46</span>
<span class="cp">#define MFC_GETLB_CMD           0x45</span>

<span class="cp">#define MFC_SDCRT_CMD           0x80</span>
<span class="cp">#define MFC_SDCRTST_CMD         0x81</span>
<span class="cp">#define MFC_SDCRZ_CMD           0x89</span>
<span class="cp">#define MFC_SDCRS_CMD           0x8D</span>
<span class="cp">#define MFC_SDCRF_CMD           0x8F</span>

<span class="cp">#define MFC_GETLLAR_CMD         0xD0</span>
<span class="cp">#define MFC_PUTLLC_CMD          0xB4</span>
<span class="cp">#define MFC_PUTLLUC_CMD         0xB0</span>
<span class="cp">#define MFC_PUTQLLUC_CMD        0xB8</span>
<span class="cp">#define MFC_SNDSIG_CMD          0xA0</span>
<span class="cp">#define MFC_SNDSIGB_CMD         0xA1</span>
<span class="cp">#define MFC_SNDSIGF_CMD         0xA2</span>
<span class="cp">#define MFC_BARRIER_CMD         0xC0</span>
<span class="cp">#define MFC_EIEIO_CMD           0xC8</span>
<span class="cp">#define MFC_SYNC_CMD            0xCC</span>

<span class="cp">#define MFC_MIN_DMA_SIZE_SHIFT  4       </span><span class="cm">/* 16 bytes */</span><span class="cp"></span>
<span class="cp">#define MFC_MAX_DMA_SIZE_SHIFT  14      </span><span class="cm">/* 16384 bytes */</span><span class="cp"></span>
<span class="cp">#define MFC_MIN_DMA_SIZE        (1 &lt;&lt; MFC_MIN_DMA_SIZE_SHIFT)</span>
<span class="cp">#define MFC_MAX_DMA_SIZE        (1 &lt;&lt; MFC_MAX_DMA_SIZE_SHIFT)</span>
<span class="cp">#define MFC_MIN_DMA_SIZE_MASK   (MFC_MIN_DMA_SIZE - 1)</span>
<span class="cp">#define MFC_MAX_DMA_SIZE_MASK   (MFC_MAX_DMA_SIZE - 1)</span>
<span class="cp">#define MFC_MIN_DMA_LIST_SIZE   0x0008  </span><span class="cm">/*   8 bytes */</span><span class="cp"></span>
<span class="cp">#define MFC_MAX_DMA_LIST_SIZE   0x4000  </span><span class="cm">/* 16K bytes */</span><span class="cp"></span>

<span class="cp">#define MFC_TAGID_TO_TAGMASK(tag_id)  (1 &lt;&lt; (tag_id &amp; 0x1F))</span>

<span class="cm">/* Events for Channels 0-2 */</span>
<span class="cp">#define MFC_DMA_TAG_STATUS_UPDATE_EVENT     0x00000001</span>
<span class="cp">#define MFC_DMA_TAG_CMD_STALL_NOTIFY_EVENT  0x00000002</span>
<span class="cp">#define MFC_DMA_QUEUE_AVAILABLE_EVENT       0x00000008</span>
<span class="cp">#define MFC_SPU_MAILBOX_WRITTEN_EVENT       0x00000010</span>
<span class="cp">#define MFC_DECREMENTER_EVENT               0x00000020</span>
<span class="cp">#define MFC_PU_INT_MAILBOX_AVAILABLE_EVENT  0x00000040</span>
<span class="cp">#define MFC_PU_MAILBOX_AVAILABLE_EVENT      0x00000080</span>
<span class="cp">#define MFC_SIGNAL_2_EVENT                  0x00000100</span>
<span class="cp">#define MFC_SIGNAL_1_EVENT                  0x00000200</span>
<span class="cp">#define MFC_LLR_LOST_EVENT                  0x00000400</span>
<span class="cp">#define MFC_PRIV_ATTN_EVENT                 0x00000800</span>
<span class="cp">#define MFC_MULTI_SRC_EVENT                 0x00001000</span>

<span class="cm">/* Flag indicating progress during context switch. */</span>
<span class="cp">#define SPU_CONTEXT_SWITCH_PENDING	0UL</span>
<span class="cp">#define SPU_CONTEXT_FAULT_PENDING	1UL</span>

<span class="k">struct</span> <span class="n">spu_context</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">spu_runqueue</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">spu_lscsa</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">device_node</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">spu_utilization_state</span> <span class="p">{</span>
	<span class="n">SPU_UTIL_USER</span><span class="p">,</span>
	<span class="n">SPU_UTIL_SYSTEM</span><span class="p">,</span>
	<span class="n">SPU_UTIL_IOWAIT</span><span class="p">,</span>
	<span class="n">SPU_UTIL_IDLE_LOADED</span><span class="p">,</span>
	<span class="n">SPU_UTIL_MAX</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">spu</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">local_store_phys</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">local_store</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">problem_phys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">problem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cbe_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">full_list</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span> <span class="n">SPU_FREE</span><span class="p">,</span> <span class="n">SPU_USED</span> <span class="p">}</span> <span class="n">alloc_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irqs</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">class_0_pending</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">class_0_dar</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">class_1_dar</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">class_1_dsisr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ls_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slb_replace</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_runqueue</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">tgid</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">register_lock</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">wbox_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">ibox_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">stop_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">mfc_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">);</span>

	<span class="kt">char</span> <span class="n">irq_c0</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">irq_c1</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">irq_c2</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="n">u64</span> <span class="n">spe_id</span><span class="p">;</span>

	<span class="kt">void</span><span class="o">*</span> <span class="n">pdata</span><span class="p">;</span> <span class="cm">/* platform private data */</span>

	<span class="cm">/* of based platforms only */</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">devnode</span><span class="p">;</span>

	<span class="cm">/* native only */</span>
	<span class="k">struct</span> <span class="n">spu_priv1</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv1</span><span class="p">;</span>

	<span class="cm">/* beat only */</span>
	<span class="n">u64</span> <span class="n">shadow_int_mask_RW</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">has_mem_affinity</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">aff_list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* protected by interrupt reentrancy */</span>
		<span class="k">enum</span> <span class="n">spu_utilization_state</span> <span class="n">util_state</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">tstamp</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">times</span><span class="p">[</span><span class="n">SPU_UTIL_MAX</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">vol_ctx_switch</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">invol_ctx_switch</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">min_flt</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">maj_flt</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">hash_flt</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">slb_flt</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">class2_intr</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">libassist</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">stats</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cbe_spu_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">list_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">spus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_spus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_active</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">busy_spus</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">reserved_spus</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">cbe_spu_info</span> <span class="n">cbe_spu_info</span><span class="p">[];</span>

<span class="kt">void</span> <span class="n">spu_init_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">spu_irq_setaffinity</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">spu_setup_kernel_slbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu_lscsa</span> <span class="o">*</span><span class="n">lscsa</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">code_size</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">spu_invalidate_slbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">spu_associate_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">spu_64k_pages_available</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Calls from the memory management to the SPU */</span>
<span class="k">struct</span> <span class="n">mm_struct</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">spu_flush_all_slbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>

<span class="cm">/* This interface allows a profiler (e.g., OProfile) to store a ref</span>
<span class="cm"> * to spu context information that it creates.	This caching technique</span>
<span class="cm"> * avoids the need to recreate this information after a save/restore operation.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumes the caller has already incremented the ref count to</span>
<span class="cm"> * profile_info; then spu_context_destroy must call kref_put</span>
<span class="cm"> * on prof_info_kref.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">spu_set_profile_private_kref</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">prof_info_kref</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="p">(</span> <span class="o">*</span> <span class="n">prof_info_release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">));</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">spu_get_profile_private_kref</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>

<span class="cm">/* system callbacks from the SPU */</span>
<span class="k">struct</span> <span class="n">spu_syscall_block</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">nr_ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">parm</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">spu_sys_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_syscall_block</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>

<span class="cm">/* syscalls implemented in spufs */</span>
<span class="k">struct</span> <span class="n">file</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">spufs_calls</span> <span class="p">{</span>
	<span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">create_thread</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">neighbor</span><span class="p">);</span>
	<span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">spu_run</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">unpc</span><span class="p">,</span>
						<span class="n">__u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ustatus</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">coredump_extra_notes_size</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">coredump_extra_notes_write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">foffset</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">notify_spus_active</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* return status from spu_run, same as in libspe */</span>
<span class="cp">#define SPE_EVENT_DMA_ALIGNMENT		0x0008	</span><span class="cm">/*A DMA alignment error */</span><span class="cp"></span>
<span class="cp">#define SPE_EVENT_SPE_ERROR		0x0010	</span><span class="cm">/*An illegal instruction error*/</span><span class="cp"></span>
<span class="cp">#define SPE_EVENT_SPE_DATA_SEGMENT	0x0020	</span><span class="cm">/*A DMA segmentation error    */</span><span class="cp"></span>
<span class="cp">#define SPE_EVENT_SPE_DATA_STORAGE	0x0040	</span><span class="cm">/*A DMA storage error */</span><span class="cp"></span>
<span class="cp">#define SPE_EVENT_INVALID_DMA		0x0800	</span><span class="cm">/* Invalid MFC DMA */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Flags for sys_spu_create.</span>
<span class="cm"> */</span>
<span class="cp">#define SPU_CREATE_EVENTS_ENABLED	0x0001</span>
<span class="cp">#define SPU_CREATE_GANG			0x0002</span>
<span class="cp">#define SPU_CREATE_NOSCHED		0x0004</span>
<span class="cp">#define SPU_CREATE_ISOLATE		0x0008</span>
<span class="cp">#define SPU_CREATE_AFFINITY_SPU		0x0010</span>
<span class="cp">#define SPU_CREATE_AFFINITY_MEM		0x0020</span>

<span class="cp">#define SPU_CREATE_FLAG_ALL		0x003f </span><span class="cm">/* mask of all valid flags */</span><span class="cp"></span>


<span class="kt">int</span> <span class="n">register_spu_syscalls</span><span class="p">(</span><span class="k">struct</span> <span class="n">spufs_calls</span> <span class="o">*</span><span class="n">calls</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">unregister_spu_syscalls</span><span class="p">(</span><span class="k">struct</span> <span class="n">spufs_calls</span> <span class="o">*</span><span class="n">calls</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">spu_add_dev_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">spu_remove_dev_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">spu_add_dev_attr_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">*</span><span class="n">attrs</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">spu_remove_dev_attr_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">*</span><span class="n">attrs</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">spu_handle_mm_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ea</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dsisr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">flt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Notifier blocks:</span>
<span class="cm"> *</span>
<span class="cm"> * oprofile can get notified when a context switch is performed</span>
<span class="cm"> * on an spe. The notifer function that gets called is passed</span>
<span class="cm"> * a pointer to the SPU structure as well as the object-id that</span>
<span class="cm"> * identifies the binary running on that SPU now.</span>
<span class="cm"> *</span>
<span class="cm"> * For a context save, the object-id that is passed is zero,</span>
<span class="cm"> * identifying that the kernel will run from that moment on.</span>
<span class="cm"> *</span>
<span class="cm"> * For a context restore, the object-id is the value written</span>
<span class="cm"> * to object-id spufs file from user space and the notifer</span>
<span class="cm"> * function can assume that spu-&gt;ctx is valid.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">notifier_block</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">spu_switch_event_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">spu_switch_event_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">notify_spus_active</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">do_notify_spus_active</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This defines the Local Store, Problem Area and Privilege Area of an SPU.</span>
<span class="cm"> */</span>

<span class="k">union</span> <span class="n">mfc_tag_size_class_cmd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">mfc_size</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">mfc_tag</span><span class="p">;</span>
		<span class="n">u8</span>  <span class="n">pad</span><span class="p">;</span>
		<span class="n">u8</span>  <span class="n">mfc_rclassid</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">mfc_cmd</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">mfc_size_tag32</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">mfc_class_cmd32</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">by32</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">all64</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mfc_cq_sr</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">mfc_cq_data0_RW</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mfc_cq_data1_RW</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mfc_cq_data2_RW</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mfc_cq_data3_RW</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">spu_problem</span> <span class="p">{</span>
<span class="cp">#define MS_SYNC_PENDING         1L</span>
	<span class="n">u64</span> <span class="n">spc_mssync_RW</span><span class="p">;</span>					<span class="cm">/* 0x0000 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x0008_0x3000</span><span class="p">[</span><span class="mh">0x3000</span> <span class="o">-</span> <span class="mh">0x0008</span><span class="p">];</span>

	<span class="cm">/* DMA Area */</span>
	<span class="n">u8</span>  <span class="n">pad_0x3000_0x3004</span><span class="p">[</span><span class="mh">0x4</span><span class="p">];</span>				<span class="cm">/* 0x3000 */</span>
	<span class="n">u32</span> <span class="n">mfc_lsa_W</span><span class="p">;</span>						<span class="cm">/* 0x3004 */</span>
	<span class="n">u64</span> <span class="n">mfc_ea_W</span><span class="p">;</span>						<span class="cm">/* 0x3008 */</span>
	<span class="k">union</span> <span class="n">mfc_tag_size_class_cmd</span> <span class="n">mfc_union_W</span><span class="p">;</span>			<span class="cm">/* 0x3010 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x3018_0x3104</span><span class="p">[</span><span class="mh">0xec</span><span class="p">];</span>				<span class="cm">/* 0x3018 */</span>
	<span class="n">u32</span> <span class="n">dma_qstatus_R</span><span class="p">;</span>					<span class="cm">/* 0x3104 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x3108_0x3204</span><span class="p">[</span><span class="mh">0xfc</span><span class="p">];</span>				<span class="cm">/* 0x3108 */</span>
	<span class="n">u32</span> <span class="n">dma_querytype_RW</span><span class="p">;</span>					<span class="cm">/* 0x3204 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x3208_0x321c</span><span class="p">[</span><span class="mh">0x14</span><span class="p">];</span>				<span class="cm">/* 0x3208 */</span>
	<span class="n">u32</span> <span class="n">dma_querymask_RW</span><span class="p">;</span>					<span class="cm">/* 0x321c */</span>
	<span class="n">u8</span>  <span class="n">pad_0x3220_0x322c</span><span class="p">[</span><span class="mh">0xc</span><span class="p">];</span>				<span class="cm">/* 0x3220 */</span>
	<span class="n">u32</span> <span class="n">dma_tagstatus_R</span><span class="p">;</span>					<span class="cm">/* 0x322c */</span>
<span class="cp">#define DMA_TAGSTATUS_INTR_ANY	1u</span>
<span class="cp">#define DMA_TAGSTATUS_INTR_ALL	2u</span>
	<span class="n">u8</span>  <span class="n">pad_0x3230_0x4000</span><span class="p">[</span><span class="mh">0x4000</span> <span class="o">-</span> <span class="mh">0x3230</span><span class="p">];</span> 		<span class="cm">/* 0x3230 */</span>

	<span class="cm">/* SPU Control Area */</span>
	<span class="n">u8</span>  <span class="n">pad_0x4000_0x4004</span><span class="p">[</span><span class="mh">0x4</span><span class="p">];</span>				<span class="cm">/* 0x4000 */</span>
	<span class="n">u32</span> <span class="n">pu_mb_R</span><span class="p">;</span>						<span class="cm">/* 0x4004 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x4008_0x400c</span><span class="p">[</span><span class="mh">0x4</span><span class="p">];</span>				<span class="cm">/* 0x4008 */</span>
	<span class="n">u32</span> <span class="n">spu_mb_W</span><span class="p">;</span>						<span class="cm">/* 0x400c */</span>
	<span class="n">u8</span>  <span class="n">pad_0x4010_0x4014</span><span class="p">[</span><span class="mh">0x4</span><span class="p">];</span>				<span class="cm">/* 0x4010 */</span>
	<span class="n">u32</span> <span class="n">mb_stat_R</span><span class="p">;</span>						<span class="cm">/* 0x4014 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x4018_0x401c</span><span class="p">[</span><span class="mh">0x4</span><span class="p">];</span>				<span class="cm">/* 0x4018 */</span>
	<span class="n">u32</span> <span class="n">spu_runcntl_RW</span><span class="p">;</span>					<span class="cm">/* 0x401c */</span>
<span class="cp">#define SPU_RUNCNTL_STOP	0L</span>
<span class="cp">#define SPU_RUNCNTL_RUNNABLE	1L</span>
<span class="cp">#define SPU_RUNCNTL_ISOLATE	2L</span>
	<span class="n">u8</span>  <span class="n">pad_0x4020_0x4024</span><span class="p">[</span><span class="mh">0x4</span><span class="p">];</span>				<span class="cm">/* 0x4020 */</span>
	<span class="n">u32</span> <span class="n">spu_status_R</span><span class="p">;</span>					<span class="cm">/* 0x4024 */</span>
<span class="cp">#define SPU_STOP_STATUS_SHIFT           16</span>
<span class="cp">#define SPU_STATUS_STOPPED		0x0</span>
<span class="cp">#define SPU_STATUS_RUNNING		0x1</span>
<span class="cp">#define SPU_STATUS_STOPPED_BY_STOP	0x2</span>
<span class="cp">#define SPU_STATUS_STOPPED_BY_HALT	0x4</span>
<span class="cp">#define SPU_STATUS_WAITING_FOR_CHANNEL	0x8</span>
<span class="cp">#define SPU_STATUS_SINGLE_STEP		0x10</span>
<span class="cp">#define SPU_STATUS_INVALID_INSTR        0x20</span>
<span class="cp">#define SPU_STATUS_INVALID_CH           0x40</span>
<span class="cp">#define SPU_STATUS_ISOLATED_STATE       0x80</span>
<span class="cp">#define SPU_STATUS_ISOLATED_LOAD_STATUS 0x200</span>
<span class="cp">#define SPU_STATUS_ISOLATED_EXIT_STATUS 0x400</span>
	<span class="n">u8</span>  <span class="n">pad_0x4028_0x402c</span><span class="p">[</span><span class="mh">0x4</span><span class="p">];</span>				<span class="cm">/* 0x4028 */</span>
	<span class="n">u32</span> <span class="n">spu_spe_R</span><span class="p">;</span>						<span class="cm">/* 0x402c */</span>
	<span class="n">u8</span>  <span class="n">pad_0x4030_0x4034</span><span class="p">[</span><span class="mh">0x4</span><span class="p">];</span>				<span class="cm">/* 0x4030 */</span>
	<span class="n">u32</span> <span class="n">spu_npc_RW</span><span class="p">;</span>						<span class="cm">/* 0x4034 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x4038_0x14000</span><span class="p">[</span><span class="mh">0x14000</span> <span class="o">-</span> <span class="mh">0x4038</span><span class="p">];</span>		<span class="cm">/* 0x4038 */</span>

	<span class="cm">/* Signal Notification Area */</span>
	<span class="n">u8</span>  <span class="n">pad_0x14000_0x1400c</span><span class="p">[</span><span class="mh">0xc</span><span class="p">];</span>				<span class="cm">/* 0x14000 */</span>
	<span class="n">u32</span> <span class="n">signal_notify1</span><span class="p">;</span>					<span class="cm">/* 0x1400c */</span>
	<span class="n">u8</span>  <span class="n">pad_0x14010_0x1c00c</span><span class="p">[</span><span class="mh">0x7ffc</span><span class="p">];</span>			<span class="cm">/* 0x14010 */</span>
	<span class="n">u32</span> <span class="n">signal_notify2</span><span class="p">;</span>					<span class="cm">/* 0x1c00c */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mh">0x20000</span><span class="p">)));</span>

<span class="cm">/* SPU Privilege 2 State Area */</span>
<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="p">{</span>
	<span class="cm">/* MFC Registers */</span>
	<span class="n">u8</span>  <span class="n">pad_0x0000_0x1100</span><span class="p">[</span><span class="mh">0x1100</span> <span class="o">-</span> <span class="mh">0x0000</span><span class="p">];</span> 		<span class="cm">/* 0x0000 */</span>

	<span class="cm">/* SLB Management Registers */</span>
	<span class="n">u8</span>  <span class="n">pad_0x1100_0x1108</span><span class="p">[</span><span class="mh">0x8</span><span class="p">];</span>				<span class="cm">/* 0x1100 */</span>
	<span class="n">u64</span> <span class="n">slb_index_W</span><span class="p">;</span>					<span class="cm">/* 0x1108 */</span>
<span class="cp">#define SLB_INDEX_MASK				0x7L</span>
	<span class="n">u64</span> <span class="n">slb_esid_RW</span><span class="p">;</span>					<span class="cm">/* 0x1110 */</span>
	<span class="n">u64</span> <span class="n">slb_vsid_RW</span><span class="p">;</span>					<span class="cm">/* 0x1118 */</span>
<span class="cp">#define SLB_VSID_SUPERVISOR_STATE	(0x1ull &lt;&lt; 11)</span>
<span class="cp">#define SLB_VSID_SUPERVISOR_STATE_MASK	(0x1ull &lt;&lt; 11)</span>
<span class="cp">#define SLB_VSID_PROBLEM_STATE		(0x1ull &lt;&lt; 10)</span>
<span class="cp">#define SLB_VSID_PROBLEM_STATE_MASK	(0x1ull &lt;&lt; 10)</span>
<span class="cp">#define SLB_VSID_EXECUTE_SEGMENT	(0x1ull &lt;&lt; 9)</span>
<span class="cp">#define SLB_VSID_NO_EXECUTE_SEGMENT	(0x1ull &lt;&lt; 9)</span>
<span class="cp">#define SLB_VSID_EXECUTE_SEGMENT_MASK	(0x1ull &lt;&lt; 9)</span>
<span class="cp">#define SLB_VSID_4K_PAGE		(0x0 &lt;&lt; 8)</span>
<span class="cp">#define SLB_VSID_LARGE_PAGE		(0x1ull &lt;&lt; 8)</span>
<span class="cp">#define SLB_VSID_PAGE_SIZE_MASK		(0x1ull &lt;&lt; 8)</span>
<span class="cp">#define SLB_VSID_CLASS_MASK		(0x1ull &lt;&lt; 7)</span>
<span class="cp">#define SLB_VSID_VIRTUAL_PAGE_SIZE_MASK	(0x1ull &lt;&lt; 6)</span>
	<span class="n">u64</span> <span class="n">slb_invalidate_entry_W</span><span class="p">;</span>				<span class="cm">/* 0x1120 */</span>
	<span class="n">u64</span> <span class="n">slb_invalidate_all_W</span><span class="p">;</span>				<span class="cm">/* 0x1128 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x1130_0x2000</span><span class="p">[</span><span class="mh">0x2000</span> <span class="o">-</span> <span class="mh">0x1130</span><span class="p">];</span> 		<span class="cm">/* 0x1130 */</span>

	<span class="cm">/* Context Save / Restore Area */</span>
	<span class="k">struct</span> <span class="n">mfc_cq_sr</span> <span class="n">spuq</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>				<span class="cm">/* 0x2000 */</span>
	<span class="k">struct</span> <span class="n">mfc_cq_sr</span> <span class="n">puq</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>				<span class="cm">/* 0x2200 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x2300_0x3000</span><span class="p">[</span><span class="mh">0x3000</span> <span class="o">-</span> <span class="mh">0x2300</span><span class="p">];</span> 		<span class="cm">/* 0x2300 */</span>

	<span class="cm">/* MFC Control */</span>
	<span class="n">u64</span> <span class="n">mfc_control_RW</span><span class="p">;</span>					<span class="cm">/* 0x3000 */</span>
<span class="cp">#define MFC_CNTL_RESUME_DMA_QUEUE		(0ull &lt;&lt; 0)</span>
<span class="cp">#define MFC_CNTL_SUSPEND_DMA_QUEUE		(1ull &lt;&lt; 0)</span>
<span class="cp">#define MFC_CNTL_SUSPEND_DMA_QUEUE_MASK		(1ull &lt;&lt; 0)</span>
<span class="cp">#define MFC_CNTL_SUSPEND_MASK			(1ull &lt;&lt; 4)</span>
<span class="cp">#define MFC_CNTL_NORMAL_DMA_QUEUE_OPERATION	(0ull &lt;&lt; 8)</span>
<span class="cp">#define MFC_CNTL_SUSPEND_IN_PROGRESS		(1ull &lt;&lt; 8)</span>
<span class="cp">#define MFC_CNTL_SUSPEND_COMPLETE		(3ull &lt;&lt; 8)</span>
<span class="cp">#define MFC_CNTL_SUSPEND_DMA_STATUS_MASK	(3ull &lt;&lt; 8)</span>
<span class="cp">#define MFC_CNTL_DMA_QUEUES_EMPTY		(1ull &lt;&lt; 14)</span>
<span class="cp">#define MFC_CNTL_DMA_QUEUES_EMPTY_MASK		(1ull &lt;&lt; 14)</span>
<span class="cp">#define MFC_CNTL_PURGE_DMA_REQUEST		(1ull &lt;&lt; 15)</span>
<span class="cp">#define MFC_CNTL_PURGE_DMA_IN_PROGRESS		(1ull &lt;&lt; 24)</span>
<span class="cp">#define MFC_CNTL_PURGE_DMA_COMPLETE		(3ull &lt;&lt; 24)</span>
<span class="cp">#define MFC_CNTL_PURGE_DMA_STATUS_MASK		(3ull &lt;&lt; 24)</span>
<span class="cp">#define MFC_CNTL_RESTART_DMA_COMMAND		(1ull &lt;&lt; 32)</span>
<span class="cp">#define MFC_CNTL_DMA_COMMAND_REISSUE_PENDING	(1ull &lt;&lt; 32)</span>
<span class="cp">#define MFC_CNTL_DMA_COMMAND_REISSUE_STATUS_MASK (1ull &lt;&lt; 32)</span>
<span class="cp">#define MFC_CNTL_MFC_PRIVILEGE_STATE		(2ull &lt;&lt; 33)</span>
<span class="cp">#define MFC_CNTL_MFC_PROBLEM_STATE		(3ull &lt;&lt; 33)</span>
<span class="cp">#define MFC_CNTL_MFC_KEY_PROTECTION_STATE_MASK	(3ull &lt;&lt; 33)</span>
<span class="cp">#define MFC_CNTL_DECREMENTER_HALTED		(1ull &lt;&lt; 35)</span>
<span class="cp">#define MFC_CNTL_DECREMENTER_RUNNING		(1ull &lt;&lt; 40)</span>
<span class="cp">#define MFC_CNTL_DECREMENTER_STATUS_MASK	(1ull &lt;&lt; 40)</span>
	<span class="n">u8</span>  <span class="n">pad_0x3008_0x4000</span><span class="p">[</span><span class="mh">0x4000</span> <span class="o">-</span> <span class="mh">0x3008</span><span class="p">];</span> 		<span class="cm">/* 0x3008 */</span>

	<span class="cm">/* Interrupt Mailbox */</span>
	<span class="n">u64</span> <span class="n">puint_mb_R</span><span class="p">;</span>						<span class="cm">/* 0x4000 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x4008_0x4040</span><span class="p">[</span><span class="mh">0x4040</span> <span class="o">-</span> <span class="mh">0x4008</span><span class="p">];</span> 		<span class="cm">/* 0x4008 */</span>

	<span class="cm">/* SPU Control */</span>
	<span class="n">u64</span> <span class="n">spu_privcntl_RW</span><span class="p">;</span>					<span class="cm">/* 0x4040 */</span>
<span class="cp">#define SPU_PRIVCNTL_MODE_NORMAL		(0x0ull &lt;&lt; 0)</span>
<span class="cp">#define SPU_PRIVCNTL_MODE_SINGLE_STEP		(0x1ull &lt;&lt; 0)</span>
<span class="cp">#define SPU_PRIVCNTL_MODE_MASK			(0x1ull &lt;&lt; 0)</span>
<span class="cp">#define SPU_PRIVCNTL_NO_ATTENTION_EVENT		(0x0ull &lt;&lt; 1)</span>
<span class="cp">#define SPU_PRIVCNTL_ATTENTION_EVENT		(0x1ull &lt;&lt; 1)</span>
<span class="cp">#define SPU_PRIVCNTL_ATTENTION_EVENT_MASK	(0x1ull &lt;&lt; 1)</span>
<span class="cp">#define SPU_PRIVCNT_LOAD_REQUEST_NORMAL		(0x0ull &lt;&lt; 2)</span>
<span class="cp">#define SPU_PRIVCNT_LOAD_REQUEST_ENABLE_MASK	(0x1ull &lt;&lt; 2)</span>
	<span class="n">u8</span>  <span class="n">pad_0x4048_0x4058</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>				<span class="cm">/* 0x4048 */</span>
	<span class="n">u64</span> <span class="n">spu_lslr_RW</span><span class="p">;</span>					<span class="cm">/* 0x4058 */</span>
	<span class="n">u64</span> <span class="n">spu_chnlcntptr_RW</span><span class="p">;</span>					<span class="cm">/* 0x4060 */</span>
	<span class="n">u64</span> <span class="n">spu_chnlcnt_RW</span><span class="p">;</span>					<span class="cm">/* 0x4068 */</span>
	<span class="n">u64</span> <span class="n">spu_chnldata_RW</span><span class="p">;</span>					<span class="cm">/* 0x4070 */</span>
	<span class="n">u64</span> <span class="n">spu_cfg_RW</span><span class="p">;</span>						<span class="cm">/* 0x4078 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x4080_0x5000</span><span class="p">[</span><span class="mh">0x5000</span> <span class="o">-</span> <span class="mh">0x4080</span><span class="p">];</span> 		<span class="cm">/* 0x4080 */</span>

	<span class="cm">/* PV2_ImplRegs: Implementation-specific privileged-state 2 regs */</span>
	<span class="n">u64</span> <span class="n">spu_pm_trace_tag_status_RW</span><span class="p">;</span>				<span class="cm">/* 0x5000 */</span>
	<span class="n">u64</span> <span class="n">spu_tag_status_query_RW</span><span class="p">;</span>				<span class="cm">/* 0x5008 */</span>
<span class="cp">#define TAG_STATUS_QUERY_CONDITION_BITS (0x3ull &lt;&lt; 32)</span>
<span class="cp">#define TAG_STATUS_QUERY_MASK_BITS (0xffffffffull)</span>
	<span class="n">u64</span> <span class="n">spu_cmd_buf1_RW</span><span class="p">;</span>					<span class="cm">/* 0x5010 */</span>
<span class="cp">#define SPU_COMMAND_BUFFER_1_LSA_BITS (0x7ffffull &lt;&lt; 32)</span>
<span class="cp">#define SPU_COMMAND_BUFFER_1_EAH_BITS (0xffffffffull)</span>
	<span class="n">u64</span> <span class="n">spu_cmd_buf2_RW</span><span class="p">;</span>					<span class="cm">/* 0x5018 */</span>
<span class="cp">#define SPU_COMMAND_BUFFER_2_EAL_BITS ((0xffffffffull) &lt;&lt; 32)</span>
<span class="cp">#define SPU_COMMAND_BUFFER_2_TS_BITS (0xffffull &lt;&lt; 16)</span>
<span class="cp">#define SPU_COMMAND_BUFFER_2_TAG_BITS (0x3full)</span>
	<span class="n">u64</span> <span class="n">spu_atomic_status_RW</span><span class="p">;</span>				<span class="cm">/* 0x5020 */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mh">0x20000</span><span class="p">)));</span>

<span class="cm">/* SPU Privilege 1 State Area */</span>
<span class="k">struct</span> <span class="n">spu_priv1</span> <span class="p">{</span>
	<span class="cm">/* Control and Configuration Area */</span>
	<span class="n">u64</span> <span class="n">mfc_sr1_RW</span><span class="p">;</span>						<span class="cm">/* 0x000 */</span>
<span class="cp">#define MFC_STATE1_LOCAL_STORAGE_DECODE_MASK	0x01ull</span>
<span class="cp">#define MFC_STATE1_BUS_TLBIE_MASK		0x02ull</span>
<span class="cp">#define MFC_STATE1_REAL_MODE_OFFSET_ENABLE_MASK	0x04ull</span>
<span class="cp">#define MFC_STATE1_PROBLEM_STATE_MASK		0x08ull</span>
<span class="cp">#define MFC_STATE1_RELOCATE_MASK		0x10ull</span>
<span class="cp">#define MFC_STATE1_MASTER_RUN_CONTROL_MASK	0x20ull</span>
<span class="cp">#define MFC_STATE1_TABLE_SEARCH_MASK		0x40ull</span>
	<span class="n">u64</span> <span class="n">mfc_lpid_RW</span><span class="p">;</span>					<span class="cm">/* 0x008 */</span>
	<span class="n">u64</span> <span class="n">spu_idr_RW</span><span class="p">;</span>						<span class="cm">/* 0x010 */</span>
	<span class="n">u64</span> <span class="n">mfc_vr_RO</span><span class="p">;</span>						<span class="cm">/* 0x018 */</span>
<span class="cp">#define MFC_VERSION_BITS		(0xffff &lt;&lt; 16)</span>
<span class="cp">#define MFC_REVISION_BITS		(0xffff)</span>
<span class="cp">#define MFC_GET_VERSION_BITS(vr)	(((vr) &amp; MFC_VERSION_BITS) &gt;&gt; 16)</span>
<span class="cp">#define MFC_GET_REVISION_BITS(vr)	((vr) &amp; MFC_REVISION_BITS)</span>
	<span class="n">u64</span> <span class="n">spu_vr_RO</span><span class="p">;</span>						<span class="cm">/* 0x020 */</span>
<span class="cp">#define SPU_VERSION_BITS		(0xffff &lt;&lt; 16)</span>
<span class="cp">#define SPU_REVISION_BITS		(0xffff)</span>
<span class="cp">#define SPU_GET_VERSION_BITS(vr)	(vr &amp; SPU_VERSION_BITS) &gt;&gt; 16</span>
<span class="cp">#define SPU_GET_REVISION_BITS(vr)	(vr &amp; SPU_REVISION_BITS)</span>
	<span class="n">u8</span>  <span class="n">pad_0x28_0x100</span><span class="p">[</span><span class="mh">0x100</span> <span class="o">-</span> <span class="mh">0x28</span><span class="p">];</span>			<span class="cm">/* 0x28 */</span>

	<span class="cm">/* Interrupt Area */</span>
	<span class="n">u64</span> <span class="n">int_mask_RW</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>					<span class="cm">/* 0x100 */</span>
<span class="cp">#define CLASS0_ENABLE_DMA_ALIGNMENT_INTR		0x1L</span>
<span class="cp">#define CLASS0_ENABLE_INVALID_DMA_COMMAND_INTR		0x2L</span>
<span class="cp">#define CLASS0_ENABLE_SPU_ERROR_INTR			0x4L</span>
<span class="cp">#define CLASS0_ENABLE_MFC_FIR_INTR			0x8L</span>
<span class="cp">#define CLASS1_ENABLE_SEGMENT_FAULT_INTR		0x1L</span>
<span class="cp">#define CLASS1_ENABLE_STORAGE_FAULT_INTR		0x2L</span>
<span class="cp">#define CLASS1_ENABLE_LS_COMPARE_SUSPEND_ON_GET_INTR	0x4L</span>
<span class="cp">#define CLASS1_ENABLE_LS_COMPARE_SUSPEND_ON_PUT_INTR	0x8L</span>
<span class="cp">#define CLASS2_ENABLE_MAILBOX_INTR			0x1L</span>
<span class="cp">#define CLASS2_ENABLE_SPU_STOP_INTR			0x2L</span>
<span class="cp">#define CLASS2_ENABLE_SPU_HALT_INTR			0x4L</span>
<span class="cp">#define CLASS2_ENABLE_SPU_DMA_TAG_GROUP_COMPLETE_INTR	0x8L</span>
<span class="cp">#define CLASS2_ENABLE_MAILBOX_THRESHOLD_INTR		0x10L</span>
	<span class="n">u8</span>  <span class="n">pad_0x118_0x140</span><span class="p">[</span><span class="mh">0x28</span><span class="p">];</span>				<span class="cm">/* 0x118 */</span>
	<span class="n">u64</span> <span class="n">int_stat_RW</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>					<span class="cm">/* 0x140 */</span>
<span class="cp">#define CLASS0_DMA_ALIGNMENT_INTR			0x1L</span>
<span class="cp">#define CLASS0_INVALID_DMA_COMMAND_INTR			0x2L</span>
<span class="cp">#define CLASS0_SPU_ERROR_INTR				0x4L</span>
<span class="cp">#define CLASS0_INTR_MASK				0x7L</span>
<span class="cp">#define CLASS1_SEGMENT_FAULT_INTR			0x1L</span>
<span class="cp">#define CLASS1_STORAGE_FAULT_INTR			0x2L</span>
<span class="cp">#define CLASS1_LS_COMPARE_SUSPEND_ON_GET_INTR		0x4L</span>
<span class="cp">#define CLASS1_LS_COMPARE_SUSPEND_ON_PUT_INTR		0x8L</span>
<span class="cp">#define CLASS1_INTR_MASK				0xfL</span>
<span class="cp">#define CLASS2_MAILBOX_INTR				0x1L</span>
<span class="cp">#define CLASS2_SPU_STOP_INTR				0x2L</span>
<span class="cp">#define CLASS2_SPU_HALT_INTR				0x4L</span>
<span class="cp">#define CLASS2_SPU_DMA_TAG_GROUP_COMPLETE_INTR		0x8L</span>
<span class="cp">#define CLASS2_MAILBOX_THRESHOLD_INTR			0x10L</span>
<span class="cp">#define CLASS2_INTR_MASK				0x1fL</span>
	<span class="n">u8</span>  <span class="n">pad_0x158_0x180</span><span class="p">[</span><span class="mh">0x28</span><span class="p">];</span>				<span class="cm">/* 0x158 */</span>
	<span class="n">u64</span> <span class="n">int_route_RW</span><span class="p">;</span>					<span class="cm">/* 0x180 */</span>

	<span class="cm">/* Interrupt Routing */</span>
	<span class="n">u8</span>  <span class="n">pad_0x188_0x200</span><span class="p">[</span><span class="mh">0x200</span> <span class="o">-</span> <span class="mh">0x188</span><span class="p">];</span>			<span class="cm">/* 0x188 */</span>

	<span class="cm">/* Atomic Unit Control Area */</span>
	<span class="n">u64</span> <span class="n">mfc_atomic_flush_RW</span><span class="p">;</span>				<span class="cm">/* 0x200 */</span>
<span class="cp">#define mfc_atomic_flush_enable			0x1L</span>
	<span class="n">u8</span>  <span class="n">pad_0x208_0x280</span><span class="p">[</span><span class="mh">0x78</span><span class="p">];</span>				<span class="cm">/* 0x208 */</span>
	<span class="n">u64</span> <span class="n">resource_allocation_groupID_RW</span><span class="p">;</span>			<span class="cm">/* 0x280 */</span>
	<span class="n">u64</span> <span class="n">resource_allocation_enable_RW</span><span class="p">;</span> 			<span class="cm">/* 0x288 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x290_0x3c8</span><span class="p">[</span><span class="mh">0x3c8</span> <span class="o">-</span> <span class="mh">0x290</span><span class="p">];</span>			<span class="cm">/* 0x290 */</span>

	<span class="cm">/* SPU_Cache_ImplRegs: Implementation-dependent cache registers */</span>

	<span class="n">u64</span> <span class="n">smf_sbi_signal_sel</span><span class="p">;</span>					<span class="cm">/* 0x3c8 */</span>
<span class="cp">#define smf_sbi_mask_lsb	56</span>
<span class="cp">#define smf_sbi_shift		(63 - smf_sbi_mask_lsb)</span>
<span class="cp">#define smf_sbi_mask		(0x301LL &lt;&lt; smf_sbi_shift)</span>
<span class="cp">#define smf_sbi_bus0_bits	(0x001LL &lt;&lt; smf_sbi_shift)</span>
<span class="cp">#define smf_sbi_bus2_bits	(0x100LL &lt;&lt; smf_sbi_shift)</span>
<span class="cp">#define smf_sbi2_bus0_bits	(0x201LL &lt;&lt; smf_sbi_shift)</span>
<span class="cp">#define smf_sbi2_bus2_bits	(0x300LL &lt;&lt; smf_sbi_shift)</span>
	<span class="n">u64</span> <span class="n">smf_ato_signal_sel</span><span class="p">;</span>					<span class="cm">/* 0x3d0 */</span>
<span class="cp">#define smf_ato_mask_lsb	35</span>
<span class="cp">#define smf_ato_shift		(63 - smf_ato_mask_lsb)</span>
<span class="cp">#define smf_ato_mask		(0x3LL &lt;&lt; smf_ato_shift)</span>
<span class="cp">#define smf_ato_bus0_bits	(0x2LL &lt;&lt; smf_ato_shift)</span>
<span class="cp">#define smf_ato_bus2_bits	(0x1LL &lt;&lt; smf_ato_shift)</span>
	<span class="n">u8</span>  <span class="n">pad_0x3d8_0x400</span><span class="p">[</span><span class="mh">0x400</span> <span class="o">-</span> <span class="mh">0x3d8</span><span class="p">];</span>			<span class="cm">/* 0x3d8 */</span>

	<span class="cm">/* TLB Management Registers */</span>
	<span class="n">u64</span> <span class="n">mfc_sdr_RW</span><span class="p">;</span>						<span class="cm">/* 0x400 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x408_0x500</span><span class="p">[</span><span class="mh">0xf8</span><span class="p">];</span>				<span class="cm">/* 0x408 */</span>
	<span class="n">u64</span> <span class="n">tlb_index_hint_RO</span><span class="p">;</span>					<span class="cm">/* 0x500 */</span>
	<span class="n">u64</span> <span class="n">tlb_index_W</span><span class="p">;</span>					<span class="cm">/* 0x508 */</span>
	<span class="n">u64</span> <span class="n">tlb_vpn_RW</span><span class="p">;</span>						<span class="cm">/* 0x510 */</span>
	<span class="n">u64</span> <span class="n">tlb_rpn_RW</span><span class="p">;</span>						<span class="cm">/* 0x518 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x520_0x540</span><span class="p">[</span><span class="mh">0x20</span><span class="p">];</span>				<span class="cm">/* 0x520 */</span>
	<span class="n">u64</span> <span class="n">tlb_invalidate_entry_W</span><span class="p">;</span>				<span class="cm">/* 0x540 */</span>
	<span class="n">u64</span> <span class="n">tlb_invalidate_all_W</span><span class="p">;</span>				<span class="cm">/* 0x548 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x550_0x580</span><span class="p">[</span><span class="mh">0x580</span> <span class="o">-</span> <span class="mh">0x550</span><span class="p">];</span>			<span class="cm">/* 0x550 */</span>

	<span class="cm">/* SPU_MMU_ImplRegs: Implementation-dependent MMU registers */</span>
	<span class="n">u64</span> <span class="n">smm_hid</span><span class="p">;</span>						<span class="cm">/* 0x580 */</span>
<span class="cp">#define PAGE_SIZE_MASK		0xf000000000000000ull</span>
<span class="cp">#define PAGE_SIZE_16MB_64KB	0x2000000000000000ull</span>
	<span class="n">u8</span>  <span class="n">pad_0x588_0x600</span><span class="p">[</span><span class="mh">0x600</span> <span class="o">-</span> <span class="mh">0x588</span><span class="p">];</span>			<span class="cm">/* 0x588 */</span>

	<span class="cm">/* MFC Status/Control Area */</span>
	<span class="n">u64</span> <span class="n">mfc_accr_RW</span><span class="p">;</span>					<span class="cm">/* 0x600 */</span>
<span class="cp">#define MFC_ACCR_EA_ACCESS_GET		(1 &lt;&lt; 0)</span>
<span class="cp">#define MFC_ACCR_EA_ACCESS_PUT		(1 &lt;&lt; 1)</span>
<span class="cp">#define MFC_ACCR_LS_ACCESS_GET		(1 &lt;&lt; 3)</span>
<span class="cp">#define MFC_ACCR_LS_ACCESS_PUT		(1 &lt;&lt; 4)</span>
	<span class="n">u8</span>  <span class="n">pad_0x608_0x610</span><span class="p">[</span><span class="mh">0x8</span><span class="p">];</span>				<span class="cm">/* 0x608 */</span>
	<span class="n">u64</span> <span class="n">mfc_dsisr_RW</span><span class="p">;</span>					<span class="cm">/* 0x610 */</span>
<span class="cp">#define MFC_DSISR_PTE_NOT_FOUND		(1 &lt;&lt; 30)</span>
<span class="cp">#define MFC_DSISR_ACCESS_DENIED		(1 &lt;&lt; 27)</span>
<span class="cp">#define MFC_DSISR_ATOMIC		(1 &lt;&lt; 26)</span>
<span class="cp">#define MFC_DSISR_ACCESS_PUT		(1 &lt;&lt; 25)</span>
<span class="cp">#define MFC_DSISR_ADDR_MATCH		(1 &lt;&lt; 22)</span>
<span class="cp">#define MFC_DSISR_LS			(1 &lt;&lt; 17)</span>
<span class="cp">#define MFC_DSISR_L			(1 &lt;&lt; 16)</span>
<span class="cp">#define MFC_DSISR_ADDRESS_OVERFLOW	(1 &lt;&lt; 0)</span>
	<span class="n">u8</span>  <span class="n">pad_0x618_0x620</span><span class="p">[</span><span class="mh">0x8</span><span class="p">];</span>				<span class="cm">/* 0x618 */</span>
	<span class="n">u64</span> <span class="n">mfc_dar_RW</span><span class="p">;</span>						<span class="cm">/* 0x620 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x628_0x700</span><span class="p">[</span><span class="mh">0x700</span> <span class="o">-</span> <span class="mh">0x628</span><span class="p">];</span>			<span class="cm">/* 0x628 */</span>

	<span class="cm">/* Replacement Management Table (RMT) Area */</span>
	<span class="n">u64</span> <span class="n">rmt_index_RW</span><span class="p">;</span>					<span class="cm">/* 0x700 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x708_0x710</span><span class="p">[</span><span class="mh">0x8</span><span class="p">];</span>				<span class="cm">/* 0x708 */</span>
	<span class="n">u64</span> <span class="n">rmt_data1_RW</span><span class="p">;</span>					<span class="cm">/* 0x710 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x718_0x800</span><span class="p">[</span><span class="mh">0x800</span> <span class="o">-</span> <span class="mh">0x718</span><span class="p">];</span>			<span class="cm">/* 0x718 */</span>

	<span class="cm">/* Control/Configuration Registers */</span>
	<span class="n">u64</span> <span class="n">mfc_dsir_R</span><span class="p">;</span>						<span class="cm">/* 0x800 */</span>
<span class="cp">#define MFC_DSIR_Q			(1 &lt;&lt; 31)</span>
<span class="cp">#define MFC_DSIR_SPU_QUEUE		MFC_DSIR_Q</span>
	<span class="n">u64</span> <span class="n">mfc_lsacr_RW</span><span class="p">;</span>					<span class="cm">/* 0x808 */</span>
<span class="cp">#define MFC_LSACR_COMPARE_MASK		((~0ull) &lt;&lt; 32)</span>
<span class="cp">#define MFC_LSACR_COMPARE_ADDR		((~0ull) &gt;&gt; 32)</span>
	<span class="n">u64</span> <span class="n">mfc_lscrr_R</span><span class="p">;</span>					<span class="cm">/* 0x810 */</span>
<span class="cp">#define MFC_LSCRR_Q			(1 &lt;&lt; 31)</span>
<span class="cp">#define MFC_LSCRR_SPU_QUEUE		MFC_LSCRR_Q</span>
<span class="cp">#define MFC_LSCRR_QI_SHIFT		32</span>
<span class="cp">#define MFC_LSCRR_QI_MASK		((~0ull) &lt;&lt; MFC_LSCRR_QI_SHIFT)</span>
	<span class="n">u8</span>  <span class="n">pad_0x818_0x820</span><span class="p">[</span><span class="mh">0x8</span><span class="p">];</span>				<span class="cm">/* 0x818 */</span>
	<span class="n">u64</span> <span class="n">mfc_tclass_id_RW</span><span class="p">;</span>					<span class="cm">/* 0x820 */</span>
<span class="cp">#define MFC_TCLASS_ID_ENABLE		(1L &lt;&lt; 0L)</span>
<span class="cp">#define MFC_TCLASS_SLOT2_ENABLE		(1L &lt;&lt; 5L)</span>
<span class="cp">#define MFC_TCLASS_SLOT1_ENABLE		(1L &lt;&lt; 6L)</span>
<span class="cp">#define MFC_TCLASS_SLOT0_ENABLE		(1L &lt;&lt; 7L)</span>
<span class="cp">#define MFC_TCLASS_QUOTA_2_SHIFT	8L</span>
<span class="cp">#define MFC_TCLASS_QUOTA_1_SHIFT	16L</span>
<span class="cp">#define MFC_TCLASS_QUOTA_0_SHIFT	24L</span>
<span class="cp">#define MFC_TCLASS_QUOTA_2_MASK		(0x1FL &lt;&lt; MFC_TCLASS_QUOTA_2_SHIFT)</span>
<span class="cp">#define MFC_TCLASS_QUOTA_1_MASK		(0x1FL &lt;&lt; MFC_TCLASS_QUOTA_1_SHIFT)</span>
<span class="cp">#define MFC_TCLASS_QUOTA_0_MASK		(0x1FL &lt;&lt; MFC_TCLASS_QUOTA_0_SHIFT)</span>
	<span class="n">u8</span>  <span class="n">pad_0x828_0x900</span><span class="p">[</span><span class="mh">0x900</span> <span class="o">-</span> <span class="mh">0x828</span><span class="p">];</span>			<span class="cm">/* 0x828 */</span>

	<span class="cm">/* Real Mode Support Registers */</span>
	<span class="n">u64</span> <span class="n">mfc_rm_boundary</span><span class="p">;</span>					<span class="cm">/* 0x900 */</span>
	<span class="n">u8</span>  <span class="n">pad_0x908_0x938</span><span class="p">[</span><span class="mh">0x30</span><span class="p">];</span>				<span class="cm">/* 0x908 */</span>
	<span class="n">u64</span> <span class="n">smf_dma_signal_sel</span><span class="p">;</span>					<span class="cm">/* 0x938 */</span>
<span class="cp">#define mfc_dma1_mask_lsb	41</span>
<span class="cp">#define mfc_dma1_shift		(63 - mfc_dma1_mask_lsb)</span>
<span class="cp">#define mfc_dma1_mask		(0x3LL &lt;&lt; mfc_dma1_shift)</span>
<span class="cp">#define mfc_dma1_bits		(0x1LL &lt;&lt; mfc_dma1_shift)</span>
<span class="cp">#define mfc_dma2_mask_lsb	43</span>
<span class="cp">#define mfc_dma2_shift		(63 - mfc_dma2_mask_lsb)</span>
<span class="cp">#define mfc_dma2_mask		(0x3LL &lt;&lt; mfc_dma2_shift)</span>
<span class="cp">#define mfc_dma2_bits		(0x1LL &lt;&lt; mfc_dma2_shift)</span>
	<span class="n">u8</span>  <span class="n">pad_0x940_0xa38</span><span class="p">[</span><span class="mh">0xf8</span><span class="p">];</span>				<span class="cm">/* 0x940 */</span>
	<span class="n">u64</span> <span class="n">smm_signal_sel</span><span class="p">;</span>					<span class="cm">/* 0xa38 */</span>
<span class="cp">#define smm_sig_mask_lsb	12</span>
<span class="cp">#define smm_sig_shift		(63 - smm_sig_mask_lsb)</span>
<span class="cp">#define smm_sig_mask		(0x3LL &lt;&lt; smm_sig_shift)</span>
<span class="cp">#define smm_sig_bus0_bits	(0x2LL &lt;&lt; smm_sig_shift)</span>
<span class="cp">#define smm_sig_bus2_bits	(0x1LL &lt;&lt; smm_sig_shift)</span>
	<span class="n">u8</span>  <span class="n">pad_0xa40_0xc00</span><span class="p">[</span><span class="mh">0xc00</span> <span class="o">-</span> <span class="mh">0xa40</span><span class="p">];</span>			<span class="cm">/* 0xa40 */</span>

	<span class="cm">/* DMA Command Error Area */</span>
	<span class="n">u64</span> <span class="n">mfc_cer_R</span><span class="p">;</span>						<span class="cm">/* 0xc00 */</span>
<span class="cp">#define MFC_CER_Q		(1 &lt;&lt; 31)</span>
<span class="cp">#define MFC_CER_SPU_QUEUE	MFC_CER_Q</span>
	<span class="n">u8</span>  <span class="n">pad_0xc08_0x1000</span><span class="p">[</span><span class="mh">0x1000</span> <span class="o">-</span> <span class="mh">0xc08</span><span class="p">];</span>			<span class="cm">/* 0xc08 */</span>

	<span class="cm">/* PV1_ImplRegs: Implementation-dependent privileged-state 1 regs */</span>
	<span class="cm">/* DMA Command Error Area */</span>
	<span class="n">u64</span> <span class="n">spu_ecc_cntl_RW</span><span class="p">;</span>					<span class="cm">/* 0x1000 */</span>
<span class="cp">#define SPU_ECC_CNTL_E			(1ull &lt;&lt; 0ull)</span>
<span class="cp">#define SPU_ECC_CNTL_ENABLE		SPU_ECC_CNTL_E</span>
<span class="cp">#define SPU_ECC_CNTL_DISABLE		(~SPU_ECC_CNTL_E &amp; 1L)</span>
<span class="cp">#define SPU_ECC_CNTL_S			(1ull &lt;&lt; 1ull)</span>
<span class="cp">#define SPU_ECC_STOP_AFTER_ERROR	SPU_ECC_CNTL_S</span>
<span class="cp">#define SPU_ECC_CONTINUE_AFTER_ERROR	(~SPU_ECC_CNTL_S &amp; 2L)</span>
<span class="cp">#define SPU_ECC_CNTL_B			(1ull &lt;&lt; 2ull)</span>
<span class="cp">#define SPU_ECC_BACKGROUND_ENABLE	SPU_ECC_CNTL_B</span>
<span class="cp">#define SPU_ECC_BACKGROUND_DISABLE	(~SPU_ECC_CNTL_B &amp; 4L)</span>
<span class="cp">#define SPU_ECC_CNTL_I_SHIFT		3ull</span>
<span class="cp">#define SPU_ECC_CNTL_I_MASK		(3ull &lt;&lt; SPU_ECC_CNTL_I_SHIFT)</span>
<span class="cp">#define SPU_ECC_WRITE_ALWAYS		(~SPU_ECC_CNTL_I &amp; 12L)</span>
<span class="cp">#define SPU_ECC_WRITE_CORRECTABLE	(1ull &lt;&lt; SPU_ECC_CNTL_I_SHIFT)</span>
<span class="cp">#define SPU_ECC_WRITE_UNCORRECTABLE	(3ull &lt;&lt; SPU_ECC_CNTL_I_SHIFT)</span>
<span class="cp">#define SPU_ECC_CNTL_D			(1ull &lt;&lt; 5ull)</span>
<span class="cp">#define SPU_ECC_DETECTION_ENABLE	SPU_ECC_CNTL_D</span>
<span class="cp">#define SPU_ECC_DETECTION_DISABLE	(~SPU_ECC_CNTL_D &amp; 32L)</span>
	<span class="n">u64</span> <span class="n">spu_ecc_stat_RW</span><span class="p">;</span>					<span class="cm">/* 0x1008 */</span>
<span class="cp">#define SPU_ECC_CORRECTED_ERROR		(1ull &lt;&lt; 0ul)</span>
<span class="cp">#define SPU_ECC_UNCORRECTED_ERROR	(1ull &lt;&lt; 1ul)</span>
<span class="cp">#define SPU_ECC_SCRUB_COMPLETE		(1ull &lt;&lt; 2ul)</span>
<span class="cp">#define SPU_ECC_SCRUB_IN_PROGRESS	(1ull &lt;&lt; 3ul)</span>
<span class="cp">#define SPU_ECC_INSTRUCTION_ERROR	(1ull &lt;&lt; 4ul)</span>
<span class="cp">#define SPU_ECC_DATA_ERROR		(1ull &lt;&lt; 5ul)</span>
<span class="cp">#define SPU_ECC_DMA_ERROR		(1ull &lt;&lt; 6ul)</span>
<span class="cp">#define SPU_ECC_STATUS_CNT_MASK		(256ull &lt;&lt; 8)</span>
	<span class="n">u64</span> <span class="n">spu_ecc_addr_RW</span><span class="p">;</span>					<span class="cm">/* 0x1010 */</span>
	<span class="n">u64</span> <span class="n">spu_err_mask_RW</span><span class="p">;</span>					<span class="cm">/* 0x1018 */</span>
<span class="cp">#define SPU_ERR_ILLEGAL_INSTR		(1ull &lt;&lt; 0ul)</span>
<span class="cp">#define SPU_ERR_ILLEGAL_CHANNEL		(1ull &lt;&lt; 1ul)</span>
	<span class="n">u8</span>  <span class="n">pad_0x1020_0x1028</span><span class="p">[</span><span class="mh">0x1028</span> <span class="o">-</span> <span class="mh">0x1020</span><span class="p">];</span>			<span class="cm">/* 0x1020 */</span>

	<span class="cm">/* SPU Debug-Trace Bus (DTB) Selection Registers */</span>
	<span class="n">u64</span> <span class="n">spu_trig0_sel</span><span class="p">;</span>					<span class="cm">/* 0x1028 */</span>
	<span class="n">u64</span> <span class="n">spu_trig1_sel</span><span class="p">;</span>					<span class="cm">/* 0x1030 */</span>
	<span class="n">u64</span> <span class="n">spu_trig2_sel</span><span class="p">;</span>					<span class="cm">/* 0x1038 */</span>
	<span class="n">u64</span> <span class="n">spu_trig3_sel</span><span class="p">;</span>					<span class="cm">/* 0x1040 */</span>
	<span class="n">u64</span> <span class="n">spu_trace_sel</span><span class="p">;</span>					<span class="cm">/* 0x1048 */</span>
<span class="cp">#define spu_trace_sel_mask		0x1f1fLL</span>
<span class="cp">#define spu_trace_sel_bus0_bits		0x1000LL</span>
<span class="cp">#define spu_trace_sel_bus2_bits		0x0010LL</span>
	<span class="n">u64</span> <span class="n">spu_event0_sel</span><span class="p">;</span>					<span class="cm">/* 0x1050 */</span>
	<span class="n">u64</span> <span class="n">spu_event1_sel</span><span class="p">;</span>					<span class="cm">/* 0x1058 */</span>
	<span class="n">u64</span> <span class="n">spu_event2_sel</span><span class="p">;</span>					<span class="cm">/* 0x1060 */</span>
	<span class="n">u64</span> <span class="n">spu_event3_sel</span><span class="p">;</span>					<span class="cm">/* 0x1068 */</span>
	<span class="n">u64</span> <span class="n">spu_trace_cntl</span><span class="p">;</span>					<span class="cm">/* 0x1070 */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mh">0x2000</span><span class="p">)));</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
