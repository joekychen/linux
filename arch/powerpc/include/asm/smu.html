<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › smu.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>smu.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _SMU_H</span>
<span class="cp">#define _SMU_H</span>

<span class="cm">/*</span>
<span class="cm"> * Definitions for talking to the SMU chip in newer G5 PowerMacs</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Known SMU commands</span>
<span class="cm"> *</span>
<span class="cm"> * Most of what is below comes from looking at the Open Firmware driver,</span>
<span class="cm"> * though this is still incomplete and could use better documentation here</span>
<span class="cm"> * or there...</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * Partition info commands</span>
<span class="cm"> *</span>
<span class="cm"> * These commands are used to retrieve the sdb-partition-XX datas from</span>
<span class="cm"> * the SMU. The length is always 2. First byte is the subcommand code</span>
<span class="cm"> * and second byte is the partition ID.</span>
<span class="cm"> *</span>
<span class="cm"> * The reply is 6 bytes:</span>
<span class="cm"> *</span>
<span class="cm"> *  - 0..1 : partition address</span>
<span class="cm"> *  - 2    : a byte containing the partition ID</span>
<span class="cm"> *  - 3    : length (maybe other bits are rest of header ?)</span>
<span class="cm"> *</span>
<span class="cm"> * The data must then be obtained with calls to another command:</span>
<span class="cm"> * SMU_CMD_MISC_ee_GET_DATABLOCK_REC (described below).</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_CMD_PARTITION_COMMAND		0x3e</span>
<span class="cp">#define   SMU_CMD_PARTITION_LATEST		0x01</span>
<span class="cp">#define   SMU_CMD_PARTITION_BASE		0x02</span>
<span class="cp">#define   SMU_CMD_PARTITION_UPDATE		0x03</span>


<span class="cm">/*</span>
<span class="cm"> * Fan control</span>
<span class="cm"> *</span>
<span class="cm"> * This is a &quot;mux&quot; for fan control commands. The command seem to</span>
<span class="cm"> * act differently based on the number of arguments. With 1 byte</span>
<span class="cm"> * of argument, this seem to be queries for fans status, setpoint,</span>
<span class="cm"> * etc..., while with 0xe arguments, we will set the fans speeds.</span>
<span class="cm"> *</span>
<span class="cm"> * Queries (1 byte arg):</span>
<span class="cm"> * ---------------------</span>
<span class="cm"> *</span>
<span class="cm"> * arg=0x01: read RPM fans status</span>
<span class="cm"> * arg=0x02: read RPM fans setpoint</span>
<span class="cm"> * arg=0x11: read PWM fans status</span>
<span class="cm"> * arg=0x12: read PWM fans setpoint</span>
<span class="cm"> *</span>
<span class="cm"> * the &quot;status&quot; queries return the current speed while the &quot;setpoint&quot; ones</span>
<span class="cm"> * return the programmed/target speed. It _seems_ that the result is a bit</span>
<span class="cm"> * mask in the first byte of active/available fans, followed by 6 words (16</span>
<span class="cm"> * bits) containing the requested speed.</span>
<span class="cm"> *</span>
<span class="cm"> * Setpoint (14 bytes arg):</span>
<span class="cm"> * ------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * first arg byte is 0 for RPM fans and 0x10 for PWM. Second arg byte is the</span>
<span class="cm"> * mask of fans affected by the command. Followed by 6 words containing the</span>
<span class="cm"> * setpoint value for selected fans in the mask (or 0 if mask value is 0)</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_CMD_FAN_COMMAND			0x4a</span>


<span class="cm">/*</span>
<span class="cm"> * Battery access</span>
<span class="cm"> *</span>
<span class="cm"> * Same command number as the PMU, could it be same syntax ?</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_CMD_BATTERY_COMMAND			0x6f</span>
<span class="cp">#define   SMU_CMD_GET_BATTERY_INFO		0x00</span>

<span class="cm">/*</span>
<span class="cm"> * Real time clock control</span>
<span class="cm"> *</span>
<span class="cm"> * This is a &quot;mux&quot;, first data byte contains the &quot;sub&quot; command.</span>
<span class="cm"> * The &quot;RTC&quot; part of the SMU controls the date, time, powerup</span>
<span class="cm"> * timer, but also a PRAM</span>
<span class="cm"> *</span>
<span class="cm"> * Dates are in BCD format on 7 bytes:</span>
<span class="cm"> * [sec] [min] [hour] [weekday] [month day] [month] [year]</span>
<span class="cm"> * with month being 1 based and year minus 100</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_CMD_RTC_COMMAND			0x8e</span>
<span class="cp">#define   SMU_CMD_RTC_SET_PWRUP_TIMER		0x00 </span><span class="cm">/* i: 7 bytes date */</span><span class="cp"></span>
<span class="cp">#define   SMU_CMD_RTC_GET_PWRUP_TIMER		0x01 </span><span class="cm">/* o: 7 bytes date */</span><span class="cp"></span>
<span class="cp">#define   SMU_CMD_RTC_STOP_PWRUP_TIMER		0x02</span>
<span class="cp">#define   SMU_CMD_RTC_SET_PRAM_BYTE_ACC		0x20 </span><span class="cm">/* i: 1 byte (address?) */</span><span class="cp"></span>
<span class="cp">#define   SMU_CMD_RTC_SET_PRAM_AUTOINC		0x21 </span><span class="cm">/* i: 1 byte (data?) */</span><span class="cp"></span>
<span class="cp">#define   SMU_CMD_RTC_SET_PRAM_LO_BYTES 	0x22 </span><span class="cm">/* i: 10 bytes */</span><span class="cp"></span>
<span class="cp">#define   SMU_CMD_RTC_SET_PRAM_HI_BYTES 	0x23 </span><span class="cm">/* i: 10 bytes */</span><span class="cp"></span>
<span class="cp">#define   SMU_CMD_RTC_GET_PRAM_BYTE		0x28 </span><span class="cm">/* i: 1 bytes (address?) */</span><span class="cp"></span>
<span class="cp">#define   SMU_CMD_RTC_GET_PRAM_LO_BYTES 	0x29 </span><span class="cm">/* o: 10 bytes */</span><span class="cp"></span>
<span class="cp">#define   SMU_CMD_RTC_GET_PRAM_HI_BYTES 	0x2a </span><span class="cm">/* o: 10 bytes */</span><span class="cp"></span>
<span class="cp">#define	  SMU_CMD_RTC_SET_DATETIME		0x80 </span><span class="cm">/* i: 7 bytes date */</span><span class="cp"></span>
<span class="cp">#define   SMU_CMD_RTC_GET_DATETIME		0x81 </span><span class="cm">/* o: 7 bytes date */</span><span class="cp"></span>

 <span class="cm">/*</span>
<span class="cm">  * i2c commands</span>
<span class="cm">  *</span>
<span class="cm">  * To issue an i2c command, first is to send a parameter block to the</span>
<span class="cm">  * the SMU. This is a command of type 0x9a with 9 bytes of header</span>
<span class="cm">  * eventually followed by data for a write:</span>
<span class="cm">  *</span>
<span class="cm">  * 0: bus number (from device-tree usually, SMU has lots of busses !)</span>
<span class="cm">  * 1: transfer type/format (see below)</span>
<span class="cm">  * 2: device address. For combined and combined4 type transfers, this</span>
<span class="cm">  *    is the &quot;write&quot; version of the address (bit 0x01 cleared)</span>
<span class="cm">  * 3: subaddress length (0..3)</span>
<span class="cm">  * 4: subaddress byte 0 (or only byte for subaddress length 1)</span>
<span class="cm">  * 5: subaddress byte 1</span>
<span class="cm">  * 6: subaddress byte 2</span>
<span class="cm">  * 7: combined address (device address for combined mode data phase)</span>
<span class="cm">  * 8: data length</span>
<span class="cm">  *</span>
<span class="cm">  * The transfer types are the same good old Apple ones it seems,</span>
<span class="cm">  * that is:</span>
<span class="cm">  *   - 0x00: Simple transfer</span>
<span class="cm">  *   - 0x01: Subaddress transfer (addr write + data tx, no restart)</span>
<span class="cm">  *   - 0x02: Combined transfer (addr write + restart + data tx)</span>
<span class="cm">  *</span>
<span class="cm">  * This is then followed by actual data for a write.</span>
<span class="cm">  *</span>
<span class="cm">  * At this point, the OF driver seems to have a limitation on transfer</span>
<span class="cm">  * sizes of 0xd bytes on reads and 0x5 bytes on writes. I do not know</span>
<span class="cm">  * wether this is just an OF limit due to some temporary buffer size</span>
<span class="cm">  * or if this is an SMU imposed limit. This driver has the same limitation</span>
<span class="cm">  * for now as I use a 0x10 bytes temporary buffer as well</span>
<span class="cm">  *</span>
<span class="cm">  * Once that is completed, a response is expected from the SMU. This is</span>
<span class="cm">  * obtained via a command of type 0x9a with a length of 1 byte containing</span>
<span class="cm">  * 0 as the data byte. OF also fills the rest of the data buffer with 0xff&#39;s</span>
<span class="cm">  * though I can&#39;t tell yet if this is actually necessary. Once this command</span>
<span class="cm">  * is complete, at this point, all I can tell is what OF does. OF tests</span>
<span class="cm">  * byte 0 of the reply:</span>
<span class="cm">  *   - on read, 0xfe or 0xfc : bus is busy, wait (see below) or nak ?</span>
<span class="cm">  *   - on read, 0x00 or 0x01 : reply is in buffer (after the byte 0)</span>
<span class="cm">  *   - on write, &lt; 0 -&gt; failure (immediate exit)</span>
<span class="cm">  *   - else, OF just exists (without error, weird)</span>
<span class="cm">  *</span>
<span class="cm">  * So on read, there is this wait-for-busy thing when getting a 0xfc or</span>
<span class="cm">  * 0xfe result. OF does a loop of up to 64 retries, waiting 20ms and</span>
<span class="cm">  * doing the above again until either the retries expire or the result</span>
<span class="cm">  * is no longer 0xfe or 0xfc</span>
<span class="cm">  *</span>
<span class="cm">  * The Darwin I2C driver is less subtle though. On any non-success status</span>
<span class="cm">  * from the response command, it waits 5ms and tries again up to 20 times,</span>
<span class="cm">  * it doesn&#39;t differenciate between fatal errors or &quot;busy&quot; status.</span>
<span class="cm">  *</span>
<span class="cm">  * This driver provides an asynchronous paramblock based i2c command</span>
<span class="cm">  * interface to be used either directly by low level code or by a higher</span>
<span class="cm">  * level driver interfacing to the linux i2c layer. The current</span>
<span class="cm">  * implementation of this relies on working timers &amp; timer interrupts</span>
<span class="cm">  * though, so be careful of calling context for now. This may be &quot;fixed&quot;</span>
<span class="cm">  * in the future by adding a polling facility.</span>
<span class="cm">  */</span>
<span class="cp">#define SMU_CMD_I2C_COMMAND			0x9a</span>
          <span class="cm">/* transfer types */</span>
<span class="cp">#define   SMU_I2C_TRANSFER_SIMPLE	0x00</span>
<span class="cp">#define   SMU_I2C_TRANSFER_STDSUB	0x01</span>
<span class="cp">#define   SMU_I2C_TRANSFER_COMBINED	0x02</span>

<span class="cm">/*</span>
<span class="cm"> * Power supply control</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;sub&quot; command is an ASCII string in the data, the</span>
<span class="cm"> * data length is that of the string.</span>
<span class="cm"> *</span>
<span class="cm"> * The VSLEW command can be used to get or set the voltage slewing.</span>
<span class="cm"> *  - length 5 (only &quot;VSLEW&quot;) : it returns &quot;DONE&quot; and 3 bytes of</span>
<span class="cm"> *    reply at data offset 6, 7 and 8.</span>
<span class="cm"> *  - length 8 (&quot;VSLEWxyz&quot;) has 3 additional bytes appended, and is</span>
<span class="cm"> *    used to set the voltage slewing point. The SMU replies with &quot;DONE&quot;</span>
<span class="cm"> * I yet have to figure out their exact meaning of those 3 bytes in</span>
<span class="cm"> * both cases. They seem to be:</span>
<span class="cm"> *  x = processor mask</span>
<span class="cm"> *  y = op. point index</span>
<span class="cm"> *  z = processor freq. step index</span>
<span class="cm"> * I haven&#39;t yet decyphered result codes</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_CMD_POWER_COMMAND			0xaa</span>
<span class="cp">#define   SMU_CMD_POWER_RESTART		       	&quot;RESTART&quot;</span>
<span class="cp">#define   SMU_CMD_POWER_SHUTDOWN		&quot;SHUTDOWN&quot;</span>
<span class="cp">#define   SMU_CMD_POWER_VOLTAGE_SLEW		&quot;VSLEW&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Read ADC sensors</span>
<span class="cm"> *</span>
<span class="cm"> * This command takes one byte of parameter: the sensor ID (or &quot;reg&quot;</span>
<span class="cm"> * value in the device-tree) and returns a 16 bits value</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_CMD_READ_ADC			0xd8</span>


<span class="cm">/* Misc commands</span>
<span class="cm"> *</span>
<span class="cm"> * This command seem to be a grab bag of various things</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *   1: subcommand</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_CMD_MISC_df_COMMAND			0xdf</span>

<span class="cm">/*</span>
<span class="cm"> * Sets &quot;system ready&quot; status</span>
<span class="cm"> *</span>
<span class="cm"> * I did not yet understand how it exactly works or what it does.</span>
<span class="cm"> *</span>
<span class="cm"> * Guessing from OF code, 0x02 activates the display backlight. Apple uses/used</span>
<span class="cm"> * the same codebase for all OF versions. On PowerBooks, this command would</span>
<span class="cm"> * enable the backlight. For the G5s, it only activates the front LED. However,</span>
<span class="cm"> * don&#39;t take this for granted.</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *   2: status [0x00, 0x01 or 0x02]</span>
<span class="cm"> */</span>
<span class="cp">#define   SMU_CMD_MISC_df_SET_DISPLAY_LIT	0x02</span>

<span class="cm">/*</span>
<span class="cm"> * Sets mode of power switch.</span>
<span class="cm"> *</span>
<span class="cm"> * What this actually does is not yet known. Maybe it enables some interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *   2: enable power switch? [0x00 or 0x01]</span>
<span class="cm"> *   3 (optional): enable nmi? [0x00 or 0x01]</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   If parameter 2 is 0x00 and parameter 3 is not specified, returns wether</span>
<span class="cm"> *   NMI is enabled. Otherwise unknown.</span>
<span class="cm"> */</span>
<span class="cp">#define   SMU_CMD_MISC_df_NMI_OPTION		0x04</span>

<span class="cm">/* Sets LED dimm offset.</span>
<span class="cm"> *</span>
<span class="cm"> * The front LED dimms itself during sleep. Its brightness (or, well, the PWM</span>
<span class="cm"> * frequency) depends on current time. Therefore, the SMU needs to know the</span>
<span class="cm"> * timezone.</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *   2-8: unknown (BCD coding)</span>
<span class="cm"> */</span>
<span class="cp">#define   SMU_CMD_MISC_df_DIMM_OFFSET		0x99</span>


<span class="cm">/*</span>
<span class="cm"> * Version info commands</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *   1 (optional): Specifies version part to retrieve</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Version value</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_CMD_VERSION_COMMAND			0xea</span>
<span class="cp">#define   SMU_VERSION_RUNNING			0x00</span>
<span class="cp">#define   SMU_VERSION_BASE			0x01</span>
<span class="cp">#define   SMU_VERSION_UPDATE			0x02</span>


<span class="cm">/*</span>
<span class="cm"> * Switches</span>
<span class="cm"> *</span>
<span class="cm"> * These are switches whose status seems to be known to the SMU.</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *   none</span>
<span class="cm"> *</span>
<span class="cm"> * Result:</span>
<span class="cm"> *   Switch bits (ORed, see below)</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_CMD_SWITCHES			0xdc</span>

<span class="cm">/* Switches bits */</span>
<span class="cp">#define SMU_SWITCH_CASE_CLOSED			0x01</span>
<span class="cp">#define SMU_SWITCH_AC_POWER			0x04</span>
<span class="cp">#define SMU_SWITCH_POWER_SWITCH			0x08</span>


<span class="cm">/*</span>
<span class="cm"> * Misc commands</span>
<span class="cm"> *</span>
<span class="cm"> * This command seem to be a grab bag of various things</span>
<span class="cm"> *</span>
<span class="cm"> * SMU_CMD_MISC_ee_GET_DATABLOCK_REC is used, among others, to</span>
<span class="cm"> * transfer blocks of data from the SMU. So far, I&#39;ve decrypted it&#39;s</span>
<span class="cm"> * usage to retrieve partition data. In order to do that, you have to</span>
<span class="cm"> * break your transfer in &quot;chunks&quot; since that command cannot transfer</span>
<span class="cm"> * more than a chunk at a time. The chunk size used by OF is 0xe bytes,</span>
<span class="cm"> * but it seems that the darwin driver will let you do 0x1e bytes if</span>
<span class="cm"> * your &quot;PMU&quot; version is &gt;= 0x30. You can get the &quot;PMU&quot; version apparently</span>
<span class="cm"> * either in the last 16 bits of property &quot;smu-version-pmu&quot; or as the 16</span>
<span class="cm"> * bytes at offset 1 of &quot;smu-version-info&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * For each chunk, the command takes 7 bytes of arguments:</span>
<span class="cm"> *  byte 0: subcommand code (0x02)</span>
<span class="cm"> *  byte 1: 0x04 (always, I don&#39;t know what it means, maybe the address</span>
<span class="cm"> *                space to use or some other nicety. It&#39;s hard coded in OF)</span>
<span class="cm"> *  byte 2..5: SMU address of the chunk (big endian 32 bits)</span>
<span class="cm"> *  byte 6: size to transfer (up to max chunk size)</span>
<span class="cm"> *</span>
<span class="cm"> * The data is returned directly</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_CMD_MISC_ee_COMMAND			0xee</span>
<span class="cp">#define   SMU_CMD_MISC_ee_GET_DATABLOCK_REC	0x02</span>

<span class="cm">/* Retrieves currently used watts.</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *   1: 0x03 (Meaning unknown)</span>
<span class="cm"> */</span>
<span class="cp">#define   SMU_CMD_MISC_ee_GET_WATTS		0x03</span>

<span class="cp">#define   SMU_CMD_MISC_ee_LEDS_CTRL		0x04 </span><span class="cm">/* i: 00 (00,01) [00] */</span><span class="cp"></span>
<span class="cp">#define   SMU_CMD_MISC_ee_GET_DATA		0x05 </span><span class="cm">/* i: 00 , o: ?? */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * Power related commands</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *   1: subcommand</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_CMD_POWER_EVENTS_COMMAND		0x8f</span>

<span class="cm">/* SMU_POWER_EVENTS subcommands */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SMU_PWR_GET_POWERUP_EVENTS</span>      <span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="n">SMU_PWR_SET_POWERUP_EVENTS</span>      <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">SMU_PWR_CLR_POWERUP_EVENTS</span>      <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">SMU_PWR_GET_WAKEUP_EVENTS</span>       <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
	<span class="n">SMU_PWR_SET_WAKEUP_EVENTS</span>       <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">SMU_PWR_CLR_WAKEUP_EVENTS</span>       <span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get last shutdown cause</span>
<span class="cm">	 *</span>
<span class="cm">	 * Returns:</span>
<span class="cm">	 *   1 byte (signed char): Last shutdown cause. Exact meaning unknown.</span>
<span class="cm">	 */</span>
	<span class="n">SMU_PWR_LAST_SHUTDOWN_CAUSE</span>	<span class="o">=</span> <span class="mh">0x07</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sets or gets server ID. Meaning or use is unknown.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Parameters:</span>
<span class="cm">	 *   2 (optional): Set server ID (1 byte)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Returns:</span>
<span class="cm">	 *   1 byte (server ID?)</span>
<span class="cm">	 */</span>
	<span class="n">SMU_PWR_SERVER_ID</span>		<span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Power events wakeup bits */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SMU_PWR_WAKEUP_KEY</span>              <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span> <span class="cm">/* Wake on key press */</span>
	<span class="n">SMU_PWR_WAKEUP_AC_INSERT</span>        <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span> <span class="cm">/* Wake on AC adapter plug */</span>
	<span class="n">SMU_PWR_WAKEUP_AC_CHANGE</span>        <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">SMU_PWR_WAKEUP_LID_OPEN</span>         <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
	<span class="n">SMU_PWR_WAKEUP_RING</span>             <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * - Kernel side interface -</span>
<span class="cm"> */</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/*</span>
<span class="cm"> * Asynchronous SMU commands</span>
<span class="cm"> *</span>
<span class="cm"> * Fill up this structure and submit it via smu_queue_command(),</span>
<span class="cm"> * and get notified by the optional done() callback, or because</span>
<span class="cm"> * status becomes != 1</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">smu_cmd</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">smu_cmd</span>
<span class="p">{</span>
	<span class="cm">/* public */</span>
	<span class="n">u8</span>			<span class="n">cmd</span><span class="p">;</span>		<span class="cm">/* command */</span>
	<span class="kt">int</span>			<span class="n">data_len</span><span class="p">;</span>	<span class="cm">/* data len */</span>
	<span class="kt">int</span>			<span class="n">reply_len</span><span class="p">;</span>	<span class="cm">/* reply len */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">data_buf</span><span class="p">;</span>	<span class="cm">/* data buffer */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">reply_buf</span><span class="p">;</span>	<span class="cm">/* reply buffer */</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>		<span class="cm">/* command status */</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">smu_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">misc</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">misc</span><span class="p">;</span>

	<span class="cm">/* private */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Queues an SMU command, all fields have to be initialized</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">smu_queue_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Simple command wrapper. This structure embeds a small buffer</span>
<span class="cm"> * to ease sending simple SMU commands from the stack</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">smu_simple_cmd</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smu_cmd</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">u8</span>	       	<span class="n">buffer</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Queues a simple command. All fields will be initialized by that</span>
<span class="cm"> * function</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">smu_queue_simple</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_simple_cmd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_len</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">smu_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">misc</span><span class="p">),</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">misc</span><span class="p">,</span>
			    <span class="p">...);</span>

<span class="cm">/*</span>
<span class="cm"> * Completion helper. Pass it to smu_queue_simple or as &#39;done&#39;</span>
<span class="cm"> * member to smu_queue_cmd, it will call complete() on the struct</span>
<span class="cm"> * completion passed in the &quot;misc&quot; argument</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">smu_done_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">misc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Synchronous helpers. Will spin-wait for completion of a command</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">smu_spinwait_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">smu_spinwait_simple</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_simple_cmd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smu_spinwait_cmd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Poll routine to call if blocked with irqs off</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">smu_poll</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Init routine, presence check....</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">smu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">smu_present</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">platform_device</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">smu_get_ofdev</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Common command wrappers</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">smu_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">smu_restart</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">rtc_time</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">smu_get_rtc_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span> <span class="o">*</span><span class="n">time</span><span class="p">,</span> <span class="kt">int</span> <span class="n">spinwait</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">smu_set_rtc_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span> <span class="o">*</span><span class="n">time</span><span class="p">,</span> <span class="kt">int</span> <span class="n">spinwait</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * SMU command buffer absolute address, exported by pmac_setup,</span>
<span class="cm"> * this is allocated very early during boot.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">smu_cmdbuf_abs</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * Kenrel asynchronous i2c interface</span>
<span class="cm"> */</span>

<span class="cp">#define SMU_I2C_READ_MAX	0x1d</span>
<span class="cp">#define SMU_I2C_WRITE_MAX	0x15</span>

<span class="cm">/* SMU i2c header, exactly matches i2c header on wire */</span>
<span class="k">struct</span> <span class="n">smu_i2c_param</span>
<span class="p">{</span>
	<span class="n">u8</span>	<span class="n">bus</span><span class="p">;</span>		<span class="cm">/* SMU bus ID (from device tree) */</span>
	<span class="n">u8</span>	<span class="n">type</span><span class="p">;</span>		<span class="cm">/* i2c transfer type */</span>
	<span class="n">u8</span>	<span class="n">devaddr</span><span class="p">;</span>	<span class="cm">/* device address (includes direction) */</span>
	<span class="n">u8</span>	<span class="n">sublen</span><span class="p">;</span>		<span class="cm">/* subaddress length */</span>
	<span class="n">u8</span>	<span class="n">subaddr</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* subaddress */</span>
	<span class="n">u8</span>	<span class="n">caddr</span><span class="p">;</span>		<span class="cm">/* combined address, filled by SMU driver */</span>
	<span class="n">u8</span>	<span class="n">datalen</span><span class="p">;</span>	<span class="cm">/* length of transfer */</span>
	<span class="n">u8</span>	<span class="n">data</span><span class="p">[</span><span class="n">SMU_I2C_READ_MAX</span><span class="p">];</span>	<span class="cm">/* data */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">smu_i2c_cmd</span>
<span class="p">{</span>
	<span class="cm">/* public */</span>
	<span class="k">struct</span> <span class="n">smu_i2c_param</span>	<span class="n">info</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">smu_i2c_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">misc</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">misc</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span> <span class="cm">/* 1 = pending, 0 = ok, &lt;0 = fail */</span>

	<span class="cm">/* private */</span>
	<span class="k">struct</span> <span class="n">smu_cmd</span>		<span class="n">scmd</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">read</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">stage</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retries</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">pdata</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Call this to queue an i2c command to the SMU. You must fill info,</span>
<span class="cm"> * including info.data for a write, done and misc.</span>
<span class="cm"> * For now, no polling interface is provided so you have to use completion</span>
<span class="cm"> * callback.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">smu_queue_i2c</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_i2c_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>


<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * - SMU &quot;sdb&quot; partitions informations -</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * Partition header format</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">smu_sdbp_header</span> <span class="p">{</span>
	<span class="n">__u8</span>	<span class="n">id</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">len</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">version</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>


 <span class="cm">/*</span>
<span class="cm"> * demangle 16 and 32 bits integer in some SMU partitions</span>
<span class="cm"> * (currently, afaik, this concerns only the FVT partition</span>
<span class="cm"> * (0x12)</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_U16_MIX(x)	le16_to_cpu(x)</span>
<span class="cp">#define SMU_U32_MIX(x)  ((((x) &amp; 0xff00ff00u) &gt;&gt; 8)|(((x) &amp; 0x00ff00ffu) &lt;&lt; 8))</span>


<span class="cm">/* This is the definition of the SMU sdb-partition-0x12 table (called</span>
<span class="cm"> * CPU F/V/T operating points in Darwin). The definition for all those</span>
<span class="cm"> * SMU tables should be moved to some separate file</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_SDB_FVT_ID			0x12</span>

<span class="k">struct</span> <span class="n">smu_sdbp_fvt</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">sysclk</span><span class="p">;</span>			<span class="cm">/* Base SysClk frequency in Hz for</span>
<span class="cm">					 * this operating point. Value need to</span>
<span class="cm">					 * be unmixed with SMU_U32_MIX()</span>
<span class="cm">					 */</span>
	<span class="n">__u8</span>	<span class="n">pad</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">maxtemp</span><span class="p">;</span>		<span class="cm">/* Max temp. supported by this</span>
<span class="cm">					 * operating point</span>
<span class="cm">					 */</span>

	<span class="n">__u16</span>	<span class="n">volts</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* CPU core voltage for the 3</span>
<span class="cm">					 * PowerTune modes, a mode with</span>
<span class="cm">					 * 0V = not supported. Value need</span>
<span class="cm">					 * to be unmixed with SMU_U16_MIX()</span>
<span class="cm">					 */</span>
<span class="p">};</span>

<span class="cm">/* This partition contains voltage &amp; current sensor calibration</span>
<span class="cm"> * informations</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_SDB_CPUVCP_ID		0x21</span>

<span class="k">struct</span> <span class="n">smu_sdbp_cpuvcp</span> <span class="p">{</span>
	<span class="n">__u16</span>	<span class="n">volt_scale</span><span class="p">;</span>		<span class="cm">/* u4.12 fixed point */</span>
	<span class="n">__s16</span>	<span class="n">volt_offset</span><span class="p">;</span>		<span class="cm">/* s4.12 fixed point */</span>
	<span class="n">__u16</span>	<span class="n">curr_scale</span><span class="p">;</span>		<span class="cm">/* u4.12 fixed point */</span>
	<span class="n">__s16</span>	<span class="n">curr_offset</span><span class="p">;</span>		<span class="cm">/* s4.12 fixed point */</span>
	<span class="n">__s32</span>	<span class="n">power_quads</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* s4.28 fixed point */</span>
<span class="p">};</span>

<span class="cm">/* This partition contains CPU thermal diode calibration</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_SDB_CPUDIODE_ID		0x18</span>

<span class="k">struct</span> <span class="n">smu_sdbp_cpudiode</span> <span class="p">{</span>
	<span class="n">__u16</span>	<span class="n">m_value</span><span class="p">;</span>		<span class="cm">/* u1.15 fixed point */</span>
	<span class="n">__s16</span>	<span class="n">b_value</span><span class="p">;</span>		<span class="cm">/* s10.6 fixed point */</span>

<span class="p">};</span>

<span class="cm">/* This partition contains Slots power calibration</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_SDB_SLOTSPOW_ID		0x78</span>

<span class="k">struct</span> <span class="n">smu_sdbp_slotspow</span> <span class="p">{</span>
	<span class="n">__u16</span>	<span class="n">pow_scale</span><span class="p">;</span>		<span class="cm">/* u4.12 fixed point */</span>
	<span class="n">__s16</span>	<span class="n">pow_offset</span><span class="p">;</span>		<span class="cm">/* s4.12 fixed point */</span>
<span class="p">};</span>

<span class="cm">/* This partition contains machine specific version information about</span>
<span class="cm"> * the sensor/control layout</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_SDB_SENSORTREE_ID		0x25</span>

<span class="k">struct</span> <span class="n">smu_sdbp_sensortree</span> <span class="p">{</span>
	<span class="n">__u8</span>	<span class="n">model_id</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">unknown</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* This partition contains CPU thermal control PID informations. So far</span>
<span class="cm"> * only single CPU machines have been seen with an SMU, so we assume this</span>
<span class="cm"> * carries only informations for those</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_SDB_CPUPIDDATA_ID		0x17</span>

<span class="k">struct</span> <span class="n">smu_sdbp_cpupiddata</span> <span class="p">{</span>
	<span class="n">__u8</span>	<span class="n">unknown1</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">target_temp_delta</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">unknown2</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">history_len</span><span class="p">;</span>
	<span class="n">__s16</span>	<span class="n">power_adj</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">max_power</span><span class="p">;</span>
	<span class="n">__s32</span>	<span class="n">gp</span><span class="p">,</span><span class="n">gr</span><span class="p">,</span><span class="n">gd</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* Other partitions without known structures */</span>
<span class="cp">#define SMU_SDB_DEBUG_SWITCHES_ID	0x05</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cm">/*</span>
<span class="cm"> * This returns the pointer to an SMU &quot;sdb&quot; partition data or NULL</span>
<span class="cm"> * if not found. The data format is described below</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">smu_sdbp_header</span> <span class="o">*</span><span class="n">smu_get_sdb_partition</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">);</span>

<span class="cm">/* Get &quot;sdb&quot; partition data from an SMU satellite */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">smu_sdbp_header</span> <span class="o">*</span><span class="n">smu_sat_get_sdb_partition</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sat_id</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">);</span>


<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * - Userland interface -</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * A given instance of the device can be configured for 2 different</span>
<span class="cm"> * things at the moment:</span>
<span class="cm"> *</span>
<span class="cm"> *  - sending SMU commands (default at open() time)</span>
<span class="cm"> *  - receiving SMU events (not yet implemented)</span>
<span class="cm"> *</span>
<span class="cm"> * Commands are written with write() of a command block. They can be</span>
<span class="cm"> * &quot;driver&quot; commands (for example to switch to event reception mode)</span>
<span class="cm"> * or real SMU commands. They are made of a header followed by command</span>
<span class="cm"> * data if any.</span>
<span class="cm"> *</span>
<span class="cm"> * For SMU commands (not for driver commands), you can then read() back</span>
<span class="cm"> * a reply. The reader will be blocked or not depending on how the device</span>
<span class="cm"> * file is opened. poll() isn&#39;t implemented yet. The reply will consist</span>
<span class="cm"> * of a header as well, followed by the reply data if any. You should</span>
<span class="cm"> * always provide a buffer large enough for the maximum reply data, I</span>
<span class="cm"> * recommand one page.</span>
<span class="cm"> *</span>
<span class="cm"> * It is illegal to send SMU commands through a file descriptor configured</span>
<span class="cm"> * for events reception</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">smu_user_cmd_hdr</span>
<span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">cmdtype</span><span class="p">;</span>
<span class="cp">#define SMU_CMDTYPE_SMU			0	</span><span class="cm">/* SMU command */</span><span class="cp"></span>
<span class="cp">#define SMU_CMDTYPE_WANTS_EVENTS	1	</span><span class="cm">/* switch fd to events mode */</span><span class="cp"></span>
<span class="cp">#define SMU_CMDTYPE_GET_PARTITION	2	</span><span class="cm">/* retrieve an sdb partition */</span><span class="cp"></span>

	<span class="n">__u8</span>		<span class="n">cmd</span><span class="p">;</span>			<span class="cm">/* SMU command byte */</span>
	<span class="n">__u8</span>		<span class="n">pad</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>			<span class="cm">/* padding */</span>
	<span class="n">__u32</span>		<span class="n">data_len</span><span class="p">;</span>		<span class="cm">/* Length of data following */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">smu_user_reply_hdr</span>
<span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">status</span><span class="p">;</span>			<span class="cm">/* Command status */</span>
	<span class="n">__u32</span>		<span class="n">reply_len</span><span class="p">;</span>		<span class="cm">/* Length of data follwing */</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/*  _SMU_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
