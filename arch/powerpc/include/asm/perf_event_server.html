<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › perf_event_server.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>perf_event_server.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Performance event support - PowerPC classic/server specific definitions.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2008-2009 Paul Mackerras, IBM Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;asm/hw_irq.h&gt;</span>

<span class="cp">#define MAX_HWEVENTS		8</span>
<span class="cp">#define MAX_EVENT_ALTERNATIVES	8</span>
<span class="cp">#define MAX_LIMITED_HWCOUNTERS	2</span>

<span class="cm">/*</span>
<span class="cm"> * This struct provides the constants and functions needed to</span>
<span class="cm"> * describe the PMU on a particular POWER-family CPU.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">power_pmu</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">n_counter</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">max_alternatives</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">add_fields</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">test_adder</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">compute_mmcr</span><span class="p">)(</span><span class="n">u64</span> <span class="n">events</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n_ev</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hwc</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmcr</span><span class="p">[]);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">get_constraint</span><span class="p">)(</span><span class="n">u64</span> <span class="n">event_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">mskp</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">valp</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">get_alternatives</span><span class="p">)(</span><span class="n">u64</span> <span class="n">event_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">alt</span><span class="p">[]);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">disable_pmc</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pmc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmcr</span><span class="p">[]);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">limited_pmc_event</span><span class="p">)(</span><span class="n">u64</span> <span class="n">event_id</span><span class="p">);</span>
	<span class="n">u32</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">n_generic</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="o">*</span><span class="n">generic_events</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">cache_events</span><span class="p">)[</span><span class="n">PERF_COUNT_HW_CACHE_MAX</span><span class="p">]</span>
			       <span class="p">[</span><span class="n">PERF_COUNT_HW_CACHE_OP_MAX</span><span class="p">]</span>
			       <span class="p">[</span><span class="n">PERF_COUNT_HW_CACHE_RESULT_MAX</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Values for power_pmu.flags</span>
<span class="cm"> */</span>
<span class="cp">#define PPMU_LIMITED_PMC5_6	1	</span><span class="cm">/* PMC5/6 have limited function */</span><span class="cp"></span>
<span class="cp">#define PPMU_ALT_SIPR		2	</span><span class="cm">/* uses alternate posn for SIPR/HV */</span><span class="cp"></span>
<span class="cp">#define PPMU_NO_SIPR		4	</span><span class="cm">/* no SIPR/HV in MMCRA at all */</span><span class="cp"></span>
<span class="cp">#define PPMU_NO_CONT_SAMPLING	8	</span><span class="cm">/* no continuous sampling */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Values for flags to get_alternatives()</span>
<span class="cm"> */</span>
<span class="cp">#define PPMU_LIMITED_PMC_OK	1	</span><span class="cm">/* can put this on a limited PMC */</span><span class="cp"></span>
<span class="cp">#define PPMU_LIMITED_PMC_REQD	2	</span><span class="cm">/* have to put this on a limited PMC */</span><span class="cp"></span>
<span class="cp">#define PPMU_ONLY_COUNT_RUN	4	</span><span class="cm">/* only counting in run state */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">register_power_pmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">power_pmu</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">pt_regs</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">perf_misc_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">perf_instruction_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Only override the default definitions in include/linux/perf_event.h</span>
<span class="cm"> * if we have hardware PMU support.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PPC_PERF_CTRS</span>
<span class="cp">#define perf_misc_flags(regs)	perf_misc_flags(regs)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The power_pmu.get_constraint function returns a 32/64-bit value and</span>
<span class="cm"> * a 32/64-bit mask that express the constraints between this event_id and</span>
<span class="cm"> * other events.</span>
<span class="cm"> *</span>
<span class="cm"> * The value and mask are divided up into (non-overlapping) bitfields</span>
<span class="cm"> * of three different types:</span>
<span class="cm"> *</span>
<span class="cm"> * Select field: this expresses the constraint that some set of bits</span>
<span class="cm"> * in MMCR* needs to be set to a specific value for this event_id.  For a</span>
<span class="cm"> * select field, the mask contains 1s in every bit of the field, and</span>
<span class="cm"> * the value contains a unique value for each possible setting of the</span>
<span class="cm"> * MMCR* bits.  The constraint checking code will ensure that two events</span>
<span class="cm"> * that set the same field in their masks have the same value in their</span>
<span class="cm"> * value dwords.</span>
<span class="cm"> *</span>
<span class="cm"> * Add field: this expresses the constraint that there can be at most</span>
<span class="cm"> * N events in a particular class.  A field of k bits can be used for</span>
<span class="cm"> * N &lt;= 2^(k-1) - 1.  The mask has the most significant bit of the field</span>
<span class="cm"> * set (and the other bits 0), and the value has only the least significant</span>
<span class="cm"> * bit of the field set.  In addition, the &#39;add_fields&#39; and &#39;test_adder&#39;</span>
<span class="cm"> * in the struct power_pmu for this processor come into play.  The</span>
<span class="cm"> * add_fields value contains 1 in the LSB of the field, and the</span>
<span class="cm"> * test_adder contains 2^(k-1) - 1 - N in the field.</span>
<span class="cm"> *</span>
<span class="cm"> * NAND field: this expresses the constraint that you may not have events</span>
<span class="cm"> * in all of a set of classes.  (For example, on PPC970, you can&#39;t select</span>
<span class="cm"> * events from the FPU, ISU and IDU simultaneously, although any two are</span>
<span class="cm"> * possible.)  For N classes, the field is N+1 bits wide, and each class</span>
<span class="cm"> * is assigned one bit from the least-significant N bits.  The mask has</span>
<span class="cm"> * only the most-significant bit set, and the value has only the bit</span>
<span class="cm"> * for the event_id&#39;s class set.  The test_adder has the least significant</span>
<span class="cm"> * bit set in the field.</span>
<span class="cm"> *</span>
<span class="cm"> * If an event_id is not subject to the constraint expressed by a particular</span>
<span class="cm"> * field, then it will have 0 in both the mask and value for that field.</span>
<span class="cm"> */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
