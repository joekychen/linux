<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › io.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>io.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_POWERPC_IO_H</span>
<span class="cp">#define _ASM_POWERPC_IO_H</span>
<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#define ARCH_HAS_IOREMAP_WC</span>

<span class="cm">/*</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cm">/* Check of existence of legacy devices */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">check_legacy_ioport</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base_port</span><span class="p">);</span>
<span class="cp">#define I8042_DATA_REG	0x60</span>
<span class="cp">#define FDC_BASE	0x3f0</span>
<span class="cm">/* only relevant for PReP */</span>
<span class="cp">#define _PIDXR		0x279</span>
<span class="cp">#define _PNPWRP		0xa79</span>
<span class="cp">#define PNPBIOS_BASE	0xf000</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/synch.h&gt;</span>
<span class="cp">#include &lt;asm/delay.h&gt;</span>
<span class="cp">#include &lt;asm/mmu.h&gt;</span>

<span class="cp">#include &lt;asm-generic/iomap.h&gt;</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cp">#include &lt;asm/paca.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#define SIO_CONFIG_RA	0x398</span>
<span class="cp">#define SIO_CONFIG_RD	0x399</span>

<span class="cp">#define SLOW_DOWN_IO</span>

<span class="cm">/* 32 bits uses slightly different variables for the various IO</span>
<span class="cm"> * bases. Most of this file only uses _IO_BASE though which we</span>
<span class="cm"> * define properly based on the platform</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_PCI</span>
<span class="cp">#define _IO_BASE	0</span>
<span class="cp">#define _ISA_MEM_BASE	0</span>
<span class="cp">#define PCI_DRAM_OFFSET 0</span>
<span class="cp">#elif defined(CONFIG_PPC32)</span>
<span class="cp">#define _IO_BASE	isa_io_base</span>
<span class="cp">#define _ISA_MEM_BASE	isa_mem_base</span>
<span class="cp">#define PCI_DRAM_OFFSET	pci_dram_offset</span>
<span class="cp">#else</span>
<span class="cp">#define _IO_BASE	pci_io_base</span>
<span class="cp">#define _ISA_MEM_BASE	isa_mem_base</span>
<span class="cp">#define PCI_DRAM_OFFSET	0</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">isa_io_base</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_io_base</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_dram_offset</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">resource_size_t</span> <span class="n">isa_mem_base</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_PPC32) &amp;&amp; defined(CONFIG_PPC_INDIRECT_IO)</span>
<span class="cp">#error CONFIG_PPC_INDIRECT_IO is not yet supported on 32 bits</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Low level MMIO accessors</span>
<span class="cm"> *</span>
<span class="cm"> * This provides the non-bus specific accessors to MMIO. Those are PowerPC</span>
<span class="cm"> * specific and thus shouldn&#39;t be used in generic code. The accessors</span>
<span class="cm"> * provided here are:</span>
<span class="cm"> *</span>
<span class="cm"> *	in_8, in_le16, in_be16, in_le32, in_be32, in_le64, in_be64</span>
<span class="cm"> *	out_8, out_le16, out_be16, out_le32, out_be32, out_le64, out_be64</span>
<span class="cm"> *	_insb, _insw_ns, _insl_ns, _outsb, _outsw_ns, _outsl_ns</span>
<span class="cm"> *</span>
<span class="cm"> * Those operate directly on a kernel virtual address. Note that the prototype</span>
<span class="cm"> * for the out_* accessors has the arguments in opposite order from the usual</span>
<span class="cm"> * linux PCI accessors. Unlike those, they take the address first and the value</span>
<span class="cm"> * next.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: I might drop the _ns suffix on the stream operations soon as it is</span>
<span class="cm"> * simply normal for stream operations to not swap in the first place.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cp">#define IO_SET_SYNC_FLAG()	do { local_paca-&gt;io_sync = 1; } while(0)</span>
<span class="cp">#else</span>
<span class="cp">#define IO_SET_SYNC_FLAG()</span>
<span class="cp">#endif</span>

<span class="cm">/* gcc 4.0 and older doesn&#39;t have &#39;Z&#39; constraint */</span>
<span class="cp">#if __GNUC__ &lt; 4 || (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ == 0)</span>
<span class="cp">#define DEF_MMIO_IN_LE(name, size, insn)				\</span>
<span class="cp">static inline u##size name(const volatile u##size __iomem *addr)	\</span>
<span class="cp">{									\</span>
<span class="cp">	u##size ret;							\</span>
<span class="cp">	__asm__ __volatile__(&quot;sync;&quot;#insn&quot; %0,0,%1;twi 0,%0,0;isync&quot;	\</span>
<span class="cp">		: &quot;=r&quot; (ret) : &quot;r&quot; (addr), &quot;m&quot; (*addr) : &quot;memory&quot;);	\</span>
<span class="cp">	return ret;							\</span>
<span class="cp">}</span>

<span class="cp">#define DEF_MMIO_OUT_LE(name, size, insn) 				\</span>
<span class="cp">static inline void name(volatile u##size __iomem *addr, u##size val)	\</span>
<span class="cp">{									\</span>
<span class="cp">	__asm__ __volatile__(&quot;sync;&quot;#insn&quot; %1,0,%2&quot;			\</span>
<span class="cp">		: &quot;=m&quot; (*addr) : &quot;r&quot; (val), &quot;r&quot; (addr) : &quot;memory&quot;);	\</span>
<span class="cp">	IO_SET_SYNC_FLAG();						\</span>
<span class="cp">}</span>
<span class="cp">#else </span><span class="cm">/* newer gcc */</span><span class="cp"></span>
<span class="cp">#define DEF_MMIO_IN_LE(name, size, insn)				\</span>
<span class="cp">static inline u##size name(const volatile u##size __iomem *addr)	\</span>
<span class="cp">{									\</span>
<span class="cp">	u##size ret;							\</span>
<span class="cp">	__asm__ __volatile__(&quot;sync;&quot;#insn&quot; %0,%y1;twi 0,%0,0;isync&quot;	\</span>
<span class="cp">		: &quot;=r&quot; (ret) : &quot;Z&quot; (*addr) : &quot;memory&quot;);			\</span>
<span class="cp">	return ret;							\</span>
<span class="cp">}</span>

<span class="cp">#define DEF_MMIO_OUT_LE(name, size, insn) 				\</span>
<span class="cp">static inline void name(volatile u##size __iomem *addr, u##size val)	\</span>
<span class="cp">{									\</span>
<span class="cp">	__asm__ __volatile__(&quot;sync;&quot;#insn&quot; %1,%y0&quot;			\</span>
<span class="cp">		: &quot;=Z&quot; (*addr) : &quot;r&quot; (val) : &quot;memory&quot;);			\</span>
<span class="cp">	IO_SET_SYNC_FLAG();						\</span>
<span class="cp">}</span>
<span class="cp">#endif</span>

<span class="cp">#define DEF_MMIO_IN_BE(name, size, insn)				\</span>
<span class="cp">static inline u##size name(const volatile u##size __iomem *addr)	\</span>
<span class="cp">{									\</span>
<span class="cp">	u##size ret;							\</span>
<span class="cp">	__asm__ __volatile__(&quot;sync;&quot;#insn&quot;%U1%X1 %0,%1;twi 0,%0,0;isync&quot;\</span>
<span class="cp">		: &quot;=r&quot; (ret) : &quot;m&quot; (*addr) : &quot;memory&quot;);			\</span>
<span class="cp">	return ret;							\</span>
<span class="cp">}</span>

<span class="cp">#define DEF_MMIO_OUT_BE(name, size, insn)				\</span>
<span class="cp">static inline void name(volatile u##size __iomem *addr, u##size val)	\</span>
<span class="cp">{									\</span>
<span class="cp">	__asm__ __volatile__(&quot;sync;&quot;#insn&quot;%U0%X0 %1,%0&quot;			\</span>
<span class="cp">		: &quot;=m&quot; (*addr) : &quot;r&quot; (val) : &quot;memory&quot;);			\</span>
<span class="cp">	IO_SET_SYNC_FLAG();						\</span>
<span class="cp">}</span>


<span class="n">DEF_MMIO_IN_BE</span><span class="p">(</span><span class="n">in_8</span><span class="p">,</span>     <span class="mi">8</span><span class="p">,</span> <span class="n">lbz</span><span class="p">);</span>
<span class="n">DEF_MMIO_IN_BE</span><span class="p">(</span><span class="n">in_be16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">lhz</span><span class="p">);</span>
<span class="n">DEF_MMIO_IN_BE</span><span class="p">(</span><span class="n">in_be32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">lwz</span><span class="p">);</span>
<span class="n">DEF_MMIO_IN_LE</span><span class="p">(</span><span class="n">in_le16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">lhbrx</span><span class="p">);</span>
<span class="n">DEF_MMIO_IN_LE</span><span class="p">(</span><span class="n">in_le32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">lwbrx</span><span class="p">);</span>

<span class="n">DEF_MMIO_OUT_BE</span><span class="p">(</span><span class="n">out_8</span><span class="p">,</span>     <span class="mi">8</span><span class="p">,</span> <span class="n">stb</span><span class="p">);</span>
<span class="n">DEF_MMIO_OUT_BE</span><span class="p">(</span><span class="n">out_be16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">sth</span><span class="p">);</span>
<span class="n">DEF_MMIO_OUT_BE</span><span class="p">(</span><span class="n">out_be32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">stw</span><span class="p">);</span>
<span class="n">DEF_MMIO_OUT_LE</span><span class="p">(</span><span class="n">out_le16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">sthbrx</span><span class="p">);</span>
<span class="n">DEF_MMIO_OUT_LE</span><span class="p">(</span><span class="n">out_le32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">stwbrx</span><span class="p">);</span>

<span class="cp">#ifdef __powerpc64__</span>
<span class="n">DEF_MMIO_OUT_BE</span><span class="p">(</span><span class="n">out_be64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">std</span><span class="p">);</span>
<span class="n">DEF_MMIO_IN_BE</span><span class="p">(</span><span class="n">in_be64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">ld</span><span class="p">);</span>

<span class="cm">/* There is no asm instructions for 64 bits reverse loads and stores */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">in_le64</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">swab64</span><span class="p">(</span><span class="n">in_be64</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">out_le64</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">swab64</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __powerpc64__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Low level IO stream instructions are defined out of line for now</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_insb</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="n">u8</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">long</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_outsb</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u8</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="kt">long</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_insw_ns</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="n">u16</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">long</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_outsw_ns</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u16</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">long</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_insl_ns</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">long</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_outsl_ns</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">long</span> <span class="n">count</span><span class="p">);</span>

<span class="cm">/* The _ns naming is historical and will be removed. For now, just #define</span>
<span class="cm"> * the non _ns equivalent names</span>
<span class="cm"> */</span>
<span class="cp">#define _insw	_insw_ns</span>
<span class="cp">#define _insl	_insl_ns</span>
<span class="cp">#define _outsw	_outsw_ns</span>
<span class="cp">#define _outsl	_outsl_ns</span>


<span class="cm">/*</span>
<span class="cm"> * memset_io, memcpy_toio, memcpy_fromio base implementations are out of line</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">_memset_io</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_memcpy_fromio</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_memcpy_toio</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * PCI and standard ISA accessors</span>
<span class="cm"> *</span>
<span class="cm"> * Those are globally defined linux accessors for devices on PCI or ISA</span>
<span class="cm"> * busses. They follow the Linux defined semantics. The current implementation</span>
<span class="cm"> * for PowerPC is as close as possible to the x86 version of these, and thus</span>
<span class="cm"> * provides fairly heavy weight barriers for the non-raw versions</span>
<span class="cm"> *</span>
<span class="cm"> * In addition, they support a hook mechanism when CONFIG_PPC_INDIRECT_IO</span>
<span class="cm"> * allowing the platform to provide its own implementation of some or all</span>
<span class="cm"> * of the accessors.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Include the EEH definitions when EEH is enabled only so they don&#39;t get</span>
<span class="cm"> * in the way when building for 32 bits</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_EEH</span>
<span class="cp">#include &lt;asm/eeh.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/* Shortcut to the MMIO argument pointer */</span>
<span class="cp">#define PCI_IO_ADDR	volatile void __iomem *</span>

<span class="cm">/* Indirect IO address tokens:</span>
<span class="cm"> *</span>
<span class="cm"> * When CONFIG_PPC_INDIRECT_IO is set, the platform can provide hooks</span>
<span class="cm"> * on all IOs. (Note that this is all 64 bits only for now)</span>
<span class="cm"> *</span>
<span class="cm"> * To help platforms who may need to differenciate MMIO addresses in</span>
<span class="cm"> * their hooks, a bitfield is reserved for use by the platform near the</span>
<span class="cm"> * top of MMIO addresses (not PIO, those have to cope the hard way).</span>
<span class="cm"> *</span>
<span class="cm"> * This bit field is 12 bits and is at the top of the IO virtual</span>
<span class="cm"> * addresses PCI_IO_INDIRECT_TOKEN_MASK.</span>
<span class="cm"> *</span>
<span class="cm"> * The kernel virtual space is thus:</span>
<span class="cm"> *</span>
<span class="cm"> *  0xD000000000000000		: vmalloc</span>
<span class="cm"> *  0xD000080000000000		: PCI PHB IO space</span>
<span class="cm"> *  0xD000080080000000		: ioremap</span>
<span class="cm"> *  0xD0000fffffffffff		: end of ioremap region</span>
<span class="cm"> *</span>
<span class="cm"> * Since the top 4 bits are reserved as the region ID, we use thus</span>
<span class="cm"> * the next 12 bits and keep 4 bits available for the future if the</span>
<span class="cm"> * virtual address space is ever to be extended.</span>
<span class="cm"> *</span>
<span class="cm"> * The direct IO mapping operations will then mask off those bits</span>
<span class="cm"> * before doing the actual access, though that only happen when</span>
<span class="cm"> * CONFIG_PPC_INDIRECT_IO is set, thus be careful when you use that</span>
<span class="cm"> * mechanism</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_PPC_INDIRECT_IO</span>
<span class="cp">#define PCI_IO_IND_TOKEN_MASK	0x0fff000000000000ul</span>
<span class="cp">#define PCI_IO_IND_TOKEN_SHIFT	48</span>
<span class="cp">#define PCI_FIX_ADDR(addr)						\</span>
<span class="cp">	((PCI_IO_ADDR)(((unsigned long)(addr)) &amp; ~PCI_IO_IND_TOKEN_MASK))</span>
<span class="cp">#define PCI_GET_ADDR_TOKEN(addr)					\</span>
<span class="cp">	(((unsigned long)(addr) &amp; PCI_IO_IND_TOKEN_MASK) &gt;&gt; 		\</span>
<span class="cp">		PCI_IO_IND_TOKEN_SHIFT)</span>
<span class="cp">#define PCI_SET_ADDR_TOKEN(addr, token) 				\</span>
<span class="cp">do {									\</span>
<span class="cp">	unsigned long __a = (unsigned long)(addr);			\</span>
<span class="cp">	__a &amp;= ~PCI_IO_IND_TOKEN_MASK;					\</span>
<span class="cp">	__a |= ((unsigned long)(token)) &lt;&lt; PCI_IO_IND_TOKEN_SHIFT;	\</span>
<span class="cp">	(addr) = (void __iomem *)__a;					\</span>
<span class="cp">} while(0)</span>
<span class="cp">#else</span>
<span class="cp">#define PCI_FIX_ADDR(addr) (addr)</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> * Non ordered and non-swapping &quot;raw&quot; accessors</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">__raw_readb</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">PCI_FIX_ADDR</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">__raw_readw</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">PCI_FIX_ADDR</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">__raw_readl</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">PCI_FIX_ADDR</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__raw_writeb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">v</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">PCI_FIX_ADDR</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__raw_writew</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">v</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">PCI_FIX_ADDR</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__raw_writel</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">PCI_FIX_ADDR</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __powerpc64__</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__raw_readq</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">PCI_FIX_ADDR</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__raw_writeq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">PCI_FIX_ADDR</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __powerpc64__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * PCI PIO and MMIO accessors.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * On 32 bits, PIO operations have a recovery mechanism in case they trigger</span>
<span class="cm"> * machine checks (which they occasionally do when probing non existing</span>
<span class="cm"> * IO ports on some platforms, like PowerMac and 8xx).</span>
<span class="cm"> * I always found it to be of dubious reliability and I am tempted to get</span>
<span class="cm"> * rid of it one of these days. So if you think it&#39;s important to keep it,</span>
<span class="cm"> * please voice up asap. We never had it for 64 bits and I do not intend</span>
<span class="cm"> * to port it over</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_PPC32</span>

<span class="cp">#define __do_in_asm(name, op)				\</span>
<span class="cp">static inline unsigned int name(unsigned int port)	\</span>
<span class="cp">{							\</span>
<span class="cp">	unsigned int x;					\</span>
<span class="cp">	__asm__ __volatile__(				\</span>
<span class="cp">		&quot;sync\n&quot;				\</span>
<span class="cp">		&quot;0:&quot;	op &quot;	%0,0,%1\n&quot;		\</span>
<span class="cp">		&quot;1:	twi	0,%0,0\n&quot;		\</span>
<span class="cp">		&quot;2:	isync\n&quot;			\</span>
<span class="cp">		&quot;3:	nop\n&quot;				\</span>
<span class="cp">		&quot;4:\n&quot;					\</span>
<span class="cp">		&quot;.section .fixup,\&quot;ax\&quot;\n&quot;		\</span>
<span class="cp">		&quot;5:	li	%0,-1\n&quot;		\</span>
<span class="cp">		&quot;	b	4b\n&quot;			\</span>
<span class="cp">		&quot;.previous\n&quot;				\</span>
<span class="cp">		&quot;.section __ex_table,\&quot;a\&quot;\n&quot;		\</span>
<span class="cp">		&quot;	.align	2\n&quot;			\</span>
<span class="cp">		&quot;	.long	0b,5b\n&quot;		\</span>
<span class="cp">		&quot;	.long	1b,5b\n&quot;		\</span>
<span class="cp">		&quot;	.long	2b,5b\n&quot;		\</span>
<span class="cp">		&quot;	.long	3b,5b\n&quot;		\</span>
<span class="cp">		&quot;.previous&quot;				\</span>
<span class="cp">		: &quot;=&amp;r&quot; (x)				\</span>
<span class="cp">		: &quot;r&quot; (port + _IO_BASE)			\</span>
<span class="cp">		: &quot;memory&quot;);  				\</span>
<span class="cp">	return x;					\</span>
<span class="cp">}</span>

<span class="cp">#define __do_out_asm(name, op)				\</span>
<span class="cp">static inline void name(unsigned int val, unsigned int port) \</span>
<span class="cp">{							\</span>
<span class="cp">	__asm__ __volatile__(				\</span>
<span class="cp">		&quot;sync\n&quot;				\</span>
<span class="cp">		&quot;0:&quot; op &quot; %0,0,%1\n&quot;			\</span>
<span class="cp">		&quot;1:	sync\n&quot;				\</span>
<span class="cp">		&quot;2:\n&quot;					\</span>
<span class="cp">		&quot;.section __ex_table,\&quot;a\&quot;\n&quot;		\</span>
<span class="cp">		&quot;	.align	2\n&quot;			\</span>
<span class="cp">		&quot;	.long	0b,2b\n&quot;		\</span>
<span class="cp">		&quot;	.long	1b,2b\n&quot;		\</span>
<span class="cp">		&quot;.previous&quot;				\</span>
<span class="cp">		: : &quot;r&quot; (val), &quot;r&quot; (port + _IO_BASE)	\</span>
<span class="cp">		: &quot;memory&quot;);   	   	   		\</span>
<span class="cp">}</span>

<span class="n">__do_in_asm</span><span class="p">(</span><span class="n">_rec_inb</span><span class="p">,</span> <span class="s">&quot;lbzx&quot;</span><span class="p">)</span>
<span class="n">__do_in_asm</span><span class="p">(</span><span class="n">_rec_inw</span><span class="p">,</span> <span class="s">&quot;lhbrx&quot;</span><span class="p">)</span>
<span class="n">__do_in_asm</span><span class="p">(</span><span class="n">_rec_inl</span><span class="p">,</span> <span class="s">&quot;lwbrx&quot;</span><span class="p">)</span>
<span class="n">__do_out_asm</span><span class="p">(</span><span class="n">_rec_outb</span><span class="p">,</span> <span class="s">&quot;stbx&quot;</span><span class="p">)</span>
<span class="n">__do_out_asm</span><span class="p">(</span><span class="n">_rec_outw</span><span class="p">,</span> <span class="s">&quot;sthbrx&quot;</span><span class="p">)</span>
<span class="n">__do_out_asm</span><span class="p">(</span><span class="n">_rec_outl</span><span class="p">,</span> <span class="s">&quot;stwbrx&quot;</span><span class="p">)</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC32 */</span><span class="cp"></span>

<span class="cm">/* The &quot;__do_*&quot; operations below provide the actual &quot;base&quot; implementation</span>
<span class="cm"> * for each of the defined accessors. Some of them use the out_* functions</span>
<span class="cm"> * directly, some of them still use EEH, though we might change that in the</span>
<span class="cm"> * future. Those macros below provide the necessary argument swapping and</span>
<span class="cm"> * handling of the IO base for PIO.</span>
<span class="cm"> *</span>
<span class="cm"> * They are themselves used by the macros that define the actual accessors</span>
<span class="cm"> * and can be used by the hooks if any.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that PIO operations are always defined in terms of their corresonding</span>
<span class="cm"> * MMIO operations. That allows platforms like iSeries who want to modify the</span>
<span class="cm"> * behaviour of both to only hook on the MMIO version and get both. It&#39;s also</span>
<span class="cm"> * possible to hook directly at the toplevel PIO operation if they have to</span>
<span class="cm"> * be handled differently</span>
<span class="cm"> */</span>
<span class="cp">#define __do_writeb(val, addr)	out_8(PCI_FIX_ADDR(addr), val)</span>
<span class="cp">#define __do_writew(val, addr)	out_le16(PCI_FIX_ADDR(addr), val)</span>
<span class="cp">#define __do_writel(val, addr)	out_le32(PCI_FIX_ADDR(addr), val)</span>
<span class="cp">#define __do_writeq(val, addr)	out_le64(PCI_FIX_ADDR(addr), val)</span>
<span class="cp">#define __do_writew_be(val, addr) out_be16(PCI_FIX_ADDR(addr), val)</span>
<span class="cp">#define __do_writel_be(val, addr) out_be32(PCI_FIX_ADDR(addr), val)</span>
<span class="cp">#define __do_writeq_be(val, addr) out_be64(PCI_FIX_ADDR(addr), val)</span>

<span class="cp">#ifdef CONFIG_EEH</span>
<span class="cp">#define __do_readb(addr)	eeh_readb(PCI_FIX_ADDR(addr))</span>
<span class="cp">#define __do_readw(addr)	eeh_readw(PCI_FIX_ADDR(addr))</span>
<span class="cp">#define __do_readl(addr)	eeh_readl(PCI_FIX_ADDR(addr))</span>
<span class="cp">#define __do_readq(addr)	eeh_readq(PCI_FIX_ADDR(addr))</span>
<span class="cp">#define __do_readw_be(addr)	eeh_readw_be(PCI_FIX_ADDR(addr))</span>
<span class="cp">#define __do_readl_be(addr)	eeh_readl_be(PCI_FIX_ADDR(addr))</span>
<span class="cp">#define __do_readq_be(addr)	eeh_readq_be(PCI_FIX_ADDR(addr))</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_EEH */</span><span class="cp"></span>
<span class="cp">#define __do_readb(addr)	in_8(PCI_FIX_ADDR(addr))</span>
<span class="cp">#define __do_readw(addr)	in_le16(PCI_FIX_ADDR(addr))</span>
<span class="cp">#define __do_readl(addr)	in_le32(PCI_FIX_ADDR(addr))</span>
<span class="cp">#define __do_readq(addr)	in_le64(PCI_FIX_ADDR(addr))</span>
<span class="cp">#define __do_readw_be(addr)	in_be16(PCI_FIX_ADDR(addr))</span>
<span class="cp">#define __do_readl_be(addr)	in_be32(PCI_FIX_ADDR(addr))</span>
<span class="cp">#define __do_readq_be(addr)	in_be64(PCI_FIX_ADDR(addr))</span>
<span class="cp">#endif </span><span class="cm">/* !defined(CONFIG_EEH) */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PPC32</span>
<span class="cp">#define __do_outb(val, port)	_rec_outb(val, port)</span>
<span class="cp">#define __do_outw(val, port)	_rec_outw(val, port)</span>
<span class="cp">#define __do_outl(val, port)	_rec_outl(val, port)</span>
<span class="cp">#define __do_inb(port)		_rec_inb(port)</span>
<span class="cp">#define __do_inw(port)		_rec_inw(port)</span>
<span class="cp">#define __do_inl(port)		_rec_inl(port)</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_PPC32 */</span><span class="cp"></span>
<span class="cp">#define __do_outb(val, port)	writeb(val,(PCI_IO_ADDR)_IO_BASE+port);</span>
<span class="cp">#define __do_outw(val, port)	writew(val,(PCI_IO_ADDR)_IO_BASE+port);</span>
<span class="cp">#define __do_outl(val, port)	writel(val,(PCI_IO_ADDR)_IO_BASE+port);</span>
<span class="cp">#define __do_inb(port)		readb((PCI_IO_ADDR)_IO_BASE + port);</span>
<span class="cp">#define __do_inw(port)		readw((PCI_IO_ADDR)_IO_BASE + port);</span>
<span class="cp">#define __do_inl(port)		readl((PCI_IO_ADDR)_IO_BASE + port);</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_PPC32 */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_EEH</span>
<span class="cp">#define __do_readsb(a, b, n)	eeh_readsb(PCI_FIX_ADDR(a), (b), (n))</span>
<span class="cp">#define __do_readsw(a, b, n)	eeh_readsw(PCI_FIX_ADDR(a), (b), (n))</span>
<span class="cp">#define __do_readsl(a, b, n)	eeh_readsl(PCI_FIX_ADDR(a), (b), (n))</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_EEH */</span><span class="cp"></span>
<span class="cp">#define __do_readsb(a, b, n)	_insb(PCI_FIX_ADDR(a), (b), (n))</span>
<span class="cp">#define __do_readsw(a, b, n)	_insw(PCI_FIX_ADDR(a), (b), (n))</span>
<span class="cp">#define __do_readsl(a, b, n)	_insl(PCI_FIX_ADDR(a), (b), (n))</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_EEH */</span><span class="cp"></span>
<span class="cp">#define __do_writesb(a, b, n)	_outsb(PCI_FIX_ADDR(a),(b),(n))</span>
<span class="cp">#define __do_writesw(a, b, n)	_outsw(PCI_FIX_ADDR(a),(b),(n))</span>
<span class="cp">#define __do_writesl(a, b, n)	_outsl(PCI_FIX_ADDR(a),(b),(n))</span>

<span class="cp">#define __do_insb(p, b, n)	readsb((PCI_IO_ADDR)_IO_BASE+(p), (b), (n))</span>
<span class="cp">#define __do_insw(p, b, n)	readsw((PCI_IO_ADDR)_IO_BASE+(p), (b), (n))</span>
<span class="cp">#define __do_insl(p, b, n)	readsl((PCI_IO_ADDR)_IO_BASE+(p), (b), (n))</span>
<span class="cp">#define __do_outsb(p, b, n)	writesb((PCI_IO_ADDR)_IO_BASE+(p),(b),(n))</span>
<span class="cp">#define __do_outsw(p, b, n)	writesw((PCI_IO_ADDR)_IO_BASE+(p),(b),(n))</span>
<span class="cp">#define __do_outsl(p, b, n)	writesl((PCI_IO_ADDR)_IO_BASE+(p),(b),(n))</span>

<span class="cp">#define __do_memset_io(addr, c, n)	\</span>
<span class="cp">				_memset_io(PCI_FIX_ADDR(addr), c, n)</span>
<span class="cp">#define __do_memcpy_toio(dst, src, n)	\</span>
<span class="cp">				_memcpy_toio(PCI_FIX_ADDR(dst), src, n)</span>

<span class="cp">#ifdef CONFIG_EEH</span>
<span class="cp">#define __do_memcpy_fromio(dst, src, n)	\</span>
<span class="cp">				eeh_memcpy_fromio(dst, PCI_FIX_ADDR(src), n)</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_EEH */</span><span class="cp"></span>
<span class="cp">#define __do_memcpy_fromio(dst, src, n)	\</span>
<span class="cp">				_memcpy_fromio(dst,PCI_FIX_ADDR(src),n)</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_EEH */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PPC_INDIRECT_PIO</span>
<span class="cp">#define DEF_PCI_HOOK_pio(x)	x</span>
<span class="cp">#else</span>
<span class="cp">#define DEF_PCI_HOOK_pio(x)	NULL</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PPC_INDIRECT_MMIO</span>
<span class="cp">#define DEF_PCI_HOOK_mem(x)	x</span>
<span class="cp">#else</span>
<span class="cp">#define DEF_PCI_HOOK_mem(x)	NULL</span>
<span class="cp">#endif</span>

<span class="cm">/* Structure containing all the hooks */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ppc_pci_io</span> <span class="p">{</span>

<span class="cp">#define DEF_PCI_AC_RET(name, ret, at, al, space, aa)	ret (*name) at;</span>
<span class="cp">#define DEF_PCI_AC_NORET(name, at, al, space, aa)	void (*name) at;</span>

<span class="cp">#include &lt;asm/io-defs.h&gt;</span>

<span class="cp">#undef DEF_PCI_AC_RET</span>
<span class="cp">#undef DEF_PCI_AC_NORET</span>

<span class="p">}</span> <span class="n">ppc_pci_io</span><span class="p">;</span>

<span class="cm">/* The inline wrappers */</span>
<span class="cp">#define DEF_PCI_AC_RET(name, ret, at, al, space, aa)		\</span>
<span class="cp">static inline ret name at					\</span>
<span class="cp">{								\</span>
<span class="cp">	if (DEF_PCI_HOOK_##space(ppc_pci_io.name) != NULL)	\</span>
<span class="cp">		return ppc_pci_io.name al;			\</span>
<span class="cp">	return __do_##name al;					\</span>
<span class="cp">}</span>

<span class="cp">#define DEF_PCI_AC_NORET(name, at, al, space, aa)		\</span>
<span class="cp">static inline void name at					\</span>
<span class="cp">{								\</span>
<span class="cp">	if (DEF_PCI_HOOK_##space(ppc_pci_io.name) != NULL)		\</span>
<span class="cp">		ppc_pci_io.name al;				\</span>
<span class="cp">	else							\</span>
<span class="cp">		__do_##name al;					\</span>
<span class="cp">}</span>

<span class="cp">#include &lt;asm/io-defs.h&gt;</span>

<span class="cp">#undef DEF_PCI_AC_RET</span>
<span class="cp">#undef DEF_PCI_AC_NORET</span>

<span class="cm">/* Some drivers check for the presence of readq &amp; writeq with</span>
<span class="cm"> * a #ifdef, so we make them happy here.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __powerpc64__</span>
<span class="cp">#define readq	readq</span>
<span class="cp">#define writeq	writeq</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Convert a physical pointer to a virtual kernel pointer for /dev/mem</span>
<span class="cm"> * access</span>
<span class="cm"> */</span>
<span class="cp">#define xlate_dev_mem_ptr(p)	__va(p)</span>

<span class="cm">/*</span>
<span class="cm"> * Convert a virtual cached pointer to an uncached pointer</span>
<span class="cm"> */</span>
<span class="cp">#define xlate_dev_kmem_ptr(p)	p</span>

<span class="cm">/*</span>
<span class="cm"> * We don&#39;t do relaxed operations yet, at least not with this semantic</span>
<span class="cm"> */</span>
<span class="cp">#define readb_relaxed(addr) readb(addr)</span>
<span class="cp">#define readw_relaxed(addr) readw(addr)</span>
<span class="cp">#define readl_relaxed(addr) readl(addr)</span>
<span class="cp">#define readq_relaxed(addr) readq(addr)</span>

<span class="cp">#ifdef CONFIG_PPC32</span>
<span class="cp">#define mmiowb()</span>
<span class="cp">#else</span>
<span class="cm">/*</span>
<span class="cm"> * Enforce synchronisation of stores vs. spin_unlock</span>
<span class="cm"> * (this does it explicitly, though our implementation of spin_unlock</span>
<span class="cm"> * does it implicitely too)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmiowb</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;sync; li %0,0; stb %0,%1(13)&quot;</span>
	<span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">paca_struct</span><span class="p">,</span> <span class="n">io_sync</span><span class="p">))</span>
	<span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_PPC32 */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iosync</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sync&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Enforce in-order execution of data I/O.</span>
<span class="cm"> * No distinction between read/write on PPC; use eieio for all three.</span>
<span class="cm"> * Those are fairly week though. They don&#39;t provide a barrier between</span>
<span class="cm"> * MMIO and cacheable storage nor do they provide a barrier vs. locks,</span>
<span class="cm"> * they only provide barriers between 2 __raw MMIO operations and</span>
<span class="cm"> * possibly break write combining.</span>
<span class="cm"> */</span>
<span class="cp">#define iobarrier_rw() eieio()</span>
<span class="cp">#define iobarrier_r()  eieio()</span>
<span class="cp">#define iobarrier_w()  eieio()</span>


<span class="cm">/*</span>
<span class="cm"> * output pause versions need a delay at least for the</span>
<span class="cm"> * w83c105 ide controller in a p610.</span>
<span class="cm"> */</span>
<span class="cp">#define inb_p(port)             inb(port)</span>
<span class="cp">#define outb_p(val, port)       (udelay(1), outb((val), (port)))</span>
<span class="cp">#define inw_p(port)             inw(port)</span>
<span class="cp">#define outw_p(val, port)       (udelay(1), outw((val), (port)))</span>
<span class="cp">#define inl_p(port)             inl(port)</span>
<span class="cp">#define outl_p(val, port)       (udelay(1), outl((val), (port)))</span>


<span class="cp">#define IO_SPACE_LIMIT ~(0UL)</span>


<span class="cm">/**</span>
<span class="cm"> * ioremap     -   map bus memory into CPU space</span>
<span class="cm"> * @address:   bus address of the memory</span>
<span class="cm"> * @size:      size of the resource to map</span>
<span class="cm"> *</span>
<span class="cm"> * ioremap performs a platform specific sequence of operations to</span>
<span class="cm"> * make bus memory CPU accessible via the readb/readw/readl/writeb/</span>
<span class="cm"> * writew/writel functions and the other mmio helpers. The returned</span>
<span class="cm"> * address is not guaranteed to be usable directly as a virtual</span>
<span class="cm"> * address.</span>
<span class="cm"> *</span>
<span class="cm"> * We provide a few variations of it:</span>
<span class="cm"> *</span>
<span class="cm"> * * ioremap is the standard one and provides non-cacheable guarded mappings</span>
<span class="cm"> *   and can be hooked by the platform via ppc_md</span>
<span class="cm"> *</span>
<span class="cm"> * * ioremap_prot allows to specify the page flags as an argument and can</span>
<span class="cm"> *   also be hooked by the platform via ppc_md.</span>
<span class="cm"> *</span>
<span class="cm"> * * ioremap_nocache is identical to ioremap</span>
<span class="cm"> *</span>
<span class="cm"> * * ioremap_wc enables write combining</span>
<span class="cm"> *</span>
<span class="cm"> * * iounmap undoes such a mapping and can be hooked</span>
<span class="cm"> *</span>
<span class="cm"> * * __ioremap_at (and the pending __iounmap_at) are low level functions to</span>
<span class="cm"> *   create hand-made mappings for use only by the PCI code and cannot</span>
<span class="cm"> *   currently be hooked. Must be page aligned.</span>
<span class="cm"> *</span>
<span class="cm"> * * __ioremap is the low level implementation used by ioremap and</span>
<span class="cm"> *   ioremap_prot and cannot be hooked (but can be used by a hook on one</span>
<span class="cm"> *   of the previous ones)</span>
<span class="cm"> *</span>
<span class="cm"> * * __ioremap_caller is the same as above but takes an explicit caller</span>
<span class="cm"> *   reference rather than using __builtin_return_address(0)</span>
<span class="cm"> *</span>
<span class="cm"> * * __iounmap, is the low level implementation used by iounmap and cannot</span>
<span class="cm"> *   be hooked (but can be used by a hook on iounmap)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioremap</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioremap_prot</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioremap_wc</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>
<span class="cp">#define ioremap_nocache(addr, size)	ioremap((addr), (size))</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">iounmap</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">__ioremap</span><span class="p">(</span><span class="n">phys_addr_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">__ioremap_caller</span><span class="p">(</span><span class="n">phys_addr_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">caller</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iounmap</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">__ioremap_at</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">pa</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ea</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iounmap_at</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ea</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * When CONFIG_PPC_INDIRECT_IO is set, we use the generic iomap implementation</span>
<span class="cm"> * which needs some additional definitions here. They basically allow PIO</span>
<span class="cm"> * space overall to be 1GB. This will work as long as we never try to use</span>
<span class="cm"> * iomap to map MMIO below 1GB which should be fine on ppc64</span>
<span class="cm"> */</span>
<span class="cp">#define HAVE_ARCH_PIO_SIZE		1</span>
<span class="cp">#define PIO_OFFSET			0x00000000UL</span>
<span class="cp">#define PIO_MASK			(FULL_IO_SIZE - 1)</span>
<span class="cp">#define PIO_RESERVED			(FULL_IO_SIZE)</span>

<span class="cp">#define mmio_read16be(addr)		readw_be(addr)</span>
<span class="cp">#define mmio_read32be(addr)		readl_be(addr)</span>
<span class="cp">#define mmio_write16be(val, addr)	writew_be(val, addr)</span>
<span class="cp">#define mmio_write32be(val, addr)	writel_be(val, addr)</span>
<span class="cp">#define mmio_insb(addr, dst, count)	readsb(addr, dst, count)</span>
<span class="cp">#define mmio_insw(addr, dst, count)	readsw(addr, dst, count)</span>
<span class="cp">#define mmio_insl(addr, dst, count)	readsl(addr, dst, count)</span>
<span class="cp">#define mmio_outsb(addr, src, count)	writesb(addr, src, count)</span>
<span class="cp">#define mmio_outsw(addr, src, count)	writesw(addr, src, count)</span>
<span class="cp">#define mmio_outsl(addr, src, count)	writesl(addr, src, count)</span>

<span class="cm">/**</span>
<span class="cm"> *	virt_to_phys	-	map virtual addresses to physical</span>
<span class="cm"> *	@address: address to remap</span>
<span class="cm"> *</span>
<span class="cm"> *	The returned physical address is the physical (CPU) mapping for</span>
<span class="cm"> *	the memory address given. It is only valid to use this function on</span>
<span class="cm"> *	addresses directly mapped or allocated via kmalloc.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function does not give bus mappings for DMA transfers. In</span>
<span class="cm"> *	almost all conceivable cases a device driver should not be using</span>
<span class="cm"> *	this function</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">virt_to_phys</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pa</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	phys_to_virt	-	map physical address to virtual</span>
<span class="cm"> *	@address: address to remap</span>
<span class="cm"> *</span>
<span class="cm"> *	The returned virtual address is a current CPU mapping for</span>
<span class="cm"> *	the memory address given. It is only valid to use this function on</span>
<span class="cm"> *	addresses that have a kernel mapping</span>
<span class="cm"> *</span>
<span class="cm"> *	This function does not handle bus mappings for DMA transfers. In</span>
<span class="cm"> *	almost all conceivable cases a device driver should not be using</span>
<span class="cm"> *	this function</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span> <span class="nf">phys_to_virt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Change &quot;struct page&quot; to physical address.</span>
<span class="cm"> */</span>
<span class="cp">#define page_to_phys(page)	((phys_addr_t)page_to_pfn(page) &lt;&lt; PAGE_SHIFT)</span>

<span class="cm">/*</span>
<span class="cm"> * 32 bits still uses virt_to_bus() for it&#39;s implementation of DMA</span>
<span class="cm"> * mappings se we have to keep it defined here. We also have some old</span>
<span class="cm"> * drivers (shame shame shame) that use bus_to_virt() and haven&#39;t been</span>
<span class="cm"> * fixed yet so I need to define it here.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PPC32</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">virt_to_bus</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">__pa</span><span class="p">(</span><span class="n">address</span><span class="p">)</span> <span class="o">+</span> <span class="n">PCI_DRAM_OFFSET</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span> <span class="nf">bus_to_virt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">__va</span><span class="p">(</span><span class="n">address</span> <span class="o">-</span> <span class="n">PCI_DRAM_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define page_to_bus(page)	(page_to_phys(page) + PCI_DRAM_OFFSET)</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC32 */</span><span class="cp"></span>

<span class="cm">/* access ports */</span>
<span class="cp">#define setbits32(_addr, _v) out_be32((_addr), in_be32(_addr) |  (_v))</span>
<span class="cp">#define clrbits32(_addr, _v) out_be32((_addr), in_be32(_addr) &amp; ~(_v))</span>

<span class="cp">#define setbits16(_addr, _v) out_be16((_addr), in_be16(_addr) |  (_v))</span>
<span class="cp">#define clrbits16(_addr, _v) out_be16((_addr), in_be16(_addr) &amp; ~(_v))</span>

<span class="cp">#define setbits8(_addr, _v) out_8((_addr), in_8(_addr) |  (_v))</span>
<span class="cp">#define clrbits8(_addr, _v) out_8((_addr), in_8(_addr) &amp; ~(_v))</span>

<span class="cm">/* Clear and set bits in one shot.  These macros can be used to clear and</span>
<span class="cm"> * set multiple bits in a register using a single read-modify-write.  These</span>
<span class="cm"> * macros can also be used to set a multiple-bit bit pattern using a mask,</span>
<span class="cm"> * by specifying the mask in the &#39;clear&#39; parameter and the new bit pattern</span>
<span class="cm"> * in the &#39;set&#39; parameter.</span>
<span class="cm"> */</span>

<span class="cp">#define clrsetbits(type, addr, clear, set) \</span>
<span class="cp">	out_##type((addr), (in_##type(addr) &amp; ~(clear)) | (set))</span>

<span class="cp">#ifdef __powerpc64__</span>
<span class="cp">#define clrsetbits_be64(addr, clear, set) clrsetbits(be64, addr, clear, set)</span>
<span class="cp">#define clrsetbits_le64(addr, clear, set) clrsetbits(le64, addr, clear, set)</span>
<span class="cp">#endif</span>

<span class="cp">#define clrsetbits_be32(addr, clear, set) clrsetbits(be32, addr, clear, set)</span>
<span class="cp">#define clrsetbits_le32(addr, clear, set) clrsetbits(le32, addr, clear, set)</span>

<span class="cp">#define clrsetbits_be16(addr, clear, set) clrsetbits(be16, addr, clear, set)</span>
<span class="cp">#define clrsetbits_le16(addr, clear, set) clrsetbits(le16, addr, clear, set)</span>

<span class="cp">#define clrsetbits_8(addr, clear, set) clrsetbits(8, addr, clear, set)</span>

<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">devm_ioremap_prot</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="n">offset</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_POWERPC_IO_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
