<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › pgtable-ppc64.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pgtable-ppc64.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_POWERPC_PGTABLE_PPC64_H_</span>
<span class="cp">#define _ASM_POWERPC_PGTABLE_PPC64_H_</span>
<span class="cm">/*</span>
<span class="cm"> * This file contains the functions and defines necessary to modify and use</span>
<span class="cm"> * the ppc64 hashed page table.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_PPC_64K_PAGES</span>
<span class="cp">#include &lt;asm/pgtable-ppc64-64k.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;asm/pgtable-ppc64-4k.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#define FIRST_USER_ADDRESS	0</span>

<span class="cm">/*</span>
<span class="cm"> * Size of EA range mapped by our pagetables.</span>
<span class="cm"> */</span>
<span class="cp">#define PGTABLE_EADDR_SIZE (PTE_INDEX_SIZE + PMD_INDEX_SIZE + \</span>
<span class="cp">                	    PUD_INDEX_SIZE + PGD_INDEX_SIZE + PAGE_SHIFT)</span>
<span class="cp">#define PGTABLE_RANGE (ASM_CONST(1) &lt;&lt; PGTABLE_EADDR_SIZE)</span>


<span class="cm">/* Some sanity checking */</span>
<span class="cp">#if TASK_SIZE_USER64 &gt; PGTABLE_RANGE</span>
<span class="cp">#error TASK_SIZE_USER64 exceeds pagetable range</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PPC_STD_MMU_64</span>
<span class="cp">#if TASK_SIZE_USER64 &gt; (1UL &lt;&lt; (USER_ESID_BITS + SID_SHIFT))</span>
<span class="cp">#error TASK_SIZE_USER64 exceeds user VSID range</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Define the address range of the kernel non-linear virtual area</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_PPC_BOOK3E</span>
<span class="cp">#define KERN_VIRT_START ASM_CONST(0x8000000000000000)</span>
<span class="cp">#else</span>
<span class="cp">#define KERN_VIRT_START ASM_CONST(0xD000000000000000)</span>
<span class="cp">#endif</span>
<span class="cp">#define KERN_VIRT_SIZE	PGTABLE_RANGE</span>

<span class="cm">/*</span>
<span class="cm"> * The vmalloc space starts at the beginning of that region, and</span>
<span class="cm"> * occupies half of it on hash CPUs and a quarter of it on Book3E</span>
<span class="cm"> * (we keep a quarter for the virtual memmap)</span>
<span class="cm"> */</span>
<span class="cp">#define VMALLOC_START	KERN_VIRT_START</span>
<span class="cp">#ifdef CONFIG_PPC_BOOK3E</span>
<span class="cp">#define VMALLOC_SIZE	(KERN_VIRT_SIZE &gt;&gt; 2)</span>
<span class="cp">#else</span>
<span class="cp">#define VMALLOC_SIZE	(KERN_VIRT_SIZE &gt;&gt; 1)</span>
<span class="cp">#endif</span>
<span class="cp">#define VMALLOC_END	(VMALLOC_START + VMALLOC_SIZE)</span>

<span class="cm">/*</span>
<span class="cm"> * The second half of the kernel virtual space is used for IO mappings,</span>
<span class="cm"> * it&#39;s itself carved into the PIO region (ISA and PHB IO space) and</span>
<span class="cm"> * the ioremap space</span>
<span class="cm"> *</span>
<span class="cm"> *  ISA_IO_BASE = KERN_IO_START, 64K reserved area</span>
<span class="cm"> *  PHB_IO_BASE = ISA_IO_BASE + 64K to ISA_IO_BASE + 2G, PHB IO spaces</span>
<span class="cm"> * IOREMAP_BASE = ISA_IO_BASE + 2G to VMALLOC_START + PGTABLE_RANGE</span>
<span class="cm"> */</span>
<span class="cp">#define KERN_IO_START	(KERN_VIRT_START + (KERN_VIRT_SIZE &gt;&gt; 1))</span>
<span class="cp">#define FULL_IO_SIZE	0x80000000ul</span>
<span class="cp">#define  ISA_IO_BASE	(KERN_IO_START)</span>
<span class="cp">#define  ISA_IO_END	(KERN_IO_START + 0x10000ul)</span>
<span class="cp">#define  PHB_IO_BASE	(ISA_IO_END)</span>
<span class="cp">#define  PHB_IO_END	(KERN_IO_START + FULL_IO_SIZE)</span>
<span class="cp">#define IOREMAP_BASE	(PHB_IO_END)</span>
<span class="cp">#define IOREMAP_END	(KERN_VIRT_START + KERN_VIRT_SIZE)</span>


<span class="cm">/*</span>
<span class="cm"> * Region IDs</span>
<span class="cm"> */</span>
<span class="cp">#define REGION_SHIFT		60UL</span>
<span class="cp">#define REGION_MASK		(0xfUL &lt;&lt; REGION_SHIFT)</span>
<span class="cp">#define REGION_ID(ea)		(((unsigned long)(ea)) &gt;&gt; REGION_SHIFT)</span>

<span class="cp">#define VMALLOC_REGION_ID	(REGION_ID(VMALLOC_START))</span>
<span class="cp">#define KERNEL_REGION_ID	(REGION_ID(PAGE_OFFSET))</span>
<span class="cp">#define VMEMMAP_REGION_ID	(0xfUL)	</span><span class="cm">/* Server only */</span><span class="cp"></span>
<span class="cp">#define USER_REGION_ID		(0UL)</span>

<span class="cm">/*</span>
<span class="cm"> * Defines the address of the vmemap area, in its own region on</span>
<span class="cm"> * hash table CPUs and after the vmalloc space on Book3E</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PPC_BOOK3E</span>
<span class="cp">#define VMEMMAP_BASE		VMALLOC_END</span>
<span class="cp">#define VMEMMAP_END		KERN_IO_START</span>
<span class="cp">#else</span>
<span class="cp">#define VMEMMAP_BASE		(VMEMMAP_REGION_ID &lt;&lt; REGION_SHIFT)</span>
<span class="cp">#endif</span>
<span class="cp">#define vmemmap			((struct page *)VMEMMAP_BASE)</span>


<span class="cm">/*</span>
<span class="cm"> * Include the PTE bits definitions</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PPC_BOOK3S</span>
<span class="cp">#include &lt;asm/pte-hash64.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;asm/pte-book3e.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;asm/pte-common.h&gt;</span>

<span class="cp">#ifdef CONFIG_PPC_MM_SLICES</span>
<span class="cp">#define HAVE_ARCH_UNMAPPED_AREA</span>
<span class="cp">#define HAVE_ARCH_UNMAPPED_AREA_TOPDOWN</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_MM_SLICES */</span><span class="cp"></span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * This is the default implementation of various PTE accessors, it&#39;s</span>
<span class="cm"> * used in all cases except Book3S with 64K pages where we have a</span>
<span class="cm"> * concept of sub-pages</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __real_pte</span>

<span class="cp">#ifdef STRICT_MM_TYPECHECKS</span>
<span class="cp">#define __real_pte(e,p)		((real_pte_t){(e)})</span>
<span class="cp">#define __rpte_to_pte(r)	((r).pte)</span>
<span class="cp">#else</span>
<span class="cp">#define __real_pte(e,p)		(e)</span>
<span class="cp">#define __rpte_to_pte(r)	(__pte(r))</span>
<span class="cp">#endif</span>
<span class="cp">#define __rpte_to_hidx(r,index)	(pte_val(__rpte_to_pte(r)) &gt;&gt; 12)</span>

<span class="cp">#define pte_iterate_hashed_subpages(rpte, psize, va, index, shift)       \</span>
<span class="cp">	do {							         \</span>
<span class="cp">		index = 0;					         \</span>
<span class="cp">		shift = mmu_psize_defs[psize].shift;		         \</span>

<span class="cp">#define pte_iterate_hashed_end() } while(0)</span>

<span class="cp">#ifdef CONFIG_PPC_HAS_HASH_64K</span>
<span class="cp">#define pte_pagesize_index(mm, addr, pte)	get_slice_psize(mm, addr)</span>
<span class="cp">#else</span>
<span class="cp">#define pte_pagesize_index(mm, addr, pte)	MMU_PAGE_4K</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __real_pte */</span><span class="cp"></span>


<span class="cm">/* pte_clear moved to later in this file */</span>

<span class="cp">#define PMD_BAD_BITS		(PTE_TABLE_SIZE-1)</span>
<span class="cp">#define PUD_BAD_BITS		(PMD_TABLE_SIZE-1)</span>

<span class="cp">#define pmd_set(pmdp, pmdval) 	(pmd_val(*(pmdp)) = (pmdval))</span>
<span class="cp">#define pmd_none(pmd)		(!pmd_val(pmd))</span>
<span class="cp">#define	pmd_bad(pmd)		(!is_kernel_addr(pmd_val(pmd)) \</span>
<span class="cp">				 || (pmd_val(pmd) &amp; PMD_BAD_BITS))</span>
<span class="cp">#define	pmd_present(pmd)	(pmd_val(pmd) != 0)</span>
<span class="cp">#define	pmd_clear(pmdp)		(pmd_val(*(pmdp)) = 0)</span>
<span class="cp">#define pmd_page_vaddr(pmd)	(pmd_val(pmd) &amp; ~PMD_MASKED_BITS)</span>
<span class="cp">#define pmd_page(pmd)		virt_to_page(pmd_page_vaddr(pmd))</span>

<span class="cp">#define pud_set(pudp, pudval)	(pud_val(*(pudp)) = (pudval))</span>
<span class="cp">#define pud_none(pud)		(!pud_val(pud))</span>
<span class="cp">#define	pud_bad(pud)		(!is_kernel_addr(pud_val(pud)) \</span>
<span class="cp">				 || (pud_val(pud) &amp; PUD_BAD_BITS))</span>
<span class="cp">#define pud_present(pud)	(pud_val(pud) != 0)</span>
<span class="cp">#define pud_clear(pudp)		(pud_val(*(pudp)) = 0)</span>
<span class="cp">#define pud_page_vaddr(pud)	(pud_val(pud) &amp; ~PUD_MASKED_BITS)</span>
<span class="cp">#define pud_page(pud)		virt_to_page(pud_page_vaddr(pud))</span>

<span class="cp">#define pgd_set(pgdp, pudp)	({pgd_val(*(pgdp)) = (unsigned long)(pudp);})</span>

<span class="cm">/*</span>
<span class="cm"> * Find an entry in a page-table-directory.  We combine the address region</span>
<span class="cm"> * (the high order N bits) and the pgd portion of the address.</span>
<span class="cm"> */</span>
<span class="cm">/* to avoid overflow in free_pgtables we don&#39;t use PTRS_PER_PGD here */</span>
<span class="cp">#define pgd_index(address) (((address) &gt;&gt; (PGDIR_SHIFT)) &amp; 0x1ff)</span>

<span class="cp">#define pgd_offset(mm, address)	 ((mm)-&gt;pgd + pgd_index(address))</span>

<span class="cp">#define pmd_offset(pudp,addr) \</span>
<span class="cp">  (((pmd_t *) pud_page_vaddr(*(pudp))) + (((addr) &gt;&gt; PMD_SHIFT) &amp; (PTRS_PER_PMD - 1)))</span>

<span class="cp">#define pte_offset_kernel(dir,addr) \</span>
<span class="cp">  (((pte_t *) pmd_page_vaddr(*(dir))) + (((addr) &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1)))</span>

<span class="cp">#define pte_offset_map(dir,addr)	pte_offset_kernel((dir), (addr))</span>
<span class="cp">#define pte_unmap(pte)			do { } while(0)</span>

<span class="cm">/* to find an entry in a kernel page-table-directory */</span>
<span class="cm">/* This now only contains the vmalloc pages */</span>
<span class="cp">#define pgd_offset_k(address) pgd_offset(&amp;init_mm, address)</span>


<span class="cm">/* Atomic PTE updates */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">pte_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				       <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clr</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">huge</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef PTE_ATOMIC_UPDATES</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
	<span class="s">&quot;1:	ldarx	%0,0,%3		# pte_update</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	andi.	%1,%0,%6</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	bne-	1b </span><span class="se">\n</span><span class="s">\</span>
<span class="s">	andc	%1,%0,%4 </span><span class="se">\n</span><span class="s">\</span>
<span class="s">	stdcx.	%1,0,%3 </span><span class="se">\n</span><span class="s">\</span>
<span class="s">	bne-	1b&quot;</span>
	<span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">old</span><span class="p">),</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
	<span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">ptep</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">clr</span><span class="p">),</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">_PAGE_BUSY</span><span class="p">)</span>
	<span class="o">:</span> <span class="s">&quot;cc&quot;</span> <span class="p">);</span>
<span class="cp">#else</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">);</span>
	<span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">__pte</span><span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">clr</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/* huge pages use the old page table lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">huge</span><span class="p">)</span>
		<span class="n">assert_pte_locked</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC_STD_MMU_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">_PAGE_HASHPTE</span><span class="p">)</span>
		<span class="n">hpte_need_flush</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">huge</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__ptep_test_and_clear_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old</span><span class="p">;</span>

       	<span class="k">if</span> <span class="p">((</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_PAGE_ACCESSED</span> <span class="o">|</span> <span class="n">_PAGE_HASHPTE</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">old</span> <span class="o">=</span> <span class="n">pte_update</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">_PAGE_ACCESSED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">_PAGE_ACCESSED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define __HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG</span>
<span class="cp">#define ptep_test_and_clear_young(__vma, __addr, __ptep)		   \</span>
<span class="cp">({									   \</span>
<span class="cp">	int __r;							   \</span>
<span class="cp">	__r = __ptep_test_and_clear_young((__vma)-&gt;vm_mm, __addr, __ptep); \</span>
<span class="cp">	__r;								   \</span>
<span class="cp">})</span>

<span class="cp">#define __HAVE_ARCH_PTEP_SET_WRPROTECT</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ptep_set_wrprotect</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				      <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_RW</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pte_update</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">_PAGE_RW</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">huge_ptep_set_wrprotect</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_RW</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pte_update</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">_PAGE_RW</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We currently remove entries from the hashtable regardless of whether</span>
<span class="cm"> * the entry was young or dirty. The generic routines only flush if the</span>
<span class="cm"> * entry was young or dirty which is not good enough.</span>
<span class="cm"> *</span>
<span class="cm"> * We should be more intelligent about this but for the moment we override</span>
<span class="cm"> * these functions and force a tlb flush unconditionally</span>
<span class="cm"> */</span>
<span class="cp">#define __HAVE_ARCH_PTEP_CLEAR_YOUNG_FLUSH</span>
<span class="cp">#define ptep_clear_flush_young(__vma, __address, __ptep)		\</span>
<span class="cp">({									\</span>
<span class="cp">	int __young = __ptep_test_and_clear_young((__vma)-&gt;vm_mm, __address, \</span>
<span class="cp">						  __ptep);		\</span>
<span class="cp">	__young;							\</span>
<span class="cp">})</span>

<span class="cp">#define __HAVE_ARCH_PTEP_GET_AND_CLEAR</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">ptep_get_and_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old</span> <span class="o">=</span> <span class="n">pte_update</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pte_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			     <span class="n">pte_t</span> <span class="o">*</span> <span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_update</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Set the dirty and/or accessed bits atomically in a linux PTE, this</span>
<span class="cm"> * function doesn&#39;t need to flush the hash entry</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__ptep_set_access_flags</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="p">(</span><span class="n">_PAGE_DIRTY</span> <span class="o">|</span> <span class="n">_PAGE_ACCESSED</span> <span class="o">|</span> <span class="n">_PAGE_RW</span> <span class="o">|</span> <span class="n">_PAGE_EXEC</span><span class="p">);</span>

<span class="cp">#ifdef PTE_ATOMIC_UPDATES</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
	<span class="s">&quot;1:	ldarx	%0,0,%4</span><span class="se">\n</span><span class="s">\</span>
<span class="s">		andi.	%1,%0,%6</span><span class="se">\n</span><span class="s">\</span>
<span class="s">		bne-	1b </span><span class="se">\n</span><span class="s">\</span>
<span class="s">		or	%0,%3,%0</span><span class="se">\n</span><span class="s">\</span>
<span class="s">		stdcx.	%0,0,%4</span><span class="se">\n</span><span class="s">\</span>
<span class="s">		bne-	1b&quot;</span>
	<span class="o">:</span><span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">old</span><span class="p">),</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
	<span class="o">:</span><span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">bits</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">ptep</span><span class="p">),</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">_PAGE_BUSY</span><span class="p">)</span>
	<span class="o">:</span><span class="s">&quot;cc&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">);</span>
	<span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">__pte</span><span class="p">(</span><span class="n">old</span> <span class="o">|</span> <span class="n">bits</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#define __HAVE_ARCH_PTE_SAME</span>
<span class="cp">#define pte_same(A,B)	(((pte_val(A) ^ pte_val(B)) &amp; ~_PAGE_HPTEFLAGS) == 0)</span>

<span class="cp">#define pte_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pte %08lx.\n&quot;, __FILE__, __LINE__, pte_val(e))</span>
<span class="cp">#define pmd_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pmd %08lx.\n&quot;, __FILE__, __LINE__, pmd_val(e))</span>
<span class="cp">#define pgd_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pgd %08lx.\n&quot;, __FILE__, __LINE__, pgd_val(e))</span>

<span class="cm">/* Encode and de-code a swap entry */</span>
<span class="cp">#define __swp_type(entry)	(((entry).val &gt;&gt; 1) &amp; 0x3f)</span>
<span class="cp">#define __swp_offset(entry)	((entry).val &gt;&gt; 8)</span>
<span class="cp">#define __swp_entry(type, offset) ((swp_entry_t){((type)&lt;&lt; 1)|((offset)&lt;&lt;8)})</span>
<span class="cp">#define __pte_to_swp_entry(pte)	((swp_entry_t){pte_val(pte) &gt;&gt; PTE_RPN_SHIFT})</span>
<span class="cp">#define __swp_entry_to_pte(x)	((pte_t) { (x).val &lt;&lt; PTE_RPN_SHIFT })</span>
<span class="cp">#define pte_to_pgoff(pte)	(pte_val(pte) &gt;&gt; PTE_RPN_SHIFT)</span>
<span class="cp">#define pgoff_to_pte(off)	((pte_t) {((off) &lt;&lt; PTE_RPN_SHIFT)|_PAGE_FILE})</span>
<span class="cp">#define PTE_FILE_MAX_BITS	(BITS_PER_LONG - PTE_RPN_SHIFT)</span>

<span class="kt">void</span> <span class="n">pgtable_cache_add</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">shift</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ctor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">void</span> <span class="n">pgtable_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * find_linux_pte returns the address of a linux pte for a given</span>
<span class="cm"> * effective address and directory.  If not found, it returns zero.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="o">*</span><span class="nf">find_linux_pte</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ea</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pu</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pm</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pg</span> <span class="o">=</span> <span class="n">pgdir</span> <span class="o">+</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">ea</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pu</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pg</span><span class="p">,</span> <span class="n">ea</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pm</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pu</span><span class="p">,</span> <span class="n">ea</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pm</span><span class="p">))</span>
				<span class="n">pt</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pm</span><span class="p">,</span> <span class="n">ea</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
<span class="n">pte_t</span> <span class="o">*</span><span class="n">find_linux_pte_or_hugepte</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ea</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="o">*</span><span class="n">shift</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="o">*</span><span class="nf">find_linux_pte_or_hugepte</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ea</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="o">*</span><span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shift</span><span class="p">)</span>
		<span class="o">*</span><span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">find_linux_pte</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">ea</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_HUGETLB_PAGE */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_POWERPC_PGTABLE_PPC64_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
