<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › epapr_hcalls.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>epapr_hcalls.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * ePAPR hcall interface</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2008-2011 Freescale Semiconductor, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Timur Tabi &lt;timur@freescale.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is provided under a dual BSD/GPL license.  When using or</span>
<span class="cm"> * redistributing this file, you may do so under either license.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions are met:</span>
<span class="cm"> *     * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *       notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *     * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *       notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *       documentation and/or other materials provided with the distribution.</span>
<span class="cm"> *     * Neither the name of Freescale Semiconductor nor the</span>
<span class="cm"> *       names of its contributors may be used to endorse or promote products</span>
<span class="cm"> *       derived from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * ALTERNATIVELY, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) as published by the Free Software</span>
<span class="cm"> * Foundation, either version 2 of that License or (at your option) any</span>
<span class="cm"> * later version.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS&#39;&#39; AND ANY</span>
<span class="cm"> * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="cm"> * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY</span>
<span class="cm"> * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<span class="cm"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="cm"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<span class="cm"> * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="cm"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cm">/* A &quot;hypercall&quot; is an &quot;sc 1&quot; instruction.  This header file file provides C</span>
<span class="cm"> * wrapper functions for the ePAPR hypervisor interface.  It is inteded</span>
<span class="cm"> * for use by Linux device drivers and other operating systems.</span>
<span class="cm"> *</span>
<span class="cm"> * The hypercalls are implemented as inline assembly, rather than assembly</span>
<span class="cm"> * language functions in a .S file, for optimization.  It allows</span>
<span class="cm"> * the caller to issue the hypercall instruction directly, improving both</span>
<span class="cm"> * performance and memory footprint.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _EPAPR_HCALLS_H</span>
<span class="cp">#define _EPAPR_HCALLS_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#define EV_BYTE_CHANNEL_SEND		1</span>
<span class="cp">#define EV_BYTE_CHANNEL_RECEIVE		2</span>
<span class="cp">#define EV_BYTE_CHANNEL_POLL		3</span>
<span class="cp">#define EV_INT_SET_CONFIG		4</span>
<span class="cp">#define EV_INT_GET_CONFIG		5</span>
<span class="cp">#define EV_INT_SET_MASK			6</span>
<span class="cp">#define EV_INT_GET_MASK			7</span>
<span class="cp">#define EV_INT_IACK			9</span>
<span class="cp">#define EV_INT_EOI			10</span>
<span class="cp">#define EV_INT_SEND_IPI			11</span>
<span class="cp">#define EV_INT_SET_TASK_PRIORITY	12</span>
<span class="cp">#define EV_INT_GET_TASK_PRIORITY	13</span>
<span class="cp">#define EV_DOORBELL_SEND		14</span>
<span class="cp">#define EV_MSGSND			15</span>
<span class="cp">#define EV_IDLE				16</span>

<span class="cm">/* vendor ID: epapr */</span>
<span class="cp">#define EV_LOCAL_VENDOR_ID		0	</span><span class="cm">/* for private use */</span><span class="cp"></span>
<span class="cp">#define EV_EPAPR_VENDOR_ID		1</span>
<span class="cp">#define EV_FSL_VENDOR_ID		2	</span><span class="cm">/* Freescale Semiconductor */</span><span class="cp"></span>
<span class="cp">#define EV_IBM_VENDOR_ID		3	</span><span class="cm">/* IBM */</span><span class="cp"></span>
<span class="cp">#define EV_GHS_VENDOR_ID		4	</span><span class="cm">/* Green Hills Software */</span><span class="cp"></span>
<span class="cp">#define EV_ENEA_VENDOR_ID		5	</span><span class="cm">/* Enea */</span><span class="cp"></span>
<span class="cp">#define EV_WR_VENDOR_ID			6	</span><span class="cm">/* Wind River Systems */</span><span class="cp"></span>
<span class="cp">#define EV_AMCC_VENDOR_ID		7	</span><span class="cm">/* Applied Micro Circuits */</span><span class="cp"></span>
<span class="cp">#define EV_KVM_VENDOR_ID		42	</span><span class="cm">/* KVM */</span><span class="cp"></span>

<span class="cm">/* The max number of bytes that a byte channel can send or receive per call */</span>
<span class="cp">#define EV_BYTE_CHANNEL_MAX_BYTES	16</span>


<span class="cp">#define _EV_HCALL_TOKEN(id, num) (((id) &lt;&lt; 16) | (num))</span>
<span class="cp">#define EV_HCALL_TOKEN(hcall_num) _EV_HCALL_TOKEN(EV_EPAPR_VENDOR_ID, hcall_num)</span>

<span class="cm">/* epapr error codes */</span>
<span class="cp">#define EV_EPERM		1	</span><span class="cm">/* Operation not permitted */</span><span class="cp"></span>
<span class="cp">#define EV_ENOENT		2	</span><span class="cm">/*  Entry Not Found */</span><span class="cp"></span>
<span class="cp">#define EV_EIO			3	</span><span class="cm">/* I/O error occured */</span><span class="cp"></span>
<span class="cp">#define EV_EAGAIN		4	</span><span class="cm">/* The operation had insufficient</span>
<span class="cm">					 * resources to complete and should be</span>
<span class="cm">					 * retried</span>
<span class="cm">					 */</span><span class="cp"></span>
<span class="cp">#define EV_ENOMEM		5	</span><span class="cm">/* There was insufficient memory to</span>
<span class="cm">					 * complete the operation */</span><span class="cp"></span>
<span class="cp">#define EV_EFAULT		6	</span><span class="cm">/* Bad guest address */</span><span class="cp"></span>
<span class="cp">#define EV_ENODEV		7	</span><span class="cm">/* No such device */</span><span class="cp"></span>
<span class="cp">#define EV_EINVAL		8	</span><span class="cm">/* An argument supplied to the hcall</span>
<span class="cm">					   was out of range or invalid */</span><span class="cp"></span>
<span class="cp">#define EV_INTERNAL		9	</span><span class="cm">/* An internal error occured */</span><span class="cp"></span>
<span class="cp">#define EV_CONFIG		10	</span><span class="cm">/* A configuration error was detected */</span><span class="cp"></span>
<span class="cp">#define EV_INVALID_STATE	11	</span><span class="cm">/* The object is in an invalid state */</span><span class="cp"></span>
<span class="cp">#define EV_UNIMPLEMENTED	12	</span><span class="cm">/* Unimplemented hypercall */</span><span class="cp"></span>
<span class="cp">#define EV_BUFFER_OVERFLOW	13	</span><span class="cm">/* Caller-supplied buffer too small */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Hypercall register clobber list</span>
<span class="cm"> *</span>
<span class="cm"> * These macros are used to define the list of clobbered registers during a</span>
<span class="cm"> * hypercall.  Technically, registers r0 and r3-r12 are always clobbered,</span>
<span class="cm"> * but the gcc inline assembly syntax does not allow us to specify registers</span>
<span class="cm"> * on the clobber list that are also on the input/output list.  Therefore,</span>
<span class="cm"> * the lists of clobbered registers depends on the number of register</span>
<span class="cm"> * parmeters (&quot;+r&quot; and &quot;=r&quot;) passed to the hypercall.</span>
<span class="cm"> *</span>
<span class="cm"> * Each assembly block should use one of the HCALL_CLOBBERSx macros.  As a</span>
<span class="cm"> * general rule, &#39;x&#39; is the number of parameters passed to the assembly</span>
<span class="cm"> * block *except* for r11.</span>
<span class="cm"> *</span>
<span class="cm"> * If you&#39;re not sure, just use the smallest value of &#39;x&#39; that does not</span>
<span class="cm"> * generate a compilation error.  Because these are static inline functions,</span>
<span class="cm"> * the compiler will only check the clobber list for a function if you</span>
<span class="cm"> * compile code that calls that function.</span>
<span class="cm"> *</span>
<span class="cm"> * r3 and r11 are not included in any clobbers list because they are always</span>
<span class="cm"> * listed as output registers.</span>
<span class="cm"> *</span>
<span class="cm"> * XER, CTR, and LR are currently listed as clobbers because it&#39;s uncertain</span>
<span class="cm"> * whether they will be clobbered.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that r11 can be used as an output parameter.</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;memory&quot; clobber is only necessary for hcalls where the Hypervisor</span>
<span class="cm"> * will read or write guest memory. However, we add it to all hcalls because</span>
<span class="cm"> * the impact is minimal, and we want to ensure that it&#39;s present for the</span>
<span class="cm"> * hcalls that need it.</span>
<span class="cm">*/</span>

<span class="cm">/* List of common clobbered registers.  Do not use this macro. */</span>
<span class="cp">#define EV_HCALL_CLOBBERS &quot;r0&quot;, &quot;r12&quot;, &quot;xer&quot;, &quot;ctr&quot;, &quot;lr&quot;, &quot;cc&quot;, &quot;memory&quot;</span>

<span class="cp">#define EV_HCALL_CLOBBERS8 EV_HCALL_CLOBBERS</span>
<span class="cp">#define EV_HCALL_CLOBBERS7 EV_HCALL_CLOBBERS8, &quot;r10&quot;</span>
<span class="cp">#define EV_HCALL_CLOBBERS6 EV_HCALL_CLOBBERS7, &quot;r9&quot;</span>
<span class="cp">#define EV_HCALL_CLOBBERS5 EV_HCALL_CLOBBERS6, &quot;r8&quot;</span>
<span class="cp">#define EV_HCALL_CLOBBERS4 EV_HCALL_CLOBBERS5, &quot;r7&quot;</span>
<span class="cp">#define EV_HCALL_CLOBBERS3 EV_HCALL_CLOBBERS4, &quot;r6&quot;</span>
<span class="cp">#define EV_HCALL_CLOBBERS2 EV_HCALL_CLOBBERS3, &quot;r5&quot;</span>
<span class="cp">#define EV_HCALL_CLOBBERS1 EV_HCALL_CLOBBERS2, &quot;r4&quot;</span>


<span class="cm">/*</span>
<span class="cm"> * We use &quot;uintptr_t&quot; to define a register because it&#39;s guaranteed to be a</span>
<span class="cm"> * 32-bit integer on a 32-bit platform, and a 64-bit integer on a 64-bit</span>
<span class="cm"> * platform.</span>
<span class="cm"> *</span>
<span class="cm"> * All registers are either input/output or output only.  Registers that are</span>
<span class="cm"> * initialized before making the hypercall are input/output.  All</span>
<span class="cm"> * input/output registers are represented with &quot;+r&quot;.  Output-only registers</span>
<span class="cm"> * are represented with &quot;=r&quot;.  Do not specify any unused registers.  The</span>
<span class="cm"> * clobber list will tell the compiler that the hypercall modifies those</span>
<span class="cm"> * registers, which is good enough.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ev_int_set_config - configure the specified interrupt</span>
<span class="cm"> * @interrupt: the interrupt number</span>
<span class="cm"> * @config: configuration for this interrupt</span>
<span class="cm"> * @priority: interrupt priority</span>
<span class="cm"> * @destination: destination CPU number</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ev_int_set_config</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">interrupt</span><span class="p">,</span>
	<span class="kt">uint32_t</span> <span class="n">config</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">destination</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r5</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r5&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r6</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r6&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">EV_HCALL_TOKEN</span><span class="p">(</span><span class="n">EV_INT_SET_CONFIG</span><span class="p">);</span>
	<span class="n">r3</span>  <span class="o">=</span> <span class="n">interrupt</span><span class="p">;</span>
	<span class="n">r4</span>  <span class="o">=</span> <span class="n">config</span><span class="p">;</span>
	<span class="n">r5</span>  <span class="o">=</span> <span class="n">priority</span><span class="p">;</span>
	<span class="n">r6</span>  <span class="o">=</span> <span class="n">destination</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r5</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r6</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS4</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ev_int_get_config - return the config of the specified interrupt</span>
<span class="cm"> * @interrupt: the interrupt number</span>
<span class="cm"> * @config: returned configuration for this interrupt</span>
<span class="cm"> * @priority: returned interrupt priority</span>
<span class="cm"> * @destination: returned destination CPU number</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ev_int_get_config</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">interrupt</span><span class="p">,</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">config</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">priority</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">destination</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r5</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r5&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r6</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r6&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">EV_HCALL_TOKEN</span><span class="p">(</span><span class="n">EV_INT_GET_CONFIG</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">interrupt</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">r5</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">r6</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS4</span>
	<span class="p">);</span>

	<span class="o">*</span><span class="n">config</span> <span class="o">=</span> <span class="n">r4</span><span class="p">;</span>
	<span class="o">*</span><span class="n">priority</span> <span class="o">=</span> <span class="n">r5</span><span class="p">;</span>
	<span class="o">*</span><span class="n">destination</span> <span class="o">=</span> <span class="n">r6</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ev_int_set_mask - sets the mask for the specified interrupt source</span>
<span class="cm"> * @interrupt: the interrupt number</span>
<span class="cm"> * @mask: 0=enable interrupts, 1=disable interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ev_int_set_mask</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">interrupt</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">EV_HCALL_TOKEN</span><span class="p">(</span><span class="n">EV_INT_SET_MASK</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">interrupt</span><span class="p">;</span>
	<span class="n">r4</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS2</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ev_int_get_mask - returns the mask for the specified interrupt source</span>
<span class="cm"> * @interrupt: the interrupt number</span>
<span class="cm"> * @mask: returned mask for this interrupt (0=enabled, 1=disabled)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ev_int_get_mask</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">interrupt</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">EV_HCALL_TOKEN</span><span class="p">(</span><span class="n">EV_INT_GET_MASK</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">interrupt</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS2</span>
	<span class="p">);</span>

	<span class="o">*</span><span class="n">mask</span> <span class="o">=</span> <span class="n">r4</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ev_int_eoi - signal the end of interrupt processing</span>
<span class="cm"> * @interrupt: the interrupt number</span>
<span class="cm"> *</span>
<span class="cm"> * This function signals the end of processing for the the specified</span>
<span class="cm"> * interrupt, which must be the interrupt currently in service. By</span>
<span class="cm"> * definition, this is also the highest-priority interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ev_int_eoi</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">interrupt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">EV_HCALL_TOKEN</span><span class="p">(</span><span class="n">EV_INT_EOI</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">interrupt</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS1</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ev_byte_channel_send - send characters to a byte stream</span>
<span class="cm"> * @handle: byte stream handle</span>
<span class="cm"> * @count: (input) num of chars to send, (output) num chars sent</span>
<span class="cm"> * @buffer: pointer to a 16-byte buffer</span>
<span class="cm"> *</span>
<span class="cm"> * @buffer must be at least 16 bytes long, because all 16 bytes will be</span>
<span class="cm"> * read from memory into registers, even if count &lt; 16.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ev_byte_channel_send</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handle</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">EV_BYTE_CHANNEL_MAX_BYTES</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r5</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r5&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r6</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r6&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r7</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r7&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r8</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r8&quot;</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">buffer</span><span class="p">;</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">EV_HCALL_TOKEN</span><span class="p">(</span><span class="n">EV_BYTE_CHANNEL_SEND</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">r4</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>
	<span class="n">r5</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">r6</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">r7</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">r8</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span>
		  <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r5</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r6</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r7</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r8</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS6</span>
	<span class="p">);</span>

	<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">r4</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ev_byte_channel_receive - fetch characters from a byte channel</span>
<span class="cm"> * @handle: byte channel handle</span>
<span class="cm"> * @count: (input) max num of chars to receive, (output) num chars received</span>
<span class="cm"> * @buffer: pointer to a 16-byte buffer</span>
<span class="cm"> *</span>
<span class="cm"> * The size of @buffer must be at least 16 bytes, even if you request fewer</span>
<span class="cm"> * than 16 characters, because we always write 16 bytes to @buffer.  This is</span>
<span class="cm"> * for performance reasons.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ev_byte_channel_receive</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handle</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">EV_BYTE_CHANNEL_MAX_BYTES</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r5</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r5&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r6</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r6&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r7</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r7&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r8</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r8&quot;</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">buffer</span><span class="p">;</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">EV_HCALL_TOKEN</span><span class="p">(</span><span class="n">EV_BYTE_CHANNEL_RECEIVE</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">r4</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">),</span>
		  <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">r5</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">r6</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">r7</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">r8</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS6</span>
	<span class="p">);</span>

	<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">r4</span><span class="p">;</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">r5</span><span class="p">);</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">r6</span><span class="p">);</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">r7</span><span class="p">);</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">r8</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ev_byte_channel_poll - returns the status of the byte channel buffers</span>
<span class="cm"> * @handle: byte channel handle</span>
<span class="cm"> * @rx_count: returned count of bytes in receive queue</span>
<span class="cm"> * @tx_count: returned count of free space in transmit queue</span>
<span class="cm"> *</span>
<span class="cm"> * This function reports the amount of data in the receive queue (i.e. the</span>
<span class="cm"> * number of bytes you can read), and the amount of free space in the transmit</span>
<span class="cm"> * queue (i.e. the number of bytes you can write).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ev_byte_channel_poll</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handle</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rx_count</span><span class="p">,</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">tx_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r5</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r5&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">EV_HCALL_TOKEN</span><span class="p">(</span><span class="n">EV_BYTE_CHANNEL_POLL</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">r5</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS3</span>
	<span class="p">);</span>

	<span class="o">*</span><span class="n">rx_count</span> <span class="o">=</span> <span class="n">r4</span><span class="p">;</span>
	<span class="o">*</span><span class="n">tx_count</span> <span class="o">=</span> <span class="n">r5</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ev_int_iack - acknowledge an interrupt</span>
<span class="cm"> * @handle: handle to the target interrupt controller</span>
<span class="cm"> * @vector: returned interrupt vector</span>
<span class="cm"> *</span>
<span class="cm"> * If handle is zero, the function returns the next interrupt source</span>
<span class="cm"> * number to be handled irrespective of the hierarchy or cascading</span>
<span class="cm"> * of interrupt controllers. If non-zero, specifies a handle to the</span>
<span class="cm"> * interrupt controller that is the target of the acknowledge.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ev_int_iack</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handle</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">EV_HCALL_TOKEN</span><span class="p">(</span><span class="n">EV_INT_IACK</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS2</span>
	<span class="p">);</span>

	<span class="o">*</span><span class="n">vector</span> <span class="o">=</span> <span class="n">r4</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ev_doorbell_send - send a doorbell to another partition</span>
<span class="cm"> * @handle: doorbell send handle</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ev_doorbell_send</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">EV_HCALL_TOKEN</span><span class="p">(</span><span class="n">EV_DOORBELL_SEND</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS1</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ev_idle -- wait for next interrupt on this core</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ev_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">EV_HCALL_TOKEN</span><span class="p">(</span><span class="n">EV_IDLE</span><span class="p">);</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS1</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
