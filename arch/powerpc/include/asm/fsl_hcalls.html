<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › fsl_hcalls.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>fsl_hcalls.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Freescale hypervisor call interface</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2008-2010 Freescale Semiconductor, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Timur Tabi &lt;timur@freescale.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is provided under a dual BSD/GPL license.  When using or</span>
<span class="cm"> * redistributing this file, you may do so under either license.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions are met:</span>
<span class="cm"> *     * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *       notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *     * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *       notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *       documentation and/or other materials provided with the distribution.</span>
<span class="cm"> *     * Neither the name of Freescale Semiconductor nor the</span>
<span class="cm"> *       names of its contributors may be used to endorse or promote products</span>
<span class="cm"> *       derived from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * ALTERNATIVELY, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) as published by the Free Software</span>
<span class="cm"> * Foundation, either version 2 of that License or (at your option) any</span>
<span class="cm"> * later version.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS&#39;&#39; AND ANY</span>
<span class="cm"> * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="cm"> * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY</span>
<span class="cm"> * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<span class="cm"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="cm"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<span class="cm"> * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="cm"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _FSL_HCALLS_H</span>
<span class="cp">#define _FSL_HCALLS_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/epapr_hcalls.h&gt;</span>

<span class="cp">#define FH_API_VERSION			1</span>

<span class="cp">#define FH_ERR_GET_INFO			1</span>
<span class="cp">#define FH_PARTITION_GET_DTPROP		2</span>
<span class="cp">#define FH_PARTITION_SET_DTPROP		3</span>
<span class="cp">#define FH_PARTITION_RESTART		4</span>
<span class="cp">#define FH_PARTITION_GET_STATUS		5</span>
<span class="cp">#define FH_PARTITION_START		6</span>
<span class="cp">#define FH_PARTITION_STOP		7</span>
<span class="cp">#define FH_PARTITION_MEMCPY		8</span>
<span class="cp">#define FH_DMA_ENABLE			9</span>
<span class="cp">#define FH_DMA_DISABLE			10</span>
<span class="cp">#define FH_SEND_NMI			11</span>
<span class="cp">#define FH_VMPIC_GET_MSIR		12</span>
<span class="cp">#define FH_SYSTEM_RESET			13</span>
<span class="cp">#define FH_GET_CORE_STATE		14</span>
<span class="cp">#define FH_ENTER_NAP			15</span>
<span class="cp">#define FH_EXIT_NAP			16</span>
<span class="cp">#define FH_CLAIM_DEVICE			17</span>
<span class="cp">#define FH_PARTITION_STOP_DMA		18</span>

<span class="cm">/* vendor ID: Freescale Semiconductor */</span>
<span class="cp">#define FH_HCALL_TOKEN(num)		_EV_HCALL_TOKEN(EV_FSL_VENDOR_ID, num)</span>

<span class="cm">/*</span>
<span class="cm"> * We use &quot;uintptr_t&quot; to define a register because it&#39;s guaranteed to be a</span>
<span class="cm"> * 32-bit integer on a 32-bit platform, and a 64-bit integer on a 64-bit</span>
<span class="cm"> * platform.</span>
<span class="cm"> *</span>
<span class="cm"> * All registers are either input/output or output only.  Registers that are</span>
<span class="cm"> * initialized before making the hypercall are input/output.  All</span>
<span class="cm"> * input/output registers are represented with &quot;+r&quot;.  Output-only registers</span>
<span class="cm"> * are represented with &quot;=r&quot;.  Do not specify any unused registers.  The</span>
<span class="cm"> * clobber list will tell the compiler that the hypercall modifies those</span>
<span class="cm"> * registers, which is good enough.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * fh_send_nmi - send NMI to virtual cpu(s).</span>
<span class="cm"> * @vcpu_mask: send NMI to virtual cpu(s) specified by this mask.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or EINVAL for invalid vcpu_mask.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_send_nmi</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vcpu_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_SEND_NMI</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">vcpu_mask</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS1</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Arbitrary limits to avoid excessive memory allocation in hypervisor */</span>
<span class="cp">#define FH_DTPROP_MAX_PATHLEN 4096</span>
<span class="cp">#define FH_DTPROP_MAX_PROPLEN 32768</span>

<span class="cm">/**</span>
<span class="cm"> * fh_partiton_get_dtprop - get a property from a guest device tree.</span>
<span class="cm"> * @handle: handle of partition whose device tree is to be accessed</span>
<span class="cm"> * @dtpath_addr: physical address of device tree path to access</span>
<span class="cm"> * @propname_addr: physical address of name of property</span>
<span class="cm"> * @propvalue_addr: physical address of property value buffer</span>
<span class="cm"> * @propvalue_len: length of buffer on entry, length of property on return</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, non-zero on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_partition_get_dtprop</span><span class="p">(</span><span class="kt">int</span> <span class="n">handle</span><span class="p">,</span>
						   <span class="kt">uint64_t</span> <span class="n">dtpath_addr</span><span class="p">,</span>
						   <span class="kt">uint64_t</span> <span class="n">propname_addr</span><span class="p">,</span>
						   <span class="kt">uint64_t</span> <span class="n">propvalue_addr</span><span class="p">,</span>
						   <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">propvalue_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r5</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r5&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r6</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r6&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r7</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r7&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r8</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r8&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r9</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r9&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r10</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r10&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_PARTITION_GET_DTPROP</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PHYS_64BIT</span>
	<span class="n">r4</span> <span class="o">=</span> <span class="n">dtpath_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">r6</span> <span class="o">=</span> <span class="n">propname_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">r8</span> <span class="o">=</span> <span class="n">propvalue_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">r4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">r6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">r8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">r5</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">dtpath_addr</span><span class="p">;</span>
	<span class="n">r7</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">propname_addr</span><span class="p">;</span>
	<span class="n">r9</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">propvalue_addr</span><span class="p">;</span>
	<span class="n">r10</span> <span class="o">=</span> <span class="o">*</span><span class="n">propvalue_len</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span>
		  <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r5</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r6</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r7</span><span class="p">),</span>
		  <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r8</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r9</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r10</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS8</span>
	<span class="p">);</span>

	<span class="o">*</span><span class="n">propvalue_len</span> <span class="o">=</span> <span class="n">r4</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Set a property in a guest device tree.</span>
<span class="cm"> * @handle: handle of partition whose device tree is to be accessed</span>
<span class="cm"> * @dtpath_addr: physical address of device tree path to access</span>
<span class="cm"> * @propname_addr: physical address of name of property</span>
<span class="cm"> * @propvalue_addr: physical address of property value</span>
<span class="cm"> * @propvalue_len: length of property</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, non-zero on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_partition_set_dtprop</span><span class="p">(</span><span class="kt">int</span> <span class="n">handle</span><span class="p">,</span>
						   <span class="kt">uint64_t</span> <span class="n">dtpath_addr</span><span class="p">,</span>
						   <span class="kt">uint64_t</span> <span class="n">propname_addr</span><span class="p">,</span>
						   <span class="kt">uint64_t</span> <span class="n">propvalue_addr</span><span class="p">,</span>
						   <span class="kt">uint32_t</span> <span class="n">propvalue_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r6</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r6&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r8</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r8&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r5</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r5&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r7</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r7&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r9</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r9&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r10</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r10&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_PARTITION_SET_DTPROP</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PHYS_64BIT</span>
	<span class="n">r4</span> <span class="o">=</span> <span class="n">dtpath_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">r6</span> <span class="o">=</span> <span class="n">propname_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">r8</span> <span class="o">=</span> <span class="n">propvalue_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">r4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">r6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">r8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">r5</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">dtpath_addr</span><span class="p">;</span>
	<span class="n">r7</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">propname_addr</span><span class="p">;</span>
	<span class="n">r9</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">propvalue_addr</span><span class="p">;</span>
	<span class="n">r10</span> <span class="o">=</span> <span class="n">propvalue_len</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span>
		  <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r5</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r6</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r7</span><span class="p">),</span>
		  <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r8</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r9</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r10</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS8</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fh_partition_restart - reboot the current partition</span>
<span class="cm"> * @partition: partition ID</span>
<span class="cm"> *</span>
<span class="cm"> * Returns an error code if reboot failed.  Does not return if it succeeds.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_partition_restart</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">partition</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_PARTITION_RESTART</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">partition</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS1</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define FH_PARTITION_STOPPED	0</span>
<span class="cp">#define FH_PARTITION_RUNNING	1</span>
<span class="cp">#define FH_PARTITION_STARTING	2</span>
<span class="cp">#define FH_PARTITION_STOPPING	3</span>
<span class="cp">#define FH_PARTITION_PAUSING	4</span>
<span class="cp">#define FH_PARTITION_PAUSED	5</span>
<span class="cp">#define FH_PARTITION_RESUMING	6</span>

<span class="cm">/**</span>
<span class="cm"> * fh_partition_get_status - gets the status of a partition</span>
<span class="cm"> * @partition: partition ID</span>
<span class="cm"> * @status: returned status code</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_partition_get_status</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">partition</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_PARTITION_GET_STATUS</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">partition</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS2</span>
	<span class="p">);</span>

	<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">r4</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fh_partition_start - boots and starts execution of the specified partition</span>
<span class="cm"> * @partition: partition ID</span>
<span class="cm"> * @entry_point: guest physical address to start execution</span>
<span class="cm"> *</span>
<span class="cm"> * The hypervisor creates a 1-to-1 virtual/physical IMA mapping, so at boot</span>
<span class="cm"> * time, guest physical address are the same as guest virtual addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_partition_start</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">partition</span><span class="p">,</span>
	<span class="kt">uint32_t</span> <span class="n">entry_point</span><span class="p">,</span> <span class="kt">int</span> <span class="n">load</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r5</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r5&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_PARTITION_START</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">partition</span><span class="p">;</span>
	<span class="n">r4</span> <span class="o">=</span> <span class="n">entry_point</span><span class="p">;</span>
	<span class="n">r5</span> <span class="o">=</span> <span class="n">load</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r5</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS3</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fh_partition_stop - stops another partition</span>
<span class="cm"> * @partition: partition ID</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_partition_stop</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">partition</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_PARTITION_STOP</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">partition</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS1</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct fh_sg_list: definition of the fh_partition_memcpy S/G list</span>
<span class="cm"> * @source: guest physical address to copy from</span>
<span class="cm"> * @target: guest physical address to copy to</span>
<span class="cm"> * @size: number of bytes to copy</span>
<span class="cm"> * @reserved: reserved, must be zero</span>
<span class="cm"> *</span>
<span class="cm"> * The scatter/gather list for fh_partition_memcpy() is an array of these</span>
<span class="cm"> * structures.  The array must be guest physically contiguous.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure must be aligned on 32-byte boundary, so that no single</span>
<span class="cm"> * strucuture can span two pages.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fh_sg_list</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">source</span><span class="p">;</span>   <span class="cm">/**&lt; guest physical address to copy from */</span>
	<span class="kt">uint64_t</span> <span class="n">target</span><span class="p">;</span>   <span class="cm">/**&lt; guest physical address to copy to */</span>
	<span class="kt">uint64_t</span> <span class="n">size</span><span class="p">;</span>     <span class="cm">/**&lt; number of bytes to copy */</span>
	<span class="kt">uint64_t</span> <span class="n">reserved</span><span class="p">;</span> <span class="cm">/**&lt; reserved, must be zero */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">32</span><span class="p">)));</span>

<span class="cm">/**</span>
<span class="cm"> * fh_partition_memcpy - copies data from one guest to another</span>
<span class="cm"> * @source: the ID of the partition to copy from</span>
<span class="cm"> * @target: the ID of the partition to copy to</span>
<span class="cm"> * @sg_list: guest physical address of an array of &amp;fh_sg_list structures</span>
<span class="cm"> * @count: the number of entries in @sg_list</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_partition_memcpy</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">source</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">phys_addr_t</span> <span class="n">sg_list</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r5</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r5&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r6</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r6&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r7</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r7&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_PARTITION_MEMCPY</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">source</span><span class="p">;</span>
	<span class="n">r4</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
	<span class="n">r5</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">sg_list</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PHYS_64BIT</span>
	<span class="n">r6</span> <span class="o">=</span> <span class="n">sg_list</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">r6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">r7</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span>
		  <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r5</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r6</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r7</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS5</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fh_dma_enable - enable DMA for the specified device</span>
<span class="cm"> * @liodn: the LIODN of the I/O device for which to enable DMA</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_dma_enable</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">liodn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_DMA_ENABLE</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">liodn</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS1</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fh_dma_disable - disable DMA for the specified device</span>
<span class="cm"> * @liodn: the LIODN of the I/O device for which to disable DMA</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_dma_disable</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">liodn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_DMA_DISABLE</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">liodn</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS1</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fh_vmpic_get_msir - returns the MPIC-MSI register value</span>
<span class="cm"> * @interrupt: the interrupt number</span>
<span class="cm"> * @msir_val: returned MPIC-MSI register value</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_vmpic_get_msir</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">interrupt</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">msir_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_VMPIC_GET_MSIR</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">interrupt</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS2</span>
	<span class="p">);</span>

	<span class="o">*</span><span class="n">msir_val</span> <span class="o">=</span> <span class="n">r4</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fh_system_reset - reset the system</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_system_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_SYSTEM_RESET</span><span class="p">);</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS1</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * fh_err_get_info - get platform error information</span>
<span class="cm"> * @queue id:</span>
<span class="cm"> * 0 for guest error event queue</span>
<span class="cm"> * 1 for global error event queue</span>
<span class="cm"> *</span>
<span class="cm"> * @pointer to store the platform error data:</span>
<span class="cm"> * platform error data is returned in registers r4 - r11</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_err_get_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">queue</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">bufsize</span><span class="p">,</span>
	<span class="kt">uint32_t</span> <span class="n">addr_hi</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">addr_lo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">peek</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r5</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r5&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r6</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r6&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r7</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r7&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_ERR_GET_INFO</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">queue</span><span class="p">;</span>
	<span class="n">r4</span> <span class="o">=</span> <span class="o">*</span><span class="n">bufsize</span><span class="p">;</span>
	<span class="n">r5</span> <span class="o">=</span> <span class="n">addr_hi</span><span class="p">;</span>
	<span class="n">r6</span> <span class="o">=</span> <span class="n">addr_lo</span><span class="p">;</span>
	<span class="n">r7</span> <span class="o">=</span> <span class="n">peek</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r5</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r6</span><span class="p">),</span>
		  <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r7</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS5</span>
	<span class="p">);</span>

	<span class="o">*</span><span class="n">bufsize</span> <span class="o">=</span> <span class="n">r4</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#define FH_VCPU_RUN	0</span>
<span class="cp">#define FH_VCPU_IDLE	1</span>
<span class="cp">#define FH_VCPU_NAP	2</span>

<span class="cm">/**</span>
<span class="cm"> * fh_get_core_state - get the state of a vcpu</span>
<span class="cm"> *</span>
<span class="cm"> * @handle: handle of partition containing the vcpu</span>
<span class="cm"> * @vcpu: vcpu number within the partition</span>
<span class="cm"> * @state:the current state of the vcpu, see FH_VCPU_*</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_get_core_state</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handle</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vcpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_GET_CORE_STATE</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">r4</span> <span class="o">=</span> <span class="n">vcpu</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS2</span>
	<span class="p">);</span>

	<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">r4</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fh_enter_nap - enter nap on a vcpu</span>
<span class="cm"> *</span>
<span class="cm"> * Note that though the API supports entering nap on a vcpu other</span>
<span class="cm"> * than the caller, this may not be implmented and may return EINVAL.</span>
<span class="cm"> *</span>
<span class="cm"> * @handle: handle of partition containing the vcpu</span>
<span class="cm"> * @vcpu: vcpu number within the partition</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_enter_nap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_ENTER_NAP</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">r4</span> <span class="o">=</span> <span class="n">vcpu</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS2</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fh_exit_nap - exit nap on a vcpu</span>
<span class="cm"> * @handle: handle of partition containing the vcpu</span>
<span class="cm"> * @vcpu: vcpu number within the partition</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_exit_nap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r4</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r4&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_EXIT_NAP</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">r4</span> <span class="o">=</span> <span class="n">vcpu</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r4</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS2</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * fh_claim_device - claim a &quot;claimable&quot; shared device</span>
<span class="cm"> * @handle: fsl,hv-device-handle of node to claim</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_claim_device</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_CLAIM_DEVICE</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS1</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Run deferred DMA disabling on a partition&#39;s private devices</span>
<span class="cm"> *</span>
<span class="cm"> * This applies to devices which a partition owns either privately,</span>
<span class="cm"> * or which are claimable and still actively owned by that partition,</span>
<span class="cm"> * and which do not have the no-dma-disable property.</span>
<span class="cm"> *</span>
<span class="cm"> * @handle: partition (must be stopped) whose DMA is to be disabled</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, or an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fh_partition_stop_dma</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r11</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">uintptr_t</span> <span class="n">r3</span> <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;r3&quot;</span><span class="p">);</span>

	<span class="n">r11</span> <span class="o">=</span> <span class="n">FH_HCALL_TOKEN</span><span class="p">(</span><span class="n">FH_PARTITION_STOP_DMA</span><span class="p">);</span>
	<span class="n">r3</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;sc 1&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r11</span><span class="p">),</span> <span class="s">&quot;+r&quot;</span> <span class="p">(</span><span class="n">r3</span><span class="p">)</span>
		<span class="o">:</span> <span class="o">:</span> <span class="n">EV_HCALL_CLOBBERS1</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
