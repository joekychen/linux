<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › bitops.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>bitops.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * PowerPC atomic bit operations.</span>
<span class="cm"> *</span>
<span class="cm"> * Merged version by David Gibson &lt;david@gibson.dropbear.id.au&gt;.</span>
<span class="cm"> * Based on ppc64 versions by: Dave Engebretsen, Todd Inglett, Don</span>
<span class="cm"> * Reed, Pat McCarthy, Peter Bergner, Anton Blanchard.  They</span>
<span class="cm"> * originally took it from the ppc32 code.</span>
<span class="cm"> *</span>
<span class="cm"> * Within a word, bits are numbered LSB first.  Lot&#39;s of places make</span>
<span class="cm"> * this assumption by directly testing bits with (val &amp; (1&lt;&lt;nr)).</span>
<span class="cm"> * This can cause confusion for large (&gt; 1 word) bitmaps on a</span>
<span class="cm"> * big-endian system because, unlike little endian, the number of each</span>
<span class="cm"> * bit depends on the word size.</span>
<span class="cm"> *</span>
<span class="cm"> * The bitop functions are defined to work on unsigned longs, so for a</span>
<span class="cm"> * ppc64 system the bits end up numbered:</span>
<span class="cm"> *   |63..............0|127............64|191...........128|255...........196|</span>
<span class="cm"> * and on ppc32:</span>
<span class="cm"> *   |31.....0|63....31|95....64|127...96|159..128|191..160|223..192|255..224|</span>
<span class="cm"> *</span>
<span class="cm"> * There are a few little-endian macros used mostly for filesystem</span>
<span class="cm"> * bitmaps, these work on similar bit arrays layouts, but</span>
<span class="cm"> * byte-oriented:</span>
<span class="cm"> *   |7...0|15...8|23...16|31...24|39...32|47...40|55...48|63...56|</span>
<span class="cm"> *</span>
<span class="cm"> * The main difference is that bit 3-5 (64b) or 3-4 (32b) in the bit</span>
<span class="cm"> * number field needs to be reversed compared to the big-endian bit</span>
<span class="cm"> * fields. This can be achieved by XOR with 0x38 (64b) or 0x18 (32b).</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_POWERPC_BITOPS_H</span>
<span class="cp">#define _ASM_POWERPC_BITOPS_H</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#ifndef _LINUX_BITOPS_H</span>
<span class="cp">#error only &lt;linux/bitops.h&gt; can be included directly</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;asm/asm-compat.h&gt;</span>
<span class="cp">#include &lt;asm/synch.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * clear_bit doesn&#39;t imply a memory barrier</span>
<span class="cm"> */</span>
<span class="cp">#define smp_mb__before_clear_bit()	smp_mb()</span>
<span class="cp">#define smp_mb__after_clear_bit()	smp_mb()</span>

<span class="cp">#define BITOP_MASK(nr)		(1UL &lt;&lt; ((nr) % BITS_PER_LONG))</span>
<span class="cp">#define BITOP_WORD(nr)		((nr) / BITS_PER_LONG)</span>
<span class="cp">#define BITOP_LE_SWIZZLE	((BITS_PER_LONG-1) &amp; ~0x7)</span>

<span class="cm">/* Macro for generating the ***_bits() functions */</span>
<span class="cp">#define DEFINE_BITOP(fn, op, prefix, postfix)	\</span>
<span class="cp">static __inline__ void fn(unsigned long mask,	\</span>
<span class="cp">		volatile unsigned long *_p)	\</span>
<span class="cp">{						\</span>
<span class="cp">	unsigned long old;			\</span>
<span class="cp">	unsigned long *p = (unsigned long *)_p;	\</span>
<span class="cp">	__asm__ __volatile__ (			\</span>
<span class="cp">	prefix					\</span>
<span class="cp">&quot;1:&quot;	PPC_LLARX(%0,0,%3,0) &quot;\n&quot;		\</span>
<span class="cp">	stringify_in_c(op) &quot;%0,%0,%2\n&quot;		\</span>
<span class="cp">	PPC405_ERR77(0,%3)			\</span>
<span class="cp">	PPC_STLCX &quot;%0,0,%3\n&quot;			\</span>
<span class="cp">	&quot;bne- 1b\n&quot;				\</span>
<span class="cp">	postfix					\</span>
<span class="cp">	: &quot;=&amp;r&quot; (old), &quot;+m&quot; (*p)		\</span>
<span class="cp">	: &quot;r&quot; (mask), &quot;r&quot; (p)			\</span>
<span class="cp">	: &quot;cc&quot;, &quot;memory&quot;);			\</span>
<span class="cp">}</span>

<span class="n">DEFINE_BITOP</span><span class="p">(</span><span class="n">set_bits</span><span class="p">,</span> <span class="n">or</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="n">DEFINE_BITOP</span><span class="p">(</span><span class="n">clear_bits</span><span class="p">,</span> <span class="n">andc</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="n">DEFINE_BITOP</span><span class="p">(</span><span class="n">clear_bits_unlock</span><span class="p">,</span> <span class="n">andc</span><span class="p">,</span> <span class="n">PPC_RELEASE_BARRIER</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="n">DEFINE_BITOP</span><span class="p">(</span><span class="n">change_bits</span><span class="p">,</span> <span class="n">xor</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="n">set_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bits</span><span class="p">(</span><span class="n">BITOP_MASK</span><span class="p">(</span><span class="n">nr</span><span class="p">),</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">BITOP_WORD</span><span class="p">(</span><span class="n">nr</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="n">clear_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bits</span><span class="p">(</span><span class="n">BITOP_MASK</span><span class="p">(</span><span class="n">nr</span><span class="p">),</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">BITOP_WORD</span><span class="p">(</span><span class="n">nr</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="n">clear_bit_unlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bits_unlock</span><span class="p">(</span><span class="n">BITOP_MASK</span><span class="p">(</span><span class="n">nr</span><span class="p">),</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">BITOP_WORD</span><span class="p">(</span><span class="n">nr</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="n">change_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">change_bits</span><span class="p">(</span><span class="n">BITOP_MASK</span><span class="p">(</span><span class="n">nr</span><span class="p">),</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">BITOP_WORD</span><span class="p">(</span><span class="n">nr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Like DEFINE_BITOP(), with changes to the arguments to &#39;op&#39; and the output</span>
<span class="cm"> * operands. */</span>
<span class="cp">#define DEFINE_TESTOP(fn, op, prefix, postfix, eh)	\</span>
<span class="cp">static __inline__ unsigned long fn(			\</span>
<span class="cp">		unsigned long mask,			\</span>
<span class="cp">		volatile unsigned long *_p)		\</span>
<span class="cp">{							\</span>
<span class="cp">	unsigned long old, t;				\</span>
<span class="cp">	unsigned long *p = (unsigned long *)_p;		\</span>
<span class="cp">	__asm__ __volatile__ (				\</span>
<span class="cp">	prefix						\</span>
<span class="cp">&quot;1:&quot;	PPC_LLARX(%0,0,%3,eh) &quot;\n&quot;			\</span>
<span class="cp">	stringify_in_c(op) &quot;%1,%0,%2\n&quot;			\</span>
<span class="cp">	PPC405_ERR77(0,%3)				\</span>
<span class="cp">	PPC_STLCX &quot;%1,0,%3\n&quot;				\</span>
<span class="cp">	&quot;bne- 1b\n&quot;					\</span>
<span class="cp">	postfix						\</span>
<span class="cp">	: &quot;=&amp;r&quot; (old), &quot;=&amp;r&quot; (t)			\</span>
<span class="cp">	: &quot;r&quot; (mask), &quot;r&quot; (p)				\</span>
<span class="cp">	: &quot;cc&quot;, &quot;memory&quot;);				\</span>
<span class="cp">	return (old &amp; mask);				\</span>
<span class="cp">}</span>

<span class="n">DEFINE_TESTOP</span><span class="p">(</span><span class="n">test_and_set_bits</span><span class="p">,</span> <span class="n">or</span><span class="p">,</span> <span class="n">PPC_ATOMIC_ENTRY_BARRIER</span><span class="p">,</span>
	      <span class="n">PPC_ATOMIC_EXIT_BARRIER</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">DEFINE_TESTOP</span><span class="p">(</span><span class="n">test_and_set_bits_lock</span><span class="p">,</span> <span class="n">or</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	      <span class="n">PPC_ACQUIRE_BARRIER</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">DEFINE_TESTOP</span><span class="p">(</span><span class="n">test_and_clear_bits</span><span class="p">,</span> <span class="n">andc</span><span class="p">,</span> <span class="n">PPC_ATOMIC_ENTRY_BARRIER</span><span class="p">,</span>
	      <span class="n">PPC_ATOMIC_EXIT_BARRIER</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">DEFINE_TESTOP</span><span class="p">(</span><span class="n">test_and_change_bits</span><span class="p">,</span> <span class="n">xor</span><span class="p">,</span> <span class="n">PPC_ATOMIC_ENTRY_BARRIER</span><span class="p">,</span>
	      <span class="n">PPC_ATOMIC_EXIT_BARRIER</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="n">test_and_set_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span>
				       <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_and_set_bits</span><span class="p">(</span><span class="n">BITOP_MASK</span><span class="p">(</span><span class="n">nr</span><span class="p">),</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">BITOP_WORD</span><span class="p">(</span><span class="n">nr</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="n">test_and_set_bit_lock</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span>
				       <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_and_set_bits_lock</span><span class="p">(</span><span class="n">BITOP_MASK</span><span class="p">(</span><span class="n">nr</span><span class="p">),</span>
				<span class="n">addr</span> <span class="o">+</span> <span class="n">BITOP_WORD</span><span class="p">(</span><span class="n">nr</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span>
					 <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_and_clear_bits</span><span class="p">(</span><span class="n">BITOP_MASK</span><span class="p">(</span><span class="n">nr</span><span class="p">),</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">BITOP_WORD</span><span class="p">(</span><span class="n">nr</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="n">test_and_change_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span>
					  <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_and_change_bits</span><span class="p">(</span><span class="n">BITOP_MASK</span><span class="p">(</span><span class="n">nr</span><span class="p">),</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">BITOP_WORD</span><span class="p">(</span><span class="n">nr</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include &lt;asm-generic/bitops/non-atomic.h&gt;</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="n">__clear_bit_unlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="n">PPC_RELEASE_BARRIER</span> <span class="s">&quot;&quot;</span> <span class="o">:::</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the zero-based bit position (LE, not IBM bit numbering) of</span>
<span class="cm"> * the most significant 1-bit in a double word.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="n">__attribute__</span><span class="p">((</span><span class="k">const</span><span class="p">))</span>
<span class="kt">int</span> <span class="n">__ilog2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lz</span><span class="p">;</span>

	<span class="n">asm</span> <span class="p">(</span><span class="n">PPC_CNTLZL</span> <span class="s">&quot;%0,%1&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">lz</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">x</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lz</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__attribute__</span><span class="p">((</span><span class="k">const</span><span class="p">))</span>
<span class="kt">int</span> <span class="n">__ilog2_u32</span><span class="p">(</span><span class="n">u32</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>
	<span class="n">asm</span> <span class="p">(</span><span class="s">&quot;cntlzw %0,%1&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">bit</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">n</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">31</span> <span class="o">-</span> <span class="n">bit</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __powerpc64__</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__attribute__</span><span class="p">((</span><span class="k">const</span><span class="p">))</span>
<span class="kt">int</span> <span class="n">__ilog2_u64</span><span class="p">(</span><span class="n">u64</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>
	<span class="n">asm</span> <span class="p">(</span><span class="s">&quot;cntlzd %0,%1&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">bit</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">n</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">63</span> <span class="o">-</span> <span class="n">bit</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Determines the bit position of the least significant 0 bit in the</span>
<span class="cm"> * specified double word. The returned bit position will be</span>
<span class="cm"> * zero-based, starting from the right side (63/31 - 0).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ffz</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* no zero exists anywhere in the 8 byte area. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">=</span> <span class="o">~</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the bit position of the least significant &#39;1&#39; bit in x</span>
<span class="cm">	 * (since x has been changed this will actually be the least significant</span>
<span class="cm">	 * &#39;0&#39; bit in * the original x).  Note: (x &amp; -x) gives us a mask that</span>
<span class="cm">	 * is the least significant * (RIGHT-most) 1-bit of the value in x.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">__ilog2</span><span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="n">__ffs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ilog2</span><span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ffs: find first bit set. This is defined the same way as</span>
<span class="cm"> * the libc and compiler builtin ffs routines, therefore</span>
<span class="cm"> * differs in spirit from the above ffz (man ffs).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="n">ffs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__ilog2</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fls: find last (most-significant) bit set.</span>
<span class="cm"> * Note fls(0) = 0, fls(1) = 1, fls(0x80000000) = 32.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="n">fls</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lz</span><span class="p">;</span>

	<span class="n">asm</span> <span class="p">(</span><span class="s">&quot;cntlzw %0,%1&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">lz</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">x</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">lz</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__fls</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ilog2</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 64-bit can do this using one cntlzd (count leading zeroes doubleword)</span>
<span class="cm"> * instruction; for 32-bit we use the generic version, which does two</span>
<span class="cm"> * 32-bit fls calls.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __powerpc64__</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="n">fls64</span><span class="p">(</span><span class="n">__u64</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lz</span><span class="p">;</span>

	<span class="n">asm</span> <span class="p">(</span><span class="s">&quot;cntlzd %0,%1&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">lz</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">x</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">64</span> <span class="o">-</span> <span class="n">lz</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;asm-generic/bitops/fls64.h&gt;</span>
<span class="cp">#endif </span><span class="cm">/* __powerpc64__ */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__arch_hweight8</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">w</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__arch_hweight16</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">w</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__arch_hweight32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">w</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__arch_hweight64</span><span class="p">(</span><span class="n">__u64</span> <span class="n">w</span><span class="p">);</span>
<span class="cp">#include &lt;asm-generic/bitops/const_hweight.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;asm-generic/bitops/hweight.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;asm-generic/bitops/find.h&gt;</span>

<span class="cm">/* Little-endian versions */</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">test_bit_le</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span>
				  <span class="n">__const__</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__const__</span> <span class="kt">unsigned</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">__const__</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">nr</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__set_bit_le</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">nr</span> <span class="o">^</span> <span class="n">BITOP_LE_SWIZZLE</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__clear_bit_le</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">nr</span> <span class="o">^</span> <span class="n">BITOP_LE_SWIZZLE</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">test_and_set_bit_le</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">nr</span> <span class="o">^</span> <span class="n">BITOP_LE_SWIZZLE</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">test_and_clear_bit_le</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">nr</span> <span class="o">^</span> <span class="n">BITOP_LE_SWIZZLE</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__test_and_set_bit_le</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__test_and_set_bit</span><span class="p">(</span><span class="n">nr</span> <span class="o">^</span> <span class="n">BITOP_LE_SWIZZLE</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__test_and_clear_bit_le</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__test_and_clear_bit</span><span class="p">(</span><span class="n">nr</span> <span class="o">^</span> <span class="n">BITOP_LE_SWIZZLE</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define find_first_zero_bit_le(addr, size) \</span>
<span class="cp">	find_next_zero_bit_le((addr), (size), 0)</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">find_next_zero_bit_le</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">find_next_bit_le</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">);</span>
<span class="cm">/* Bitmap functions for the ext2 filesystem */</span>

<span class="cp">#include &lt;asm-generic/bitops/ext2-atomic-setbit.h&gt;</span>

<span class="cp">#include &lt;asm-generic/bitops/sched.h&gt;</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_POWERPC_BITOPS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
