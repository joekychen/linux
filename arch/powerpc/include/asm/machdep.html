<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › machdep.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>machdep.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_POWERPC_MACHDEP_H</span>
<span class="cp">#define _ASM_POWERPC_MACHDEP_H</span>
<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/*</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cp">#include &lt;asm/setup.h&gt;</span>

<span class="cm">/* We export this macro for external modules like Alsa to know if</span>
<span class="cm"> * ppc_md.feature_call is implemented or not</span>
<span class="cm"> */</span>
<span class="cp">#define CONFIG_PPC_HAS_FEATURE_CALLS</span>

<span class="k">struct</span> <span class="n">pt_regs</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pci_bus</span><span class="p">;</span>	
<span class="k">struct</span> <span class="n">device_node</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">iommu_table</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">rtc_time</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">file</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pci_controller</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kimage</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">machdep_calls</span> <span class="p">{</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="kt">void</span>            <span class="p">(</span><span class="o">*</span><span class="n">hpte_invalidate</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">slot</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">psize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ssize</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">local</span><span class="p">);</span>
	<span class="kt">long</span>		<span class="p">(</span><span class="o">*</span><span class="n">hpte_updatepp</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">slot</span><span class="p">,</span> 
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newpp</span><span class="p">,</span> 
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">psize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ssize</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">local</span><span class="p">);</span>
	<span class="kt">void</span>            <span class="p">(</span><span class="o">*</span><span class="n">hpte_updateboltedpp</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newpp</span><span class="p">,</span> 
					       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ea</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="n">psize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ssize</span><span class="p">);</span>
	<span class="kt">long</span>		<span class="p">(</span><span class="o">*</span><span class="n">hpte_insert</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hpte_group</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prpn</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rflags</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vflags</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">psize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ssize</span><span class="p">);</span>
	<span class="kt">long</span>		<span class="p">(</span><span class="o">*</span><span class="n">hpte_remove</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hpte_group</span><span class="p">);</span>
	<span class="kt">void</span>            <span class="p">(</span><span class="o">*</span><span class="n">hpte_removebolted</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ea</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">psize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ssize</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">flush_hash_range</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">number</span><span class="p">,</span> <span class="kt">int</span> <span class="n">local</span><span class="p">);</span>

	<span class="cm">/* special for kexec, to be called in real mode, linear mapping is</span>
<span class="cm">	 * destroyed as well */</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">hpte_clear_all</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">tce_build</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span>
				     <span class="kt">long</span> <span class="n">index</span><span class="p">,</span>
				     <span class="kt">long</span> <span class="n">npages</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uaddr</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">tce_free</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span>
				    <span class="kt">long</span> <span class="n">index</span><span class="p">,</span>
				    <span class="kt">long</span> <span class="n">npages</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="p">(</span><span class="o">*</span><span class="n">tce_get</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span>
				    <span class="kt">long</span> <span class="n">index</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">tce_flush</span><span class="p">)(</span><span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">);</span>

	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span>	<span class="p">(</span><span class="o">*</span><span class="n">ioremap</span><span class="p">)(</span><span class="n">phys_addr_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">caller</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">iounmap</span><span class="p">)(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">token</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">iommu_save</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">iommu_restore</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>

	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">pci_dma_dev_setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">pci_dma_bus_setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

	<span class="cm">/* Platform set_dma_mask and dma_get_required_mask overrides */</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">dma_set_mask</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">dma_mask</span><span class="p">);</span>
	<span class="n">u64</span>		<span class="p">(</span><span class="o">*</span><span class="n">dma_get_required_mask</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">setup_arch</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span> <span class="cm">/* Optional, may be NULL */</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">init_early</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="cm">/* Optional, may be NULL. */</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">show_cpuinfo</span><span class="p">)(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">show_percpuinfo</span><span class="p">)(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">);</span>

	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">init_IRQ</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="cm">/* Return an irq, or NO_IRQ to indicate there are none pending. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_irq</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="cm">/* PCI stuff */</span>
	<span class="cm">/* Called after scanning the bus, before allocating resources */</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">pcibios_fixup</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">pci_probe_mode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">pci_irq_fixup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* To setup PHBs when using automatic OF platform driver for PCI */</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">pci_setup_phb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI_MSI</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">msi_check_device</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span><span class="o">*</span> <span class="n">dev</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">nvec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">setup_msi_irqs</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">nvec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">teardown_msi_irqs</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">restart</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">power_off</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">halt</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">panic</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">cpu_die</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="kt">long</span>		<span class="p">(</span><span class="o">*</span><span class="n">time_init</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span> <span class="cm">/* Optional, may be NULL */</span>

	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">set_rtc_time</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rtc_time</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">get_rtc_time</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rtc_time</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_boot_time</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> 	<span class="p">(</span><span class="o">*</span><span class="n">rtc_read_val</span><span class="p">)(</span><span class="kt">int</span> <span class="n">addr</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">rtc_write_val</span><span class="p">)(</span><span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">);</span>

	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">calibrate_decr</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">progress</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span><span class="p">);</span>

	<span class="cm">/* Interface for platform error logging */</span>
	<span class="kt">void</span> 		<span class="p">(</span><span class="o">*</span><span class="n">log_error</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">err_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fatal</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> 	<span class="p">(</span><span class="o">*</span><span class="n">nvram_read_val</span><span class="p">)(</span><span class="kt">int</span> <span class="n">addr</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">nvram_write_val</span><span class="p">)(</span><span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">);</span>
	<span class="kt">ssize_t</span>		<span class="p">(</span><span class="o">*</span><span class="n">nvram_write</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">index</span><span class="p">);</span>
	<span class="kt">ssize_t</span>		<span class="p">(</span><span class="o">*</span><span class="n">nvram_read</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">index</span><span class="p">);</span>	
	<span class="kt">ssize_t</span>		<span class="p">(</span><span class="o">*</span><span class="n">nvram_size</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>		
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">nvram_sync</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="cm">/* Exception handlers */</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">system_reset_exception</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
	<span class="kt">int</span> 		<span class="p">(</span><span class="o">*</span><span class="n">machine_check_exception</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

	<span class="cm">/* Motherboard/chipset features. This is a kind of general purpose</span>
<span class="cm">	 * hook used to control some machine specific features (like reset</span>
<span class="cm">	 * lines, chip power control, etc...).</span>
<span class="cm">	 */</span>
	<span class="kt">long</span>	 	<span class="p">(</span><span class="o">*</span><span class="n">feature_call</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">feature</span><span class="p">,</span> <span class="p">...);</span>

	<span class="cm">/* Get legacy PCI/IDE interrupt mapping */</span> 
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">pci_get_legacy_ide_irq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">);</span>
	
	<span class="cm">/* Get access protection for /dev/mem */</span>
	<span class="n">pgprot_t</span>	<span class="p">(</span><span class="o">*</span><span class="n">phys_mem_access_prot</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
						<span class="n">pgprot_t</span> <span class="n">vma_prot</span><span class="p">);</span>

	<span class="cm">/* Idle loop for this platform, leave empty for default idle loop */</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">idle_loop</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Function for waiting for work with reduced power in idle loop;</span>
<span class="cm">	 * called with interrupts disabled.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">power_save</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="cm">/* Function to enable performance monitor counters for this</span>
<span class="cm">	   platform, called once per cpu. */</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">enable_pmcs</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="cm">/* Set DABR for this platform, leave empty for default implemenation */</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">set_dabr</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dabr</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC32	</span><span class="cm">/* XXX for now */</span><span class="cp"></span>
	<span class="cm">/* A general init function, called by ppc_init in init/main.c.</span>
<span class="cm">	   May be NULL. */</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">kgdb_map_scc</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * optional PCI &quot;hooks&quot;</span>
<span class="cm">	 */</span>
	<span class="cm">/* Called at then very end of pcibios_init() */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pcibios_after_init</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC32 */</span><span class="cp"></span>

	<span class="cm">/* Called in indirect_* to avoid touching devices */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pci_exclude_device</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">);</span>

	<span class="cm">/* Called after PPC generic resource fixup to perform</span>
<span class="cm">	   machine specific fixups */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pcibios_fixup_resources</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Called for each PCI bus in the system when it&#39;s probed */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pcibios_fixup_bus</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Called when pci_enable_device() is called. Returns 0 to</span>
<span class="cm">	 * allow assignment/enabling of the device. */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">pcibios_enable_device_hook</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Called after scan and before resource survey */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pcibios_fixup_phb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">hose</span><span class="p">);</span>

	<span class="cm">/* Called to shutdown machine specific hardware not already controlled</span>
<span class="cm">	 * by other drivers.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">machine_shutdown</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_KEXEC</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">kexec_cpu_down</span><span class="p">)(</span><span class="kt">int</span> <span class="n">crash_shutdown</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondary</span><span class="p">);</span>

	<span class="cm">/* Called to do what every setup is needed on image and the</span>
<span class="cm">	 * reboot code buffer. Returns 0 on success.</span>
<span class="cm">	 * Provide your own (maybe dummy) implementation if your platform</span>
<span class="cm">	 * claims to support kexec.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">machine_kexec_prepare</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">);</span>

	<span class="cm">/* Called to perform the _real_ kexec.</span>
<span class="cm">	 * Do NOT allocate memory or fail here. We are past the point of</span>
<span class="cm">	 * no return.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">machine_kexec</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_KEXEC */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SUSPEND</span>
	<span class="cm">/* These are called to disable and enable, respectively, IRQs when</span>
<span class="cm">	 * entering a suspend state.  If NULL, then the generic versions</span>
<span class="cm">	 * will be called.  The generic versions disable/enable the</span>
<span class="cm">	 * decrementer along with interrupts.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend_disable_irqs</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend_enable_irqs</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend_disable_cpu</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ARCH_CPU_PROBE_RELEASE</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">cpu_probe</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">cpu_release</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">e500_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">power4_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">power7_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ppc6xx_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">book3e_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ppc_md contains a copy of the machine description structure for the</span>
<span class="cm"> * current platform. machine_id contains the initial address where the</span>
<span class="cm"> * description was found during boot.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">machdep_calls</span> <span class="n">ppc_md</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">machdep_calls</span> <span class="o">*</span><span class="n">machine_id</span><span class="p">;</span>

<span class="cp">#define __machine_desc __attribute__ ((__section__ (&quot;.machine.desc&quot;)))</span>

<span class="cp">#define define_machine(name)					\</span>
<span class="cp">	extern struct machdep_calls mach_##name;		\</span>
<span class="cp">	EXPORT_SYMBOL(mach_##name);				\</span>
<span class="cp">	struct machdep_calls mach_##name __machine_desc =</span>

<span class="cp">#define machine_is(name) \</span>
<span class="cp">	({ \</span>
<span class="cp">		extern struct machdep_calls mach_##name \</span>
<span class="cp">			__attribute__((weak));		 \</span>
<span class="cp">		machine_id == &amp;mach_##name; \</span>
<span class="cp">	})</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">probe_machine</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">char</span> <span class="n">cmd_line</span><span class="p">[</span><span class="n">COMMAND_LINE_SIZE</span><span class="p">];</span>

<span class="cp">#ifdef CONFIG_PPC_PMAC</span>
<span class="cm">/*</span>
<span class="cm"> * Power macintoshes have either a CUDA, PMU or SMU controlling</span>
<span class="cm"> * system reset, power, NVRAM, RTC.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">sys_ctrler_kind</span> <span class="p">{</span>
	<span class="n">SYS_CTRLER_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SYS_CTRLER_CUDA</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SYS_CTRLER_PMU</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">SYS_CTRLER_SMU</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">}</span> <span class="n">sys_ctrler_t</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">sys_ctrler_t</span> <span class="n">sys_ctrler</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_PMAC */</span><span class="cp"></span>


<span class="cm">/* Functions to produce codes on the leds.</span>
<span class="cm"> * The SRC code should be unique for the message category and should</span>
<span class="cm"> * be limited to the lower 24 bits (the upper 8 are set by these funcs),</span>
<span class="cm"> * and (for boot &amp; dump) should be sorted numerically in the order</span>
<span class="cm"> * the events occur.</span>
<span class="cm"> */</span>
<span class="cm">/* Print a boot progress message. */</span>
<span class="kt">void</span> <span class="n">ppc64_boot_msg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">log_error</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">err_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fatal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">log_error</span><span class="p">)</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">err_type</span><span class="p">,</span> <span class="n">fatal</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define __define_machine_initcall(mach,level,fn,id) \</span>
<span class="cp">	static int __init __machine_initcall_##mach##_##fn(void) { \</span>
<span class="cp">		if (machine_is(mach)) return fn(); \</span>
<span class="cp">		return 0; \</span>
<span class="cp">	} \</span>
<span class="cp">	__define_initcall(level,__machine_initcall_##mach##_##fn,id);</span>

<span class="cp">#define machine_core_initcall(mach,fn)		__define_machine_initcall(mach,&quot;1&quot;,fn,1)</span>
<span class="cp">#define machine_core_initcall_sync(mach,fn)	__define_machine_initcall(mach,&quot;1s&quot;,fn,1s)</span>
<span class="cp">#define machine_postcore_initcall(mach,fn)	__define_machine_initcall(mach,&quot;2&quot;,fn,2)</span>
<span class="cp">#define machine_postcore_initcall_sync(mach,fn)	__define_machine_initcall(mach,&quot;2s&quot;,fn,2s)</span>
<span class="cp">#define machine_arch_initcall(mach,fn)		__define_machine_initcall(mach,&quot;3&quot;,fn,3)</span>
<span class="cp">#define machine_arch_initcall_sync(mach,fn)	__define_machine_initcall(mach,&quot;3s&quot;,fn,3s)</span>
<span class="cp">#define machine_subsys_initcall(mach,fn)	__define_machine_initcall(mach,&quot;4&quot;,fn,4)</span>
<span class="cp">#define machine_subsys_initcall_sync(mach,fn)	__define_machine_initcall(mach,&quot;4s&quot;,fn,4s)</span>
<span class="cp">#define machine_fs_initcall(mach,fn)		__define_machine_initcall(mach,&quot;5&quot;,fn,5)</span>
<span class="cp">#define machine_fs_initcall_sync(mach,fn)	__define_machine_initcall(mach,&quot;5s&quot;,fn,5s)</span>
<span class="cp">#define machine_rootfs_initcall(mach,fn)	__define_machine_initcall(mach,&quot;rootfs&quot;,fn,rootfs)</span>
<span class="cp">#define machine_device_initcall(mach,fn)	__define_machine_initcall(mach,&quot;6&quot;,fn,6)</span>
<span class="cp">#define machine_device_initcall_sync(mach,fn)	__define_machine_initcall(mach,&quot;6s&quot;,fn,6s)</span>
<span class="cp">#define machine_late_initcall(mach,fn)		__define_machine_initcall(mach,&quot;7&quot;,fn,7)</span>
<span class="cp">#define machine_late_initcall_sync(mach,fn)	__define_machine_initcall(mach,&quot;7s&quot;,fn,7s)</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _ASM_POWERPC_MACHDEP_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
