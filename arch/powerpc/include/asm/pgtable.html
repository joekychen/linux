<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › pgtable.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pgtable.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_POWERPC_PGTABLE_H</span>
<span class="cp">#define _ASM_POWERPC_PGTABLE_H</span>
<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cp">#include &lt;asm/processor.h&gt;		</span><span class="cm">/* For TASK_SIZE */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/mmu.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>

<span class="k">struct</span> <span class="n">mm_struct</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_VM</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">assert_pte_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_DEBUG_VM */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">assert_pte_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_DEBUG_VM */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#if defined(CONFIG_PPC64)</span>
<span class="cp">#  include &lt;asm/pgtable-ppc64.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#  include &lt;asm/pgtable-ppc32.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cm">/* Generic accessors to PTE bits */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_write</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>		<span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_RW</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_dirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>		<span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_DIRTY</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_young</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>		<span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_ACCESSED</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_file</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>		<span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_FILE</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_special</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_SPECIAL</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_present</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_PRESENT</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_none</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>		<span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_PTE_NONE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pgprot_t</span> <span class="nf">pte_pgprot</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span> <span class="k">return</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_PROT_BITS</span><span class="p">);</span> <span class="p">}</span>

<span class="cm">/* Conversion functions: convert a page and protection to a page entry,</span>
<span class="cm"> * and a page entry and page directory to the page they refer to.</span>
<span class="cm"> *</span>
<span class="cm"> * Even if PTEs can be unsigned long long, a PFN is always an unsigned</span>
<span class="cm"> * long for now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pfn_pte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">pgprot</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">(((</span><span class="n">pte_basic_t</span><span class="p">)(</span><span class="n">pfn</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PTE_RPN_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		     <span class="n">pgprot_val</span><span class="p">(</span><span class="n">pgprot</span><span class="p">));</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">pte_pfn</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PTE_RPN_SHIFT</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Keep these as a macros to avoid include dependency mess */</span>
<span class="cp">#define pte_page(x)		pfn_to_page(pte_pfn(x))</span>
<span class="cp">#define mk_pte(page, pgprot)	pfn_pte(page_to_pfn(page), (pgprot))</span>

<span class="cm">/* Generic modifiers for PTE bits */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_wrprotect</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">_PAGE_RW</span> <span class="o">|</span> <span class="n">_PAGE_HWWRITE</span><span class="p">);</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkclean</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">_PAGE_DIRTY</span> <span class="o">|</span> <span class="n">_PAGE_HWWRITE</span><span class="p">);</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkold</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_PAGE_ACCESSED</span><span class="p">;</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkwrite</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_RW</span><span class="p">;</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkdirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_DIRTY</span><span class="p">;</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkyoung</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_ACCESSED</span><span class="p">;</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkspecial</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_SPECIAL</span><span class="p">;</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkhuge</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_modify</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">newprot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_CHG_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">newprot</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Insert a PTE, top-level function is out of line. It uses an inline</span>
<span class="cm"> * low level function in the respective pgtable-* files</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_pte_at</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span>
		       <span class="n">pte_t</span> <span class="n">pte</span><span class="p">);</span>

<span class="cm">/* This low level function performs the actual PTE insertion</span>
<span class="cm"> * Setting the PTE depends on the MMU type and other factors. It&#39;s</span>
<span class="cm"> * an horrible mess that I&#39;m not going to try to clean up now but</span>
<span class="cm"> * I&#39;m keeping it in one place rather than spread around</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__set_pte_at</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">,</span> <span class="kt">int</span> <span class="n">percpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_PPC_STD_MMU_32) &amp;&amp; defined(CONFIG_SMP) &amp;&amp; !defined(CONFIG_PTE_64BIT)</span>
	<span class="cm">/* First case is 32-bit Hash MMU in SMP mode with 32-bit PTEs. We use the</span>
<span class="cm">	 * helper pte_update() which does an atomic update. We need to do that</span>
<span class="cm">	 * because a concurrent invalidation can clear _PAGE_HASHPTE. If it&#39;s a</span>
<span class="cm">	 * per-CPU PTE such as a kmap_atomic, we do a simple update preserving</span>
<span class="cm">	 * the hash bits instead (ie, same as the non-SMP case)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">percpu</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">__pte</span><span class="p">((</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_HASHPTE</span><span class="p">)</span>
			      <span class="o">|</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_PAGE_HASHPTE</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">pte_update</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="o">~</span><span class="n">_PAGE_HASHPTE</span><span class="p">,</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>

<span class="cp">#elif defined(CONFIG_PPC32) &amp;&amp; defined(CONFIG_PTE_64BIT)</span>
	<span class="cm">/* Second case is 32-bit with 64-bit PTE.  In this case, we</span>
<span class="cm">	 * can just store as long as we do the two halves in the right order</span>
<span class="cm">	 * with a barrier in between. This is possible because we take care,</span>
<span class="cm">	 * in the hash code, to pre-invalidate if the PTE was already hashed,</span>
<span class="cm">	 * which synchronizes us with any concurrent invalidation.</span>
<span class="cm">	 * In the percpu case, we also fallback to the simple update preserving</span>
<span class="cm">	 * the hash bits</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">percpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">__pte</span><span class="p">((</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_HASHPTE</span><span class="p">)</span>
			      <span class="o">|</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_PAGE_HASHPTE</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if _PAGE_HASHPTE != 0</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_HASHPTE</span><span class="p">)</span>
		<span class="n">flush_hash_entry</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;\</span>
<span class="s">		stw%U0%X0 %2,%0</span><span class="se">\n</span><span class="s">\</span>
<span class="s">		eieio</span><span class="se">\n</span><span class="s">\</span>
<span class="s">		stw%U0%X0 %L2,%1&quot;</span>
	<span class="o">:</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">),</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ptep</span><span class="o">+</span><span class="mi">4</span><span class="p">))</span>
	<span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>

<span class="cp">#elif defined(CONFIG_PPC_STD_MMU_32)</span>
	<span class="cm">/* Third case is 32-bit hash table in UP mode, we need to preserve</span>
<span class="cm">	 * the _PAGE_HASHPTE bit since we may not have invalidated the previous</span>
<span class="cm">	 * translation in the hash yet (done in a subsequent flush_tlb_xxx())</span>
<span class="cm">	 * and see we need to keep track that this PTE needs invalidating</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">__pte</span><span class="p">((</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_HASHPTE</span><span class="p">)</span>
		      <span class="o">|</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_PAGE_HASHPTE</span><span class="p">));</span>

<span class="cp">#else</span>
	<span class="cm">/* Anything else just stores the PTE normally. That covers all 64-bit</span>
<span class="cm">	 * cases, and 32-bit non-hash with 32-bit PTEs.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">pte</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cp">#define __HAVE_ARCH_PTEP_SET_ACCESS_FLAGS</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ptep_set_access_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
				 <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">entry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Macro to mark a page protection value as &quot;uncacheable&quot;.</span>
<span class="cm"> */</span>

<span class="cp">#define _PAGE_CACHE_CTL	(_PAGE_COHERENT | _PAGE_GUARDED | _PAGE_NO_CACHE | \</span>
<span class="cp">			 _PAGE_WRITETHRU)</span>

<span class="cp">#define pgprot_noncached(prot)	  (__pgprot((pgprot_val(prot) &amp; ~_PAGE_CACHE_CTL) | \</span>
<span class="cp">				            _PAGE_NO_CACHE | _PAGE_GUARDED))</span>

<span class="cp">#define pgprot_noncached_wc(prot) (__pgprot((pgprot_val(prot) &amp; ~_PAGE_CACHE_CTL) | \</span>
<span class="cp">				            _PAGE_NO_CACHE))</span>

<span class="cp">#define pgprot_cached(prot)       (__pgprot((pgprot_val(prot) &amp; ~_PAGE_CACHE_CTL) | \</span>
<span class="cp">				            _PAGE_COHERENT))</span>

<span class="cp">#define pgprot_cached_wthru(prot) (__pgprot((pgprot_val(prot) &amp; ~_PAGE_CACHE_CTL) | \</span>
<span class="cp">				            _PAGE_COHERENT | _PAGE_WRITETHRU))</span>

<span class="cp">#define pgprot_cached_noncoherent(prot) \</span>
<span class="cp">		(__pgprot(pgprot_val(prot) &amp; ~_PAGE_CACHE_CTL))</span>

<span class="cp">#define pgprot_writecombine pgprot_noncached_wc</span>

<span class="k">struct</span> <span class="n">file</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">pgprot_t</span> <span class="n">phys_mem_access_prot</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">vma_prot</span><span class="p">);</span>
<span class="cp">#define __HAVE_PHYS_MEM_ACCESS_PROT</span>

<span class="cm">/*</span>
<span class="cm"> * ZERO_PAGE is a global shared page that is always zero: used</span>
<span class="cm"> * for zero-mapped memory areas etc..</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">empty_zero_page</span><span class="p">[];</span>
<span class="cp">#define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))</span>

<span class="k">extern</span> <span class="n">pgd_t</span> <span class="n">swapper_pg_dir</span><span class="p">[];</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">paging_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * kern_addr_valid is intended to indicate whether an address is a valid</span>
<span class="cm"> * kernel address.  Most 32-bit archs define it as always true (like this)</span>
<span class="cm"> * but most 64-bit archs actually perform a test.  What should we do here?</span>
<span class="cm"> */</span>
<span class="cp">#define kern_addr_valid(addr)	(1)</span>

<span class="cp">#define io_remap_pfn_range(vma, vaddr, pfn, size, prot)		\</span>
<span class="cp">		remap_pfn_range(vma, vaddr, pfn, size, prot)</span>

<span class="cp">#include &lt;asm-generic/pgtable.h&gt;</span>


<span class="cm">/*</span>
<span class="cm"> * This gets called at the end of handling a page fault, when</span>
<span class="cm"> * the kernel has put a new PTE into the page table for the process.</span>
<span class="cm"> * We use it to ensure coherency between the i-cache and d-cache</span>
<span class="cm"> * for the page which has just been mapped in.</span>
<span class="cm"> * On machines which use an MMU hash table, we use this to put a</span>
<span class="cm"> * corresponding HPTE into the hash table ahead of time, instead of</span>
<span class="cm"> * waiting for the inevitable extra hash-table miss exception.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">update_mmu_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">gup_hugepd</span><span class="p">(</span><span class="n">hugepd_t</span> <span class="o">*</span><span class="n">hugepd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">pdshift</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nr</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _ASM_POWERPC_PGTABLE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
