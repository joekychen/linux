<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › pmac_pfunc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pmac_pfunc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __PMAC_PFUNC_H__</span>
<span class="cp">#define __PMAC_PFUNC_H__</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>

<span class="cm">/* Flags in command lists */</span>
<span class="cp">#define PMF_FLAGS_ON_INIT		0x80000000u</span>
<span class="cp">#define PMF_FLGAS_ON_TERM		0x40000000u</span>
<span class="cp">#define PMF_FLAGS_ON_SLEEP		0x20000000u</span>
<span class="cp">#define PMF_FLAGS_ON_WAKE		0x10000000u</span>
<span class="cp">#define PMF_FLAGS_ON_DEMAND		0x08000000u</span>
<span class="cp">#define PMF_FLAGS_INT_GEN		0x04000000u</span>
<span class="cp">#define PMF_FLAGS_HIGH_SPEED		0x02000000u</span>
<span class="cp">#define PMF_FLAGS_LOW_SPEED		0x01000000u</span>
<span class="cp">#define PMF_FLAGS_SIDE_EFFECTS		0x00800000u</span>

<span class="cm">/*</span>
<span class="cm"> * Arguments to a platform function call.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: By convention, pointer arguments point to an u32</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pmf_args</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * A driver capable of interpreting commands provides a handlers</span>
<span class="cm"> * structure filled with whatever handlers are implemented by this</span>
<span class="cm"> * driver. Non implemented handlers are left NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * PMF_STD_ARGS are the same arguments that are passed to the parser</span>
<span class="cm"> * and that gets passed back to the various handlers.</span>
<span class="cm"> *</span>
<span class="cm"> * Interpreting a given function always start with a begin() call which</span>
<span class="cm"> * returns an instance data to be passed around subsequent calls, and</span>
<span class="cm"> * ends with an end() call. This allows the low level driver to implement</span>
<span class="cm"> * locking policy or per-function instance data.</span>
<span class="cm"> *</span>
<span class="cm"> * For interrupt capable functions, irq_enable() is called when a client</span>
<span class="cm"> * registers, and irq_disable() is called when the last client unregisters</span>
<span class="cm"> * Note that irq_enable &amp; irq_disable are called within a semaphore held</span>
<span class="cm"> * by the core, thus you should not try to register yourself to some other</span>
<span class="cm"> * pmf interrupt during those calls.</span>
<span class="cm"> */</span>

<span class="cp">#define PMF_STD_ARGS	struct pmf_function *func, void *instdata, \</span>
<span class="cp">		        struct pmf_args *args</span>

<span class="k">struct</span> <span class="n">pmf_function</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">pmf_handlers</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">begin</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pmf_function</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pmf_args</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pmf_function</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">instdata</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_enable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pmf_function</span> <span class="o">*</span><span class="n">func</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_disable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pmf_function</span> <span class="o">*</span><span class="n">func</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_gpio</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_gpio</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rshift</span><span class="p">,</span> <span class="n">u8</span> <span class="n">xor</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_reg32</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_reg32</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_reg16</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mask</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_reg16</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_reg8</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_reg8</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">delay</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">duration</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">wait_reg32</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">wait_reg16</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mask</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">wait_reg8</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_i2c</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_i2c</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rmw_i2c</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">masklen</span><span class="p">,</span> <span class="n">u32</span> <span class="n">valuelen</span><span class="p">,</span> <span class="n">u32</span> <span class="n">totallen</span><span class="p">,</span>
		       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">maskdata</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">valuedata</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_cfg</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_cfg</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rmw_cfg</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">masklen</span><span class="p">,</span> <span class="n">u32</span> <span class="n">valuelen</span><span class="p">,</span>
		       <span class="n">u32</span> <span class="n">totallen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">maskdata</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">valuedata</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_i2c_sub</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u8</span> <span class="n">subaddr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_i2c_sub</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u8</span> <span class="n">subaddr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_i2c_mode</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rmw_i2c_sub</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u8</span> <span class="n">subaddr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">masklen</span><span class="p">,</span> <span class="n">u32</span> <span class="n">valuelen</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="n">totallen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">maskdata</span><span class="p">,</span>
			   <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">valuedata</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_reg32_msrx</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">shift</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">xor</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_reg16_msrx</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">shift</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">xor</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_reg8_msrx</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">shift</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">xor</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_reg32_slm</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">shift</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_reg16_slm</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">shift</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_reg8_slm</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">shift</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mask_and_compare</span><span class="p">)(</span><span class="n">PMF_STD_ARGS</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">maskdata</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">valuedata</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Drivers who expose platform functions register at init time, this</span>
<span class="cm"> * causes the platform functions for that device node to be parsed in</span>
<span class="cm"> * advance and associated with the device. The data structures are</span>
<span class="cm"> * partially public so a driver can walk the list of platform functions</span>
<span class="cm"> * and eventually inspect the flags</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pmf_device</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">pmf_function</span> <span class="p">{</span>
	<span class="cm">/* All functions for a given driver are linked */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>

	<span class="cm">/* Function node &amp; driver data */</span>
	<span class="k">struct</span> <span class="n">device_node</span>	<span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="cm">/* For internal use by core */</span>
	<span class="k">struct</span> <span class="n">pmf_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* The name is the &quot;xxx&quot; in &quot;platform-do-xxx&quot;, this is how</span>
<span class="cm">	 * platform functions are identified by this code. Some functions</span>
<span class="cm">	 * only operate for a given target, in which case the phandle is</span>
<span class="cm">	 * here (or 0 if the filter doesn&#39;t apply)</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">phandle</span><span class="p">;</span>

	<span class="cm">/* The flags for that function. You can have several functions</span>
<span class="cm">	 * with the same name and different flag</span>
<span class="cm">	 */</span>
	<span class="n">u32</span>			<span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* The actual tokenized function blob */</span>
	<span class="k">const</span> <span class="kt">void</span>		<span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">length</span><span class="p">;</span>

	<span class="cm">/* Interrupt clients */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">irq_clients</span><span class="p">;</span>

	<span class="cm">/* Refcounting */</span>
	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">ref</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * For platform functions that are interrupts, one can register</span>
<span class="cm"> * irq_client structures. You canNOT use the same structure twice</span>
<span class="cm"> * as it contains a link member. Also, the callback is called with</span>
<span class="cm"> * a spinlock held, you must not call back into any of the pmf_* functions</span>
<span class="cm"> * from within that callback</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pmf_irq_client</span> <span class="p">{</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span>		<span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmf_function</span>	<span class="o">*</span><span class="n">func</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Register/Unregister a function-capable driver and its handlers</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pmf_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">pmf_handlers</span> <span class="o">*</span><span class="n">handlers</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">driverdata</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">pmf_unregister_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Register/Unregister interrupt clients</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pmf_register_irq_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">pmf_irq_client</span> <span class="o">*</span><span class="n">client</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">pmf_unregister_irq_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmf_irq_client</span> <span class="o">*</span><span class="n">client</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Called by the handlers when an irq happens</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pmf_do_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmf_function</span> <span class="o">*</span><span class="n">func</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Low level call to platform functions.</span>
<span class="cm"> *</span>
<span class="cm"> * The phandle can filter on the target object for functions that have</span>
<span class="cm"> * multiple targets, the flags allow you to restrict the call to a given</span>
<span class="cm"> * combination of flags.</span>
<span class="cm"> *</span>
<span class="cm"> * The args array contains as many arguments as is required by the function,</span>
<span class="cm"> * this is dependent on the function you are calling, unfortunately Apple</span>
<span class="cm"> * mechanism provides no way to encode that so you have to get it right at</span>
<span class="cm"> * the call site. Some functions require no args, in which case, you can</span>
<span class="cm"> * pass NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * You can also pass NULL to the name. This will match any function that has</span>
<span class="cm"> * the appropriate combination of flags &amp; phandle or you can pass 0 to the</span>
<span class="cm"> * phandle to match any</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pmf_do_functions</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">phandle</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pmf_args</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>



<span class="cm">/*</span>
<span class="cm"> * High level call to a platform function.</span>
<span class="cm"> *</span>
<span class="cm"> * This one looks for the platform-xxx first so you should call it to the</span>
<span class="cm"> * actual target if any. It will fallback to platform-do-xxx if it can&#39;t</span>
<span class="cm"> * find one. It will also exclusively target functions that have</span>
<span class="cm"> * the &quot;OnDemand&quot; flag.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">pmf_call_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">pmf_args</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * For low latency interrupt usage, you can lookup for on-demand functions</span>
<span class="cm"> * using the functions below</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">pmf_function</span> <span class="o">*</span><span class="n">pmf_find_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span>
					      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">pmf_function</span> <span class="o">*</span> <span class="n">pmf_get_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmf_function</span> <span class="o">*</span><span class="n">func</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pmf_put_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmf_function</span> <span class="o">*</span><span class="n">func</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">pmf_call_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmf_function</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pmf_args</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>


<span class="cm">/* Suspend/resume code called by via-pmu directly for now */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pmac_pfunc_base_suspend</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pmac_pfunc_base_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __PMAC_PFUNC_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
