<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › sfp-machine.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>sfp-machine.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Machine-dependent software floating-point definitions.  PPC version.</span>
<span class="cm">   Copyright (C) 1997 Free Software Foundation, Inc.</span>
<span class="cm">   This file is part of the GNU C Library.</span>

<span class="cm">   The GNU C Library is free software; you can redistribute it and/or</span>
<span class="cm">   modify it under the terms of the GNU Library General Public License as</span>
<span class="cm">   published by the Free Software Foundation; either version 2 of the</span>
<span class="cm">   License, or (at your option) any later version.</span>

<span class="cm">   The GNU C Library is distributed in the hope that it will be useful,</span>
<span class="cm">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm">   Library General Public License for more details.</span>

<span class="cm">   You should have received a copy of the GNU Library General Public</span>
<span class="cm">   License along with the GNU C Library; see the file COPYING.LIB.  If</span>
<span class="cm">   not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>

<span class="cm">   Actually, this is a PPC (32bit) version, written based on the</span>
<span class="cm">   i386, sparc, and sparc64 versions, by me,</span>
<span class="cm">   Peter Maydell (pmaydell@chiark.greenend.org.uk).</span>
<span class="cm">   Comments are by and large also mine, although they may be inaccurate.</span>

<span class="cm">   In picking out asm fragments I&#39;ve gone with the lowest common</span>
<span class="cm">   denominator, which also happens to be the hardware I have :-&gt;</span>
<span class="cm">   That is, a SPARC without hardware multiply and divide.</span>
<span class="cm"> */</span>

<span class="cm">/* basic word size definitions */</span>
<span class="cp">#define _FP_W_TYPE_SIZE		32</span>
<span class="cp">#define _FP_W_TYPE		unsigned int</span>
<span class="cp">#define _FP_WS_TYPE		signed int</span>
<span class="cp">#define _FP_I_TYPE		int</span>

<span class="cp">#define __ll_B			((UWtype) 1 &lt;&lt; (W_TYPE_SIZE / 2))</span>
<span class="cp">#define __ll_lowpart(t)		((UWtype) (t) &amp; (__ll_B - 1))</span>
<span class="cp">#define __ll_highpart(t)	((UWtype) (t) &gt;&gt; (W_TYPE_SIZE / 2))</span>

<span class="cm">/* You can optionally code some things like addition in asm. For</span>
<span class="cm"> * example, i386 defines __FP_FRAC_ADD_2 as asm. If you don&#39;t</span>
<span class="cm"> * then you get a fragment of C code [if you change an #ifdef 0</span>
<span class="cm"> * in op-2.h] or a call to add_ssaaaa (see below).</span>
<span class="cm"> * Good places to look for asm fragments to use are gcc and glibc.</span>
<span class="cm"> * gcc&#39;s longlong.h is useful.</span>
<span class="cm"> */</span>

<span class="cm">/* We need to know how to multiply and divide. If the host word size</span>
<span class="cm"> * is &gt;= 2*fracbits you can use FP_MUL_MEAT_n_imm(t,R,X,Y) which</span>
<span class="cm"> * codes the multiply with whatever gcc does to &#39;a * b&#39;.</span>
<span class="cm"> * _FP_MUL_MEAT_n_wide(t,R,X,Y,f) is used when you have an asm</span>
<span class="cm"> * function that can multiply two 1W values and get a 2W result.</span>
<span class="cm"> * Otherwise you&#39;re stuck with _FP_MUL_MEAT_n_hard(t,R,X,Y) which</span>
<span class="cm"> * does bitshifting to avoid overflow.</span>
<span class="cm"> * For division there is FP_DIV_MEAT_n_imm(t,R,X,Y,f) for word size</span>
<span class="cm"> * &gt;= 2*fracbits, where f is either _FP_DIV_HELP_imm or</span>
<span class="cm"> * _FP_DIV_HELP_ldiv (see op-1.h).</span>
<span class="cm"> * _FP_DIV_MEAT_udiv() is if you have asm to do 2W/1W =&gt; (1W, 1W).</span>
<span class="cm"> * [GCC and glibc have longlong.h which has the asm macro udiv_qrnnd</span>
<span class="cm"> * to do this.]</span>
<span class="cm"> * In general, &#39;n&#39; is the number of words required to hold the type,</span>
<span class="cm"> * and &#39;t&#39; is either S, D or Q for single/double/quad.</span>
<span class="cm"> *           -- PMM</span>
<span class="cm"> */</span>
<span class="cm">/* Example: SPARC64:</span>
<span class="cm"> * #define _FP_MUL_MEAT_S(R,X,Y)	_FP_MUL_MEAT_1_imm(S,R,X,Y)</span>
<span class="cm"> * #define _FP_MUL_MEAT_D(R,X,Y)	_FP_MUL_MEAT_1_wide(D,R,X,Y,umul_ppmm)</span>
<span class="cm"> * #define _FP_MUL_MEAT_Q(R,X,Y)	_FP_MUL_MEAT_2_wide(Q,R,X,Y,umul_ppmm)</span>
<span class="cm"> *</span>
<span class="cm"> * #define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_imm(S,R,X,Y,_FP_DIV_HELP_imm)</span>
<span class="cm"> * #define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_1_udiv(D,R,X,Y)</span>
<span class="cm"> * #define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_2_udiv_64(Q,R,X,Y)</span>
<span class="cm"> *</span>
<span class="cm"> * Example: i386:</span>
<span class="cm"> * #define _FP_MUL_MEAT_S(R,X,Y)   _FP_MUL_MEAT_1_wide(S,R,X,Y,_i386_mul_32_64)</span>
<span class="cm"> * #define _FP_MUL_MEAT_D(R,X,Y)   _FP_MUL_MEAT_2_wide(D,R,X,Y,_i386_mul_32_64)</span>
<span class="cm"> *</span>
<span class="cm"> * #define _FP_DIV_MEAT_S(R,X,Y)   _FP_DIV_MEAT_1_udiv(S,R,X,Y,_i386_div_64_32)</span>
<span class="cm"> * #define _FP_DIV_MEAT_D(R,X,Y)   _FP_DIV_MEAT_2_udiv_64(D,R,X,Y)</span>
<span class="cm"> */</span>

<span class="cp">#define _FP_MUL_MEAT_S(R,X,Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)</span>
<span class="cp">#define _FP_MUL_MEAT_D(R,X,Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)</span>

<span class="cp">#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_udiv_norm(S,R,X,Y)</span>
<span class="cp">#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)</span>

<span class="cm">/* These macros define what NaN looks like. They&#39;re supposed to expand to</span>
<span class="cm"> * a comma-separated set of 32bit unsigned ints that encode NaN.</span>
<span class="cm"> */</span>
<span class="cp">#define _FP_NANFRAC_S		((_FP_QNANBIT_S &lt;&lt; 1) - 1)</span>
<span class="cp">#define _FP_NANFRAC_D		((_FP_QNANBIT_D &lt;&lt; 1) - 1), -1</span>
<span class="cp">#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q &lt;&lt; 1) - 1), -1, -1, -1</span>
<span class="cp">#define _FP_NANSIGN_S		0</span>
<span class="cp">#define _FP_NANSIGN_D		0</span>
<span class="cp">#define _FP_NANSIGN_Q		0</span>

<span class="cp">#define _FP_KEEPNANFRACP 1</span>

<span class="cp">#ifdef FP_EX_BOOKE_E500_SPE</span>
<span class="cp">#define FP_EX_INEXACT		(1 &lt;&lt; 21)</span>
<span class="cp">#define FP_EX_INVALID		(1 &lt;&lt; 20)</span>
<span class="cp">#define FP_EX_DIVZERO		(1 &lt;&lt; 19)</span>
<span class="cp">#define FP_EX_UNDERFLOW		(1 &lt;&lt; 18)</span>
<span class="cp">#define FP_EX_OVERFLOW		(1 &lt;&lt; 17)</span>
<span class="cp">#define FP_INHIBIT_RESULTS	0</span>

<span class="cp">#define __FPU_FPSCR	(current-&gt;thread.spefscr)</span>
<span class="cp">#define __FPU_ENABLED_EXC		\</span>
<span class="cp">({					\</span>
<span class="cp">	(__FPU_FPSCR &gt;&gt; 2) &amp; 0x1f;	\</span>
<span class="cp">})</span>
<span class="cp">#else</span>
<span class="cm">/* Exception flags.  We use the bit positions of the appropriate bits</span>
<span class="cm">   in the FPSCR, which also correspond to the FE_* bits.  This makes</span>
<span class="cm">   everything easier ;-).  */</span>
<span class="cp">#define FP_EX_INVALID         (1 &lt;&lt; (31 - 2))</span>
<span class="cp">#define FP_EX_INVALID_SNAN	EFLAG_VXSNAN</span>
<span class="cp">#define FP_EX_INVALID_ISI	EFLAG_VXISI</span>
<span class="cp">#define FP_EX_INVALID_IDI	EFLAG_VXIDI</span>
<span class="cp">#define FP_EX_INVALID_ZDZ	EFLAG_VXZDZ</span>
<span class="cp">#define FP_EX_INVALID_IMZ	EFLAG_VXIMZ</span>
<span class="cp">#define FP_EX_OVERFLOW        (1 &lt;&lt; (31 - 3))</span>
<span class="cp">#define FP_EX_UNDERFLOW       (1 &lt;&lt; (31 - 4))</span>
<span class="cp">#define FP_EX_DIVZERO         (1 &lt;&lt; (31 - 5))</span>
<span class="cp">#define FP_EX_INEXACT         (1 &lt;&lt; (31 - 6))</span>

<span class="cp">#define __FPU_FPSCR	(current-&gt;thread.fpscr.val)</span>

<span class="cm">/* We only actually write to the destination register</span>
<span class="cm"> * if exceptions signalled (if any) will not trap.</span>
<span class="cm"> */</span>
<span class="cp">#define __FPU_ENABLED_EXC \</span>
<span class="cp">({						\</span>
<span class="cp">	(__FPU_FPSCR &gt;&gt; 3) &amp; 0x1f;	\</span>
<span class="cp">})</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * If one NaN is signaling and the other is not,</span>
<span class="cm"> * we choose that one, otherwise we choose X.</span>
<span class="cm"> */</span>
<span class="cp">#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\</span>
<span class="cp">  do {								\</span>
<span class="cp">    if ((_FP_FRAC_HIGH_RAW_##fs(Y) &amp; _FP_QNANBIT_##fs)		\</span>
<span class="cp">	&amp;&amp; !(_FP_FRAC_HIGH_RAW_##fs(X) &amp; _FP_QNANBIT_##fs))	\</span>
<span class="cp">      {								\</span>
<span class="cp">	R##_s = X##_s;						\</span>
<span class="cp">	_FP_FRAC_COPY_##wc(R,X);				\</span>
<span class="cp">      }								\</span>
<span class="cp">    else							\</span>
<span class="cp">      {								\</span>
<span class="cp">	R##_s = Y##_s;						\</span>
<span class="cp">	_FP_FRAC_COPY_##wc(R,Y);				\</span>
<span class="cp">      }								\</span>
<span class="cp">    R##_c = FP_CLS_NAN;						\</span>
<span class="cp">  } while (0)</span>


<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cp">#define __FPU_TRAP_P(bits) \</span>
<span class="cp">	((__FPU_ENABLED_EXC &amp; (bits)) != 0)</span>

<span class="cp">#define __FP_PACK_S(val,X)			\</span>
<span class="cp">({  int __exc = _FP_PACK_CANONICAL(S,1,X);	\</span>
<span class="cp">    if(!__exc || !__FPU_TRAP_P(__exc))		\</span>
<span class="cp">        _FP_PACK_RAW_1_P(S,val,X);		\</span>
<span class="cp">    __exc;					\</span>
<span class="cp">})</span>

<span class="cp">#define __FP_PACK_D(val,X)			\</span>
<span class="cp">   do {									\</span>
<span class="cp">	_FP_PACK_CANONICAL(D, 2, X);					\</span>
<span class="cp">	if (!FP_CUR_EXCEPTIONS || !__FPU_TRAP_P(FP_CUR_EXCEPTIONS))	\</span>
<span class="cp">		_FP_PACK_RAW_2_P(D, val, X);				\</span>
<span class="cp">   } while (0)</span>

<span class="cp">#define __FP_PACK_DS(val,X)							\</span>
<span class="cp">   do {										\</span>
<span class="cp">	   FP_DECL_S(__X);							\</span>
<span class="cp">	   FP_CONV(S, D, 1, 2, __X, X);						\</span>
<span class="cp">	   _FP_PACK_CANONICAL(S, 1, __X);					\</span>
<span class="cp">	   if (!FP_CUR_EXCEPTIONS || !__FPU_TRAP_P(FP_CUR_EXCEPTIONS)) {	\</span>
<span class="cp">		   _FP_UNPACK_CANONICAL(S, 1, __X);				\</span>
<span class="cp">		   FP_CONV(D, S, 2, 1, X, __X);					\</span>
<span class="cp">		   _FP_PACK_CANONICAL(D, 2, X);					\</span>
<span class="cp">		   if (!FP_CUR_EXCEPTIONS || !__FPU_TRAP_P(FP_CUR_EXCEPTIONS))	\</span>
<span class="cp">		   _FP_PACK_RAW_2_P(D, val, X);					\</span>
<span class="cp">	   }									\</span>
<span class="cp">   } while (0)</span>

<span class="cm">/* Obtain the current rounding mode. */</span>
<span class="cp">#define FP_ROUNDMODE			\</span>
<span class="cp">({					\</span>
<span class="cp">	__FPU_FPSCR &amp; 0x3;		\</span>
<span class="cp">})</span>

<span class="cm">/* the asm fragments go here: all these are taken from glibc-2.0.5&#39;s</span>
<span class="cm"> * stdlib/longlong.h</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cm">/* add_ssaaaa is used in op-2.h and should be equivalent to</span>
<span class="cm"> * #define add_ssaaaa(sh,sl,ah,al,bh,bl) (sh = ah+bh+ (( sl = al+bl) &lt; al))</span>
<span class="cm"> * add_ssaaaa(high_sum, low_sum, high_addend_1, low_addend_1,</span>
<span class="cm"> * high_addend_2, low_addend_2) adds two UWtype integers, composed by</span>
<span class="cm"> * HIGH_ADDEND_1 and LOW_ADDEND_1, and HIGH_ADDEND_2 and LOW_ADDEND_2</span>
<span class="cm"> * respectively.  The result is placed in HIGH_SUM and LOW_SUM.  Overflow</span>
<span class="cm"> * (i.e. carry out) is not stored anywhere, and is lost.</span>
<span class="cm"> */</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl)				\</span>
<span class="cp">  do {									\</span>
<span class="cp">    if (__builtin_constant_p (bh) &amp;&amp; (bh) == 0)				\</span>
<span class="cp">      __asm__ (&quot;{a%I4|add%I4c} %1,%3,%4\n\t{aze|addze} %0,%2&quot;		\</span>
<span class="cp">	     : &quot;=r&quot; ((USItype)(sh)),					\</span>
<span class="cp">	       &quot;=&amp;r&quot; ((USItype)(sl))					\</span>
<span class="cp">	     : &quot;%r&quot; ((USItype)(ah)),					\</span>
<span class="cp">	       &quot;%r&quot; ((USItype)(al)),					\</span>
<span class="cp">	       &quot;rI&quot; ((USItype)(bl)));					\</span>
<span class="cp">    else if (__builtin_constant_p (bh) &amp;&amp; (bh) ==~(USItype) 0)		\</span>
<span class="cp">      __asm__ (&quot;{a%I4|add%I4c} %1,%3,%4\n\t{ame|addme} %0,%2&quot;		\</span>
<span class="cp">	     : &quot;=r&quot; ((USItype)(sh)),					\</span>
<span class="cp">	       &quot;=&amp;r&quot; ((USItype)(sl))					\</span>
<span class="cp">	     : &quot;%r&quot; ((USItype)(ah)),					\</span>
<span class="cp">	       &quot;%r&quot; ((USItype)(al)),					\</span>
<span class="cp">	       &quot;rI&quot; ((USItype)(bl)));					\</span>
<span class="cp">    else								\</span>
<span class="cp">      __asm__ (&quot;{a%I5|add%I5c} %1,%4,%5\n\t{ae|adde} %0,%2,%3&quot;		\</span>
<span class="cp">	     : &quot;=r&quot; ((USItype)(sh)),					\</span>
<span class="cp">	       &quot;=&amp;r&quot; ((USItype)(sl))					\</span>
<span class="cp">	     : &quot;%r&quot; ((USItype)(ah)),					\</span>
<span class="cp">	       &quot;r&quot; ((USItype)(bh)),					\</span>
<span class="cp">	       &quot;%r&quot; ((USItype)(al)),					\</span>
<span class="cp">	       &quot;rI&quot; ((USItype)(bl)));					\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/* sub_ddmmss is used in op-2.h and udivmodti4.c and should be equivalent to</span>
<span class="cm"> * #define sub_ddmmss(sh, sl, ah, al, bh, bl) (sh = ah-bh - ((sl = al-bl) &gt; al))</span>
<span class="cm"> * sub_ddmmss(high_difference, low_difference, high_minuend, low_minuend,</span>
<span class="cm"> * high_subtrahend, low_subtrahend) subtracts two two-word UWtype integers,</span>
<span class="cm"> * composed by HIGH_MINUEND_1 and LOW_MINUEND_1, and HIGH_SUBTRAHEND_2 and</span>
<span class="cm"> * LOW_SUBTRAHEND_2 respectively.  The result is placed in HIGH_DIFFERENCE</span>
<span class="cm"> * and LOW_DIFFERENCE.  Overflow (i.e. carry out) is not stored anywhere,</span>
<span class="cm"> * and is lost.</span>
<span class="cm"> */</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl)				\</span>
<span class="cp">  do {									\</span>
<span class="cp">    if (__builtin_constant_p (ah) &amp;&amp; (ah) == 0)				\</span>
<span class="cp">      __asm__ (&quot;{sf%I3|subf%I3c} %1,%4,%3\n\t{sfze|subfze} %0,%2&quot;	\</span>
<span class="cp">	       : &quot;=r&quot; ((USItype)(sh)),					\</span>
<span class="cp">		 &quot;=&amp;r&quot; ((USItype)(sl))					\</span>
<span class="cp">	       : &quot;r&quot; ((USItype)(bh)),					\</span>
<span class="cp">		 &quot;rI&quot; ((USItype)(al)),					\</span>
<span class="cp">		 &quot;r&quot; ((USItype)(bl)));					\</span>
<span class="cp">    else if (__builtin_constant_p (ah) &amp;&amp; (ah) ==~(USItype) 0)		\</span>
<span class="cp">      __asm__ (&quot;{sf%I3|subf%I3c} %1,%4,%3\n\t{sfme|subfme} %0,%2&quot;	\</span>
<span class="cp">	       : &quot;=r&quot; ((USItype)(sh)),					\</span>
<span class="cp">		 &quot;=&amp;r&quot; ((USItype)(sl))					\</span>
<span class="cp">	       : &quot;r&quot; ((USItype)(bh)),					\</span>
<span class="cp">		 &quot;rI&quot; ((USItype)(al)),					\</span>
<span class="cp">		 &quot;r&quot; ((USItype)(bl)));					\</span>
<span class="cp">    else if (__builtin_constant_p (bh) &amp;&amp; (bh) == 0)			\</span>
<span class="cp">      __asm__ (&quot;{sf%I3|subf%I3c} %1,%4,%3\n\t{ame|addme} %0,%2&quot;		\</span>
<span class="cp">	       : &quot;=r&quot; ((USItype)(sh)),					\</span>
<span class="cp">		 &quot;=&amp;r&quot; ((USItype)(sl))					\</span>
<span class="cp">	       : &quot;r&quot; ((USItype)(ah)),					\</span>
<span class="cp">		 &quot;rI&quot; ((USItype)(al)),					\</span>
<span class="cp">		 &quot;r&quot; ((USItype)(bl)));					\</span>
<span class="cp">    else if (__builtin_constant_p (bh) &amp;&amp; (bh) ==~(USItype) 0)		\</span>
<span class="cp">      __asm__ (&quot;{sf%I3|subf%I3c} %1,%4,%3\n\t{aze|addze} %0,%2&quot;		\</span>
<span class="cp">	       : &quot;=r&quot; ((USItype)(sh)),					\</span>
<span class="cp">		 &quot;=&amp;r&quot; ((USItype)(sl))					\</span>
<span class="cp">	       : &quot;r&quot; ((USItype)(ah)),					\</span>
<span class="cp">		 &quot;rI&quot; ((USItype)(al)),					\</span>
<span class="cp">		 &quot;r&quot; ((USItype)(bl)));					\</span>
<span class="cp">    else								\</span>
<span class="cp">      __asm__ (&quot;{sf%I4|subf%I4c} %1,%5,%4\n\t{sfe|subfe} %0,%3,%2&quot;	\</span>
<span class="cp">	       : &quot;=r&quot; ((USItype)(sh)),					\</span>
<span class="cp">		 &quot;=&amp;r&quot; ((USItype)(sl))					\</span>
<span class="cp">	       : &quot;r&quot; ((USItype)(ah)),					\</span>
<span class="cp">		 &quot;r&quot; ((USItype)(bh)),					\</span>
<span class="cp">		 &quot;rI&quot; ((USItype)(al)),					\</span>
<span class="cp">		 &quot;r&quot; ((USItype)(bl)));					\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/* asm fragments for mul and div */</span>

<span class="cm">/* umul_ppmm(high_prod, low_prod, multipler, multiplicand) multiplies two</span>
<span class="cm"> * UWtype integers MULTIPLER and MULTIPLICAND, and generates a two UWtype</span>
<span class="cm"> * word product in HIGH_PROD and LOW_PROD.</span>
<span class="cm"> */</span>
<span class="cp">#define umul_ppmm(ph, pl, m0, m1)					\</span>
<span class="cp">  do {									\</span>
<span class="cp">    USItype __m0 = (m0), __m1 = (m1);					\</span>
<span class="cp">    __asm__ (&quot;mulhwu %0,%1,%2&quot;						\</span>
<span class="cp">	     : &quot;=r&quot; ((USItype)(ph))					\</span>
<span class="cp">	     : &quot;%r&quot; (__m0),						\</span>
<span class="cp">               &quot;r&quot; (__m1));						\</span>
<span class="cp">    (pl) = __m0 * __m1;							\</span>
<span class="cp">  } while (0)</span>

<span class="cm">/* udiv_qrnnd(quotient, remainder, high_numerator, low_numerator,</span>
<span class="cm"> * denominator) divides a UDWtype, composed by the UWtype integers</span>
<span class="cm"> * HIGH_NUMERATOR and LOW_NUMERATOR, by DENOMINATOR and places the quotient</span>
<span class="cm"> * in QUOTIENT and the remainder in REMAINDER.  HIGH_NUMERATOR must be less</span>
<span class="cm"> * than DENOMINATOR for correct operation.  If, in addition, the most</span>
<span class="cm"> * significant bit of DENOMINATOR must be 1, then the pre-processor symbol</span>
<span class="cm"> * UDIV_NEEDS_NORMALIZATION is defined to 1.</span>
<span class="cm"> */</span>
<span class="cp">#define udiv_qrnnd(q, r, n1, n0, d)					\</span>
<span class="cp">  do {									\</span>
<span class="cp">    UWtype __d1, __d0, __q1, __q0, __r1, __r0, __m;			\</span>
<span class="cp">    __d1 = __ll_highpart (d);						\</span>
<span class="cp">    __d0 = __ll_lowpart (d);						\</span>
<span class="cp">									\</span>
<span class="cp">    __r1 = (n1) % __d1;							\</span>
<span class="cp">    __q1 = (n1) / __d1;							\</span>
<span class="cp">    __m = (UWtype) __q1 * __d0;						\</span>
<span class="cp">    __r1 = __r1 * __ll_B | __ll_highpart (n0);				\</span>
<span class="cp">    if (__r1 &lt; __m)							\</span>
<span class="cp">      {									\</span>
<span class="cp">	__q1--, __r1 += (d);						\</span>
<span class="cp">	if (__r1 &gt;= (d)) </span><span class="cm">/* we didn&#39;t get carry when adding to __r1 */</span><span class="cp">	\</span>
<span class="cp">	  if (__r1 &lt; __m)						\</span>
<span class="cp">	    __q1--, __r1 += (d);					\</span>
<span class="cp">      }									\</span>
<span class="cp">    __r1 -= __m;							\</span>
<span class="cp">									\</span>
<span class="cp">    __r0 = __r1 % __d1;							\</span>
<span class="cp">    __q0 = __r1 / __d1;							\</span>
<span class="cp">    __m = (UWtype) __q0 * __d0;						\</span>
<span class="cp">    __r0 = __r0 * __ll_B | __ll_lowpart (n0);				\</span>
<span class="cp">    if (__r0 &lt; __m)							\</span>
<span class="cp">      {									\</span>
<span class="cp">	__q0--, __r0 += (d);						\</span>
<span class="cp">	if (__r0 &gt;= (d))						\</span>
<span class="cp">	  if (__r0 &lt; __m)						\</span>
<span class="cp">	    __q0--, __r0 += (d);					\</span>
<span class="cp">      }									\</span>
<span class="cp">    __r0 -= __m;							\</span>
<span class="cp">									\</span>
<span class="cp">    (q) = (UWtype) __q1 * __ll_B | __q0;				\</span>
<span class="cp">    (r) = __r0;								\</span>
<span class="cp">  } while (0)</span>

<span class="cp">#define UDIV_NEEDS_NORMALIZATION 1</span>

<span class="cp">#define abort()								\</span>
<span class="cp">	return 0</span>

<span class="cp">#ifdef __BIG_ENDIAN</span>
<span class="cp">#define __BYTE_ORDER __BIG_ENDIAN</span>
<span class="cp">#else</span>
<span class="cp">#define __BYTE_ORDER __LITTLE_ENDIAN</span>
<span class="cp">#endif</span>

<span class="cm">/* Exception flags. */</span>
<span class="cp">#define EFLAG_INVALID		(1 &lt;&lt; (31 - 2))</span>
<span class="cp">#define EFLAG_OVERFLOW		(1 &lt;&lt; (31 - 3))</span>
<span class="cp">#define EFLAG_UNDERFLOW		(1 &lt;&lt; (31 - 4))</span>
<span class="cp">#define EFLAG_DIVZERO		(1 &lt;&lt; (31 - 5))</span>
<span class="cp">#define EFLAG_INEXACT		(1 &lt;&lt; (31 - 6))</span>

<span class="cp">#define EFLAG_VXSNAN		(1 &lt;&lt; (31 - 7))</span>
<span class="cp">#define EFLAG_VXISI		(1 &lt;&lt; (31 - 8))</span>
<span class="cp">#define EFLAG_VXIDI		(1 &lt;&lt; (31 - 9))</span>
<span class="cp">#define EFLAG_VXZDZ		(1 &lt;&lt; (31 - 10))</span>
<span class="cp">#define EFLAG_VXIMZ		(1 &lt;&lt; (31 - 11))</span>
<span class="cp">#define EFLAG_VXVC		(1 &lt;&lt; (31 - 12))</span>
<span class="cp">#define EFLAG_VXSOFT		(1 &lt;&lt; (31 - 21))</span>
<span class="cp">#define EFLAG_VXSQRT		(1 &lt;&lt; (31 - 22))</span>
<span class="cp">#define EFLAG_VXCVI		(1 &lt;&lt; (31 - 23))</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
