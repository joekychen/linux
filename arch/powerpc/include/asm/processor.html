<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › processor.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>processor.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_POWERPC_PROCESSOR_H</span>
<span class="cp">#define _ASM_POWERPC_PROCESSOR_H</span>

<span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2001 PPC 64 Team, IBM Corp</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;asm/reg.h&gt;</span>

<span class="cp">#ifdef CONFIG_VSX</span>
<span class="cp">#define TS_FPRWIDTH 2</span>
<span class="cp">#else</span>
<span class="cp">#define TS_FPRWIDTH 1</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>

<span class="cm">/* We do _not_ want to define new machine types at all, those must die</span>
<span class="cm"> * in favor of using the device-tree</span>
<span class="cm"> * -- BenH.</span>
<span class="cm"> */</span>

<span class="cm">/* PREP sub-platform types see residual.h for these */</span>
<span class="cp">#define _PREP_Motorola	0x01	</span><span class="cm">/* motorola prep */</span><span class="cp"></span>
<span class="cp">#define _PREP_Firm	0x02	</span><span class="cm">/* firmworks prep */</span><span class="cp"></span>
<span class="cp">#define _PREP_IBM	0x00	</span><span class="cm">/* ibm prep */</span><span class="cp"></span>
<span class="cp">#define _PREP_Bull	0x03	</span><span class="cm">/* bull prep */</span><span class="cp"></span>

<span class="cm">/* CHRP sub-platform types. These are arbitrary */</span>
<span class="cp">#define _CHRP_Motorola	0x04	</span><span class="cm">/* motorola chrp, the cobra */</span><span class="cp"></span>
<span class="cp">#define _CHRP_IBM	0x05	</span><span class="cm">/* IBM chrp, the longtrail and longtrail 2 */</span><span class="cp"></span>
<span class="cp">#define _CHRP_Pegasos	0x06	</span><span class="cm">/* Genesi/bplan&#39;s Pegasos and Pegasos2 */</span><span class="cp"></span>
<span class="cp">#define _CHRP_briq	0x07	</span><span class="cm">/* TotalImpact&#39;s briQ */</span><span class="cp"></span>

<span class="cp">#if defined(__KERNEL__) &amp;&amp; defined(CONFIG_PPC32)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">_chrp_type</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC_PREP</span>

<span class="cm">/* what kind of prep workstation we are */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">_prep_type</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_PREP */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* defined(__KERNEL__) &amp;&amp; defined(CONFIG_PPC32) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Default implementation of macro that returns current</span>
<span class="cm"> * instruction pointer (&quot;program counter&quot;).</span>
<span class="cm"> */</span>
<span class="cp">#define current_text_addr() ({ __label__ _l; _l: &amp;&amp;_l;})</span>

<span class="cm">/* Macros for adjusting thread priority (hardware multi-threading) */</span>
<span class="cp">#define HMT_very_low()   asm volatile(&quot;or 31,31,31   # very low priority&quot;)</span>
<span class="cp">#define HMT_low()	 asm volatile(&quot;or 1,1,1	     # low priority&quot;)</span>
<span class="cp">#define HMT_medium_low() asm volatile(&quot;or 6,6,6      # medium low priority&quot;)</span>
<span class="cp">#define HMT_medium()	 asm volatile(&quot;or 2,2,2	     # medium priority&quot;)</span>
<span class="cp">#define HMT_medium_high() asm volatile(&quot;or 5,5,5      # medium high priority&quot;)</span>
<span class="cp">#define HMT_high()	 asm volatile(&quot;or 3,3,3	     # high priority&quot;)</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">start_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fdptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">release_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Create a new kernel thread. */</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">kernel_thread</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/* Lazy FPU handling on uni-processor */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">last_task_used_math</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">last_task_used_altivec</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">last_task_used_vsx</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">last_task_used_spe</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC32</span>

<span class="cp">#if CONFIG_TASK_SIZE &gt; CONFIG_KERNEL_START</span>
<span class="cp">#error User TASK_SIZE overlaps with KERNEL_START address</span>
<span class="cp">#endif</span>
<span class="cp">#define TASK_SIZE	(CONFIG_TASK_SIZE)</span>

<span class="cm">/* This decides where the kernel will search for a free chunk of vm</span>
<span class="cm"> * space during mmap&#39;s.</span>
<span class="cm"> */</span>
<span class="cp">#define TASK_UNMAPPED_BASE	(TASK_SIZE / 8 * 3)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cm">/* 64-bit user address space is 44-bits (16TB user VM) */</span>
<span class="cp">#define TASK_SIZE_USER64 (0x0000100000000000UL)</span>

<span class="cm">/* </span>
<span class="cm"> * 32-bit user address space is 4GB - 1 page </span>
<span class="cm"> * (this 1 page is needed so referencing of 0xFFFFFFFF generates EFAULT</span>
<span class="cm"> */</span>
<span class="cp">#define TASK_SIZE_USER32 (0x0000000100000000UL - (1*PAGE_SIZE))</span>

<span class="cp">#define TASK_SIZE_OF(tsk) (test_tsk_thread_flag(tsk, TIF_32BIT) ? \</span>
<span class="cp">		TASK_SIZE_USER32 : TASK_SIZE_USER64)</span>
<span class="cp">#define TASK_SIZE	  TASK_SIZE_OF(current)</span>

<span class="cm">/* This decides where the kernel will search for a free chunk of vm</span>
<span class="cm"> * space during mmap&#39;s.</span>
<span class="cm"> */</span>
<span class="cp">#define TASK_UNMAPPED_BASE_USER32 (PAGE_ALIGN(TASK_SIZE_USER32 / 4))</span>
<span class="cp">#define TASK_UNMAPPED_BASE_USER64 (PAGE_ALIGN(TASK_SIZE_USER64 / 4))</span>

<span class="cp">#define TASK_UNMAPPED_BASE ((is_32bit_task()) ? \</span>
<span class="cp">		TASK_UNMAPPED_BASE_USER32 : TASK_UNMAPPED_BASE_USER64 )</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef __powerpc64__</span>

<span class="cp">#define STACK_TOP_USER64 TASK_SIZE_USER64</span>
<span class="cp">#define STACK_TOP_USER32 TASK_SIZE_USER32</span>

<span class="cp">#define STACK_TOP (is_32bit_task() ? \</span>
<span class="cp">		   STACK_TOP_USER32 : STACK_TOP_USER64)</span>

<span class="cp">#define STACK_TOP_MAX STACK_TOP_USER64</span>

<span class="cp">#else </span><span class="cm">/* __powerpc64__ */</span><span class="cp"></span>

<span class="cp">#define STACK_TOP TASK_SIZE</span>
<span class="cp">#define STACK_TOP_MAX	STACK_TOP</span>

<span class="cp">#endif </span><span class="cm">/* __powerpc64__ */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seg</span><span class="p">;</span>
<span class="p">}</span> <span class="n">mm_segment_t</span><span class="p">;</span>

<span class="cp">#define TS_FPROFFSET 0</span>
<span class="cp">#define TS_VSRLOWOFFSET 1</span>
<span class="cp">#define TS_FPR(i) fpr[i][TS_FPROFFSET]</span>

<span class="k">struct</span> <span class="n">thread_struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">ksp</span><span class="p">;</span>		<span class="cm">/* Kernel stack pointer */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">ksp_limit</span><span class="p">;</span>	<span class="cm">/* if ksp &lt;= ksp_limit stack overflow */</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">ksp_vsid</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">pt_regs</span>	<span class="o">*</span><span class="n">regs</span><span class="p">;</span>		<span class="cm">/* Pointer to saved register state */</span>
	<span class="n">mm_segment_t</span>	<span class="n">fs</span><span class="p">;</span>		<span class="cm">/* for get_fs() validation */</span>
<span class="cp">#ifdef CONFIG_BOOKE</span>
	<span class="cm">/* BookE base exception scratch space; align on cacheline */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">normsave</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_PPC32</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">pgdir</span><span class="p">;</span>		<span class="cm">/* root of page-table tree */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_PPC_ADV_DEBUG_REGS</span>
	<span class="cm">/*</span>
<span class="cm">	 * The following help to manage the use of Debug Control Registers</span>
<span class="cm">	 * om the BookE platforms.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dbcr0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dbcr1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BOOKE</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dbcr2</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * The stored value of the DBSR register will be the value at the</span>
<span class="cm">	 * last debug interrupt. This register can only be read from the</span>
<span class="cm">	 * user (will never be written to) and has value while helping to</span>
<span class="cm">	 * describe the reason for the last debug trap.  Torez</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dbsr</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The following will contain addresses used by debug applications</span>
<span class="cm">	 * to help trace and trap on particular address locations.</span>
<span class="cm">	 * The bits in the Debug Control Registers above help define which</span>
<span class="cm">	 * of the following registers will contain valid data and/or addresses.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">iac1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">iac2</span><span class="p">;</span>
<span class="cp">#if CONFIG_PPC_ADV_DEBUG_IACS &gt; 2</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">iac3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">iac4</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dac1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dac2</span><span class="p">;</span>
<span class="cp">#if CONFIG_PPC_ADV_DEBUG_DVCS &gt; 0</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dvc1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dvc2</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
	<span class="cm">/* FP and VSX 0-31 register set */</span>
	<span class="kt">double</span>		<span class="n">fpr</span><span class="p">[</span><span class="mi">32</span><span class="p">][</span><span class="n">TS_FPRWIDTH</span><span class="p">];</span>
	<span class="k">struct</span> <span class="p">{</span>

		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>	<span class="cm">/* Floating point status */</span>
	<span class="p">}</span> <span class="n">fpscr</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">fpexc_mode</span><span class="p">;</span>	<span class="cm">/* floating-point exception mode */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">align_ctl</span><span class="p">;</span>	<span class="cm">/* alignment handling control */</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">start_tb</span><span class="p">;</span>	<span class="cm">/* Start purr when proc switched in */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">accum_tb</span><span class="p">;</span>	<span class="cm">/* Total accumilated purr for process */</span>
<span class="cp">#ifdef CONFIG_HAVE_HW_BREAKPOINT</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">ptrace_bps</span><span class="p">[</span><span class="n">HBP_NUM</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * Helps identify source of single-step exception and subsequent</span>
<span class="cm">	 * hw-breakpoint enablement</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">last_hit_ubp</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HAVE_HW_BREAKPOINT */</span><span class="cp"></span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dabr</span><span class="p">;</span>		<span class="cm">/* Data address breakpoint register */</span>
<span class="cp">#ifdef CONFIG_ALTIVEC</span>
	<span class="cm">/* Complete AltiVec register set */</span>
	<span class="n">vector128</span>	<span class="n">vr</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span>
	<span class="cm">/* AltiVec status */</span>
	<span class="n">vector128</span>	<span class="n">vscr</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">vrsave</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">used_vr</span><span class="p">;</span>	<span class="cm">/* set if process has used altivec */</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ALTIVEC */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_VSX</span>
	<span class="cm">/* VSR status */</span>
	<span class="kt">int</span>		<span class="n">used_vsr</span><span class="p">;</span>	<span class="cm">/* set if process has used altivec */</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_VSX */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_SPE</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">evr</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="cm">/* upper 32-bits of SPE regs */</span>
	<span class="n">u64</span>		<span class="n">acc</span><span class="p">;</span>		<span class="cm">/* Accumulator */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">spefscr</span><span class="p">;</span>	<span class="cm">/* SPE &amp; eFP status */</span>
	<span class="kt">int</span>		<span class="n">used_spe</span><span class="p">;</span>	<span class="cm">/* set if process has used spe */</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SPE */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_KVM_BOOK3S_32_HANDLER</span>
	<span class="kt">void</span><span class="o">*</span>		<span class="n">kvm_shadow_vcpu</span><span class="p">;</span> <span class="cm">/* KVM internal data */</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_KVM_BOOK3S_32_HANDLER */</span><span class="cp"></span>
<span class="cp">#if defined(CONFIG_KVM) &amp;&amp; defined(CONFIG_BOOKE)</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span>	<span class="o">*</span><span class="n">kvm_vcpu</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dscr</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">dscr_inherit</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#define ARCH_MIN_TASKALIGN 16</span>

<span class="cp">#define INIT_SP		(sizeof(init_stack) + (unsigned long) &amp;init_stack)</span>
<span class="cp">#define INIT_SP_LIMIT \</span>
<span class="cp">	(_ALIGN_UP(sizeof(init_thread_info), 16) + (unsigned long) &amp;init_stack)</span>

<span class="cp">#ifdef CONFIG_SPE</span>
<span class="cp">#define SPEFSCR_INIT .spefscr = SPEFSCR_FINVE | SPEFSCR_FDBZE | SPEFSCR_FUNFE | SPEFSCR_FOVFE,</span>
<span class="cp">#else</span>
<span class="cp">#define SPEFSCR_INIT</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PPC32</span>
<span class="cp">#define INIT_THREAD { \</span>
<span class="cp">	.ksp = INIT_SP, \</span>
<span class="cp">	.ksp_limit = INIT_SP_LIMIT, \</span>
<span class="cp">	.fs = KERNEL_DS, \</span>
<span class="cp">	.pgdir = swapper_pg_dir, \</span>
<span class="cp">	.fpexc_mode = MSR_FE0 | MSR_FE1, \</span>
<span class="cp">	SPEFSCR_INIT \</span>
<span class="cp">}</span>
<span class="cp">#else</span>
<span class="cp">#define INIT_THREAD  { \</span>
<span class="cp">	.ksp = INIT_SP, \</span>
<span class="cp">	.ksp_limit = INIT_SP_LIMIT, \</span>
<span class="cp">	.regs = (struct pt_regs *)INIT_SP - 1, </span><span class="cm">/* XXX bogus, I think */</span><span class="cp"> \</span>
<span class="cp">	.fs = KERNEL_DS, \</span>
<span class="cp">	.fpr = {{0}}, \</span>
<span class="cp">	.fpscr = { .val = 0, }, \</span>
<span class="cp">	.fpexc_mode = 0, \</span>
<span class="cp">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Return saved PC of a blocked thread. For now, this is the &quot;user&quot; PC</span>
<span class="cm"> */</span>
<span class="cp">#define thread_saved_pc(tsk)    \</span>
<span class="cp">        ((tsk)-&gt;thread.regs? (tsk)-&gt;thread.regs-&gt;nip: 0)</span>

<span class="cp">#define task_pt_regs(tsk)	((struct pt_regs *)(tsk)-&gt;thread.regs)</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_wchan</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cp">#define KSTK_EIP(tsk)  ((tsk)-&gt;thread.regs? (tsk)-&gt;thread.regs-&gt;nip: 0)</span>
<span class="cp">#define KSTK_ESP(tsk)  ((tsk)-&gt;thread.regs? (tsk)-&gt;thread.regs-&gt;gpr[1]: 0)</span>

<span class="cm">/* Get/set floating-point exception mode */</span>
<span class="cp">#define GET_FPEXC_CTL(tsk, adr) get_fpexc_mode((tsk), (adr))</span>
<span class="cp">#define SET_FPEXC_CTL(tsk, val) set_fpexc_mode((tsk), (val))</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">get_fpexc_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">set_fpexc_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cp">#define GET_ENDIAN(tsk, adr) get_endian((tsk), (adr))</span>
<span class="cp">#define SET_ENDIAN(tsk, val) set_endian((tsk), (val))</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">get_endian</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">set_endian</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cp">#define GET_UNALIGN_CTL(tsk, adr)	get_unalign_ctl((tsk), (adr))</span>
<span class="cp">#define SET_UNALIGN_CTL(tsk, val)	set_unalign_ctl((tsk), (val))</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">get_unalign_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">set_unalign_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">__unpack_fe01</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msr_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">msr_bits</span> <span class="o">&amp;</span> <span class="n">MSR_FE0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">msr_bits</span> <span class="o">&amp;</span> <span class="n">MSR_FE1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__pack_fe01</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fpmode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">fpmode</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MSR_FE0</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">fpmode</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MSR_FE1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cp">#define cpu_relax()	do { HMT_low(); HMT_medium(); barrier(); } while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define cpu_relax()	barrier()</span>
<span class="cp">#endif</span>

<span class="cm">/* Check that a certain kernel stack pointer is valid in task_struct p */</span>
<span class="kt">int</span> <span class="n">validate_sp</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
                       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nbytes</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Prefetch macros.</span>
<span class="cm"> */</span>
<span class="cp">#define ARCH_HAS_PREFETCH</span>
<span class="cp">#define ARCH_HAS_PREFETCHW</span>
<span class="cp">#define ARCH_HAS_SPINLOCK_PREFETCH</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">prefetch</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;dcbt 0,%0&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">prefetchw</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;dcbtst 0,%0&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define spin_lock_prefetch(x)	prefetchw(x)</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cp">#define HAVE_ARCH_PICK_MMAP_LAYOUT</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_clean_sp</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_32</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_32</span><span class="p">)</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0ffffffffUL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_clean_sp</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_32</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpuidle_disable</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">idle_boot_override</span> <span class="p">{</span><span class="n">IDLE_NO_OVERRIDE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IDLE_POWERSAVE_OFF</span><span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">powersave_nap</span><span class="p">;</span>	<span class="cm">/* set if nap mode can be used in idle loop */</span>

<span class="cp">#ifdef CONFIG_PSERIES_IDLE</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">update_smt_snooze_delay</span><span class="p">(</span><span class="kt">int</span> <span class="n">snooze</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pseries_notify_cpuidle_add_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_smt_snooze_delay</span><span class="p">(</span><span class="kt">int</span> <span class="n">snooze</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pseries_notify_cpuidle_add_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">flush_instruction_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hard_reset_now</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">poweroff_now</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fix_alignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cvt_fd</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">to</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cvt_df</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">to</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">_nmask_and_or_msr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nmask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">or_val</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cm">/*</span>
<span class="cm"> * We handle most unaligned accesses in hardware. On the other hand </span>
<span class="cm"> * unaligned DMA can be very expensive on some ppc64 IO chips (it does</span>
<span class="cm"> * powers of 2 writes until it reaches sufficient alignment).</span>
<span class="cm"> *</span>
<span class="cm"> * Based on this we disable the IP header alignment in network drivers.</span>
<span class="cm"> */</span>
<span class="cp">#define NET_IP_ALIGN	0</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _ASM_POWERPC_PROCESSOR_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
