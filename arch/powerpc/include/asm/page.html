<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › page.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>page.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_POWERPC_PAGE_H</span>
<span class="cp">#define _ASM_POWERPC_PAGE_H</span>

<span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2001,2005 IBM Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;asm/asm-compat.h&gt;</span>
<span class="cp">#include &lt;asm/kdump.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * On regular PPC32 page size is 4K (but we support 4K/16K/64K/256K pages</span>
<span class="cm"> * on PPC44x). For PPC64 we support either 4K or 64K software</span>
<span class="cm"> * page size. When using 64K pages however, whether we are really supporting</span>
<span class="cm"> * 64K pages in HW or not is irrelevant to those definitions.</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_PPC_256K_PAGES)</span>
<span class="cp">#define PAGE_SHIFT		18</span>
<span class="cp">#elif defined(CONFIG_PPC_64K_PAGES)</span>
<span class="cp">#define PAGE_SHIFT		16</span>
<span class="cp">#elif defined(CONFIG_PPC_16K_PAGES)</span>
<span class="cp">#define PAGE_SHIFT		14</span>
<span class="cp">#else</span>
<span class="cp">#define PAGE_SHIFT		12</span>
<span class="cp">#endif</span>

<span class="cp">#define PAGE_SIZE		(ASM_CONST(1) &lt;&lt; PAGE_SHIFT)</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">HPAGE_SHIFT</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#define HPAGE_SHIFT PAGE_SHIFT</span>
<span class="cp">#endif</span>
<span class="cp">#define HPAGE_SIZE		((1UL) &lt;&lt; HPAGE_SHIFT)</span>
<span class="cp">#define HPAGE_MASK		(~(HPAGE_SIZE - 1))</span>
<span class="cp">#define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)</span>
<span class="cp">#define HUGE_MAX_HSTATE		(MMU_PAGE_COUNT-1)</span>
<span class="cp">#endif</span>

<span class="cm">/* We do define AT_SYSINFO_EHDR but don&#39;t use the gate mechanism */</span>
<span class="cp">#define __HAVE_ARCH_GATE_AREA		1</span>

<span class="cm">/*</span>
<span class="cm"> * Subtle: (1 &lt;&lt; PAGE_SHIFT) is an int, not an unsigned long. So if we</span>
<span class="cm"> * assign PAGE_MASK to a larger type it gets extended the way we want</span>
<span class="cm"> * (i.e. with 1s in the high bits)</span>
<span class="cm"> */</span>
<span class="cp">#define PAGE_MASK      (~((1 &lt;&lt; PAGE_SHIFT) - 1))</span>

<span class="cm">/*</span>
<span class="cm"> * KERNELBASE is the virtual address of the start of the kernel, it&#39;s often</span>
<span class="cm"> * the same as PAGE_OFFSET, but _might not be_.</span>
<span class="cm"> *</span>
<span class="cm"> * The kdump dump kernel is one example where KERNELBASE != PAGE_OFFSET.</span>
<span class="cm"> *</span>
<span class="cm"> * PAGE_OFFSET is the virtual address of the start of lowmem.</span>
<span class="cm"> *</span>
<span class="cm"> * PHYSICAL_START is the physical address of the start of the kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * MEMORY_START is the physical address of the start of lowmem.</span>
<span class="cm"> *</span>
<span class="cm"> * KERNELBASE, PAGE_OFFSET, and PHYSICAL_START are all configurable on</span>
<span class="cm"> * ppc32 and based on how they are set we determine MEMORY_START.</span>
<span class="cm"> *</span>
<span class="cm"> * For the linear mapping the following equation should be true:</span>
<span class="cm"> * KERNELBASE - PAGE_OFFSET = PHYSICAL_START - MEMORY_START</span>
<span class="cm"> *</span>
<span class="cm"> * Also, KERNELBASE &gt;= PAGE_OFFSET and PHYSICAL_START &gt;= MEMORY_START</span>
<span class="cm"> *</span>
<span class="cm"> * There are two was to determine a physical address from a virtual one:</span>
<span class="cm"> * va = pa + PAGE_OFFSET - MEMORY_START</span>
<span class="cm"> * va = pa + KERNELBASE - PHYSICAL_START</span>
<span class="cm"> *</span>
<span class="cm"> * If you want to know something&#39;s offset from the start of the kernel you</span>
<span class="cm"> * should subtract KERNELBASE.</span>
<span class="cm"> *</span>
<span class="cm"> * If you want to test if something&#39;s a kernel address, use is_kernel_addr().</span>
<span class="cm"> */</span>

<span class="cp">#define KERNELBASE      ASM_CONST(CONFIG_KERNEL_START)</span>
<span class="cp">#define PAGE_OFFSET	ASM_CONST(CONFIG_PAGE_OFFSET)</span>
<span class="cp">#define LOAD_OFFSET	ASM_CONST((CONFIG_KERNEL_START-CONFIG_PHYSICAL_START))</span>

<span class="cp">#if defined(CONFIG_NONSTATIC_KERNEL)</span>
<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="k">extern</span> <span class="n">phys_addr_t</span> <span class="n">memstart_addr</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">phys_addr_t</span> <span class="n">kernstart_addr</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_RELOCATABLE_PPC32</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">virt_phys_offset</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>
<span class="cp">#define PHYSICAL_START	kernstart_addr</span>

<span class="cp">#else	</span><span class="cm">/* !CONFIG_NONSTATIC_KERNEL */</span><span class="cp"></span>
<span class="cp">#define PHYSICAL_START	ASM_CONST(CONFIG_PHYSICAL_START)</span>
<span class="cp">#endif</span>

<span class="cm">/* See Description below for VIRT_PHYS_OFFSET */</span>
<span class="cp">#ifdef CONFIG_RELOCATABLE_PPC32</span>
<span class="cp">#define VIRT_PHYS_OFFSET virt_phys_offset</span>
<span class="cp">#else</span>
<span class="cp">#define VIRT_PHYS_OFFSET (KERNELBASE - PHYSICAL_START)</span>
<span class="cp">#endif</span>


<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cp">#define MEMORY_START	0UL</span>
<span class="cp">#elif defined(CONFIG_NONSTATIC_KERNEL)</span>
<span class="cp">#define MEMORY_START	memstart_addr</span>
<span class="cp">#else</span>
<span class="cp">#define MEMORY_START	(PHYSICAL_START + PAGE_OFFSET - KERNELBASE)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_FLATMEM</span>
<span class="cp">#define ARCH_PFN_OFFSET		((unsigned long)(MEMORY_START &gt;&gt; PAGE_SHIFT))</span>
<span class="cp">#define pfn_valid(pfn)		((pfn) &gt;= ARCH_PFN_OFFSET &amp;&amp; (pfn) &lt; max_mapnr)</span>
<span class="cp">#endif</span>

<span class="cp">#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) &gt;&gt; PAGE_SHIFT)</span>
<span class="cp">#define pfn_to_kaddr(pfn)	__va((pfn) &lt;&lt; PAGE_SHIFT)</span>
<span class="cp">#define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) &gt;&gt; PAGE_SHIFT)</span>

<span class="cm">/*</span>
<span class="cm"> * On Book-E parts we need __va to parse the device tree and we can&#39;t</span>
<span class="cm"> * determine MEMORY_START until then.  However we can determine PHYSICAL_START</span>
<span class="cm"> * from information at hand (program counter, TLB lookup).</span>
<span class="cm"> *</span>
<span class="cm"> * On BookE with RELOCATABLE (RELOCATABLE_PPC32)</span>
<span class="cm"> *</span>
<span class="cm"> *   With RELOCATABLE_PPC32,  we support loading the kernel at any physical </span>
<span class="cm"> *   address without any restriction on the page alignment.</span>
<span class="cm"> *</span>
<span class="cm"> *   We find the runtime address of _stext and relocate ourselves based on </span>
<span class="cm"> *   the following calculation:</span>
<span class="cm"> *</span>
<span class="cm"> *  	  virtual_base = ALIGN_DOWN(KERNELBASE,256M) +</span>
<span class="cm"> *  				MODULO(_stext.run,256M)</span>
<span class="cm"> *   and create the following mapping:</span>
<span class="cm"> *</span>
<span class="cm"> * 	  ALIGN_DOWN(_stext.run,256M) =&gt; ALIGN_DOWN(KERNELBASE,256M)</span>
<span class="cm"> *</span>
<span class="cm"> *   When we process relocations, we cannot depend on the</span>
<span class="cm"> *   existing equation for the __va()/__pa() translations:</span>
<span class="cm"> *</span>
<span class="cm"> * 	   __va(x) = (x)  - PHYSICAL_START + KERNELBASE</span>
<span class="cm"> *</span>
<span class="cm"> *   Where:</span>
<span class="cm"> *   	 PHYSICAL_START = kernstart_addr = Physical address of _stext</span>
<span class="cm"> *  	 KERNELBASE = Compiled virtual address of _stext.</span>
<span class="cm"> *</span>
<span class="cm"> *   This formula holds true iff, kernel load address is TLB page aligned.</span>
<span class="cm"> *</span>
<span class="cm"> *   In our case, we need to also account for the shift in the kernel Virtual </span>
<span class="cm"> *   address.</span>
<span class="cm"> *</span>
<span class="cm"> *   E.g.,</span>
<span class="cm"> *</span>
<span class="cm"> *   Let the kernel be loaded at 64MB and KERNELBASE be 0xc0000000 (same as PAGE_OFFSET).</span>
<span class="cm"> *   In this case, we would be mapping 0 to 0xc0000000, and kernstart_addr = 64M</span>
<span class="cm"> *</span>
<span class="cm"> *   Now __va(1MB) = (0x100000) - (0x4000000) + 0xc0000000</span>
<span class="cm"> *                 = 0xbc100000 , which is wrong.</span>
<span class="cm"> *</span>
<span class="cm"> *   Rather, it should be : 0xc0000000 + 0x100000 = 0xc0100000</span>
<span class="cm"> *      	according to our mapping.</span>
<span class="cm"> *</span>
<span class="cm"> *   Hence we use the following formula to get the translations right:</span>
<span class="cm"> *</span>
<span class="cm"> * 	  __va(x) = (x) - [ PHYSICAL_START - Effective KERNELBASE ]</span>
<span class="cm"> *</span>
<span class="cm"> * 	  Where :</span>
<span class="cm"> * 		PHYSICAL_START = dynamic load address.(kernstart_addr variable)</span>
<span class="cm"> * 		Effective KERNELBASE = virtual_base =</span>
<span class="cm"> * 				     = ALIGN_DOWN(KERNELBASE,256M) +</span>
<span class="cm"> * 						MODULO(PHYSICAL_START,256M)</span>
<span class="cm"> *</span>
<span class="cm"> * 	To make the cost of __va() / __pa() more light weight, we introduce</span>
<span class="cm"> * 	a new variable virt_phys_offset, which will hold :</span>
<span class="cm"> *</span>
<span class="cm"> * 	virt_phys_offset = Effective KERNELBASE - PHYSICAL_START</span>
<span class="cm"> * 			 = ALIGN_DOWN(KERNELBASE,256M) - </span>
<span class="cm"> * 			 	ALIGN_DOWN(PHYSICALSTART,256M)</span>
<span class="cm"> *</span>
<span class="cm"> * 	Hence :</span>
<span class="cm"> *</span>
<span class="cm"> * 	__va(x) = x - PHYSICAL_START + Effective KERNELBASE</span>
<span class="cm"> * 		= x + virt_phys_offset</span>
<span class="cm"> *</span>
<span class="cm"> * 		and</span>
<span class="cm"> * 	__pa(x) = x + PHYSICAL_START - Effective KERNELBASE</span>
<span class="cm"> * 		= x - virt_phys_offset</span>
<span class="cm"> * 		</span>
<span class="cm"> * On non-Book-E PPC64 PAGE_OFFSET and MEMORY_START are constants so use</span>
<span class="cm"> * the other definitions for __va &amp; __pa.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_BOOKE</span>
<span class="cp">#define __va(x) ((void *)(unsigned long)((phys_addr_t)(x) + VIRT_PHYS_OFFSET))</span>
<span class="cp">#define __pa(x) ((unsigned long)(x) - VIRT_PHYS_OFFSET)</span>
<span class="cp">#else</span>
<span class="cp">#define __va(x) ((void *)(unsigned long)((phys_addr_t)(x) + PAGE_OFFSET - MEMORY_START))</span>
<span class="cp">#define __pa(x) ((unsigned long)(x) - PAGE_OFFSET + MEMORY_START)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Unfortunately the PLT is in the BSS in the PPC32 ELF ABI,</span>
<span class="cm"> * and needs to be executable.  This means the whole heap ends</span>
<span class="cm"> * up being executable.</span>
<span class="cm"> */</span>
<span class="cp">#define VM_DATA_DEFAULT_FLAGS32	(VM_READ | VM_WRITE | VM_EXEC | \</span>
<span class="cp">				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)</span>

<span class="cp">#define VM_DATA_DEFAULT_FLAGS64	(VM_READ | VM_WRITE | \</span>
<span class="cp">				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)</span>

<span class="cp">#ifdef __powerpc64__</span>
<span class="cp">#include &lt;asm/page_64.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;asm/page_32.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/* align addr on a size boundary - adjust address up/down if needed */</span>
<span class="cp">#define _ALIGN_UP(addr,size)	(((addr)+((size)-1))&amp;(~((size)-1)))</span>
<span class="cp">#define _ALIGN_DOWN(addr,size)	((addr)&amp;(~((size)-1)))</span>

<span class="cm">/* align addr on a size boundary - adjust address up if needed */</span>
<span class="cp">#define _ALIGN(addr,size)     _ALIGN_UP(addr,size)</span>

<span class="cm">/*</span>
<span class="cm"> * Don&#39;t compare things with KERNELBASE or PAGE_OFFSET to test for</span>
<span class="cm"> * &quot;kernelness&quot;, use is_kernel_addr() - it should do what you want.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PPC_BOOK3E_64</span>
<span class="cp">#define is_kernel_addr(x)	((x) &gt;= 0x8000000000000000ul)</span>
<span class="cp">#else</span>
<span class="cp">#define is_kernel_addr(x)	((x) &gt;= PAGE_OFFSET)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Use the top bit of the higher-level page table entries to indicate whether</span>
<span class="cm"> * the entries we point to contain hugepages.  This works because we know that</span>
<span class="cm"> * the page tables live in kernel space.  If we ever decide to support having</span>
<span class="cm"> * page tables at arbitrary addresses, this breaks and will have to change.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cp">#define PD_HUGE 0x8000000000000000</span>
<span class="cp">#else</span>
<span class="cp">#define PD_HUGE 0x80000000</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Some number of bits at the level of the page table that points to</span>
<span class="cm"> * a hugepte are used to encode the size.  This masks those bits.</span>
<span class="cm"> */</span>
<span class="cp">#define HUGEPD_SHIFT_MASK     0x3f</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#undef STRICT_MM_TYPECHECKS</span>

<span class="cp">#ifdef STRICT_MM_TYPECHECKS</span>
<span class="cm">/* These are used to make use of C type-checking. */</span>

<span class="cm">/* PTE level */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="n">pte_basic_t</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span> <span class="n">pte_t</span><span class="p">;</span>
<span class="cp">#define pte_val(x)	((x).pte)</span>
<span class="cp">#define __pte(x)	((pte_t) { (x) })</span>

<span class="cm">/* 64k pages additionally define a bigger &quot;real PTE&quot; type that gathers</span>
<span class="cm"> * the &quot;second half&quot; part of the PTE for pseudo 64k pages</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_PPC_64K_PAGES) &amp;&amp; defined(CONFIG_PPC_STD_MMU_64)</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hidx</span><span class="p">;</span> <span class="p">}</span> <span class="n">real_pte_t</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span> <span class="n">real_pte_t</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/* PMD level */</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmd</span><span class="p">;</span> <span class="p">}</span> <span class="n">pmd_t</span><span class="p">;</span>
<span class="cp">#define pmd_val(x)	((x).pmd)</span>
<span class="cp">#define __pmd(x)	((pmd_t) { (x) })</span>

<span class="cm">/* PUD level exusts only on 4k pages */</span>
<span class="cp">#ifndef CONFIG_PPC_64K_PAGES</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pud</span><span class="p">;</span> <span class="p">}</span> <span class="n">pud_t</span><span class="p">;</span>
<span class="cp">#define pud_val(x)	((x).pud)</span>
<span class="cp">#define __pud(x)	((pud_t) { (x) })</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_PPC_64K_PAGES */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>

<span class="cm">/* PGD level */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgd</span><span class="p">;</span> <span class="p">}</span> <span class="n">pgd_t</span><span class="p">;</span>
<span class="cp">#define pgd_val(x)	((x).pgd)</span>
<span class="cp">#define __pgd(x)	((pgd_t) { (x) })</span>

<span class="cm">/* Page protection bits */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgprot</span><span class="p">;</span> <span class="p">}</span> <span class="n">pgprot_t</span><span class="p">;</span>
<span class="cp">#define pgprot_val(x)	((x).pgprot)</span>
<span class="cp">#define __pgprot(x)	((pgprot_t) { (x) })</span>

<span class="cp">#else</span>

<span class="cm">/*</span>
<span class="cm"> * .. while these make it easier on the compiler</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="n">pte_basic_t</span> <span class="n">pte_t</span><span class="p">;</span>
<span class="cp">#define pte_val(x)	(x)</span>
<span class="cp">#define __pte(x)	(x)</span>

<span class="cp">#if defined(CONFIG_PPC_64K_PAGES) &amp;&amp; defined(CONFIG_PPC_STD_MMU_64)</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hidx</span><span class="p">;</span> <span class="p">}</span> <span class="n">real_pte_t</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">typedef</span> <span class="n">pte_t</span> <span class="n">real_pte_t</span><span class="p">;</span>
<span class="cp">#endif</span>


<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmd_t</span><span class="p">;</span>
<span class="cp">#define pmd_val(x)	(x)</span>
<span class="cp">#define __pmd(x)	(x)</span>

<span class="cp">#ifndef CONFIG_PPC_64K_PAGES</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pud_t</span><span class="p">;</span>
<span class="cp">#define pud_val(x)	(x)</span>
<span class="cp">#define __pud(x)	(x)</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_PPC_64K_PAGES */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgd_t</span><span class="p">;</span>
<span class="cp">#define pgd_val(x)	(x)</span>
<span class="cp">#define pgprot_val(x)	(x)</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgprot_t</span><span class="p">;</span>
<span class="cp">#define __pgd(x)	(x)</span>
<span class="cp">#define __pgprot(x)	(x)</span>

<span class="cp">#endif</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">signed</span> <span class="kt">long</span> <span class="n">pd</span><span class="p">;</span> <span class="p">}</span> <span class="n">hugepd_t</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hugepd_ok</span><span class="p">(</span><span class="n">hugepd_t</span> <span class="n">hpd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">hpd</span><span class="p">.</span><span class="n">pd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define is_hugepd(pdep)               (hugepd_ok(*((hugepd_t *)(pdep))))</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_HUGETLB_PAGE */</span><span class="cp"></span>
<span class="cp">#define is_hugepd(pdep)			0</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HUGETLB_PAGE */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">page</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">clear_user_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">copy_user_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">page_is_ram</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">devmem_is_allowed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC_SMLPAR</span>
<span class="kt">void</span> <span class="n">arch_free_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">);</span>
<span class="cp">#define HAVE_ARCH_FREE_PAGE</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pgtable_t</span><span class="p">;</span>

<span class="cp">#include &lt;asm-generic/memory_model.h&gt;</span>
<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_POWERPC_PAGE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
