<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › pmac_feature.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pmac_feature.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Definition of platform feature hooks for PowerMacs</span>
<span class="cm"> *</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998 Paul Mackerras &amp;</span>
<span class="cm"> *                    Ben. Herrenschmidt.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Note: I removed media-bay details from the feature stuff, I believe it&#39;s</span>
<span class="cm"> *       not worth it, the media-bay driver can directly use the mac-io</span>
<span class="cm"> *       ASIC registers.</span>
<span class="cm"> *</span>
<span class="cm"> * Implementation note: Currently, none of these functions will block.</span>
<span class="cm"> * However, they may internally protect themselves with a spinlock</span>
<span class="cm"> * for way too long. Be prepared for at least some of these to block</span>
<span class="cm"> * in the future.</span>
<span class="cm"> *</span>
<span class="cm"> * Unless specifically defined, the result code is assumed to be an</span>
<span class="cm"> * error when negative, 0 is the default success result. Some functions</span>
<span class="cm"> * may return additional positive result values.</span>
<span class="cm"> *</span>
<span class="cm"> * To keep implementation simple, all feature calls are assumed to have</span>
<span class="cm"> * the prototype parameters (struct device_node* node, int value).</span>
<span class="cm"> * When either is not used, pass 0.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#ifndef __ASM_POWERPC_PMAC_FEATURE_H</span>
<span class="cp">#define __ASM_POWERPC_PMAC_FEATURE_H</span>

<span class="cp">#include &lt;asm/macio.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Known Mac motherboard models</span>
<span class="cm"> *</span>
<span class="cm"> * Please, report any error here to benh@kernel.crashing.org, thanks !</span>
<span class="cm"> *</span>
<span class="cm"> * Note that I don&#39;t fully maintain this list for Core99 &amp; MacRISC2</span>
<span class="cm"> * and I&#39;m considering removing all NewWorld entries from it and</span>
<span class="cm"> * entirely rely on the model string.</span>
<span class="cm"> */</span>

<span class="cm">/* PowerSurge are the first generation of PCI Pmacs. This include</span>
<span class="cm"> * all of the Grand-Central based machines. We currently don&#39;t</span>
<span class="cm"> * differenciate most of them.</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_TYPE_PSURGE		0x10	</span><span class="cm">/* PowerSurge */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_ANS			0x11	</span><span class="cm">/* Apple Network Server */</span><span class="cp"></span>

<span class="cm">/* Here is the infamous serie of OHare based machines</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_TYPE_COMET			0x20	</span><span class="cm">/* Believed to be PowerBook 2400 */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_HOOPER		0x21	</span><span class="cm">/* Believed to be PowerBook 3400 */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_KANGA			0x22	</span><span class="cm">/* PowerBook 3500 (first G3) */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_ALCHEMY		0x23	</span><span class="cm">/* Alchemy motherboard base */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_GAZELLE		0x24	</span><span class="cm">/* Spartacus, some 5xxx/6xxx */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_UNKNOWN_OHARE		0x2f	</span><span class="cm">/* Unknown, but OHare based */</span><span class="cp"></span>

<span class="cm">/* Here are the Heathrow based machines</span>
<span class="cm"> * FIXME: Differenciate wallstreet,mainstreet,wallstreetII</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_TYPE_GOSSAMER		0x30	</span><span class="cm">/* Gossamer motherboard */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_SILK			0x31	</span><span class="cm">/* Desktop PowerMac G3 */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_WALLSTREET		0x32	</span><span class="cm">/* Wallstreet/Mainstreet PowerBook*/</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_UNKNOWN_HEATHROW	0x3f	</span><span class="cm">/* Unknown but heathrow based */</span><span class="cp"></span>

<span class="cm">/* Here are newworld machines based on Paddington (heathrow derivative)</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_TYPE_101_PBOOK		0x40	</span><span class="cm">/* 101 PowerBook (aka Lombard) */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_ORIG_IMAC		0x41	</span><span class="cm">/* First generation iMac */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_YOSEMITE		0x42	</span><span class="cm">/* B&amp;W G3 */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_YIKES			0x43	</span><span class="cm">/* Yikes G4 (PCI graphics) */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_UNKNOWN_PADDINGTON	0x4f	</span><span class="cm">/* Unknown but paddington based */</span><span class="cp"></span>

<span class="cm">/* Core99 machines based on UniNorth 1.0 and 1.5</span>
<span class="cm"> *</span>
<span class="cm"> * Note: A single entry here may cover several actual models according</span>
<span class="cm"> * to the device-tree. (Sawtooth is most tower G4s, FW_IMAC is most</span>
<span class="cm"> * FireWire based iMacs, etc...). Those machines are too similar to be</span>
<span class="cm"> * distinguished here, when they need to be differencied, use the</span>
<span class="cm"> * device-tree &quot;model&quot; or &quot;compatible&quot; property.</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_TYPE_ORIG_IBOOK		0x40	</span><span class="cm">/* First iBook model (no firewire) */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_SAWTOOTH		0x41	</span><span class="cm">/* Desktop G4s */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_FW_IMAC		0x42	</span><span class="cm">/* FireWire iMacs (except Pangea based) */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_FW_IBOOK		0x43	</span><span class="cm">/* FireWire iBooks (except iBook2) */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_CUBE			0x44	</span><span class="cm">/* Cube PowerMac */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_QUICKSILVER		0x45	</span><span class="cm">/* QuickSilver G4s */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_PISMO			0x46	</span><span class="cm">/* Pismo PowerBook */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_TITANIUM		0x47	</span><span class="cm">/* Titanium PowerBook */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_TITANIUM2		0x48	</span><span class="cm">/* Titanium II PowerBook (no L3, M6) */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_TITANIUM3		0x49	</span><span class="cm">/* Titanium III PowerBook (with L3 &amp; M7) */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_TITANIUM4		0x50	</span><span class="cm">/* Titanium IV PowerBook (with L3 &amp; M9) */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_EMAC			0x50	</span><span class="cm">/* eMac */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_UNKNOWN_CORE99	0x5f</span>

<span class="cm">/* MacRisc2 with UniNorth 2.0 */</span>
<span class="cp">#define PMAC_TYPE_RACKMAC		0x80	</span><span class="cm">/* XServe */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_WINDTUNNEL		0x81</span>

<span class="cm">/* MacRISC2 machines based on the Pangea chipset</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_TYPE_PANGEA_IMAC		0x100	</span><span class="cm">/* Flower Power iMac */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_IBOOK2		0x101	</span><span class="cm">/* iBook2 (polycarbonate) */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_FLAT_PANEL_IMAC	0x102	</span><span class="cm">/* Flat panel iMac */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_UNKNOWN_PANGEA	0x10f</span>

<span class="cm">/* MacRISC2 machines based on the Intrepid chipset</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_TYPE_UNKNOWN_INTREPID	0x11f	</span><span class="cm">/* Generic */</span><span class="cp"></span>

<span class="cm">/* MacRISC4 / G5 machines. We don&#39;t have per-machine selection here anymore,</span>
<span class="cm"> * but rather machine families</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_TYPE_POWERMAC_G5		0x150	</span><span class="cm">/* U3 &amp; U3H based */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_POWERMAC_G5_U3L	0x151	</span><span class="cm">/* U3L based desktop */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_IMAC_G5		0x152	</span><span class="cm">/* iMac G5 */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_XSERVE_G5		0x153	</span><span class="cm">/* Xserve G5 */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_UNKNOWN_K2		0x19f	</span><span class="cm">/* Any other K2 based */</span><span class="cp"></span>
<span class="cp">#define PMAC_TYPE_UNKNOWN_SHASTA       	0x19e	</span><span class="cm">/* Any other Shasta based */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Motherboard flags</span>
<span class="cm"> */</span>

<span class="cp">#define PMAC_MB_CAN_SLEEP		0x00000001</span>
<span class="cp">#define PMAC_MB_HAS_FW_POWER		0x00000002</span>
<span class="cp">#define PMAC_MB_OLD_CORE99		0x00000004</span>
<span class="cp">#define PMAC_MB_MOBILE			0x00000008</span>
<span class="cp">#define PMAC_MB_MAY_SLEEP		0x00000010</span>

<span class="cm">/*</span>
<span class="cm"> * Feature calls supported on pmac</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Use this inline wrapper</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">pmac_call_feature</span><span class="p">(</span><span class="kt">int</span> <span class="n">selector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span>
					<span class="kt">long</span> <span class="n">param</span><span class="p">,</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">feature_call</span> <span class="o">||</span> <span class="o">!</span><span class="n">machine_is</span><span class="p">(</span><span class="n">powermac</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ppc_md</span><span class="p">.</span><span class="n">feature_call</span><span class="p">(</span><span class="n">selector</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* PMAC_FTR_SERIAL_ENABLE	(struct device_node* node, int param, int value)</span>
<span class="cm"> * enable/disable an SCC side. Pass the node corresponding to the</span>
<span class="cm"> * channel side as a parameter.</span>
<span class="cm"> * param is the type of port</span>
<span class="cm"> * if param is ored with PMAC_SCC_FLAG_XMON, then the SCC is locked enabled</span>
<span class="cm"> * for use by xmon.</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_SCC_ENABLE		PMAC_FTR_DEF(0)</span>
	<span class="cp">#define PMAC_SCC_ASYNC		0</span>
	<span class="cp">#define PMAC_SCC_IRDA		1</span>
	<span class="cp">#define PMAC_SCC_I2S1		2</span>
	<span class="cp">#define PMAC_SCC_FLAG_XMON	0x00001000</span>

<span class="cm">/* PMAC_FTR_MODEM_ENABLE	(struct device_node* node, 0, int value)</span>
<span class="cm"> * enable/disable the internal modem.</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_MODEM_ENABLE		PMAC_FTR_DEF(1)</span>

<span class="cm">/* PMAC_FTR_SWIM3_ENABLE	(struct device_node* node, 0,int value)</span>
<span class="cm"> * enable/disable the swim3 (floppy) cell of a mac-io ASIC</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_SWIM3_ENABLE		PMAC_FTR_DEF(2)</span>

<span class="cm">/* PMAC_FTR_MESH_ENABLE		(struct device_node* node, 0, int value)</span>
<span class="cm"> * enable/disable the mesh (scsi) cell of a mac-io ASIC</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_MESH_ENABLE		PMAC_FTR_DEF(3)</span>

<span class="cm">/* PMAC_FTR_IDE_ENABLE		(struct device_node* node, int busID, int value)</span>
<span class="cm"> * enable/disable an IDE port of a mac-io ASIC</span>
<span class="cm"> * pass the busID parameter</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_IDE_ENABLE		PMAC_FTR_DEF(4)</span>

<span class="cm">/* PMAC_FTR_IDE_RESET		(struct device_node* node, int busID, int value)</span>
<span class="cm"> * assert(1)/release(0) an IDE reset line (mac-io IDE only)</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_IDE_RESET		PMAC_FTR_DEF(5)</span>

<span class="cm">/* PMAC_FTR_BMAC_ENABLE		(struct device_node* node, 0, int value)</span>
<span class="cm"> * enable/disable the bmac (ethernet) cell of a mac-io ASIC, also drive</span>
<span class="cm"> * it&#39;s reset line</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_BMAC_ENABLE		PMAC_FTR_DEF(6)</span>

<span class="cm">/* PMAC_FTR_GMAC_ENABLE		(struct device_node* node, 0, int value)</span>
<span class="cm"> * enable/disable the gmac (ethernet) cell of an uninorth ASIC. This</span>
<span class="cm"> * control the cell&#39;s clock.</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_GMAC_ENABLE		PMAC_FTR_DEF(7)</span>

<span class="cm">/* PMAC_FTR_GMAC_PHY_RESET	(struct device_node* node, 0, 0)</span>
<span class="cm"> * Perform a HW reset of the PHY connected to a gmac controller.</span>
<span class="cm"> * Pass the gmac device node, not the PHY node.</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_GMAC_PHY_RESET		PMAC_FTR_DEF(8)</span>

<span class="cm">/* PMAC_FTR_SOUND_CHIP_ENABLE	(struct device_node* node, 0, int value)</span>
<span class="cm"> * enable/disable the sound chip, whatever it is and provided it can</span>
<span class="cm"> * acually be controlled</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_SOUND_CHIP_ENABLE	PMAC_FTR_DEF(9)</span>

<span class="cm">/* -- add various tweaks related to sound routing -- */</span>

<span class="cm">/* PMAC_FTR_AIRPORT_ENABLE	(struct device_node* node, 0, int value)</span>
<span class="cm"> * enable/disable the airport card</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_AIRPORT_ENABLE		PMAC_FTR_DEF(10)</span>

<span class="cm">/* PMAC_FTR_RESET_CPU		(NULL, int cpu_nr, 0)</span>
<span class="cm"> * toggle the reset line of a CPU on an uninorth-based SMP machine</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_RESET_CPU		PMAC_FTR_DEF(11)</span>

<span class="cm">/* PMAC_FTR_USB_ENABLE		(struct device_node* node, 0, int value)</span>
<span class="cm"> * enable/disable an USB cell, along with the power of the USB &quot;pad&quot;</span>
<span class="cm"> * on keylargo based machines</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_USB_ENABLE		PMAC_FTR_DEF(12)</span>

<span class="cm">/* PMAC_FTR_1394_ENABLE		(struct device_node* node, 0, int value)</span>
<span class="cm"> * enable/disable the firewire cell of an uninorth ASIC.</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_1394_ENABLE		PMAC_FTR_DEF(13)</span>

<span class="cm">/* PMAC_FTR_1394_CABLE_POWER	(struct device_node* node, 0, int value)</span>
<span class="cm"> * enable/disable the firewire cable power supply of the uninorth</span>
<span class="cm"> * firewire cell</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_1394_CABLE_POWER	PMAC_FTR_DEF(14)</span>

<span class="cm">/* PMAC_FTR_SLEEP_STATE		(struct device_node* node, 0, int value)</span>
<span class="cm"> * set the sleep state of the motherboard.</span>
<span class="cm"> *</span>
<span class="cm"> * Pass -1 as value to query for sleep capability</span>
<span class="cm"> * Pass 1 to set IOs to sleep</span>
<span class="cm"> * Pass 0 to set IOs to wake</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_SLEEP_STATE		PMAC_FTR_DEF(15)</span>

<span class="cm">/* PMAC_FTR_GET_MB_INFO		(NULL, selector, 0)</span>
<span class="cm"> *</span>
<span class="cm"> * returns some motherboard infos.</span>
<span class="cm"> * selector: 0  - model id</span>
<span class="cm"> *           1  - model flags (capabilities)</span>
<span class="cm"> *           2  - model name (cast to const char *)</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_GET_MB_INFO		PMAC_FTR_DEF(16)</span>
<span class="cp">#define   PMAC_MB_INFO_MODEL	0</span>
<span class="cp">#define   PMAC_MB_INFO_FLAGS	1</span>
<span class="cp">#define   PMAC_MB_INFO_NAME	2</span>

<span class="cm">/* PMAC_FTR_READ_GPIO		(NULL, int index, 0)</span>
<span class="cm"> *</span>
<span class="cm"> * read a GPIO from a mac-io controller of type KeyLargo or Pangea.</span>
<span class="cm"> * the value returned is a byte (positive), or a negative error code</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_READ_GPIO		PMAC_FTR_DEF(17)</span>

<span class="cm">/* PMAC_FTR_WRITE_GPIO		(NULL, int index, int value)</span>
<span class="cm"> *</span>
<span class="cm"> * write a GPIO of a mac-io controller of type KeyLargo or Pangea.</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_WRITE_GPIO		PMAC_FTR_DEF(18)</span>

<span class="cm">/* PMAC_FTR_ENABLE_MPIC</span>
<span class="cm"> *</span>
<span class="cm"> * Enable the MPIC cell</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_ENABLE_MPIC		PMAC_FTR_DEF(19)</span>

<span class="cm">/* PMAC_FTR_AACK_DELAY_ENABLE	(NULL, int enable, 0)</span>
<span class="cm"> *</span>
<span class="cm"> * Enable/disable the AACK delay on the northbridge for systems using DFS</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_AACK_DELAY_ENABLE     	PMAC_FTR_DEF(20)</span>

<span class="cm">/* PMAC_FTR_DEVICE_CAN_WAKE</span>
<span class="cm"> *</span>
<span class="cm"> * Used by video drivers to inform system that they can actually perform</span>
<span class="cm"> * wakeup from sleep</span>
<span class="cm"> */</span>
<span class="cp">#define PMAC_FTR_DEVICE_CAN_WAKE	PMAC_FTR_DEF(22)</span>


<span class="cm">/* Don&#39;t use those directly, they are for the sake of pmac_setup.c */</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">pmac_do_feature_call</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">selector</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pmac_feature_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Video suspend tweak */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pmac_set_early_video_resume</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">proc</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pmac_call_early_video_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define PMAC_FTR_DEF(x) ((0x6660000) | (x))</span>

<span class="cm">/* The AGP driver registers itself here */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pmac_register_agp_pm</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">bridge</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">bridge</span><span class="p">),</span>
				 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">bridge</span><span class="p">));</span>

<span class="cm">/* Those are meant to be used by video drivers to deal with AGP</span>
<span class="cm"> * suspend resume properly</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pmac_suspend_agp_for_card</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pmac_resume_agp_for_card</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The part below is for use by macio_asic.c only, do not rely</span>
<span class="cm"> * on the data structures or constants below in a normal driver</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define MAX_MACIO_CHIPS		2</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">macio_unknown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">macio_grand_central</span><span class="p">,</span>
	<span class="n">macio_ohare</span><span class="p">,</span>
	<span class="n">macio_ohareII</span><span class="p">,</span>
	<span class="n">macio_heathrow</span><span class="p">,</span>
	<span class="n">macio_gatwick</span><span class="p">,</span>
	<span class="n">macio_paddington</span><span class="p">,</span>
	<span class="n">macio_keylargo</span><span class="p">,</span>
	<span class="n">macio_pangea</span><span class="p">,</span>
	<span class="n">macio_intrepid</span><span class="p">,</span>
	<span class="n">macio_keylargo2</span><span class="p">,</span>
	<span class="n">macio_shasta</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">macio_chip</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span>	<span class="o">*</span><span class="n">of_node</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">type</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rev</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span>		<span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* For use by macio_asic PCI driver */</span>
	<span class="k">struct</span> <span class="n">macio_bus</span>	<span class="n">lbus</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">macio_chip</span> <span class="n">macio_chips</span><span class="p">[</span><span class="n">MAX_MACIO_CHIPS</span><span class="p">];</span>

<span class="cp">#define MACIO_FLAG_SCCA_ON	0x00000001</span>
<span class="cp">#define MACIO_FLAG_SCCB_ON	0x00000002</span>
<span class="cp">#define MACIO_FLAG_SCC_LOCKED	0x00000004</span>
<span class="cp">#define MACIO_FLAG_AIRPORT_ON	0x00000010</span>
<span class="cp">#define MACIO_FLAG_FW_SUPPORTED	0x00000020</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">macio_chip</span><span class="o">*</span> <span class="n">macio_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span><span class="o">*</span> <span class="n">child</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>

<span class="cp">#define MACIO_FCR32(macio, r)	((macio)-&gt;base + ((r) &gt;&gt; 2))</span>
<span class="cp">#define MACIO_FCR8(macio, r)	(((volatile u8 __iomem *)((macio)-&gt;base)) + (r))</span>

<span class="cp">#define MACIO_IN32(r)		(in_le32(MACIO_FCR32(macio,r)))</span>
<span class="cp">#define MACIO_OUT32(r,v)	(out_le32(MACIO_FCR32(macio,r), (v)))</span>
<span class="cp">#define MACIO_BIS(r,v)		(MACIO_OUT32((r), MACIO_IN32(r) | (v)))</span>
<span class="cp">#define MACIO_BIC(r,v)		(MACIO_OUT32((r), MACIO_IN32(r) &amp; ~(v)))</span>
<span class="cp">#define MACIO_IN8(r)		(in_8(MACIO_FCR8(macio,r)))</span>
<span class="cp">#define MACIO_OUT8(r,v)		(out_8(MACIO_FCR8(macio,r), (v)))</span>

<span class="cm">/*</span>
<span class="cm"> * Those are exported by pmac feature for internal use by arch code</span>
<span class="cm"> * only like the platform function callbacks, do not use directly in drivers</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">raw_spinlock_t</span> <span class="n">feature_lock</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">uninorth_node</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">uninorth_base</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Uninorth reg. access. Note that Uni-N regs are big endian</span>
<span class="cm"> */</span>

<span class="cp">#define UN_REG(r)	(uninorth_base + ((r) &gt;&gt; 2))</span>
<span class="cp">#define UN_IN(r)	(in_be32(UN_REG(r)))</span>
<span class="cp">#define UN_OUT(r,v)	(out_be32(UN_REG(r), (v)))</span>
<span class="cp">#define UN_BIS(r,v)	(UN_OUT((r), UN_IN(r) | (v)))</span>
<span class="cp">#define UN_BIC(r,v)	(UN_OUT((r), UN_IN(r) &amp; ~(v)))</span>

<span class="cm">/* Uninorth variant:</span>
<span class="cm"> *</span>
<span class="cm"> * 0 = not uninorth</span>
<span class="cm"> * 1 = U1.x or U2.x</span>
<span class="cm"> * 3 = U3</span>
<span class="cm"> * 4 = U4</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pmac_get_uninorth_variant</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __ASM_POWERPC_PMAC_FEATURE_H */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
