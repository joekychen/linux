<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › exception-64s.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>exception-64s.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_POWERPC_EXCEPTION_H</span>
<span class="cp">#define _ASM_POWERPC_EXCEPTION_H</span>
<span class="cm">/*</span>
<span class="cm"> * Extracted from head_64.S</span>
<span class="cm"> *</span>
<span class="cm"> *  PowerPC version</span>
<span class="cm"> *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)</span>
<span class="cm"> *</span>
<span class="cm"> *  Rewritten by Cort Dougan (cort@cs.nmt.edu) for PReP</span>
<span class="cm"> *    Copyright (C) 1996 Cort Dougan &lt;cort@cs.nmt.edu&gt;</span>
<span class="cm"> *  Adapted for Power Macintosh by Paul Mackerras.</span>
<span class="cm"> *  Low-level exception handlers and MMU support</span>
<span class="cm"> *  rewritten by Paul Mackerras.</span>
<span class="cm"> *    Copyright (C) 1996 Paul Mackerras.</span>
<span class="cm"> *</span>
<span class="cm"> *  Adapted for 64bit PowerPC by Dave Engebretsen, Peter Bergner, and</span>
<span class="cm"> *    Mike Corrigan {engebret|bergner|mikejc}@us.ibm.com</span>
<span class="cm"> *</span>
<span class="cm"> *  This file contains the low-level support and setup for the</span>
<span class="cm"> *  PowerPC-64 platform, including trap and interrupt dispatch.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or</span>
<span class="cm"> *  modify it under the terms of the GNU General Public License</span>
<span class="cm"> *  as published by the Free Software Foundation; either version</span>
<span class="cm"> *  2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * The following macros define the code that appears as</span>
<span class="cm"> * the prologue to each of the exception handlers.  They</span>
<span class="cm"> * are split into two parts to allow a single kernel binary</span>
<span class="cm"> * to be used for pSeries and iSeries.</span>
<span class="cm"> *</span>
<span class="cm"> * We make as much of the exception code common between native</span>
<span class="cm"> * exception handlers (including pSeries LPAR) and iSeries LPAR</span>
<span class="cm"> * implementations as possible.</span>
<span class="cm"> */</span>

<span class="cp">#define EX_R9		0</span>
<span class="cp">#define EX_R10		8</span>
<span class="cp">#define EX_R11		16</span>
<span class="cp">#define EX_R12		24</span>
<span class="cp">#define EX_R13		32</span>
<span class="cp">#define EX_SRR0		40</span>
<span class="cp">#define EX_DAR		48</span>
<span class="cp">#define EX_DSISR	56</span>
<span class="cp">#define EX_CCR		60</span>
<span class="cp">#define EX_R3		64</span>
<span class="cp">#define EX_LR		72</span>
<span class="cp">#define EX_CFAR		80</span>

<span class="cm">/*</span>
<span class="cm"> * We&#39;re short on space and time in the exception prolog, so we can&#39;t</span>
<span class="cm"> * use the normal SET_REG_IMMEDIATE macro. Normally we just need the</span>
<span class="cm"> * low halfword of the address, but for Kdump we need the whole low</span>
<span class="cm"> * word.</span>
<span class="cm"> */</span>
<span class="cp">#define LOAD_HANDLER(reg, label)					\</span>
<span class="cp">	addi	reg,reg,(label)-_stext;	</span><span class="cm">/* virt addr of handler ... */</span><span class="cp"></span>

<span class="cm">/* Exception register prefixes */</span>
<span class="cp">#define EXC_HV	H</span>
<span class="cp">#define EXC_STD</span>

<span class="cp">#define __EXCEPTION_PROLOG_1(area, extra, vec)				\</span>
<span class="cp">	GET_PACA(r13);							\</span>
<span class="cp">	std	r9,area+EX_R9(r13);	</span><span class="cm">/* save r9 - r12 */</span><span class="cp">		\</span>
<span class="cp">	std	r10,area+EX_R10(r13);					\</span>
<span class="cp">	BEGIN_FTR_SECTION_NESTED(66);					\</span>
<span class="cp">	mfspr	r10,SPRN_CFAR;						\</span>
<span class="cp">	std	r10,area+EX_CFAR(r13);					\</span>
<span class="cp">	END_FTR_SECTION_NESTED(CPU_FTR_CFAR, CPU_FTR_CFAR, 66);		\</span>
<span class="cp">	mfcr	r9;							\</span>
<span class="cp">	extra(vec);							\</span>
<span class="cp">	std	r11,area+EX_R11(r13);					\</span>
<span class="cp">	std	r12,area+EX_R12(r13);					\</span>
<span class="cp">	GET_SCRATCH0(r10);						\</span>
<span class="cp">	std	r10,area+EX_R13(r13)</span>
<span class="cp">#define EXCEPTION_PROLOG_1(area, extra, vec)				\</span>
<span class="cp">	__EXCEPTION_PROLOG_1(area, extra, vec)</span>

<span class="cp">#define __EXCEPTION_PROLOG_PSERIES_1(label, h)				\</span>
<span class="cp">	ld	r12,PACAKBASE(r13);	</span><span class="cm">/* get high part of &amp;label */</span><span class="cp">	\</span>
<span class="cp">	ld	r10,PACAKMSR(r13);	</span><span class="cm">/* get MSR value for kernel */</span><span class="cp">	\</span>
<span class="cp">	mfspr	r11,SPRN_##h##SRR0;	</span><span class="cm">/* save SRR0 */</span><span class="cp">			\</span>
<span class="cp">	LOAD_HANDLER(r12,label)						\</span>
<span class="cp">	mtspr	SPRN_##h##SRR0,r12;					\</span>
<span class="cp">	mfspr	r12,SPRN_##h##SRR1;	</span><span class="cm">/* and SRR1 */</span><span class="cp">			\</span>
<span class="cp">	mtspr	SPRN_##h##SRR1,r10;					\</span>
<span class="cp">	h##rfid;							\</span>
<span class="cp">	b	.	</span><span class="cm">/* prevent speculative execution */</span><span class="cp"></span>
<span class="cp">#define EXCEPTION_PROLOG_PSERIES_1(label, h)				\</span>
<span class="cp">	__EXCEPTION_PROLOG_PSERIES_1(label, h)</span>

<span class="cp">#define EXCEPTION_PROLOG_PSERIES(area, label, h, extra, vec)		\</span>
<span class="cp">	EXCEPTION_PROLOG_1(area, extra, vec);				\</span>
<span class="cp">	EXCEPTION_PROLOG_PSERIES_1(label, h);</span>

<span class="cp">#define __KVMTEST(n)							\</span>
<span class="cp">	lbz	r10,HSTATE_IN_GUEST(r13);			\</span>
<span class="cp">	cmpwi	r10,0;							\</span>
<span class="cp">	bne	do_kvm_##n</span>

<span class="cp">#define __KVM_HANDLER(area, h, n)					\</span>
<span class="cp">do_kvm_##n:								\</span>
<span class="cp">	ld	r10,area+EX_R10(r13);					\</span>
<span class="cp">	stw	r9,HSTATE_SCRATCH1(r13);			\</span>
<span class="cp">	ld	r9,area+EX_R9(r13);					\</span>
<span class="cp">	std	r12,HSTATE_SCRATCH0(r13);			\</span>
<span class="cp">	li	r12,n;							\</span>
<span class="cp">	b	kvmppc_interrupt</span>

<span class="cp">#define __KVM_HANDLER_SKIP(area, h, n)					\</span>
<span class="cp">do_kvm_##n:								\</span>
<span class="cp">	cmpwi	r10,KVM_GUEST_MODE_SKIP;				\</span>
<span class="cp">	ld	r10,area+EX_R10(r13);					\</span>
<span class="cp">	beq	89f;							\</span>
<span class="cp">	stw	r9,HSTATE_SCRATCH1(r13);			\</span>
<span class="cp">	ld	r9,area+EX_R9(r13);					\</span>
<span class="cp">	std	r12,HSTATE_SCRATCH0(r13);			\</span>
<span class="cp">	li	r12,n;							\</span>
<span class="cp">	b	kvmppc_interrupt;					\</span>
<span class="cp">89:	mtocrf	0x80,r9;						\</span>
<span class="cp">	ld	r9,area+EX_R9(r13);					\</span>
<span class="cp">	b	kvmppc_skip_##h##interrupt</span>

<span class="cp">#ifdef CONFIG_KVM_BOOK3S_64_HANDLER</span>
<span class="cp">#define KVMTEST(n)			__KVMTEST(n)</span>
<span class="cp">#define KVM_HANDLER(area, h, n)		__KVM_HANDLER(area, h, n)</span>
<span class="cp">#define KVM_HANDLER_SKIP(area, h, n)	__KVM_HANDLER_SKIP(area, h, n)</span>

<span class="cp">#else</span>
<span class="cp">#define KVMTEST(n)</span>
<span class="cp">#define KVM_HANDLER(area, h, n)</span>
<span class="cp">#define KVM_HANDLER_SKIP(area, h, n)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_KVM_BOOK3S_PR</span>
<span class="cp">#define KVMTEST_PR(n)			__KVMTEST(n)</span>
<span class="cp">#define KVM_HANDLER_PR(area, h, n)	__KVM_HANDLER(area, h, n)</span>
<span class="cp">#define KVM_HANDLER_PR_SKIP(area, h, n)	__KVM_HANDLER_SKIP(area, h, n)</span>

<span class="cp">#else</span>
<span class="cp">#define KVMTEST_PR(n)</span>
<span class="cp">#define KVM_HANDLER_PR(area, h, n)</span>
<span class="cp">#define KVM_HANDLER_PR_SKIP(area, h, n)</span>
<span class="cp">#endif</span>

<span class="cp">#define NOTEST(n)</span>

<span class="cm">/*</span>
<span class="cm"> * The common exception prolog is used for all except a few exceptions</span>
<span class="cm"> * such as a segment miss on a kernel address.  We have to be prepared</span>
<span class="cm"> * to take another exception from the point where we first touch the</span>
<span class="cm"> * kernel stack onwards.</span>
<span class="cm"> *</span>
<span class="cm"> * On entry r13 points to the paca, r9-r13 are saved in the paca,</span>
<span class="cm"> * r9 contains the saved CR, r11 and r12 contain the saved SRR0 and</span>
<span class="cm"> * SRR1, and relocation is on.</span>
<span class="cm"> */</span>
<span class="cp">#define EXCEPTION_PROLOG_COMMON(n, area)				   \</span>
<span class="cp">	andi.	r10,r12,MSR_PR;		</span><span class="cm">/* See if coming from user	*/</span><span class="cp"> \</span>
<span class="cp">	mr	r10,r1;			</span><span class="cm">/* Save r1			*/</span><span class="cp"> \</span>
<span class="cp">	subi	r1,r1,INT_FRAME_SIZE;	</span><span class="cm">/* alloc frame on kernel stack	*/</span><span class="cp"> \</span>
<span class="cp">	beq-	1f;							   \</span>
<span class="cp">	ld	r1,PACAKSAVE(r13);	</span><span class="cm">/* kernel stack to use		*/</span><span class="cp"> \</span>
<span class="cp">1:	cmpdi	cr1,r1,0;		</span><span class="cm">/* check if r1 is in userspace	*/</span><span class="cp"> \</span>
<span class="cp">	blt+	cr1,3f;			</span><span class="cm">/* abort if it is		*/</span><span class="cp"> \</span>
<span class="cp">	li	r1,(n);			</span><span class="cm">/* will be reloaded later	*/</span><span class="cp"> \</span>
<span class="cp">	sth	r1,PACA_TRAP_SAVE(r13);					   \</span>
<span class="cp">	std	r3,area+EX_R3(r13);					   \</span>
<span class="cp">	addi	r3,r13,area;		</span><span class="cm">/* r3 -&gt; where regs are saved*/</span><span class="cp">	   \</span>
<span class="cp">	b	bad_stack;						   \</span>
<span class="cp">3:	std	r9,_CCR(r1);		</span><span class="cm">/* save CR in stackframe	*/</span><span class="cp"> \</span>
<span class="cp">	std	r11,_NIP(r1);		</span><span class="cm">/* save SRR0 in stackframe	*/</span><span class="cp"> \</span>
<span class="cp">	std	r12,_MSR(r1);		</span><span class="cm">/* save SRR1 in stackframe	*/</span><span class="cp"> \</span>
<span class="cp">	std	r10,0(r1);		</span><span class="cm">/* make stack chain pointer	*/</span><span class="cp"> \</span>
<span class="cp">	std	r0,GPR0(r1);		</span><span class="cm">/* save r0 in stackframe	*/</span><span class="cp"> \</span>
<span class="cp">	std	r10,GPR1(r1);		</span><span class="cm">/* save r1 in stackframe	*/</span><span class="cp"> \</span>
<span class="cp">	ACCOUNT_CPU_USER_ENTRY(r9, r10);				   \</span>
<span class="cp">	std	r2,GPR2(r1);		</span><span class="cm">/* save r2 in stackframe	*/</span><span class="cp"> \</span>
<span class="cp">	SAVE_4GPRS(3, r1);		</span><span class="cm">/* save r3 - r6 in stackframe	*/</span><span class="cp"> \</span>
<span class="cp">	SAVE_2GPRS(7, r1);		</span><span class="cm">/* save r7, r8 in stackframe	*/</span><span class="cp"> \</span>
<span class="cp">	ld	r9,area+EX_R9(r13);	</span><span class="cm">/* move r9, r10 to stackframe	*/</span><span class="cp"> \</span>
<span class="cp">	ld	r10,area+EX_R10(r13);					   \</span>
<span class="cp">	std	r9,GPR9(r1);						   \</span>
<span class="cp">	std	r10,GPR10(r1);						   \</span>
<span class="cp">	ld	r9,area+EX_R11(r13);	</span><span class="cm">/* move r11 - r13 to stackframe	*/</span><span class="cp"> \</span>
<span class="cp">	ld	r10,area+EX_R12(r13);					   \</span>
<span class="cp">	ld	r11,area+EX_R13(r13);					   \</span>
<span class="cp">	std	r9,GPR11(r1);						   \</span>
<span class="cp">	std	r10,GPR12(r1);						   \</span>
<span class="cp">	std	r11,GPR13(r1);						   \</span>
<span class="cp">	BEGIN_FTR_SECTION_NESTED(66);					   \</span>
<span class="cp">	ld	r10,area+EX_CFAR(r13);					   \</span>
<span class="cp">	std	r10,ORIG_GPR3(r1);					   \</span>
<span class="cp">	END_FTR_SECTION_NESTED(CPU_FTR_CFAR, CPU_FTR_CFAR, 66);		   \</span>
<span class="cp">	ld	r2,PACATOC(r13);	</span><span class="cm">/* get kernel TOC into r2	*/</span><span class="cp"> \</span>
<span class="cp">	mflr	r9;			</span><span class="cm">/* save LR in stackframe	*/</span><span class="cp"> \</span>
<span class="cp">	std	r9,_LINK(r1);						   \</span>
<span class="cp">	mfctr	r10;			</span><span class="cm">/* save CTR in stackframe	*/</span><span class="cp"> \</span>
<span class="cp">	std	r10,_CTR(r1);						   \</span>
<span class="cp">	lbz	r10,PACASOFTIRQEN(r13);				   \</span>
<span class="cp">	mfspr	r11,SPRN_XER;		</span><span class="cm">/* save XER in stackframe	*/</span><span class="cp"> \</span>
<span class="cp">	std	r10,SOFTE(r1);						   \</span>
<span class="cp">	std	r11,_XER(r1);						   \</span>
<span class="cp">	li	r9,(n)+1;						   \</span>
<span class="cp">	std	r9,_TRAP(r1);		</span><span class="cm">/* set trap number		*/</span><span class="cp"> \</span>
<span class="cp">	li	r10,0;							   \</span>
<span class="cp">	ld	r11,exception_marker@toc(r2);				   \</span>
<span class="cp">	std	r10,RESULT(r1);		</span><span class="cm">/* clear regs-&gt;result		*/</span><span class="cp"> \</span>
<span class="cp">	std	r11,STACK_FRAME_OVERHEAD-16(r1); </span><span class="cm">/* mark the frame	*/</span><span class="cp"> \</span>
<span class="cp">	ACCOUNT_STOLEN_TIME</span>

<span class="cm">/*</span>
<span class="cm"> * Exception vectors.</span>
<span class="cm"> */</span>
<span class="cp">#define STD_EXCEPTION_PSERIES(loc, vec, label)		\</span>
<span class="cp">	. = loc;					\</span>
<span class="cp">	.globl label##_pSeries;				\</span>
<span class="cp">label##_pSeries:					\</span>
<span class="cp">	HMT_MEDIUM;					\</span>
<span class="cp">	SET_SCRATCH0(r13);		</span><span class="cm">/* save r13 */</span><span class="cp">		\</span>
<span class="cp">	EXCEPTION_PROLOG_PSERIES(PACA_EXGEN, label##_common,	\</span>
<span class="cp">				 EXC_STD, KVMTEST_PR, vec)</span>

<span class="cp">#define STD_EXCEPTION_HV(loc, vec, label)		\</span>
<span class="cp">	. = loc;					\</span>
<span class="cp">	.globl label##_hv;				\</span>
<span class="cp">label##_hv:						\</span>
<span class="cp">	HMT_MEDIUM;					\</span>
<span class="cp">	SET_SCRATCH0(r13);	</span><span class="cm">/* save r13 */</span><span class="cp">			\</span>
<span class="cp">	EXCEPTION_PROLOG_PSERIES(PACA_EXGEN, label##_common,	\</span>
<span class="cp">				 EXC_HV, KVMTEST, vec)</span>

<span class="cm">/* This associate vector numbers with bits in paca-&gt;irq_happened */</span>
<span class="cp">#define SOFTEN_VALUE_0x500	PACA_IRQ_EE</span>
<span class="cp">#define SOFTEN_VALUE_0x502	PACA_IRQ_EE</span>
<span class="cp">#define SOFTEN_VALUE_0x900	PACA_IRQ_DEC</span>
<span class="cp">#define SOFTEN_VALUE_0x982	PACA_IRQ_DEC</span>

<span class="cp">#define __SOFTEN_TEST(h, vec)						\</span>
<span class="cp">	lbz	r10,PACASOFTIRQEN(r13);					\</span>
<span class="cp">	cmpwi	r10,0;							\</span>
<span class="cp">	li	r10,SOFTEN_VALUE_##vec;					\</span>
<span class="cp">	beq	masked_##h##interrupt</span>
<span class="cp">#define _SOFTEN_TEST(h, vec)	__SOFTEN_TEST(h, vec)</span>

<span class="cp">#define SOFTEN_TEST_PR(vec)						\</span>
<span class="cp">	KVMTEST_PR(vec);						\</span>
<span class="cp">	_SOFTEN_TEST(EXC_STD, vec)</span>

<span class="cp">#define SOFTEN_TEST_HV(vec)						\</span>
<span class="cp">	KVMTEST(vec);							\</span>
<span class="cp">	_SOFTEN_TEST(EXC_HV, vec)</span>

<span class="cp">#define SOFTEN_TEST_HV_201(vec)						\</span>
<span class="cp">	KVMTEST(vec);							\</span>
<span class="cp">	_SOFTEN_TEST(EXC_STD, vec)</span>

<span class="cp">#define __MASKABLE_EXCEPTION_PSERIES(vec, label, h, extra)		\</span>
<span class="cp">	HMT_MEDIUM;							\</span>
<span class="cp">	SET_SCRATCH0(r13);    </span><span class="cm">/* save r13 */</span><span class="cp">				\</span>
<span class="cp">	__EXCEPTION_PROLOG_1(PACA_EXGEN, extra, vec);		\</span>
<span class="cp">	EXCEPTION_PROLOG_PSERIES_1(label##_common, h);</span>
<span class="cp">#define _MASKABLE_EXCEPTION_PSERIES(vec, label, h, extra)		\</span>
<span class="cp">	__MASKABLE_EXCEPTION_PSERIES(vec, label, h, extra)</span>

<span class="cp">#define MASKABLE_EXCEPTION_PSERIES(loc, vec, label)			\</span>
<span class="cp">	. = loc;							\</span>
<span class="cp">	.globl label##_pSeries;						\</span>
<span class="cp">label##_pSeries:							\</span>
<span class="cp">	_MASKABLE_EXCEPTION_PSERIES(vec, label,				\</span>
<span class="cp">				    EXC_STD, SOFTEN_TEST_PR)</span>

<span class="cp">#define MASKABLE_EXCEPTION_HV(loc, vec, label)				\</span>
<span class="cp">	. = loc;							\</span>
<span class="cp">	.globl label##_hv;						\</span>
<span class="cp">label##_hv:								\</span>
<span class="cp">	_MASKABLE_EXCEPTION_PSERIES(vec, label,				\</span>
<span class="cp">				    EXC_HV, SOFTEN_TEST_HV)</span>

<span class="cm">/*</span>
<span class="cm"> * Our exception common code can be passed various &quot;additions&quot;</span>
<span class="cm"> * to specify the behaviour of interrupts, whether to kick the</span>
<span class="cm"> * runlatch, etc...</span>
<span class="cm"> */</span>

<span class="cm">/* Exception addition: Hard disable interrupts */</span>
<span class="cp">#define DISABLE_INTS	SOFT_DISABLE_INTS(r10,r11)</span>

<span class="cp">#define ADD_NVGPRS				\</span>
<span class="cp">	bl	.save_nvgprs</span>

<span class="cp">#define RUNLATCH_ON				\</span>
<span class="cp">BEGIN_FTR_SECTION				\</span>
<span class="cp">	clrrdi	r3,r1,THREAD_SHIFT;		\</span>
<span class="cp">	ld	r4,TI_LOCAL_FLAGS(r3);		\</span>
<span class="cp">	andi.	r0,r4,_TLF_RUNLATCH;		\</span>
<span class="cp">	beql	ppc64_runlatch_on_trampoline;	\</span>
<span class="cp">END_FTR_SECTION_IFSET(CPU_FTR_CTRL)</span>

<span class="cp">#define EXCEPTION_COMMON(trap, label, hdlr, ret, additions)	\</span>
<span class="cp">	.align	7;						\</span>
<span class="cp">	.globl label##_common;					\</span>
<span class="cp">label##_common:							\</span>
<span class="cp">	EXCEPTION_PROLOG_COMMON(trap, PACA_EXGEN);		\</span>
<span class="cp">	additions;						\</span>
<span class="cp">	addi	r3,r1,STACK_FRAME_OVERHEAD;			\</span>
<span class="cp">	bl	hdlr;						\</span>
<span class="cp">	b	ret</span>

<span class="cp">#define STD_EXCEPTION_COMMON(trap, label, hdlr)			\</span>
<span class="cp">	EXCEPTION_COMMON(trap, label, hdlr, ret_from_except,	\</span>
<span class="cp">			 ADD_NVGPRS;DISABLE_INTS)</span>

<span class="cm">/*</span>
<span class="cm"> * Like STD_EXCEPTION_COMMON, but for exceptions that can occur</span>
<span class="cm"> * in the idle task and therefore need the special idle handling</span>
<span class="cm"> * (finish nap and runlatch)</span>
<span class="cm"> */</span>
<span class="cp">#define STD_EXCEPTION_COMMON_ASYNC(trap, label, hdlr)		  \</span>
<span class="cp">	EXCEPTION_COMMON(trap, label, hdlr, ret_from_except_lite, \</span>
<span class="cp">			 FINISH_NAP;RUNLATCH_ON;DISABLE_INTS)</span>

<span class="cm">/*</span>
<span class="cm"> * When the idle code in power4_idle puts the CPU into NAP mode,</span>
<span class="cm"> * it has to do so in a loop, and relies on the external interrupt</span>
<span class="cm"> * and decrementer interrupt entry code to get it out of the loop.</span>
<span class="cm"> * It sets the _TLF_NAPPING bit in current_thread_info()-&gt;local_flags</span>
<span class="cm"> * to signal that it is in the loop and needs help to get out.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PPC_970_NAP</span>
<span class="cp">#define FINISH_NAP				\</span>
<span class="cp">BEGIN_FTR_SECTION				\</span>
<span class="cp">	clrrdi	r11,r1,THREAD_SHIFT;		\</span>
<span class="cp">	ld	r9,TI_LOCAL_FLAGS(r11);		\</span>
<span class="cp">	andi.	r10,r9,_TLF_NAPPING;		\</span>
<span class="cp">	bnel	power4_fixup_nap;		\</span>
<span class="cp">END_FTR_SECTION_IFSET(CPU_FTR_CAN_NAP)</span>
<span class="cp">#else</span>
<span class="cp">#define FINISH_NAP</span>
<span class="cp">#endif</span>

<span class="cp">#endif	</span><span class="cm">/* _ASM_POWERPC_EXCEPTION_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
