<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › pgtable-ppc32.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pgtable-ppc32.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_POWERPC_PGTABLE_PPC32_H</span>
<span class="cp">#define _ASM_POWERPC_PGTABLE_PPC32_H</span>

<span class="cp">#include &lt;asm-generic/pgtable-nopmd.h&gt;</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;			</span><span class="cm">/* For sub-arch specific PPC_PIN_SIZE */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va_to_phys</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">va_to_pte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioremap_bot</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_44x</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">icache_44x_need_flush</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The normal case is that PTEs are 32-bits and we have a 1-page</span>
<span class="cm"> * 1024-entry pgdir pointing to 1-page 1024-entry PTE pages.  -- paulus</span>
<span class="cm"> *</span>
<span class="cm"> * For any &gt;32-bit physical address platform, we can use the following</span>
<span class="cm"> * two level page table layout where the pgdir is 8KB and the MS 13 bits</span>
<span class="cm"> * are an index to the second level table.  The combined pgdir/pmd first</span>
<span class="cm"> * level has 2048 entries and the second level has 512 64-bit PTE entries.</span>
<span class="cm"> * -Matt</span>
<span class="cm"> */</span>
<span class="cm">/* PGDIR_SHIFT determines what a top-level page table entry can map */</span>
<span class="cp">#define PGDIR_SHIFT	(PAGE_SHIFT + PTE_SHIFT)</span>
<span class="cp">#define PGDIR_SIZE	(1UL &lt;&lt; PGDIR_SHIFT)</span>
<span class="cp">#define PGDIR_MASK	(~(PGDIR_SIZE-1))</span>

<span class="cm">/*</span>
<span class="cm"> * entries per page directory level: our page-table tree is two-level, so</span>
<span class="cm"> * we don&#39;t really have any PMD directory.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cp">#define PTE_TABLE_SIZE	(sizeof(pte_t) &lt;&lt; PTE_SHIFT)</span>
<span class="cp">#define PGD_TABLE_SIZE	(sizeof(pgd_t) &lt;&lt; (32 - PGDIR_SHIFT))</span>
<span class="cp">#endif	</span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#define PTRS_PER_PTE	(1 &lt;&lt; PTE_SHIFT)</span>
<span class="cp">#define PTRS_PER_PMD	1</span>
<span class="cp">#define PTRS_PER_PGD	(1 &lt;&lt; (32 - PGDIR_SHIFT))</span>

<span class="cp">#define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)</span>
<span class="cp">#define FIRST_USER_ADDRESS	0</span>

<span class="cp">#define pte_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pte %llx.\n&quot;, __FILE__, __LINE__, \</span>
<span class="cp">		(unsigned long long)pte_val(e))</span>
<span class="cp">#define pgd_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pgd %08lx.\n&quot;, __FILE__, __LINE__, pgd_val(e))</span>

<span class="cm">/*</span>
<span class="cm"> * This is the bottom of the PKMAP area with HIGHMEM or an arbitrary</span>
<span class="cm"> * value (for now) on others, from where we can start layout kernel</span>
<span class="cm"> * virtual space that goes below PKMAP and FIXMAP</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
<span class="cp">#define KVIRT_TOP	PKMAP_BASE</span>
<span class="cp">#else</span>
<span class="cp">#define KVIRT_TOP	(0xfe000000UL)	</span><span class="cm">/* for now, could be FIXMAP_BASE ? */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * ioremap_bot starts at that address. Early ioremaps move down from there,</span>
<span class="cm"> * until mem_init() at which point this becomes the top of the vmalloc</span>
<span class="cm"> * and ioremap space</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_NOT_COHERENT_CACHE</span>
<span class="cp">#define IOREMAP_TOP	((KVIRT_TOP - CONFIG_CONSISTENT_SIZE) &amp; PAGE_MASK)</span>
<span class="cp">#else</span>
<span class="cp">#define IOREMAP_TOP	KVIRT_TOP</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Just any arbitrary offset to the start of the vmalloc VM area: the</span>
<span class="cm"> * current 16MB value just means that there will be a 64MB &quot;hole&quot; after the</span>
<span class="cm"> * physical memory until the kernel virtual memory starts.  That means that</span>
<span class="cm"> * any out-of-bounds memory accesses will hopefully be caught.</span>
<span class="cm"> * The vmalloc() routines leaves a hole of 4kB between each vmalloced</span>
<span class="cm"> * area for the same reason. ;)</span>
<span class="cm"> *</span>
<span class="cm"> * We no longer map larger than phys RAM with the BATs so we don&#39;t have</span>
<span class="cm"> * to worry about the VMALLOC_OFFSET causing problems.  We do have to worry</span>
<span class="cm"> * about clashes between our early calls to ioremap() that start growing down</span>
<span class="cm"> * from ioremap_base being run into the VM area allocations (growing upwards</span>
<span class="cm"> * from VMALLOC_START).  For this reason we have ioremap_bot to check when</span>
<span class="cm"> * we actually run into our mappings setup in the early boot with the VM</span>
<span class="cm"> * system.  This really does become a problem for machines with good amounts</span>
<span class="cm"> * of RAM.  -- Cort</span>
<span class="cm"> */</span>
<span class="cp">#define VMALLOC_OFFSET (0x1000000) </span><span class="cm">/* 16M */</span><span class="cp"></span>
<span class="cp">#ifdef PPC_PIN_SIZE</span>
<span class="cp">#define VMALLOC_START (((_ALIGN((long)high_memory, PPC_PIN_SIZE) + VMALLOC_OFFSET) &amp; ~(VMALLOC_OFFSET-1)))</span>
<span class="cp">#else</span>
<span class="cp">#define VMALLOC_START ((((long)high_memory + VMALLOC_OFFSET) &amp; ~(VMALLOC_OFFSET-1)))</span>
<span class="cp">#endif</span>
<span class="cp">#define VMALLOC_END	ioremap_bot</span>

<span class="cm">/*</span>
<span class="cm"> * Bits in a linux-style PTE.  These match the bits in the</span>
<span class="cm"> * (hardware-defined) PowerPC PTE as closely as possible.</span>
<span class="cm"> */</span>

<span class="cp">#if defined(CONFIG_40x)</span>
<span class="cp">#include &lt;asm/pte-40x.h&gt;</span>
<span class="cp">#elif defined(CONFIG_44x)</span>
<span class="cp">#include &lt;asm/pte-44x.h&gt;</span>
<span class="cp">#elif defined(CONFIG_FSL_BOOKE) &amp;&amp; defined(CONFIG_PTE_64BIT)</span>
<span class="cp">#include &lt;asm/pte-book3e.h&gt;</span>
<span class="cp">#elif defined(CONFIG_FSL_BOOKE)</span>
<span class="cp">#include &lt;asm/pte-fsl-booke.h&gt;</span>
<span class="cp">#elif defined(CONFIG_8xx)</span>
<span class="cp">#include &lt;asm/pte-8xx.h&gt;</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_6xx */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/pte-hash32.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/* And here we include common definitions */</span>
<span class="cp">#include &lt;asm/pte-common.h&gt;</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#define pte_clear(mm, addr, ptep) \</span>
<span class="cp">	do { pte_update(ptep, ~_PAGE_HASHPTE, 0); } while (0)</span>

<span class="cp">#define pmd_none(pmd)		(!pmd_val(pmd))</span>
<span class="cp">#define	pmd_bad(pmd)		(pmd_val(pmd) &amp; _PMD_BAD)</span>
<span class="cp">#define	pmd_present(pmd)	(pmd_val(pmd) &amp; _PMD_PRESENT_MASK)</span>
<span class="cp">#define	pmd_clear(pmdp)		do { pmd_val(*(pmdp)) = 0; } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * When flushing the tlb entry for a page, we also need to flush the hash</span>
<span class="cm"> * table entry.  flush_hash_pages is assembler (for speed) in hashtable.S.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">flush_hash_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">context</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmdval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="cm">/* Add an HPTE to the hash table */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">add_hash_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">context</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmdval</span><span class="p">);</span>

<span class="cm">/* Flush an entry from the TLB/hash table */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">flush_hash_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * PTE updates. This function is called whenever an existing</span>
<span class="cm"> * valid PTE is updated. This does -not- include set_pte_at()</span>
<span class="cm"> * which nowadays only sets a new PTE.</span>
<span class="cm"> *</span>
<span class="cm"> * Depending on the type of MMU, we may need to use atomic updates</span>
<span class="cm"> * and the PTE may be either 32 or 64 bit wide. In the later case,</span>
<span class="cm"> * when using atomic updates, only the low part of the PTE is</span>
<span class="cm"> * accessed atomically.</span>
<span class="cm"> *</span>
<span class="cm"> * In addition, on 44x, we also maintain a global flag indicating</span>
<span class="cm"> * that an executable user mapping was modified, which is needed</span>
<span class="cm"> * to properly flush the virtually tagged instruction cache of</span>
<span class="cm"> * those implementations.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_PTE_64BIT</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">pte_update</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clr</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef PTE_ATOMIC_UPDATES</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;\</span>
<span class="s">1:	lwarx	%0,0,%3</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	andc	%1,%0,%4</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	or	%1,%1,%5</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="n">PPC405_ERR77</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">%</span><span class="mi">3</span><span class="p">)</span>
<span class="s">&quot;	stwcx.	%1,0,%3</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	bne-	1b&quot;</span>
	<span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">old</span><span class="p">),</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
	<span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">clr</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">set</span><span class="p">),</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
	<span class="o">:</span> <span class="s">&quot;cc&quot;</span> <span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* PTE_ATOMIC_UPDATES */</span><span class="cp"></span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">__pte</span><span class="p">((</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">clr</span><span class="p">)</span> <span class="o">|</span> <span class="n">set</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* !PTE_ATOMIC_UPDATES */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_44x</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">_PAGE_USER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">_PAGE_EXEC</span><span class="p">))</span>
		<span class="n">icache_44x_need_flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_PTE_64BIT */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">pte_update</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clr</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef PTE_ATOMIC_UPDATES</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">old</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;\</span>
<span class="s">1:	lwarx	%L0,0,%4</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	lwzx	%0,0,%3</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	andc	%1,%L0,%5</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	or	%1,%1,%6</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="n">PPC405_ERR77</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">%</span><span class="mi">3</span><span class="p">)</span>
<span class="s">&quot;	stwcx.	%1,0,%4</span><span class="se">\n</span><span class="s">\</span>
<span class="s">	bne-	1b&quot;</span>
	<span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">old</span><span class="p">),</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
	<span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">clr</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">set</span><span class="p">),</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
	<span class="o">:</span> <span class="s">&quot;cc&quot;</span> <span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* PTE_ATOMIC_UPDATES */</span><span class="cp"></span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">old</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">__pte</span><span class="p">((</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">clr</span><span class="p">)</span> <span class="o">|</span> <span class="n">set</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* !PTE_ATOMIC_UPDATES */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_44x</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">_PAGE_USER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">_PAGE_EXEC</span><span class="p">))</span>
		<span class="n">icache_44x_need_flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PTE_64BIT */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * 2.6 calls this without flushing the TLB entry; this is wrong</span>
<span class="cm"> * for our hash-based implementation, we fix that up here.</span>
<span class="cm"> */</span>
<span class="cp">#define __HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__ptep_test_and_clear_young</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">context</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old</span><span class="p">;</span>
	<span class="n">old</span> <span class="o">=</span> <span class="n">pte_update</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">_PAGE_ACCESSED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#if _PAGE_HASHPTE != 0</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">_PAGE_HASHPTE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptephys</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="n">flush_hash_pages</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptephys</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">_PAGE_ACCESSED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define ptep_test_and_clear_young(__vma, __addr, __ptep) \</span>
<span class="cp">	__ptep_test_and_clear_young((__vma)-&gt;vm_mm-&gt;context.id, __addr, __ptep)</span>

<span class="cp">#define __HAVE_ARCH_PTEP_GET_AND_CLEAR</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">ptep_get_and_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				       <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">(</span><span class="n">pte_update</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="o">~</span><span class="n">_PAGE_HASHPTE</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define __HAVE_ARCH_PTEP_SET_WRPROTECT</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ptep_set_wrprotect</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				      <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_update</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="p">(</span><span class="n">_PAGE_RW</span> <span class="o">|</span> <span class="n">_PAGE_HWWRITE</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">huge_ptep_set_wrprotect</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ptep_set_wrprotect</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__ptep_set_access_flags</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="p">(</span><span class="n">_PAGE_DIRTY</span> <span class="o">|</span> <span class="n">_PAGE_ACCESSED</span> <span class="o">|</span> <span class="n">_PAGE_RW</span> <span class="o">|</span> <span class="n">_PAGE_EXEC</span><span class="p">);</span>
	<span class="n">pte_update</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define __HAVE_ARCH_PTE_SAME</span>
<span class="cp">#define pte_same(A,B)	(((pte_val(A) ^ pte_val(B)) &amp; ~_PAGE_HASHPTE) == 0)</span>

<span class="cm">/*</span>
<span class="cm"> * Note that on Book E processors, the pmd contains the kernel virtual</span>
<span class="cm"> * (lowmem) address of the pte page.  The physical address is less useful</span>
<span class="cm"> * because everything runs with translation enabled (even the TLB miss</span>
<span class="cm"> * handler).  On everything else the pmd contains the physical address</span>
<span class="cm"> * of the pte page.  -- paulus</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_BOOKE</span>
<span class="cp">#define pmd_page_vaddr(pmd)	\</span>
<span class="cp">	((unsigned long) __va(pmd_val(pmd) &amp; PAGE_MASK))</span>
<span class="cp">#define pmd_page(pmd)		\</span>
<span class="cp">	pfn_to_page(pmd_val(pmd) &gt;&gt; PAGE_SHIFT)</span>
<span class="cp">#else</span>
<span class="cp">#define pmd_page_vaddr(pmd)	\</span>
<span class="cp">	((unsigned long) (pmd_val(pmd) &amp; PAGE_MASK))</span>
<span class="cp">#define pmd_page(pmd)		\</span>
<span class="cp">	pfn_to_page((__pa(pmd_val(pmd)) &gt;&gt; PAGE_SHIFT))</span>
<span class="cp">#endif</span>

<span class="cm">/* to find an entry in a kernel page-table-directory */</span>
<span class="cp">#define pgd_offset_k(address) pgd_offset(&amp;init_mm, address)</span>

<span class="cm">/* to find an entry in a page-table-directory */</span>
<span class="cp">#define pgd_index(address)	 ((address) &gt;&gt; PGDIR_SHIFT)</span>
<span class="cp">#define pgd_offset(mm, address)	 ((mm)-&gt;pgd + pgd_index(address))</span>

<span class="cm">/* Find an entry in the third-level page table.. */</span>
<span class="cp">#define pte_index(address)		\</span>
<span class="cp">	(((address) &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1))</span>
<span class="cp">#define pte_offset_kernel(dir, addr)	\</span>
<span class="cp">	((pte_t *) pmd_page_vaddr(*(dir)) + pte_index(addr))</span>
<span class="cp">#define pte_offset_map(dir, addr)		\</span>
<span class="cp">	((pte_t *) kmap_atomic(pmd_page(*(dir))) + pte_index(addr))</span>
<span class="cp">#define pte_unmap(pte)		kunmap_atomic(pte)</span>

<span class="cm">/*</span>
<span class="cm"> * Encode and decode a swap entry.</span>
<span class="cm"> * Note that the bits we use in a PTE for representing a swap entry</span>
<span class="cm"> * must not include the _PAGE_PRESENT bit, the _PAGE_FILE bit, or the</span>
<span class="cm"> *_PAGE_HASHPTE bit (if used).  -- paulus</span>
<span class="cm"> */</span>
<span class="cp">#define __swp_type(entry)		((entry).val &amp; 0x1f)</span>
<span class="cp">#define __swp_offset(entry)		((entry).val &gt;&gt; 5)</span>
<span class="cp">#define __swp_entry(type, offset)	((swp_entry_t) { (type) | ((offset) &lt;&lt; 5) })</span>
<span class="cp">#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) &gt;&gt; 3 })</span>
<span class="cp">#define __swp_entry_to_pte(x)		((pte_t) { (x).val &lt;&lt; 3 })</span>

<span class="cm">/* Encode and decode a nonlinear file mapping entry */</span>
<span class="cp">#define PTE_FILE_MAX_BITS	29</span>
<span class="cp">#define pte_to_pgoff(pte)	(pte_val(pte) &gt;&gt; 3)</span>
<span class="cp">#define pgoff_to_pte(off)	((pte_t) { ((off) &lt;&lt; 3) | _PAGE_FILE })</span>

<span class="cm">/*</span>
<span class="cm"> * No page table caches to initialise</span>
<span class="cm"> */</span>
<span class="cp">#define pgtable_cache_init()	do { } while (0)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">get_pteptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">**</span><span class="n">ptep</span><span class="p">,</span>
		      <span class="n">pmd_t</span> <span class="o">**</span><span class="n">pmdp</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_POWERPC_PGTABLE_PPC32_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
