<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › ppc_asm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ppc_asm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 1995-1999 Gary Thomas, Paul Mackerras, Cort Dougan.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _ASM_POWERPC_PPC_ASM_H</span>
<span class="cp">#define _ASM_POWERPC_PPC_ASM_H</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/stringify.h&gt;</span>
<span class="cp">#include &lt;asm/asm-compat.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/ppc-opcode.h&gt;</span>
<span class="cp">#include &lt;asm/firmware.h&gt;</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cp">#error __FILE__ should only be used in assembler files</span>
<span class="cp">#else</span>

<span class="cp">#define SZL			(BITS_PER_LONG/8)</span>

<span class="cm">/*</span>
<span class="cm"> * Stuff for accurate CPU time accounting.</span>
<span class="cm"> * These macros handle transitions between user and system state</span>
<span class="cm"> * in exception entry and exit and accumulate time to the</span>
<span class="cm"> * user_time and system_time fields in the paca.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef CONFIG_VIRT_CPU_ACCOUNTING</span>
<span class="cp">#define ACCOUNT_CPU_USER_ENTRY(ra, rb)</span>
<span class="cp">#define ACCOUNT_CPU_USER_EXIT(ra, rb)</span>
<span class="cp">#define ACCOUNT_STOLEN_TIME</span>
<span class="cp">#else</span>
<span class="cp">#define ACCOUNT_CPU_USER_ENTRY(ra, rb)					\</span>
<span class="cp">	beq	2f;			</span><span class="cm">/* if from kernel mode */</span><span class="cp">	\</span>
<span class="cp">	MFTB(ra);			</span><span class="cm">/* get timebase */</span><span class="cp">		\</span>
<span class="cp">	ld	rb,PACA_STARTTIME_USER(r13);				\</span>
<span class="cp">	std	ra,PACA_STARTTIME(r13);					\</span>
<span class="cp">	subf	rb,rb,ra;		</span><span class="cm">/* subtract start value */</span><span class="cp">	\</span>
<span class="cp">	ld	ra,PACA_USER_TIME(r13);					\</span>
<span class="cp">	add	ra,ra,rb;		</span><span class="cm">/* add on to user time */</span><span class="cp">	\</span>
<span class="cp">	std	ra,PACA_USER_TIME(r13);					\</span>
<span class="cp">2:</span>

<span class="cp">#define ACCOUNT_CPU_USER_EXIT(ra, rb)					\</span>
<span class="cp">	MFTB(ra);			</span><span class="cm">/* get timebase */</span><span class="cp">		\</span>
<span class="cp">	ld	rb,PACA_STARTTIME(r13);					\</span>
<span class="cp">	std	ra,PACA_STARTTIME_USER(r13);				\</span>
<span class="cp">	subf	rb,rb,ra;		</span><span class="cm">/* subtract start value */</span><span class="cp">	\</span>
<span class="cp">	ld	ra,PACA_SYSTEM_TIME(r13);				\</span>
<span class="cp">	add	ra,ra,rb;		</span><span class="cm">/* add on to system time */</span><span class="cp">	\</span>
<span class="cp">	std	ra,PACA_SYSTEM_TIME(r13)</span>

<span class="cp">#ifdef CONFIG_PPC_SPLPAR</span>
<span class="cp">#define ACCOUNT_STOLEN_TIME						\</span>
<span class="cp">BEGIN_FW_FTR_SECTION;							\</span>
<span class="cp">	beq	33f;							\</span>
<span class="cp">	</span><span class="cm">/* from user - see if there are any DTL entries to process */</span><span class="cp">	\</span>
<span class="cp">	ld	r10,PACALPPACAPTR(r13);	</span><span class="cm">/* get ptr to VPA */</span><span class="cp">		\</span>
<span class="cp">	ld	r11,PACA_DTL_RIDX(r13);	</span><span class="cm">/* get log read index */</span><span class="cp">	\</span>
<span class="cp">	ld	r10,LPPACA_DTLIDX(r10);	</span><span class="cm">/* get log write index */</span><span class="cp">	\</span>
<span class="cp">	cmpd	cr1,r11,r10;						\</span>
<span class="cp">	beq+	cr1,33f;						\</span>
<span class="cp">	bl	.accumulate_stolen_time;				\</span>
<span class="cp">	ld	r12,_MSR(r1);						\</span>
<span class="cp">	andi.	r10,r12,MSR_PR;		</span><span class="cm">/* Restore cr0 (coming from user) */</span><span class="cp"> \</span>
<span class="cp">33:									\</span>
<span class="cp">END_FW_FTR_SECTION_IFSET(FW_FEATURE_SPLPAR)</span>

<span class="cp">#else  </span><span class="cm">/* CONFIG_PPC_SPLPAR */</span><span class="cp"></span>
<span class="cp">#define ACCOUNT_STOLEN_TIME</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_SPLPAR */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_VIRT_CPU_ACCOUNTING */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Macros for storing registers into and loading registers from</span>
<span class="cm"> * exception frames.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __powerpc64__</span>
<span class="cp">#define SAVE_GPR(n, base)	std	n,GPR0+8*(n)(base)</span>
<span class="cp">#define REST_GPR(n, base)	ld	n,GPR0+8*(n)(base)</span>
<span class="cp">#define SAVE_NVGPRS(base)	SAVE_8GPRS(14, base); SAVE_10GPRS(22, base)</span>
<span class="cp">#define REST_NVGPRS(base)	REST_8GPRS(14, base); REST_10GPRS(22, base)</span>
<span class="cp">#else</span>
<span class="cp">#define SAVE_GPR(n, base)	stw	n,GPR0+4*(n)(base)</span>
<span class="cp">#define REST_GPR(n, base)	lwz	n,GPR0+4*(n)(base)</span>
<span class="cp">#define SAVE_NVGPRS(base)	SAVE_GPR(13, base); SAVE_8GPRS(14, base); \</span>
<span class="cp">				SAVE_10GPRS(22, base)</span>
<span class="cp">#define REST_NVGPRS(base)	REST_GPR(13, base); REST_8GPRS(14, base); \</span>
<span class="cp">				REST_10GPRS(22, base)</span>
<span class="cp">#endif</span>

<span class="cp">#define SAVE_2GPRS(n, base)	SAVE_GPR(n, base); SAVE_GPR(n+1, base)</span>
<span class="cp">#define SAVE_4GPRS(n, base)	SAVE_2GPRS(n, base); SAVE_2GPRS(n+2, base)</span>
<span class="cp">#define SAVE_8GPRS(n, base)	SAVE_4GPRS(n, base); SAVE_4GPRS(n+4, base)</span>
<span class="cp">#define SAVE_10GPRS(n, base)	SAVE_8GPRS(n, base); SAVE_2GPRS(n+8, base)</span>
<span class="cp">#define REST_2GPRS(n, base)	REST_GPR(n, base); REST_GPR(n+1, base)</span>
<span class="cp">#define REST_4GPRS(n, base)	REST_2GPRS(n, base); REST_2GPRS(n+2, base)</span>
<span class="cp">#define REST_8GPRS(n, base)	REST_4GPRS(n, base); REST_4GPRS(n+4, base)</span>
<span class="cp">#define REST_10GPRS(n, base)	REST_8GPRS(n, base); REST_2GPRS(n+8, base)</span>

<span class="cp">#define SAVE_FPR(n, base)	stfd	n,THREAD_FPR0+8*TS_FPRWIDTH*(n)(base)</span>
<span class="cp">#define SAVE_2FPRS(n, base)	SAVE_FPR(n, base); SAVE_FPR(n+1, base)</span>
<span class="cp">#define SAVE_4FPRS(n, base)	SAVE_2FPRS(n, base); SAVE_2FPRS(n+2, base)</span>
<span class="cp">#define SAVE_8FPRS(n, base)	SAVE_4FPRS(n, base); SAVE_4FPRS(n+4, base)</span>
<span class="cp">#define SAVE_16FPRS(n, base)	SAVE_8FPRS(n, base); SAVE_8FPRS(n+8, base)</span>
<span class="cp">#define SAVE_32FPRS(n, base)	SAVE_16FPRS(n, base); SAVE_16FPRS(n+16, base)</span>
<span class="cp">#define REST_FPR(n, base)	lfd	n,THREAD_FPR0+8*TS_FPRWIDTH*(n)(base)</span>
<span class="cp">#define REST_2FPRS(n, base)	REST_FPR(n, base); REST_FPR(n+1, base)</span>
<span class="cp">#define REST_4FPRS(n, base)	REST_2FPRS(n, base); REST_2FPRS(n+2, base)</span>
<span class="cp">#define REST_8FPRS(n, base)	REST_4FPRS(n, base); REST_4FPRS(n+4, base)</span>
<span class="cp">#define REST_16FPRS(n, base)	REST_8FPRS(n, base); REST_8FPRS(n+8, base)</span>
<span class="cp">#define REST_32FPRS(n, base)	REST_16FPRS(n, base); REST_16FPRS(n+16, base)</span>

<span class="cp">#define SAVE_VR(n,b,base)	li b,THREAD_VR0+(16*(n));  stvx n,base,b</span>
<span class="cp">#define SAVE_2VRS(n,b,base)	SAVE_VR(n,b,base); SAVE_VR(n+1,b,base)</span>
<span class="cp">#define SAVE_4VRS(n,b,base)	SAVE_2VRS(n,b,base); SAVE_2VRS(n+2,b,base)</span>
<span class="cp">#define SAVE_8VRS(n,b,base)	SAVE_4VRS(n,b,base); SAVE_4VRS(n+4,b,base)</span>
<span class="cp">#define SAVE_16VRS(n,b,base)	SAVE_8VRS(n,b,base); SAVE_8VRS(n+8,b,base)</span>
<span class="cp">#define SAVE_32VRS(n,b,base)	SAVE_16VRS(n,b,base); SAVE_16VRS(n+16,b,base)</span>
<span class="cp">#define REST_VR(n,b,base)	li b,THREAD_VR0+(16*(n)); lvx n,base,b</span>
<span class="cp">#define REST_2VRS(n,b,base)	REST_VR(n,b,base); REST_VR(n+1,b,base)</span>
<span class="cp">#define REST_4VRS(n,b,base)	REST_2VRS(n,b,base); REST_2VRS(n+2,b,base)</span>
<span class="cp">#define REST_8VRS(n,b,base)	REST_4VRS(n,b,base); REST_4VRS(n+4,b,base)</span>
<span class="cp">#define REST_16VRS(n,b,base)	REST_8VRS(n,b,base); REST_8VRS(n+8,b,base)</span>
<span class="cp">#define REST_32VRS(n,b,base)	REST_16VRS(n,b,base); REST_16VRS(n+16,b,base)</span>

<span class="cm">/* Save the lower 32 VSRs in the thread VSR region */</span>
<span class="cp">#define SAVE_VSR(n,b,base)	li b,THREAD_VSR0+(16*(n));  STXVD2X(n,base,b)</span>
<span class="cp">#define SAVE_2VSRS(n,b,base)	SAVE_VSR(n,b,base); SAVE_VSR(n+1,b,base)</span>
<span class="cp">#define SAVE_4VSRS(n,b,base)	SAVE_2VSRS(n,b,base); SAVE_2VSRS(n+2,b,base)</span>
<span class="cp">#define SAVE_8VSRS(n,b,base)	SAVE_4VSRS(n,b,base); SAVE_4VSRS(n+4,b,base)</span>
<span class="cp">#define SAVE_16VSRS(n,b,base)	SAVE_8VSRS(n,b,base); SAVE_8VSRS(n+8,b,base)</span>
<span class="cp">#define SAVE_32VSRS(n,b,base)	SAVE_16VSRS(n,b,base); SAVE_16VSRS(n+16,b,base)</span>
<span class="cp">#define REST_VSR(n,b,base)	li b,THREAD_VSR0+(16*(n)); LXVD2X(n,base,b)</span>
<span class="cp">#define REST_2VSRS(n,b,base)	REST_VSR(n,b,base); REST_VSR(n+1,b,base)</span>
<span class="cp">#define REST_4VSRS(n,b,base)	REST_2VSRS(n,b,base); REST_2VSRS(n+2,b,base)</span>
<span class="cp">#define REST_8VSRS(n,b,base)	REST_4VSRS(n,b,base); REST_4VSRS(n+4,b,base)</span>
<span class="cp">#define REST_16VSRS(n,b,base)	REST_8VSRS(n,b,base); REST_8VSRS(n+8,b,base)</span>
<span class="cp">#define REST_32VSRS(n,b,base)	REST_16VSRS(n,b,base); REST_16VSRS(n+16,b,base)</span>
<span class="cm">/* Save the upper 32 VSRs (32-63) in the thread VSX region (0-31) */</span>
<span class="cp">#define SAVE_VSRU(n,b,base)	li b,THREAD_VR0+(16*(n));  STXVD2X(n+32,base,b)</span>
<span class="cp">#define SAVE_2VSRSU(n,b,base)	SAVE_VSRU(n,b,base); SAVE_VSRU(n+1,b,base)</span>
<span class="cp">#define SAVE_4VSRSU(n,b,base)	SAVE_2VSRSU(n,b,base); SAVE_2VSRSU(n+2,b,base)</span>
<span class="cp">#define SAVE_8VSRSU(n,b,base)	SAVE_4VSRSU(n,b,base); SAVE_4VSRSU(n+4,b,base)</span>
<span class="cp">#define SAVE_16VSRSU(n,b,base)	SAVE_8VSRSU(n,b,base); SAVE_8VSRSU(n+8,b,base)</span>
<span class="cp">#define SAVE_32VSRSU(n,b,base)	SAVE_16VSRSU(n,b,base); SAVE_16VSRSU(n+16,b,base)</span>
<span class="cp">#define REST_VSRU(n,b,base)	li b,THREAD_VR0+(16*(n)); LXVD2X(n+32,base,b)</span>
<span class="cp">#define REST_2VSRSU(n,b,base)	REST_VSRU(n,b,base); REST_VSRU(n+1,b,base)</span>
<span class="cp">#define REST_4VSRSU(n,b,base)	REST_2VSRSU(n,b,base); REST_2VSRSU(n+2,b,base)</span>
<span class="cp">#define REST_8VSRSU(n,b,base)	REST_4VSRSU(n,b,base); REST_4VSRSU(n+4,b,base)</span>
<span class="cp">#define REST_16VSRSU(n,b,base)	REST_8VSRSU(n,b,base); REST_8VSRSU(n+8,b,base)</span>
<span class="cp">#define REST_32VSRSU(n,b,base)	REST_16VSRSU(n,b,base); REST_16VSRSU(n+16,b,base)</span>

<span class="cm">/*</span>
<span class="cm"> * b = base register for addressing, o = base offset from register of 1st EVR</span>
<span class="cm"> * n = first EVR, s = scratch</span>
<span class="cm"> */</span>
<span class="cp">#define SAVE_EVR(n,s,b,o)	evmergehi s,s,n; stw s,o+4*(n)(b)</span>
<span class="cp">#define SAVE_2EVRS(n,s,b,o)	SAVE_EVR(n,s,b,o); SAVE_EVR(n+1,s,b,o)</span>
<span class="cp">#define SAVE_4EVRS(n,s,b,o)	SAVE_2EVRS(n,s,b,o); SAVE_2EVRS(n+2,s,b,o)</span>
<span class="cp">#define SAVE_8EVRS(n,s,b,o)	SAVE_4EVRS(n,s,b,o); SAVE_4EVRS(n+4,s,b,o)</span>
<span class="cp">#define SAVE_16EVRS(n,s,b,o)	SAVE_8EVRS(n,s,b,o); SAVE_8EVRS(n+8,s,b,o)</span>
<span class="cp">#define SAVE_32EVRS(n,s,b,o)	SAVE_16EVRS(n,s,b,o); SAVE_16EVRS(n+16,s,b,o)</span>
<span class="cp">#define REST_EVR(n,s,b,o)	lwz s,o+4*(n)(b); evmergelo n,s,n</span>
<span class="cp">#define REST_2EVRS(n,s,b,o)	REST_EVR(n,s,b,o); REST_EVR(n+1,s,b,o)</span>
<span class="cp">#define REST_4EVRS(n,s,b,o)	REST_2EVRS(n,s,b,o); REST_2EVRS(n+2,s,b,o)</span>
<span class="cp">#define REST_8EVRS(n,s,b,o)	REST_4EVRS(n,s,b,o); REST_4EVRS(n+4,s,b,o)</span>
<span class="cp">#define REST_16EVRS(n,s,b,o)	REST_8EVRS(n,s,b,o); REST_8EVRS(n+8,s,b,o)</span>
<span class="cp">#define REST_32EVRS(n,s,b,o)	REST_16EVRS(n,s,b,o); REST_16EVRS(n+16,s,b,o)</span>

<span class="cm">/* Macros to adjust thread priority for hardware multithreading */</span>
<span class="cp">#define HMT_VERY_LOW	or	31,31,31	# very low priority</span>
<span class="cp">#define HMT_LOW		or	1,1,1</span>
<span class="cp">#define HMT_MEDIUM_LOW  or	6,6,6		# medium low priority</span>
<span class="cp">#define HMT_MEDIUM	or	2,2,2</span>
<span class="cp">#define HMT_MEDIUM_HIGH or	5,5,5		# medium high priority</span>
<span class="cp">#define HMT_HIGH	or	3,3,3</span>
<span class="cp">#define HMT_EXTRA_HIGH	or	7,7,7		# power7 only</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#ifdef CONFIG_PPC64</span>

<span class="cp">#define XGLUE(a,b) a##b</span>
<span class="cp">#define GLUE(a,b) XGLUE(a,b)</span>

<span class="cp">#define _GLOBAL(name) \</span>
<span class="cp">	.section &quot;.text&quot;; \</span>
<span class="cp">	.align 2 ; \</span>
<span class="cp">	.globl name; \</span>
<span class="cp">	.globl GLUE(.,name); \</span>
<span class="cp">	.section &quot;.opd&quot;,&quot;aw&quot;; \</span>
<span class="cp">name: \</span>
<span class="cp">	.quad GLUE(.,name); \</span>
<span class="cp">	.quad .TOC.@tocbase; \</span>
<span class="cp">	.quad 0; \</span>
<span class="cp">	.previous; \</span>
<span class="cp">	.type GLUE(.,name),@function; \</span>
<span class="cp">GLUE(.,name):</span>

<span class="cp">#define _INIT_GLOBAL(name) \</span>
<span class="cp">	__REF; \</span>
<span class="cp">	.align 2 ; \</span>
<span class="cp">	.globl name; \</span>
<span class="cp">	.globl GLUE(.,name); \</span>
<span class="cp">	.section &quot;.opd&quot;,&quot;aw&quot;; \</span>
<span class="cp">name: \</span>
<span class="cp">	.quad GLUE(.,name); \</span>
<span class="cp">	.quad .TOC.@tocbase; \</span>
<span class="cp">	.quad 0; \</span>
<span class="cp">	.previous; \</span>
<span class="cp">	.type GLUE(.,name),@function; \</span>
<span class="cp">GLUE(.,name):</span>

<span class="cp">#define _KPROBE(name) \</span>
<span class="cp">	.section &quot;.kprobes.text&quot;,&quot;a&quot;; \</span>
<span class="cp">	.align 2 ; \</span>
<span class="cp">	.globl name; \</span>
<span class="cp">	.globl GLUE(.,name); \</span>
<span class="cp">	.section &quot;.opd&quot;,&quot;aw&quot;; \</span>
<span class="cp">name: \</span>
<span class="cp">	.quad GLUE(.,name); \</span>
<span class="cp">	.quad .TOC.@tocbase; \</span>
<span class="cp">	.quad 0; \</span>
<span class="cp">	.previous; \</span>
<span class="cp">	.type GLUE(.,name),@function; \</span>
<span class="cp">GLUE(.,name):</span>

<span class="cp">#define _STATIC(name) \</span>
<span class="cp">	.section &quot;.text&quot;; \</span>
<span class="cp">	.align 2 ; \</span>
<span class="cp">	.section &quot;.opd&quot;,&quot;aw&quot;; \</span>
<span class="cp">name: \</span>
<span class="cp">	.quad GLUE(.,name); \</span>
<span class="cp">	.quad .TOC.@tocbase; \</span>
<span class="cp">	.quad 0; \</span>
<span class="cp">	.previous; \</span>
<span class="cp">	.type GLUE(.,name),@function; \</span>
<span class="cp">GLUE(.,name):</span>

<span class="cp">#define _INIT_STATIC(name) \</span>
<span class="cp">	__REF; \</span>
<span class="cp">	.align 2 ; \</span>
<span class="cp">	.section &quot;.opd&quot;,&quot;aw&quot;; \</span>
<span class="cp">name: \</span>
<span class="cp">	.quad GLUE(.,name); \</span>
<span class="cp">	.quad .TOC.@tocbase; \</span>
<span class="cp">	.quad 0; \</span>
<span class="cp">	.previous; \</span>
<span class="cp">	.type GLUE(.,name),@function; \</span>
<span class="cp">GLUE(.,name):</span>

<span class="cp">#else </span><span class="cm">/* 32-bit */</span><span class="cp"></span>

<span class="cp">#define _ENTRY(n)	\</span>
<span class="cp">	.globl n;	\</span>
<span class="cp">n:</span>

<span class="cp">#define _GLOBAL(n)	\</span>
<span class="cp">	.text;		\</span>
<span class="cp">	.stabs __stringify(n:F-1),N_FUN,0,0,n;\</span>
<span class="cp">	.globl n;	\</span>
<span class="cp">n:</span>

<span class="cp">#define _KPROBE(n)	\</span>
<span class="cp">	.section &quot;.kprobes.text&quot;,&quot;a&quot;;	\</span>
<span class="cp">	.globl	n;	\</span>
<span class="cp">n:</span>

<span class="cp">#endif</span>

<span class="cm">/* </span>
<span class="cm"> * LOAD_REG_IMMEDIATE(rn, expr)</span>
<span class="cm"> *   Loads the value of the constant expression &#39;expr&#39; into register &#39;rn&#39;</span>
<span class="cm"> *   using immediate instructions only.  Use this when it&#39;s important not</span>
<span class="cm"> *   to reference other data (i.e. on ppc64 when the TOC pointer is not</span>
<span class="cm"> *   valid) and when &#39;expr&#39; is a constant or absolute address.</span>
<span class="cm"> *</span>
<span class="cm"> * LOAD_REG_ADDR(rn, name)</span>
<span class="cm"> *   Loads the address of label &#39;name&#39; into register &#39;rn&#39;.  Use this when</span>
<span class="cm"> *   you don&#39;t particularly need immediate instructions only, but you need</span>
<span class="cm"> *   the whole address in one register (e.g. it&#39;s a structure address and</span>
<span class="cm"> *   you want to access various offsets within it).  On ppc32 this is</span>
<span class="cm"> *   identical to LOAD_REG_IMMEDIATE.</span>
<span class="cm"> *</span>
<span class="cm"> * LOAD_REG_ADDRBASE(rn, name)</span>
<span class="cm"> * ADDROFF(name)</span>
<span class="cm"> *   LOAD_REG_ADDRBASE loads part of the address of label &#39;name&#39; into</span>
<span class="cm"> *   register &#39;rn&#39;.  ADDROFF(name) returns the remainder of the address as</span>
<span class="cm"> *   a constant expression.  ADDROFF(name) is a signed expression &lt; 16 bits</span>
<span class="cm"> *   in size, so is suitable for use directly as an offset in load and store</span>
<span class="cm"> *   instructions.  Use this when loading/storing a single word or less as:</span>
<span class="cm"> *      LOAD_REG_ADDRBASE(rX, name)</span>
<span class="cm"> *      ld	rY,ADDROFF(name)(rX)</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __powerpc64__</span>
<span class="cp">#define LOAD_REG_IMMEDIATE(reg,expr)		\</span>
<span class="cp">	lis     (reg),(expr)@highest;		\</span>
<span class="cp">	ori     (reg),(reg),(expr)@higher;	\</span>
<span class="cp">	rldicr  (reg),(reg),32,31;		\</span>
<span class="cp">	oris    (reg),(reg),(expr)@h;		\</span>
<span class="cp">	ori     (reg),(reg),(expr)@l;</span>

<span class="cp">#define LOAD_REG_ADDR(reg,name)			\</span>
<span class="cp">	ld	(reg),name@got(r2)</span>

<span class="cp">#define LOAD_REG_ADDRBASE(reg,name)	LOAD_REG_ADDR(reg,name)</span>
<span class="cp">#define ADDROFF(name)			0</span>

<span class="cm">/* offsets for stack frame layout */</span>
<span class="cp">#define LRSAVE	16</span>

<span class="cp">#else </span><span class="cm">/* 32-bit */</span><span class="cp"></span>

<span class="cp">#define LOAD_REG_IMMEDIATE(reg,expr)		\</span>
<span class="cp">	lis	(reg),(expr)@ha;		\</span>
<span class="cp">	addi	(reg),(reg),(expr)@l;</span>

<span class="cp">#define LOAD_REG_ADDR(reg,name)		LOAD_REG_IMMEDIATE(reg, name)</span>

<span class="cp">#define LOAD_REG_ADDRBASE(reg, name)	lis	(reg),name@ha</span>
<span class="cp">#define ADDROFF(name)			name@l</span>

<span class="cm">/* offsets for stack frame layout */</span>
<span class="cp">#define LRSAVE	4</span>

<span class="cp">#endif</span>

<span class="cm">/* various errata or part fixups */</span>
<span class="cp">#ifdef CONFIG_PPC601_SYNC_FIX</span>
<span class="cp">#define SYNC				\</span>
<span class="cp">BEGIN_FTR_SECTION			\</span>
<span class="cp">	sync;				\</span>
<span class="cp">	isync;				\</span>
<span class="cp">END_FTR_SECTION_IFSET(CPU_FTR_601)</span>
<span class="cp">#define SYNC_601			\</span>
<span class="cp">BEGIN_FTR_SECTION			\</span>
<span class="cp">	sync;				\</span>
<span class="cp">END_FTR_SECTION_IFSET(CPU_FTR_601)</span>
<span class="cp">#define ISYNC_601			\</span>
<span class="cp">BEGIN_FTR_SECTION			\</span>
<span class="cp">	isync;				\</span>
<span class="cp">END_FTR_SECTION_IFSET(CPU_FTR_601)</span>
<span class="cp">#else</span>
<span class="cp">#define	SYNC</span>
<span class="cp">#define SYNC_601</span>
<span class="cp">#define ISYNC_601</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PPC_CELL</span>
<span class="cp">#define MFTB(dest)			\</span>
<span class="cp">90:	mftb  dest;			\</span>
<span class="cp">BEGIN_FTR_SECTION_NESTED(96);		\</span>
<span class="cp">	cmpwi dest,0;			\</span>
<span class="cp">	beq-  90b;			\</span>
<span class="cp">END_FTR_SECTION_NESTED(CPU_FTR_CELL_TB_BUG, CPU_FTR_CELL_TB_BUG, 96)</span>
<span class="cp">#else</span>
<span class="cp">#define MFTB(dest)			mftb dest</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CONFIG_SMP</span>
<span class="cp">#define TLBSYNC</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>
<span class="cm">/* tlbsync is not implemented on 601 */</span>
<span class="cp">#define TLBSYNC				\</span>
<span class="cp">BEGIN_FTR_SECTION			\</span>
<span class="cp">	tlbsync;			\</span>
<span class="cp">	sync;				\</span>
<span class="cp">END_FTR_SECTION_IFCLR(CPU_FTR_601)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cp">#define MTOCRF(FXM, RS)			\</span>
<span class="cp">	BEGIN_FTR_SECTION_NESTED(848);	\</span>
<span class="cp">	mtcrf	(FXM), (RS);		\</span>
<span class="cp">	FTR_SECTION_ELSE_NESTED(848);	\</span>
<span class="cp">	mtocrf (FXM), (RS);		\</span>
<span class="cp">	ALT_FTR_SECTION_END_NESTED_IFCLR(CPU_FTR_NOEXECUTE, 848)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * This instruction is not implemented on the PPC 603 or 601; however, on</span>
<span class="cm"> * the 403GCX and 405GP tlbia IS defined and tlbie is not.</span>
<span class="cm"> * All of these instructions exist in the 8xx, they have magical powers,</span>
<span class="cm"> * and they must be used.</span>
<span class="cm"> */</span>

<span class="cp">#if !defined(CONFIG_4xx) &amp;&amp; !defined(CONFIG_8xx)</span>
<span class="cp">#define tlbia					\</span>
<span class="cp">	li	r4,1024;			\</span>
<span class="cp">	mtctr	r4;				\</span>
<span class="cp">	lis	r4,KERNELBASE@h;		\</span>
<span class="cp">0:	tlbie	r4;				\</span>
<span class="cp">	addi	r4,r4,0x1000;			\</span>
<span class="cp">	bdnz	0b</span>
<span class="cp">#endif</span>


<span class="cp">#ifdef CONFIG_IBM440EP_ERR42</span>
<span class="cp">#define PPC440EP_ERR42 isync</span>
<span class="cp">#else</span>
<span class="cp">#define PPC440EP_ERR42</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * toreal/fromreal/tophys/tovirt macros. 32-bit BookE makes them</span>
<span class="cm"> * keep the address intact to be compatible with code shared with</span>
<span class="cm"> * 32-bit classic.</span>
<span class="cm"> *</span>
<span class="cm"> * On the other hand, I find it useful to have them behave as expected</span>
<span class="cm"> * by their name (ie always do the addition) on 64-bit BookE</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_BOOKE) &amp;&amp; !defined(CONFIG_PPC64)</span>
<span class="cp">#define toreal(rd)</span>
<span class="cp">#define fromreal(rd)</span>

<span class="cm">/*</span>
<span class="cm"> * We use addis to ensure compatibility with the &quot;classic&quot; ppc versions of</span>
<span class="cm"> * these macros, which use rs = 0 to get the tophys offset in rd, rather than</span>
<span class="cm"> * converting the address in r0, and so this version has to do that too</span>
<span class="cm"> * (i.e. set register rd to 0 when rs == 0).</span>
<span class="cm"> */</span>
<span class="cp">#define tophys(rd,rs)				\</span>
<span class="cp">	addis	rd,rs,0</span>

<span class="cp">#define tovirt(rd,rs)				\</span>
<span class="cp">	addis	rd,rs,0</span>

<span class="cp">#elif defined(CONFIG_PPC64)</span>
<span class="cp">#define toreal(rd)		</span><span class="cm">/* we can access c000... in real mode */</span><span class="cp"></span>
<span class="cp">#define fromreal(rd)</span>

<span class="cp">#define tophys(rd,rs)                           \</span>
<span class="cp">	clrldi	rd,rs,2</span>

<span class="cp">#define tovirt(rd,rs)                           \</span>
<span class="cp">	rotldi	rd,rs,16;			\</span>
<span class="cp">	ori	rd,rd,((KERNELBASE&gt;&gt;48)&amp;0xFFFF);\</span>
<span class="cp">	rotldi	rd,rd,48</span>
<span class="cp">#else</span>
<span class="cm">/*</span>
<span class="cm"> * On APUS (Amiga PowerPC cpu upgrade board), we don&#39;t know the</span>
<span class="cm"> * physical base address of RAM at compile time.</span>
<span class="cm"> */</span>
<span class="cp">#define toreal(rd)	tophys(rd,rd)</span>
<span class="cp">#define fromreal(rd)	tovirt(rd,rd)</span>

<span class="cp">#define tophys(rd,rs)				\</span>
<span class="cp">0:	addis	rd,rs,-PAGE_OFFSET@h;		\</span>
<span class="cp">	.section &quot;.vtop_fixup&quot;,&quot;aw&quot;;		\</span>
<span class="cp">	.align  1;				\</span>
<span class="cp">	.long   0b;				\</span>
<span class="cp">	.previous</span>

<span class="cp">#define tovirt(rd,rs)				\</span>
<span class="cp">0:	addis	rd,rs,PAGE_OFFSET@h;		\</span>
<span class="cp">	.section &quot;.ptov_fixup&quot;,&quot;aw&quot;;		\</span>
<span class="cp">	.align  1;				\</span>
<span class="cp">	.long   0b;				\</span>
<span class="cp">	.previous</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PPC_BOOK3S_64</span>
<span class="cp">#define RFI		rfid</span>
<span class="cp">#define MTMSRD(r)	mtmsrd	r</span>
<span class="cp">#else</span>
<span class="cp">#define FIX_SRR1(ra, rb)</span>
<span class="cp">#ifndef CONFIG_40x</span>
<span class="cp">#define	RFI		rfi</span>
<span class="cp">#else</span>
<span class="cp">#define RFI		rfi; b .	</span><span class="cm">/* Prevent prefetch past rfi */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#define MTMSRD(r)	mtmsr	r</span>
<span class="cp">#define CLR_TOP32(r)</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cm">/* The boring bits... */</span>

<span class="cm">/* Condition Register Bit Fields */</span>

<span class="cp">#define	cr0	0</span>
<span class="cp">#define	cr1	1</span>
<span class="cp">#define	cr2	2</span>
<span class="cp">#define	cr3	3</span>
<span class="cp">#define	cr4	4</span>
<span class="cp">#define	cr5	5</span>
<span class="cp">#define	cr6	6</span>
<span class="cp">#define	cr7	7</span>


<span class="cm">/* General Purpose Registers (GPRs) */</span>

<span class="cp">#define	r0	0</span>
<span class="cp">#define	r1	1</span>
<span class="cp">#define	r2	2</span>
<span class="cp">#define	r3	3</span>
<span class="cp">#define	r4	4</span>
<span class="cp">#define	r5	5</span>
<span class="cp">#define	r6	6</span>
<span class="cp">#define	r7	7</span>
<span class="cp">#define	r8	8</span>
<span class="cp">#define	r9	9</span>
<span class="cp">#define	r10	10</span>
<span class="cp">#define	r11	11</span>
<span class="cp">#define	r12	12</span>
<span class="cp">#define	r13	13</span>
<span class="cp">#define	r14	14</span>
<span class="cp">#define	r15	15</span>
<span class="cp">#define	r16	16</span>
<span class="cp">#define	r17	17</span>
<span class="cp">#define	r18	18</span>
<span class="cp">#define	r19	19</span>
<span class="cp">#define	r20	20</span>
<span class="cp">#define	r21	21</span>
<span class="cp">#define	r22	22</span>
<span class="cp">#define	r23	23</span>
<span class="cp">#define	r24	24</span>
<span class="cp">#define	r25	25</span>
<span class="cp">#define	r26	26</span>
<span class="cp">#define	r27	27</span>
<span class="cp">#define	r28	28</span>
<span class="cp">#define	r29	29</span>
<span class="cp">#define	r30	30</span>
<span class="cp">#define	r31	31</span>


<span class="cm">/* Floating Point Registers (FPRs) */</span>

<span class="cp">#define	fr0	0</span>
<span class="cp">#define	fr1	1</span>
<span class="cp">#define	fr2	2</span>
<span class="cp">#define	fr3	3</span>
<span class="cp">#define	fr4	4</span>
<span class="cp">#define	fr5	5</span>
<span class="cp">#define	fr6	6</span>
<span class="cp">#define	fr7	7</span>
<span class="cp">#define	fr8	8</span>
<span class="cp">#define	fr9	9</span>
<span class="cp">#define	fr10	10</span>
<span class="cp">#define	fr11	11</span>
<span class="cp">#define	fr12	12</span>
<span class="cp">#define	fr13	13</span>
<span class="cp">#define	fr14	14</span>
<span class="cp">#define	fr15	15</span>
<span class="cp">#define	fr16	16</span>
<span class="cp">#define	fr17	17</span>
<span class="cp">#define	fr18	18</span>
<span class="cp">#define	fr19	19</span>
<span class="cp">#define	fr20	20</span>
<span class="cp">#define	fr21	21</span>
<span class="cp">#define	fr22	22</span>
<span class="cp">#define	fr23	23</span>
<span class="cp">#define	fr24	24</span>
<span class="cp">#define	fr25	25</span>
<span class="cp">#define	fr26	26</span>
<span class="cp">#define	fr27	27</span>
<span class="cp">#define	fr28	28</span>
<span class="cp">#define	fr29	29</span>
<span class="cp">#define	fr30	30</span>
<span class="cp">#define	fr31	31</span>

<span class="cm">/* AltiVec Registers (VPRs) */</span>

<span class="cp">#define	vr0	0</span>
<span class="cp">#define	vr1	1</span>
<span class="cp">#define	vr2	2</span>
<span class="cp">#define	vr3	3</span>
<span class="cp">#define	vr4	4</span>
<span class="cp">#define	vr5	5</span>
<span class="cp">#define	vr6	6</span>
<span class="cp">#define	vr7	7</span>
<span class="cp">#define	vr8	8</span>
<span class="cp">#define	vr9	9</span>
<span class="cp">#define	vr10	10</span>
<span class="cp">#define	vr11	11</span>
<span class="cp">#define	vr12	12</span>
<span class="cp">#define	vr13	13</span>
<span class="cp">#define	vr14	14</span>
<span class="cp">#define	vr15	15</span>
<span class="cp">#define	vr16	16</span>
<span class="cp">#define	vr17	17</span>
<span class="cp">#define	vr18	18</span>
<span class="cp">#define	vr19	19</span>
<span class="cp">#define	vr20	20</span>
<span class="cp">#define	vr21	21</span>
<span class="cp">#define	vr22	22</span>
<span class="cp">#define	vr23	23</span>
<span class="cp">#define	vr24	24</span>
<span class="cp">#define	vr25	25</span>
<span class="cp">#define	vr26	26</span>
<span class="cp">#define	vr27	27</span>
<span class="cp">#define	vr28	28</span>
<span class="cp">#define	vr29	29</span>
<span class="cp">#define	vr30	30</span>
<span class="cp">#define	vr31	31</span>

<span class="cm">/* VSX Registers (VSRs) */</span>

<span class="cp">#define	vsr0	0</span>
<span class="cp">#define	vsr1	1</span>
<span class="cp">#define	vsr2	2</span>
<span class="cp">#define	vsr3	3</span>
<span class="cp">#define	vsr4	4</span>
<span class="cp">#define	vsr5	5</span>
<span class="cp">#define	vsr6	6</span>
<span class="cp">#define	vsr7	7</span>
<span class="cp">#define	vsr8	8</span>
<span class="cp">#define	vsr9	9</span>
<span class="cp">#define	vsr10	10</span>
<span class="cp">#define	vsr11	11</span>
<span class="cp">#define	vsr12	12</span>
<span class="cp">#define	vsr13	13</span>
<span class="cp">#define	vsr14	14</span>
<span class="cp">#define	vsr15	15</span>
<span class="cp">#define	vsr16	16</span>
<span class="cp">#define	vsr17	17</span>
<span class="cp">#define	vsr18	18</span>
<span class="cp">#define	vsr19	19</span>
<span class="cp">#define	vsr20	20</span>
<span class="cp">#define	vsr21	21</span>
<span class="cp">#define	vsr22	22</span>
<span class="cp">#define	vsr23	23</span>
<span class="cp">#define	vsr24	24</span>
<span class="cp">#define	vsr25	25</span>
<span class="cp">#define	vsr26	26</span>
<span class="cp">#define	vsr27	27</span>
<span class="cp">#define	vsr28	28</span>
<span class="cp">#define	vsr29	29</span>
<span class="cp">#define	vsr30	30</span>
<span class="cp">#define	vsr31	31</span>
<span class="cp">#define	vsr32	32</span>
<span class="cp">#define	vsr33	33</span>
<span class="cp">#define	vsr34	34</span>
<span class="cp">#define	vsr35	35</span>
<span class="cp">#define	vsr36	36</span>
<span class="cp">#define	vsr37	37</span>
<span class="cp">#define	vsr38	38</span>
<span class="cp">#define	vsr39	39</span>
<span class="cp">#define	vsr40	40</span>
<span class="cp">#define	vsr41	41</span>
<span class="cp">#define	vsr42	42</span>
<span class="cp">#define	vsr43	43</span>
<span class="cp">#define	vsr44	44</span>
<span class="cp">#define	vsr45	45</span>
<span class="cp">#define	vsr46	46</span>
<span class="cp">#define	vsr47	47</span>
<span class="cp">#define	vsr48	48</span>
<span class="cp">#define	vsr49	49</span>
<span class="cp">#define	vsr50	50</span>
<span class="cp">#define	vsr51	51</span>
<span class="cp">#define	vsr52	52</span>
<span class="cp">#define	vsr53	53</span>
<span class="cp">#define	vsr54	54</span>
<span class="cp">#define	vsr55	55</span>
<span class="cp">#define	vsr56	56</span>
<span class="cp">#define	vsr57	57</span>
<span class="cp">#define	vsr58	58</span>
<span class="cp">#define	vsr59	59</span>
<span class="cp">#define	vsr60	60</span>
<span class="cp">#define	vsr61	61</span>
<span class="cp">#define	vsr62	62</span>
<span class="cp">#define	vsr63	63</span>

<span class="cm">/* SPE Registers (EVPRs) */</span>

<span class="cp">#define	evr0	0</span>
<span class="cp">#define	evr1	1</span>
<span class="cp">#define	evr2	2</span>
<span class="cp">#define	evr3	3</span>
<span class="cp">#define	evr4	4</span>
<span class="cp">#define	evr5	5</span>
<span class="cp">#define	evr6	6</span>
<span class="cp">#define	evr7	7</span>
<span class="cp">#define	evr8	8</span>
<span class="cp">#define	evr9	9</span>
<span class="cp">#define	evr10	10</span>
<span class="cp">#define	evr11	11</span>
<span class="cp">#define	evr12	12</span>
<span class="cp">#define	evr13	13</span>
<span class="cp">#define	evr14	14</span>
<span class="cp">#define	evr15	15</span>
<span class="cp">#define	evr16	16</span>
<span class="cp">#define	evr17	17</span>
<span class="cp">#define	evr18	18</span>
<span class="cp">#define	evr19	19</span>
<span class="cp">#define	evr20	20</span>
<span class="cp">#define	evr21	21</span>
<span class="cp">#define	evr22	22</span>
<span class="cp">#define	evr23	23</span>
<span class="cp">#define	evr24	24</span>
<span class="cp">#define	evr25	25</span>
<span class="cp">#define	evr26	26</span>
<span class="cp">#define	evr27	27</span>
<span class="cp">#define	evr28	28</span>
<span class="cp">#define	evr29	29</span>
<span class="cp">#define	evr30	30</span>
<span class="cp">#define	evr31	31</span>

<span class="cm">/* some stab codes */</span>
<span class="cp">#define N_FUN	36</span>
<span class="cp">#define N_RSYM	64</span>
<span class="cp">#define N_SLINE	68</span>
<span class="cp">#define N_SO	100</span>

<span class="cp">#endif </span><span class="cm">/*  __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_POWERPC_PPC_ASM_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
