<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › elf.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>elf.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_POWERPC_ELF_H</span>
<span class="cp">#define _ASM_POWERPC_ELF_H</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/sched.h&gt;	</span><span class="cm">/* for task_struct */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/string.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/cputable.h&gt;</span>
<span class="cp">#include &lt;asm/auxvec.h&gt;</span>

<span class="cm">/* PowerPC relocations defined by the ABIs */</span>
<span class="cp">#define R_PPC_NONE		0</span>
<span class="cp">#define R_PPC_ADDR32		1	</span><span class="cm">/* 32bit absolute address */</span><span class="cp"></span>
<span class="cp">#define R_PPC_ADDR24		2	</span><span class="cm">/* 26bit address, 2 bits ignored.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC_ADDR16		3	</span><span class="cm">/* 16bit absolute address */</span><span class="cp"></span>
<span class="cp">#define R_PPC_ADDR16_LO		4	</span><span class="cm">/* lower 16bit of absolute address */</span><span class="cp"></span>
<span class="cp">#define R_PPC_ADDR16_HI		5	</span><span class="cm">/* high 16bit of absolute address */</span><span class="cp"></span>
<span class="cp">#define R_PPC_ADDR16_HA		6	</span><span class="cm">/* adjusted high 16bit */</span><span class="cp"></span>
<span class="cp">#define R_PPC_ADDR14		7	</span><span class="cm">/* 16bit address, 2 bits ignored */</span><span class="cp"></span>
<span class="cp">#define R_PPC_ADDR14_BRTAKEN	8</span>
<span class="cp">#define R_PPC_ADDR14_BRNTAKEN	9</span>
<span class="cp">#define R_PPC_REL24		10	</span><span class="cm">/* PC relative 26 bit */</span><span class="cp"></span>
<span class="cp">#define R_PPC_REL14		11	</span><span class="cm">/* PC relative 16 bit */</span><span class="cp"></span>
<span class="cp">#define R_PPC_REL14_BRTAKEN	12</span>
<span class="cp">#define R_PPC_REL14_BRNTAKEN	13</span>
<span class="cp">#define R_PPC_GOT16		14</span>
<span class="cp">#define R_PPC_GOT16_LO		15</span>
<span class="cp">#define R_PPC_GOT16_HI		16</span>
<span class="cp">#define R_PPC_GOT16_HA		17</span>
<span class="cp">#define R_PPC_PLTREL24		18</span>
<span class="cp">#define R_PPC_COPY		19</span>
<span class="cp">#define R_PPC_GLOB_DAT		20</span>
<span class="cp">#define R_PPC_JMP_SLOT		21</span>
<span class="cp">#define R_PPC_RELATIVE		22</span>
<span class="cp">#define R_PPC_LOCAL24PC		23</span>
<span class="cp">#define R_PPC_UADDR32		24</span>
<span class="cp">#define R_PPC_UADDR16		25</span>
<span class="cp">#define R_PPC_REL32		26</span>
<span class="cp">#define R_PPC_PLT32		27</span>
<span class="cp">#define R_PPC_PLTREL32		28</span>
<span class="cp">#define R_PPC_PLT16_LO		29</span>
<span class="cp">#define R_PPC_PLT16_HI		30</span>
<span class="cp">#define R_PPC_PLT16_HA		31</span>
<span class="cp">#define R_PPC_SDAREL16		32</span>
<span class="cp">#define R_PPC_SECTOFF		33</span>
<span class="cp">#define R_PPC_SECTOFF_LO	34</span>
<span class="cp">#define R_PPC_SECTOFF_HI	35</span>
<span class="cp">#define R_PPC_SECTOFF_HA	36</span>

<span class="cm">/* PowerPC relocations defined for the TLS access ABI.  */</span>
<span class="cp">#define R_PPC_TLS		67 </span><span class="cm">/* none	(sym+add)@tls */</span><span class="cp"></span>
<span class="cp">#define R_PPC_DTPMOD32		68 </span><span class="cm">/* word32	(sym+add)@dtpmod */</span><span class="cp"></span>
<span class="cp">#define R_PPC_TPREL16		69 </span><span class="cm">/* half16*	(sym+add)@tprel */</span><span class="cp"></span>
<span class="cp">#define R_PPC_TPREL16_LO	70 </span><span class="cm">/* half16	(sym+add)@tprel@l */</span><span class="cp"></span>
<span class="cp">#define R_PPC_TPREL16_HI	71 </span><span class="cm">/* half16	(sym+add)@tprel@h */</span><span class="cp"></span>
<span class="cp">#define R_PPC_TPREL16_HA	72 </span><span class="cm">/* half16	(sym+add)@tprel@ha */</span><span class="cp"></span>
<span class="cp">#define R_PPC_TPREL32		73 </span><span class="cm">/* word32	(sym+add)@tprel */</span><span class="cp"></span>
<span class="cp">#define R_PPC_DTPREL16		74 </span><span class="cm">/* half16*	(sym+add)@dtprel */</span><span class="cp"></span>
<span class="cp">#define R_PPC_DTPREL16_LO	75 </span><span class="cm">/* half16	(sym+add)@dtprel@l */</span><span class="cp"></span>
<span class="cp">#define R_PPC_DTPREL16_HI	76 </span><span class="cm">/* half16	(sym+add)@dtprel@h */</span><span class="cp"></span>
<span class="cp">#define R_PPC_DTPREL16_HA	77 </span><span class="cm">/* half16	(sym+add)@dtprel@ha */</span><span class="cp"></span>
<span class="cp">#define R_PPC_DTPREL32		78 </span><span class="cm">/* word32	(sym+add)@dtprel */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_TLSGD16	79 </span><span class="cm">/* half16*	(sym+add)@got@tlsgd */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_TLSGD16_LO	80 </span><span class="cm">/* half16	(sym+add)@got@tlsgd@l */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_TLSGD16_HI	81 </span><span class="cm">/* half16	(sym+add)@got@tlsgd@h */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_TLSGD16_HA	82 </span><span class="cm">/* half16	(sym+add)@got@tlsgd@ha */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_TLSLD16	83 </span><span class="cm">/* half16*	(sym+add)@got@tlsld */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_TLSLD16_LO	84 </span><span class="cm">/* half16	(sym+add)@got@tlsld@l */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_TLSLD16_HI	85 </span><span class="cm">/* half16	(sym+add)@got@tlsld@h */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_TLSLD16_HA	86 </span><span class="cm">/* half16	(sym+add)@got@tlsld@ha */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_TPREL16	87 </span><span class="cm">/* half16*	(sym+add)@got@tprel */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_TPREL16_LO	88 </span><span class="cm">/* half16	(sym+add)@got@tprel@l */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_TPREL16_HI	89 </span><span class="cm">/* half16	(sym+add)@got@tprel@h */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_TPREL16_HA	90 </span><span class="cm">/* half16	(sym+add)@got@tprel@ha */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_DTPREL16	91 </span><span class="cm">/* half16*	(sym+add)@got@dtprel */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_DTPREL16_LO	92 </span><span class="cm">/* half16*	(sym+add)@got@dtprel@l */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_DTPREL16_HI	93 </span><span class="cm">/* half16*	(sym+add)@got@dtprel@h */</span><span class="cp"></span>
<span class="cp">#define R_PPC_GOT_DTPREL16_HA	94 </span><span class="cm">/* half16*	(sym+add)@got@dtprel@ha */</span><span class="cp"></span>

<span class="cm">/* keep this the last entry. */</span>
<span class="cp">#define R_PPC_NUM		95</span>

<span class="cm">/*</span>
<span class="cm"> * ELF register definitions..</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#define ELF_NGREG	48	</span><span class="cm">/* includes nip, msr, lr, etc. */</span><span class="cp"></span>
<span class="cp">#define ELF_NFPREG	33	</span><span class="cm">/* includes fpscr */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elf_greg_t64</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">elf_greg_t64</span> <span class="n">elf_gregset_t64</span><span class="p">[</span><span class="n">ELF_NGREG</span><span class="p">];</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">elf_greg_t32</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">elf_greg_t32</span> <span class="n">elf_gregset_t32</span><span class="p">[</span><span class="n">ELF_NGREG</span><span class="p">];</span>
<span class="k">typedef</span> <span class="n">elf_gregset_t32</span> <span class="n">compat_elf_gregset_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * ELF_ARCH, CLASS, and DATA are used to set parameters in the core dumps.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __powerpc64__</span>
<span class="cp"># define ELF_NVRREG32	33	</span><span class="cm">/* includes vscr &amp; vrsave stuffed together */</span><span class="cp"></span>
<span class="cp"># define ELF_NVRREG	34	</span><span class="cm">/* includes vscr &amp; vrsave in split vectors */</span><span class="cp"></span>
<span class="cp"># define ELF_NVSRHALFREG 32	</span><span class="cm">/* Half the vsx registers */</span><span class="cp"></span>
<span class="cp"># define ELF_GREG_TYPE	elf_greg_t64</span>
<span class="cp">#else</span>
<span class="cp"># define ELF_NEVRREG	34	</span><span class="cm">/* includes acc (as 2) */</span><span class="cp"></span>
<span class="cp"># define ELF_NVRREG	33	</span><span class="cm">/* includes vscr */</span><span class="cp"></span>
<span class="cp"># define ELF_GREG_TYPE	elf_greg_t32</span>
<span class="cp"># define ELF_ARCH	EM_PPC</span>
<span class="cp"># define ELF_CLASS	ELFCLASS32</span>
<span class="cp"># define ELF_DATA	ELFDATA2MSB</span>
<span class="cp">#endif </span><span class="cm">/* __powerpc64__ */</span><span class="cp"></span>

<span class="cp">#ifndef ELF_ARCH</span>
<span class="cp"># define ELF_ARCH	EM_PPC64</span>
<span class="cp"># define ELF_CLASS	ELFCLASS64</span>
<span class="cp"># define ELF_DATA	ELFDATA2MSB</span>
  <span class="k">typedef</span> <span class="n">elf_greg_t64</span> <span class="n">elf_greg_t</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">elf_gregset_t64</span> <span class="n">elf_gregset_t</span><span class="p">;</span>
<span class="cp">#else</span>
  <span class="cm">/* Assumption: ELF_ARCH == EM_PPC and ELF_CLASS == ELFCLASS32 */</span>
  <span class="k">typedef</span> <span class="n">elf_greg_t32</span> <span class="n">elf_greg_t</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">elf_gregset_t32</span> <span class="n">elf_gregset_t</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* ELF_ARCH */</span><span class="cp"></span>

<span class="cm">/* Floating point registers */</span>
<span class="k">typedef</span> <span class="kt">double</span> <span class="n">elf_fpreg_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">elf_fpreg_t</span> <span class="n">elf_fpregset_t</span><span class="p">[</span><span class="n">ELF_NFPREG</span><span class="p">];</span>

<span class="cm">/* Altivec registers */</span>
<span class="cm">/*</span>
<span class="cm"> * The entries with indexes 0-31 contain the corresponding vector registers. </span>
<span class="cm"> * The entry with index 32 contains the vscr as the last word (offset 12) </span>
<span class="cm"> * within the quadword.  This allows the vscr to be stored as either a </span>
<span class="cm"> * quadword (since it must be copied via a vector register to/from storage) </span>
<span class="cm"> * or as a word.  </span>
<span class="cm"> *</span>
<span class="cm"> * 64-bit kernel notes: The entry at index 33 contains the vrsave as the first  </span>
<span class="cm"> * word (offset 0) within the quadword.</span>
<span class="cm"> *</span>
<span class="cm"> * This definition of the VMX state is compatible with the current PPC32 </span>
<span class="cm"> * ptrace interface.  This allows signal handling and ptrace to use the same </span>
<span class="cm"> * structures.  This also simplifies the implementation of a bi-arch </span>
<span class="cm"> * (combined (32- and 64-bit) gdb.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that it&#39;s _not_ compatible with 32 bits ucontext which stuffs the</span>
<span class="cm"> * vrsave along with vscr and so only uses 33 vectors for the register set</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">__vector128</span> <span class="n">elf_vrreg_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">elf_vrreg_t</span> <span class="n">elf_vrregset_t</span><span class="p">[</span><span class="n">ELF_NVRREG</span><span class="p">];</span>
<span class="cp">#ifdef __powerpc64__</span>
<span class="k">typedef</span> <span class="n">elf_vrreg_t</span> <span class="n">elf_vrregset_t32</span><span class="p">[</span><span class="n">ELF_NVRREG32</span><span class="p">];</span>
<span class="k">typedef</span> <span class="n">elf_fpreg_t</span> <span class="n">elf_vsrreghalf_t32</span><span class="p">[</span><span class="n">ELF_NVSRHALFREG</span><span class="p">];</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cm">/*</span>
<span class="cm"> * This is used to ensure we don&#39;t load something for the wrong architecture.</span>
<span class="cm"> */</span>
<span class="cp">#define elf_check_arch(x) ((x)-&gt;e_machine == ELF_ARCH)</span>
<span class="cp">#define compat_elf_check_arch(x)	((x)-&gt;e_machine == EM_PPC)</span>

<span class="cp">#define CORE_DUMP_USE_REGSET</span>
<span class="cp">#define ELF_EXEC_PAGESIZE	PAGE_SIZE</span>

<span class="cm">/* This is the location that an ET_DYN program is loaded if exec&#39;ed.  Typical</span>
<span class="cm">   use of this is to invoke &quot;./ld.so someprog&quot; to test out a new version of</span>
<span class="cm">   the loader.  We need to make sure that it is out of the way of the program</span>
<span class="cm">   that it will &quot;exec&quot;, and that there is sufficient room for the brk.  */</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">randomize_et_dyn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">);</span>
<span class="cp">#define ELF_ET_DYN_BASE		(randomize_et_dyn(0x20000000))</span>

<span class="cm">/*</span>
<span class="cm"> * Our registers are always unsigned longs, whether we&#39;re a 32 bit</span>
<span class="cm"> * process or 64 bit, on either a 64 bit or 32 bit kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro relies on elf_regs[i] having the right type to truncate to,</span>
<span class="cm"> * either u32 or u64.  It defines the body of the elf_core_copy_regs</span>
<span class="cm"> * function, either the native one with elf_gregset_t elf_regs or</span>
<span class="cm"> * the 32-bit one with elf_gregset_t32 elf_regs.</span>
<span class="cm"> */</span>
<span class="cp">#define PPC_ELF_CORE_COPY_REGS(elf_regs, regs) \</span>
<span class="cp">	int i, nregs = min(sizeof(*regs) / sizeof(unsigned long), \</span>
<span class="cp">			   (size_t)ELF_NGREG);			  \</span>
<span class="cp">	for (i = 0; i &lt; nregs; i++) \</span>
<span class="cp">		elf_regs[i] = ((unsigned long *) regs)[i]; \</span>
<span class="cp">	memset(&amp;elf_regs[i], 0, (ELF_NGREG - i) * sizeof(elf_regs[0]))</span>

<span class="cm">/* Common routine for both 32-bit and 64-bit native processes */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ppc_elf_core_copy_regs</span><span class="p">(</span><span class="n">elf_gregset_t</span> <span class="n">elf_regs</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PPC_ELF_CORE_COPY_REGS</span><span class="p">(</span><span class="n">elf_regs</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define ELF_CORE_COPY_REGS(gregs, regs) ppc_elf_core_copy_regs(gregs, regs);</span>

<span class="k">typedef</span> <span class="n">elf_vrregset_t</span> <span class="n">elf_fpxregset_t</span><span class="p">;</span>

<span class="cm">/* ELF_HWCAP yields a mask that user programs can use to figure out what</span>
<span class="cm">   instruction set this cpu supports.  This could be done in userspace,</span>
<span class="cm">   but it&#39;s not easy, and we&#39;ve already done it here.  */</span>
<span class="cp"># define ELF_HWCAP	(cur_cpu_spec-&gt;cpu_user_features)</span>

<span class="cm">/* This yields a string that ld.so will use to load implementation</span>
<span class="cm">   specific libraries for optimization.  This is more specific in</span>
<span class="cm">   intent than poking at uname or /proc/cpuinfo.  */</span>

<span class="cp">#define ELF_PLATFORM	(cur_cpu_spec-&gt;platform)</span>

<span class="cm">/* While ELF_PLATFORM indicates the ISA supported by the platform, it</span>
<span class="cm"> * may not accurately reflect the underlying behavior of the hardware</span>
<span class="cm"> * (as in the case of running in Power5+ compatibility mode on a</span>
<span class="cm"> * Power6 machine).  ELF_BASE_PLATFORM allows ld.so to load libraries</span>
<span class="cm"> * that are tuned for the real hardware.</span>
<span class="cm"> */</span>
<span class="cp">#define ELF_BASE_PLATFORM (powerpc_base_platform)</span>

<span class="cp">#ifdef __powerpc64__</span>
<span class="cp"># define ELF_PLAT_INIT(_r, load_addr)	do {	\</span>
<span class="cp">	_r-&gt;gpr[2] = load_addr; 		\</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif </span><span class="cm">/* __powerpc64__ */</span><span class="cp"></span>

<span class="cp">#ifdef __powerpc64__</span>
<span class="cp"># define SET_PERSONALITY(ex)					\</span>
<span class="cp">do {								\</span>
<span class="cp">	if ((ex).e_ident[EI_CLASS] == ELFCLASS32)		\</span>
<span class="cp">		set_thread_flag(TIF_32BIT);			\</span>
<span class="cp">	else							\</span>
<span class="cp">		clear_thread_flag(TIF_32BIT);			\</span>
<span class="cp">	if (personality(current-&gt;personality) != PER_LINUX32)	\</span>
<span class="cp">		set_personality(PER_LINUX |			\</span>
<span class="cp">			(current-&gt;personality &amp; (~PER_MASK)));	\</span>
<span class="cp">} while (0)</span>
<span class="cm">/*</span>
<span class="cm"> * An executable for which elf_read_implies_exec() returns TRUE will</span>
<span class="cm"> * have the READ_IMPLIES_EXEC personality flag set automatically. This</span>
<span class="cm"> * is only required to work around bugs in old 32bit toolchains. Since</span>
<span class="cm"> * the 64bit ABI has never had these issues dont enable the workaround</span>
<span class="cm"> * even if we have an executable stack.</span>
<span class="cm"> */</span>
<span class="cp"># define elf_read_implies_exec(ex, exec_stk) (is_32bit_task() ? \</span>
<span class="cp">		(exec_stk == EXSTACK_DEFAULT) : 0)</span>
<span class="cp">#else </span>
<span class="cp"># define SET_PERSONALITY(ex) \</span>
<span class="cp">  set_personality(PER_LINUX | (current-&gt;personality &amp; (~PER_MASK)))</span>
<span class="cp"># define elf_read_implies_exec(ex, exec_stk) (exec_stk == EXSTACK_DEFAULT)</span>
<span class="cp">#endif </span><span class="cm">/* __powerpc64__ */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcache_bsize</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">icache_bsize</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ucache_bsize</span><span class="p">;</span>

<span class="cm">/* vDSO has arch_setup_additional_pages */</span>
<span class="cp">#define ARCH_HAS_SETUP_ADDITIONAL_PAGES</span>
<span class="k">struct</span> <span class="n">linux_binprm</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">arch_setup_additional_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">uses_interp</span><span class="p">);</span>
<span class="cp">#define VDSO_AUX_ENT(a,b) NEW_AUX_ENT(a,b)</span>

<span class="cm">/* 1GB for 64bit, 8MB for 32bit */</span>
<span class="cp">#define STACK_RND_MASK (is_32bit_task() ? \</span>
<span class="cp">	(0x7ff &gt;&gt; (PAGE_SHIFT - 12)) : \</span>
<span class="cp">	(0x3ffff &gt;&gt; (PAGE_SHIFT - 12)))</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arch_randomize_brk</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="cp">#define arch_randomize_brk arch_randomize_brk</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The requirements here are:</span>
<span class="cm"> * - keep the final alignment of sp (sp &amp; 0xf)</span>
<span class="cm"> * - make sure the 32-bit value at the first 16 byte aligned position of</span>
<span class="cm"> *   AUXV is greater than 16 for glibc compatibility.</span>
<span class="cm"> *   AT_IGNOREPPC is used for that.</span>
<span class="cm"> * - for compatibility with glibc ARCH_DLINFO must always be defined on PPC,</span>
<span class="cm"> *   even if DLINFO_ARCH_ITEMS goes to zero or is undefined.</span>
<span class="cm"> * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes</span>
<span class="cm"> */</span>
<span class="cp">#define ARCH_DLINFO							\</span>
<span class="cp">do {									\</span>
<span class="cp">	</span><span class="cm">/* Handle glibc compatibility. */</span><span class="cp">				\</span>
<span class="cp">	NEW_AUX_ENT(AT_IGNOREPPC, AT_IGNOREPPC);			\</span>
<span class="cp">	NEW_AUX_ENT(AT_IGNOREPPC, AT_IGNOREPPC);			\</span>
<span class="cp">	</span><span class="cm">/* Cache size items */</span><span class="cp">						\</span>
<span class="cp">	NEW_AUX_ENT(AT_DCACHEBSIZE, dcache_bsize);			\</span>
<span class="cp">	NEW_AUX_ENT(AT_ICACHEBSIZE, icache_bsize);			\</span>
<span class="cp">	NEW_AUX_ENT(AT_UCACHEBSIZE, ucache_bsize);			\</span>
<span class="cp">	VDSO_AUX_ENT(AT_SYSINFO_EHDR, current-&gt;mm-&gt;context.vdso_base);	\</span>
<span class="cp">} while (0)</span>

<span class="cm">/* PowerPC64 relocations defined by the ABIs */</span>
<span class="cp">#define R_PPC64_NONE    R_PPC_NONE</span>
<span class="cp">#define R_PPC64_ADDR32  R_PPC_ADDR32  </span><span class="cm">/* 32bit absolute address.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_ADDR24  R_PPC_ADDR24  </span><span class="cm">/* 26bit address, word aligned.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_ADDR16  R_PPC_ADDR16  </span><span class="cm">/* 16bit absolute address. */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_ADDR16_LO R_PPC_ADDR16_LO </span><span class="cm">/* lower 16bits of abs. address.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_ADDR16_HI R_PPC_ADDR16_HI </span><span class="cm">/* high 16bits of abs. address. */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_ADDR16_HA R_PPC_ADDR16_HA </span><span class="cm">/* adjusted high 16bits.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_ADDR14 R_PPC_ADDR14   </span><span class="cm">/* 16bit address, word aligned.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_ADDR14_BRTAKEN  R_PPC_ADDR14_BRTAKEN</span>
<span class="cp">#define R_PPC64_ADDR14_BRNTAKEN R_PPC_ADDR14_BRNTAKEN</span>
<span class="cp">#define R_PPC64_REL24   R_PPC_REL24 </span><span class="cm">/* PC relative 26 bit, word aligned.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_REL14   R_PPC_REL14 </span><span class="cm">/* PC relative 16 bit. */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_REL14_BRTAKEN   R_PPC_REL14_BRTAKEN</span>
<span class="cp">#define R_PPC64_REL14_BRNTAKEN  R_PPC_REL14_BRNTAKEN</span>
<span class="cp">#define R_PPC64_GOT16     R_PPC_GOT16</span>
<span class="cp">#define R_PPC64_GOT16_LO  R_PPC_GOT16_LO</span>
<span class="cp">#define R_PPC64_GOT16_HI  R_PPC_GOT16_HI</span>
<span class="cp">#define R_PPC64_GOT16_HA  R_PPC_GOT16_HA</span>

<span class="cp">#define R_PPC64_COPY      R_PPC_COPY</span>
<span class="cp">#define R_PPC64_GLOB_DAT  R_PPC_GLOB_DAT</span>
<span class="cp">#define R_PPC64_JMP_SLOT  R_PPC_JMP_SLOT</span>
<span class="cp">#define R_PPC64_RELATIVE  R_PPC_RELATIVE</span>

<span class="cp">#define R_PPC64_UADDR32   R_PPC_UADDR32</span>
<span class="cp">#define R_PPC64_UADDR16   R_PPC_UADDR16</span>
<span class="cp">#define R_PPC64_REL32     R_PPC_REL32</span>
<span class="cp">#define R_PPC64_PLT32     R_PPC_PLT32</span>
<span class="cp">#define R_PPC64_PLTREL32  R_PPC_PLTREL32</span>
<span class="cp">#define R_PPC64_PLT16_LO  R_PPC_PLT16_LO</span>
<span class="cp">#define R_PPC64_PLT16_HI  R_PPC_PLT16_HI</span>
<span class="cp">#define R_PPC64_PLT16_HA  R_PPC_PLT16_HA</span>

<span class="cp">#define R_PPC64_SECTOFF     R_PPC_SECTOFF</span>
<span class="cp">#define R_PPC64_SECTOFF_LO  R_PPC_SECTOFF_LO</span>
<span class="cp">#define R_PPC64_SECTOFF_HI  R_PPC_SECTOFF_HI</span>
<span class="cp">#define R_PPC64_SECTOFF_HA  R_PPC_SECTOFF_HA</span>
<span class="cp">#define R_PPC64_ADDR30          37  </span><span class="cm">/* word30 (S + A - P) &gt;&gt; 2.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_ADDR64          38  </span><span class="cm">/* doubleword64 S + A.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_ADDR16_HIGHER   39  </span><span class="cm">/* half16 #higher(S + A).  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_ADDR16_HIGHERA  40  </span><span class="cm">/* half16 #highera(S + A).  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_ADDR16_HIGHEST  41  </span><span class="cm">/* half16 #highest(S + A).  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_ADDR16_HIGHESTA 42  </span><span class="cm">/* half16 #highesta(S + A). */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_UADDR64     43  </span><span class="cm">/* doubleword64 S + A.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_REL64       44  </span><span class="cm">/* doubleword64 S + A - P.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_PLT64       45  </span><span class="cm">/* doubleword64 L + A.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_PLTREL64    46  </span><span class="cm">/* doubleword64 L + A - P.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TOC16       47  </span><span class="cm">/* half16* S + A - .TOC.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TOC16_LO    48  </span><span class="cm">/* half16 #lo(S + A - .TOC.).  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TOC16_HI    49  </span><span class="cm">/* half16 #hi(S + A - .TOC.).  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TOC16_HA    50  </span><span class="cm">/* half16 #ha(S + A - .TOC.).  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TOC         51  </span><span class="cm">/* doubleword64 .TOC. */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_PLTGOT16    52  </span><span class="cm">/* half16* M + A.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_PLTGOT16_LO 53  </span><span class="cm">/* half16 #lo(M + A).  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_PLTGOT16_HI 54  </span><span class="cm">/* half16 #hi(M + A).  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_PLTGOT16_HA 55  </span><span class="cm">/* half16 #ha(M + A).  */</span><span class="cp"></span>

<span class="cp">#define R_PPC64_ADDR16_DS      56 </span><span class="cm">/* half16ds* (S + A) &gt;&gt; 2.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_ADDR16_LO_DS   57 </span><span class="cm">/* half16ds  #lo(S + A) &gt;&gt; 2.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT16_DS       58 </span><span class="cm">/* half16ds* (G + A) &gt;&gt; 2.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT16_LO_DS    59 </span><span class="cm">/* half16ds  #lo(G + A) &gt;&gt; 2.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_PLT16_LO_DS    60 </span><span class="cm">/* half16ds  #lo(L + A) &gt;&gt; 2.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_SECTOFF_DS     61 </span><span class="cm">/* half16ds* (R + A) &gt;&gt; 2.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_SECTOFF_LO_DS  62 </span><span class="cm">/* half16ds  #lo(R + A) &gt;&gt; 2.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TOC16_DS       63 </span><span class="cm">/* half16ds* (S + A - .TOC.) &gt;&gt; 2.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TOC16_LO_DS    64 </span><span class="cm">/* half16ds  #lo(S + A - .TOC.) &gt;&gt; 2.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_PLTGOT16_DS    65 </span><span class="cm">/* half16ds* (M + A) &gt;&gt; 2.  */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_PLTGOT16_LO_DS 66 </span><span class="cm">/* half16ds  #lo(M + A) &gt;&gt; 2.  */</span><span class="cp"></span>

<span class="cm">/* PowerPC64 relocations defined for the TLS access ABI.  */</span>
<span class="cp">#define R_PPC64_TLS		67 </span><span class="cm">/* none	(sym+add)@tls */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_DTPMOD64	68 </span><span class="cm">/* doubleword64 (sym+add)@dtpmod */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TPREL16		69 </span><span class="cm">/* half16*	(sym+add)@tprel */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TPREL16_LO	70 </span><span class="cm">/* half16	(sym+add)@tprel@l */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TPREL16_HI	71 </span><span class="cm">/* half16	(sym+add)@tprel@h */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TPREL16_HA	72 </span><span class="cm">/* half16	(sym+add)@tprel@ha */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TPREL64		73 </span><span class="cm">/* doubleword64 (sym+add)@tprel */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_DTPREL16	74 </span><span class="cm">/* half16*	(sym+add)@dtprel */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_DTPREL16_LO	75 </span><span class="cm">/* half16	(sym+add)@dtprel@l */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_DTPREL16_HI	76 </span><span class="cm">/* half16	(sym+add)@dtprel@h */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_DTPREL16_HA	77 </span><span class="cm">/* half16	(sym+add)@dtprel@ha */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_DTPREL64	78 </span><span class="cm">/* doubleword64 (sym+add)@dtprel */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_TLSGD16	79 </span><span class="cm">/* half16*	(sym+add)@got@tlsgd */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_TLSGD16_LO	80 </span><span class="cm">/* half16	(sym+add)@got@tlsgd@l */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_TLSGD16_HI	81 </span><span class="cm">/* half16	(sym+add)@got@tlsgd@h */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_TLSGD16_HA	82 </span><span class="cm">/* half16	(sym+add)@got@tlsgd@ha */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_TLSLD16	83 </span><span class="cm">/* half16*	(sym+add)@got@tlsld */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_TLSLD16_LO	84 </span><span class="cm">/* half16	(sym+add)@got@tlsld@l */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_TLSLD16_HI	85 </span><span class="cm">/* half16	(sym+add)@got@tlsld@h */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_TLSLD16_HA	86 </span><span class="cm">/* half16	(sym+add)@got@tlsld@ha */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_TPREL16_DS	87 </span><span class="cm">/* half16ds*	(sym+add)@got@tprel */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_TPREL16_LO_DS 88 </span><span class="cm">/* half16ds (sym+add)@got@tprel@l */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_TPREL16_HI	89 </span><span class="cm">/* half16	(sym+add)@got@tprel@h */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_TPREL16_HA	90 </span><span class="cm">/* half16	(sym+add)@got@tprel@ha */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_DTPREL16_DS	91 </span><span class="cm">/* half16ds*	(sym+add)@got@dtprel */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_DTPREL16_LO_DS 92 </span><span class="cm">/* half16ds (sym+add)@got@dtprel@l */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_DTPREL16_HI	93 </span><span class="cm">/* half16	(sym+add)@got@dtprel@h */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_GOT_DTPREL16_HA	94 </span><span class="cm">/* half16	(sym+add)@got@dtprel@ha */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TPREL16_DS	95 </span><span class="cm">/* half16ds*	(sym+add)@tprel */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TPREL16_LO_DS	96 </span><span class="cm">/* half16ds	(sym+add)@tprel@l */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TPREL16_HIGHER	97 </span><span class="cm">/* half16	(sym+add)@tprel@higher */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TPREL16_HIGHERA	98 </span><span class="cm">/* half16	(sym+add)@tprel@highera */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TPREL16_HIGHEST	99 </span><span class="cm">/* half16	(sym+add)@tprel@highest */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_TPREL16_HIGHESTA 100 </span><span class="cm">/* half16	(sym+add)@tprel@highesta */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_DTPREL16_DS	101 </span><span class="cm">/* half16ds* (sym+add)@dtprel */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_DTPREL16_LO_DS	102 </span><span class="cm">/* half16ds	(sym+add)@dtprel@l */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_DTPREL16_HIGHER	103 </span><span class="cm">/* half16	(sym+add)@dtprel@higher */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_DTPREL16_HIGHERA 104 </span><span class="cm">/* half16	(sym+add)@dtprel@highera */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_DTPREL16_HIGHEST 105 </span><span class="cm">/* half16	(sym+add)@dtprel@highest */</span><span class="cp"></span>
<span class="cp">#define R_PPC64_DTPREL16_HIGHESTA 106 </span><span class="cm">/* half16	(sym+add)@dtprel@highesta */</span><span class="cp"></span>

<span class="cm">/* Keep this the last entry.  */</span>
<span class="cp">#define R_PPC64_NUM		107</span>

<span class="cm">/* There&#39;s actually a third entry here, but it&#39;s unused */</span>
<span class="k">struct</span> <span class="n">ppc64_opd_entry</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">funcaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r2</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef  __KERNEL__</span>

<span class="cp">#ifdef CONFIG_SPU_BASE</span>
<span class="cm">/* Notes used in ET_CORE. Note name is &quot;SPU/&lt;fd&gt;/&lt;filename&gt;&quot;. */</span>
<span class="cp">#define NT_SPU		1</span>

<span class="cp">#define ARCH_HAVE_EXTRA_ELF_NOTES</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SPU_BASE */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_POWERPC_ELF_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
