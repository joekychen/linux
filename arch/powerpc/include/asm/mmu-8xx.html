<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › include › asm › mmu-8xx.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>mmu-8xx.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_POWERPC_MMU_8XX_H_</span>
<span class="cp">#define _ASM_POWERPC_MMU_8XX_H_</span>
<span class="cm">/*</span>
<span class="cm"> * PPC8xx support</span>
<span class="cm"> */</span>

<span class="cm">/* Control/status registers for the MPC8xx.</span>
<span class="cm"> * A write operation to these registers causes serialized access.</span>
<span class="cm"> * During software tablewalk, the registers used perform mask/shift-add</span>
<span class="cm"> * operations when written/read.  A TLB entry is created when the Mx_RPN</span>
<span class="cm"> * is written, and the contents of several registers are used to</span>
<span class="cm"> * create the entry.</span>
<span class="cm"> */</span>
<span class="cp">#define SPRN_MI_CTR	784	</span><span class="cm">/* Instruction TLB control register */</span><span class="cp"></span>
<span class="cp">#define MI_GPM		0x80000000	</span><span class="cm">/* Set domain manager mode */</span><span class="cp"></span>
<span class="cp">#define MI_PPM		0x40000000	</span><span class="cm">/* Set subpage protection */</span><span class="cp"></span>
<span class="cp">#define MI_CIDEF	0x20000000	</span><span class="cm">/* Set cache inhibit when MMU dis */</span><span class="cp"></span>
<span class="cp">#define MI_RSV4I	0x08000000	</span><span class="cm">/* Reserve 4 TLB entries */</span><span class="cp"></span>
<span class="cp">#define MI_PPCS		0x02000000	</span><span class="cm">/* Use MI_RPN prob/priv state */</span><span class="cp"></span>
<span class="cp">#define MI_IDXMASK	0x00001f00	</span><span class="cm">/* TLB index to be loaded */</span><span class="cp"></span>
<span class="cp">#define MI_RESETVAL	0x00000000	</span><span class="cm">/* Value of register at reset */</span><span class="cp"></span>

<span class="cm">/* These are the Ks and Kp from the PowerPC books.  For proper operation,</span>
<span class="cm"> * Ks = 0, Kp = 1.</span>
<span class="cm"> */</span>
<span class="cp">#define SPRN_MI_AP	786</span>
<span class="cp">#define MI_Ks		0x80000000	</span><span class="cm">/* Should not be set */</span><span class="cp"></span>
<span class="cp">#define MI_Kp		0x40000000	</span><span class="cm">/* Should always be set */</span><span class="cp"></span>

<span class="cm">/* The effective page number register.  When read, contains the information</span>
<span class="cm"> * about the last instruction TLB miss.  When MI_RPN is written, bits in</span>
<span class="cm"> * this register are used to create the TLB entry.</span>
<span class="cm"> */</span>
<span class="cp">#define SPRN_MI_EPN	787</span>
<span class="cp">#define MI_EPNMASK	0xfffff000	</span><span class="cm">/* Effective page number for entry */</span><span class="cp"></span>
<span class="cp">#define MI_EVALID	0x00000200	</span><span class="cm">/* Entry is valid */</span><span class="cp"></span>
<span class="cp">#define MI_ASIDMASK	0x0000000f	</span><span class="cm">/* ASID match value */</span><span class="cp"></span>
					<span class="cm">/* Reset value is undefined */</span>

<span class="cm">/* A &quot;level 1&quot; or &quot;segment&quot; or whatever you want to call it register.</span>
<span class="cm"> * For the instruction TLB, it contains bits that get loaded into the</span>
<span class="cm"> * TLB entry when the MI_RPN is written.</span>
<span class="cm"> */</span>
<span class="cp">#define SPRN_MI_TWC	789</span>
<span class="cp">#define MI_APG		0x000001e0	</span><span class="cm">/* Access protection group (0) */</span><span class="cp"></span>
<span class="cp">#define MI_GUARDED	0x00000010	</span><span class="cm">/* Guarded storage */</span><span class="cp"></span>
<span class="cp">#define MI_PSMASK	0x0000000c	</span><span class="cm">/* Mask of page size bits */</span><span class="cp"></span>
<span class="cp">#define MI_PS8MEG	0x0000000c	</span><span class="cm">/* 8M page size */</span><span class="cp"></span>
<span class="cp">#define MI_PS512K	0x00000004	</span><span class="cm">/* 512K page size */</span><span class="cp"></span>
<span class="cp">#define MI_PS4K_16K	0x00000000	</span><span class="cm">/* 4K or 16K page size */</span><span class="cp"></span>
<span class="cp">#define MI_SVALID	0x00000001	</span><span class="cm">/* Segment entry is valid */</span><span class="cp"></span>
					<span class="cm">/* Reset value is undefined */</span>

<span class="cm">/* Real page number.  Defined by the pte.  Writing this register</span>
<span class="cm"> * causes a TLB entry to be created for the instruction TLB, using</span>
<span class="cm"> * additional information from the MI_EPN, and MI_TWC registers.</span>
<span class="cm"> */</span>
<span class="cp">#define SPRN_MI_RPN	790</span>

<span class="cm">/* Define an RPN value for mapping kernel memory to large virtual</span>
<span class="cm"> * pages for boot initialization.  This has real page number of 0,</span>
<span class="cm"> * large page size, shared page, cache enabled, and valid.</span>
<span class="cm"> * Also mark all subpages valid and write access.</span>
<span class="cm"> */</span>
<span class="cp">#define MI_BOOTINIT	0x000001fd</span>

<span class="cp">#define SPRN_MD_CTR	792	</span><span class="cm">/* Data TLB control register */</span><span class="cp"></span>
<span class="cp">#define MD_GPM		0x80000000	</span><span class="cm">/* Set domain manager mode */</span><span class="cp"></span>
<span class="cp">#define MD_PPM		0x40000000	</span><span class="cm">/* Set subpage protection */</span><span class="cp"></span>
<span class="cp">#define MD_CIDEF	0x20000000	</span><span class="cm">/* Set cache inhibit when MMU dis */</span><span class="cp"></span>
<span class="cp">#define MD_WTDEF	0x10000000	</span><span class="cm">/* Set writethrough when MMU dis */</span><span class="cp"></span>
<span class="cp">#define MD_RSV4I	0x08000000	</span><span class="cm">/* Reserve 4 TLB entries */</span><span class="cp"></span>
<span class="cp">#define MD_TWAM		0x04000000	</span><span class="cm">/* Use 4K page hardware assist */</span><span class="cp"></span>
<span class="cp">#define MD_PPCS		0x02000000	</span><span class="cm">/* Use MI_RPN prob/priv state */</span><span class="cp"></span>
<span class="cp">#define MD_IDXMASK	0x00001f00	</span><span class="cm">/* TLB index to be loaded */</span><span class="cp"></span>
<span class="cp">#define MD_RESETVAL	0x04000000	</span><span class="cm">/* Value of register at reset */</span><span class="cp"></span>

<span class="cp">#define SPRN_M_CASID	793	</span><span class="cm">/* Address space ID (context) to match */</span><span class="cp"></span>
<span class="cp">#define MC_ASIDMASK	0x0000000f	</span><span class="cm">/* Bits used for ASID value */</span><span class="cp"></span>


<span class="cm">/* These are the Ks and Kp from the PowerPC books.  For proper operation,</span>
<span class="cm"> * Ks = 0, Kp = 1.</span>
<span class="cm"> */</span>
<span class="cp">#define SPRN_MD_AP	794</span>
<span class="cp">#define MD_Ks		0x80000000	</span><span class="cm">/* Should not be set */</span><span class="cp"></span>
<span class="cp">#define MD_Kp		0x40000000	</span><span class="cm">/* Should always be set */</span><span class="cp"></span>

<span class="cm">/* The effective page number register.  When read, contains the information</span>
<span class="cm"> * about the last instruction TLB miss.  When MD_RPN is written, bits in</span>
<span class="cm"> * this register are used to create the TLB entry.</span>
<span class="cm"> */</span>
<span class="cp">#define SPRN_MD_EPN	795</span>
<span class="cp">#define MD_EPNMASK	0xfffff000	</span><span class="cm">/* Effective page number for entry */</span><span class="cp"></span>
<span class="cp">#define MD_EVALID	0x00000200	</span><span class="cm">/* Entry is valid */</span><span class="cp"></span>
<span class="cp">#define MD_ASIDMASK	0x0000000f	</span><span class="cm">/* ASID match value */</span><span class="cp"></span>
					<span class="cm">/* Reset value is undefined */</span>

<span class="cm">/* The pointer to the base address of the first level page table.</span>
<span class="cm"> * During a software tablewalk, reading this register provides the address</span>
<span class="cm"> * of the entry associated with MD_EPN.</span>
<span class="cm"> */</span>
<span class="cp">#define SPRN_M_TWB	796</span>
<span class="cp">#define	M_L1TB		0xfffff000	</span><span class="cm">/* Level 1 table base address */</span><span class="cp"></span>
<span class="cp">#define M_L1INDX	0x00000ffc	</span><span class="cm">/* Level 1 index, when read */</span><span class="cp"></span>
					<span class="cm">/* Reset value is undefined */</span>

<span class="cm">/* A &quot;level 1&quot; or &quot;segment&quot; or whatever you want to call it register.</span>
<span class="cm"> * For the data TLB, it contains bits that get loaded into the TLB entry</span>
<span class="cm"> * when the MD_RPN is written.  It is also provides the hardware assist</span>
<span class="cm"> * for finding the PTE address during software tablewalk.</span>
<span class="cm"> */</span>
<span class="cp">#define SPRN_MD_TWC	797</span>
<span class="cp">#define MD_L2TB		0xfffff000	</span><span class="cm">/* Level 2 table base address */</span><span class="cp"></span>
<span class="cp">#define MD_L2INDX	0xfffffe00	</span><span class="cm">/* Level 2 index (*pte), when read */</span><span class="cp"></span>
<span class="cp">#define MD_APG		0x000001e0	</span><span class="cm">/* Access protection group (0) */</span><span class="cp"></span>
<span class="cp">#define MD_GUARDED	0x00000010	</span><span class="cm">/* Guarded storage */</span><span class="cp"></span>
<span class="cp">#define MD_PSMASK	0x0000000c	</span><span class="cm">/* Mask of page size bits */</span><span class="cp"></span>
<span class="cp">#define MD_PS8MEG	0x0000000c	</span><span class="cm">/* 8M page size */</span><span class="cp"></span>
<span class="cp">#define MD_PS512K	0x00000004	</span><span class="cm">/* 512K page size */</span><span class="cp"></span>
<span class="cp">#define MD_PS4K_16K	0x00000000	</span><span class="cm">/* 4K or 16K page size */</span><span class="cp"></span>
<span class="cp">#define MD_WT		0x00000002	</span><span class="cm">/* Use writethrough page attribute */</span><span class="cp"></span>
<span class="cp">#define MD_SVALID	0x00000001	</span><span class="cm">/* Segment entry is valid */</span><span class="cp"></span>
					<span class="cm">/* Reset value is undefined */</span>


<span class="cm">/* Real page number.  Defined by the pte.  Writing this register</span>
<span class="cm"> * causes a TLB entry to be created for the data TLB, using</span>
<span class="cm"> * additional information from the MD_EPN, and MD_TWC registers.</span>
<span class="cm"> */</span>
<span class="cp">#define SPRN_MD_RPN	798</span>

<span class="cm">/* This is a temporary storage register that could be used to save</span>
<span class="cm"> * a processor working register during a tablewalk.</span>
<span class="cm"> */</span>
<span class="cp">#define SPRN_M_TW	799</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">active</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vdso_base</span><span class="p">;</span>
<span class="p">}</span> <span class="n">mm_context_t</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#define mmu_virtual_psize	MMU_PAGE_4K</span>
<span class="cp">#define mmu_linear_psize	MMU_PAGE_8M</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_POWERPC_MMU_8XX_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
