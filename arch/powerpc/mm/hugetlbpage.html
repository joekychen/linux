<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › mm › hugetlbpage.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hugetlbpage.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * PPC Huge TLB Page Support for Kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2003 David Gibson, IBM Corporation.</span>
<span class="cm"> * Copyright (C) 2011 Becky Bruce, Freescale Semiconductor</span>
<span class="cm"> *</span>
<span class="cm"> * Based on the IA-32 version:</span>
<span class="cm"> * Copyright (C) 2002, Rohit Seth &lt;rohit.seth@intel.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/of_fdt.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>

<span class="cp">#define PAGE_SHIFT_64K	16</span>
<span class="cp">#define PAGE_SHIFT_16M	24</span>
<span class="cp">#define PAGE_SHIFT_16G	34</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">HPAGE_SHIFT</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Tracks gpages after the device tree is scanned and before the</span>
<span class="cm"> * huge_boot_pages list is ready.  On non-Freescale implementations, this is</span>
<span class="cm"> * just used to track 16G pages and so is a single array.  FSL-based</span>
<span class="cm"> * implementations may have more than one gpage size, so we need multiple</span>
<span class="cm"> * arrays</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PPC_FSL_BOOK3E</span>
<span class="cp">#define MAX_NUMBER_GPAGES	128</span>
<span class="k">struct</span> <span class="n">psize_gpages</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">gpage_list</span><span class="p">[</span><span class="n">MAX_NUMBER_GPAGES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_gpages</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">psize_gpages</span> <span class="n">gpage_freearray</span><span class="p">[</span><span class="n">MMU_PAGE_COUNT</span><span class="p">];</span>
<span class="cp">#else</span>
<span class="cp">#define MAX_NUMBER_GPAGES	1024</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">gpage_freearray</span><span class="p">[</span><span class="n">MAX_NUMBER_GPAGES</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">nr_gpages</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">shift_to_mmu_psize</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">psize</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">psize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">psize</span> <span class="o">&lt;</span> <span class="n">MMU_PAGE_COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">psize</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">psize</span><span class="p">].</span><span class="n">shift</span> <span class="o">==</span> <span class="n">shift</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">psize</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mmu_psize_to_shift</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mmu_psize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">mmu_psize</span><span class="p">].</span><span class="n">shift</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">mmu_psize</span><span class="p">].</span><span class="n">shift</span><span class="p">;</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#define hugepd_none(hpd)	((hpd).pd == 0)</span>

<span class="n">pte_t</span> <span class="o">*</span><span class="nf">find_linux_pte_or_hugepte</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ea</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pu</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pm</span><span class="p">;</span>
	<span class="n">hugepd_t</span> <span class="o">*</span><span class="n">hpdp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">pdshift</span> <span class="o">=</span> <span class="n">PGDIR_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shift</span><span class="p">)</span>
		<span class="o">*</span><span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pg</span> <span class="o">=</span> <span class="n">pgdir</span> <span class="o">+</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">ea</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_hugepd</span><span class="p">(</span><span class="n">pg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hpdp</span> <span class="o">=</span> <span class="p">(</span><span class="n">hugepd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pdshift</span> <span class="o">=</span> <span class="n">PUD_SHIFT</span><span class="p">;</span>
		<span class="n">pu</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pg</span><span class="p">,</span> <span class="n">ea</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_hugepd</span><span class="p">(</span><span class="n">pu</span><span class="p">))</span>
			<span class="n">hpdp</span> <span class="o">=</span> <span class="p">(</span><span class="n">hugepd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pu</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pdshift</span> <span class="o">=</span> <span class="n">PMD_SHIFT</span><span class="p">;</span>
			<span class="n">pm</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pu</span><span class="p">,</span> <span class="n">ea</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_hugepd</span><span class="p">(</span><span class="n">pm</span><span class="p">))</span>
				<span class="n">hpdp</span> <span class="o">=</span> <span class="p">(</span><span class="n">hugepd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pm</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pm</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pm</span><span class="p">,</span> <span class="n">ea</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpdp</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shift</span><span class="p">)</span>
		<span class="o">*</span><span class="n">shift</span> <span class="o">=</span> <span class="n">hugepd_shift</span><span class="p">(</span><span class="o">*</span><span class="n">hpdp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">hugepte_offset</span><span class="p">(</span><span class="n">hpdp</span><span class="p">,</span> <span class="n">ea</span><span class="p">,</span> <span class="n">pdshift</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">find_linux_pte_or_hugepte</span><span class="p">);</span>

<span class="n">pte_t</span> <span class="o">*</span><span class="nf">huge_pte_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">find_linux_pte_or_hugepte</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__hugepte_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">hugepd_t</span> <span class="o">*</span><span class="n">hpdp</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">pdshift</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">pshift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC_FSL_BOOK3E</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_hugepd</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">pshift</span> <span class="o">-</span> <span class="n">pdshift</span><span class="p">);</span>
	<span class="n">cachep</span> <span class="o">=</span> <span class="n">hugepte_cache</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">cachep</span> <span class="o">=</span> <span class="n">PGT_CACHE</span><span class="p">(</span><span class="n">pdshift</span> <span class="o">-</span> <span class="n">pshift</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">__GFP_REPEAT</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pshift</span> <span class="o">&gt;</span> <span class="n">HUGEPD_SHIFT_MASK</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">new</span> <span class="o">&amp;</span> <span class="n">HUGEPD_SHIFT_MASK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PPC_FSL_BOOK3E</span>
	<span class="cm">/*</span>
<span class="cm">	 * We have multiple higher-level entries that point to the same</span>
<span class="cm">	 * actual pte location.  Fill in each as we go and backtrack on error.</span>
<span class="cm">	 * We need all of these so the DTLB pgtable walk code can find the</span>
<span class="cm">	 * right higher-level entry without knowing if it&#39;s a hugepage or not.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_hugepd</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">hpdp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">hugepd_none</span><span class="p">(</span><span class="o">*</span><span class="n">hpdp</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">hpdp</span><span class="o">-&gt;</span><span class="n">pd</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">new</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PD_HUGE</span><span class="p">)</span> <span class="o">|</span> <span class="n">pshift</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* If we bailed from the for loop early, an error occurred, clean up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_hugepd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">,</span> <span class="n">hpdp</span><span class="o">--</span><span class="p">)</span>
			<span class="n">hpdp</span><span class="o">-&gt;</span><span class="n">pd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hugepd_none</span><span class="p">(</span><span class="o">*</span><span class="n">hpdp</span><span class="p">))</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">hpdp</span><span class="o">-&gt;</span><span class="n">pd</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">new</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PD_HUGE</span><span class="p">)</span> <span class="o">|</span> <span class="n">pshift</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These macros define how to determine which level of the page table holds</span>
<span class="cm"> * the hpdp.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PPC_FSL_BOOK3E</span>
<span class="cp">#define HUGEPD_PGD_SHIFT PGDIR_SHIFT</span>
<span class="cp">#define HUGEPD_PUD_SHIFT PUD_SHIFT</span>
<span class="cp">#else</span>
<span class="cp">#define HUGEPD_PGD_SHIFT PUD_SHIFT</span>
<span class="cp">#define HUGEPD_PUD_SHIFT PMD_SHIFT</span>
<span class="cp">#endif</span>

<span class="n">pte_t</span> <span class="o">*</span><span class="nf">huge_pte_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pu</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pm</span><span class="p">;</span>
	<span class="n">hugepd_t</span> <span class="o">*</span><span class="n">hpdp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">pshift</span> <span class="o">=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">pdshift</span> <span class="o">=</span> <span class="n">PGDIR_SHIFT</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">sz</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">pg</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pshift</span> <span class="o">&gt;=</span> <span class="n">HUGEPD_PGD_SHIFT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hpdp</span> <span class="o">=</span> <span class="p">(</span><span class="n">hugepd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pdshift</span> <span class="o">=</span> <span class="n">PUD_SHIFT</span><span class="p">;</span>
		<span class="n">pu</span> <span class="o">=</span> <span class="n">pud_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pg</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pshift</span> <span class="o">&gt;=</span> <span class="n">HUGEPD_PUD_SHIFT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hpdp</span> <span class="o">=</span> <span class="p">(</span><span class="n">hugepd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pu</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pdshift</span> <span class="o">=</span> <span class="n">PMD_SHIFT</span><span class="p">;</span>
			<span class="n">pm</span> <span class="o">=</span> <span class="n">pmd_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pu</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="n">hpdp</span> <span class="o">=</span> <span class="p">(</span><span class="n">hugepd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pm</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpdp</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">hugepd_none</span><span class="p">(</span><span class="o">*</span><span class="n">hpdp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hugepd_ok</span><span class="p">(</span><span class="o">*</span><span class="n">hpdp</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hugepd_none</span><span class="p">(</span><span class="o">*</span><span class="n">hpdp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">__hugepte_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">hpdp</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pdshift</span><span class="p">,</span> <span class="n">pshift</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hugepte_offset</span><span class="p">(</span><span class="n">hpdp</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pdshift</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC_FSL_BOOK3E</span>
<span class="cm">/* Build list of addresses of gigantic pages.  This function is used in early</span>
<span class="cm"> * boot before the buddy or bootmem allocator is setup.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">add_gpage</span><span class="p">(</span><span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">page_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">number_of_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">shift_to_mmu_psize</span><span class="p">(</span><span class="n">__ffs</span><span class="p">(</span><span class="n">page_size</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">gpage_freearray</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">nr_gpages</span> <span class="o">=</span> <span class="n">number_of_pages</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">number_of_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gpage_freearray</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">gpage_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">page_size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Moves the gigantic page addresses from the temporary list to the</span>
<span class="cm"> * huge_boot_pages list.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">alloc_bootmem_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">hstate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">huge_bootmem_page</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">shift_to_mmu_psize</span><span class="p">(</span><span class="n">hstate</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">nr_gpages</span> <span class="o">=</span> <span class="n">gpage_freearray</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">nr_gpages</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_gpages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="cm">/*</span>
<span class="cm">	 * If gpages can be in highmem we can&#39;t use the trick of storing the</span>
<span class="cm">	 * data structure in the page; allocate space for this</span>
<span class="cm">	 */</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">huge_bootmem_page</span><span class="p">));</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">phys</span> <span class="o">=</span> <span class="n">gpage_freearray</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">gpage_list</span><span class="p">[</span><span class="o">--</span><span class="n">nr_gpages</span><span class="p">];</span>
<span class="cp">#else</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">gpage_freearray</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">gpage_list</span><span class="p">[</span><span class="o">--</span><span class="n">nr_gpages</span><span class="p">]);</span>
<span class="cp">#endif</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">huge_boot_pages</span><span class="p">);</span>
	<span class="n">gpage_freearray</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">nr_gpages</span> <span class="o">=</span> <span class="n">nr_gpages</span><span class="p">;</span>
	<span class="n">gpage_freearray</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">gpage_list</span><span class="p">[</span><span class="n">nr_gpages</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">hstate</span> <span class="o">=</span> <span class="n">hstate</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Scan the command line hugepagesz= options for gigantic pages; store those in</span>
<span class="cm"> * a list that we use to allocate the memory once all options are parsed.</span>
<span class="cm"> */</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpage_npages</span><span class="p">[</span><span class="n">MMU_PAGE_COUNT</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">do_gpage_early_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The hugepagesz and hugepages cmdline options are interleaved.  We</span>
<span class="cm">	 * use the size variable to keep track of whether or not this was done</span>
<span class="cm">	 * properly and skip over instances where it is incorrect.  Other</span>
<span class="cm">	 * command-line parsing code will issue warnings, so we don&#39;t need to.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">strcmp</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s">&quot;default_hugepagesz&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s">&quot;hugepagesz&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s">&quot;hugepages&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">npages</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">npages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">gpage_npages</span><span class="p">[</span><span class="n">shift_to_mmu_psize</span><span class="p">(</span><span class="n">__ffs</span><span class="p">(</span><span class="n">size</span><span class="p">))]</span> <span class="o">=</span> <span class="n">npages</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * This function allocates physical space for pages that are larger than the</span>
<span class="cm"> * buddy allocator can handle.  We want to allocate these in highmem because</span>
<span class="cm"> * the amount of lowmem is limited.  This means that this function MUST be</span>
<span class="cm"> * called before lowmem_end_addr is set up in MMU_init() in order for the lmb</span>
<span class="cm"> * allocate to grab highmem.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">reserve_hugetlb_gpages</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">__initdata</span> <span class="kt">char</span> <span class="n">cmdline</span><span class="p">[</span><span class="n">COMMAND_LINE_SIZE</span><span class="p">];</span>
	<span class="n">phys_addr_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">cmdline</span><span class="p">,</span> <span class="n">boot_command_line</span><span class="p">,</span> <span class="n">COMMAND_LINE_SIZE</span><span class="p">);</span>
	<span class="n">parse_args</span><span class="p">(</span><span class="s">&quot;hugetlb gpages&quot;</span><span class="p">,</span> <span class="n">cmdline</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">do_gpage_early_setup</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Walk gpage list in reverse, allocating larger page sizes first.</span>
<span class="cm">	 * Skip over unsupported sizes, or sizes that have 0 gpages allocated.</span>
<span class="cm">	 * When we reach the point in the list where pages are no longer</span>
<span class="cm">	 * considered gpages, we&#39;re done.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">MMU_PAGE_COUNT</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">shift</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">gpage_npages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mmu_psize_to_shift</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MAX_ORDER</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">phys_addr_t</span><span class="p">)(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">mmu_psize_to_shift</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">memblock_alloc_base</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="n">gpage_npages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">size</span><span class="p">,</span>
					   <span class="n">MEMBLOCK_ALLOC_ANYWHERE</span><span class="p">);</span>
		<span class="n">add_gpage</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">gpage_npages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !PPC_FSL_BOOK3E */</span><span class="cp"></span>

<span class="cm">/* Build list of addresses of gigantic pages.  This function is used in early</span>
<span class="cm"> * boot before the buddy or bootmem allocator is setup.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">add_gpage</span><span class="p">(</span><span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">page_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">number_of_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">number_of_pages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gpage_freearray</span><span class="p">[</span><span class="n">nr_gpages</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">nr_gpages</span><span class="o">++</span><span class="p">;</span>
		<span class="n">number_of_pages</span><span class="o">--</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">page_size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Moves the gigantic page addresses from the temporary list to the</span>
<span class="cm"> * huge_boot_pages list.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">alloc_bootmem_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">hstate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">huge_bootmem_page</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_gpages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">gpage_freearray</span><span class="p">[</span><span class="o">--</span><span class="n">nr_gpages</span><span class="p">]);</span>
	<span class="n">gpage_freearray</span><span class="p">[</span><span class="n">nr_gpages</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">huge_boot_pages</span><span class="p">);</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">hstate</span> <span class="o">=</span> <span class="n">hstate</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">huge_pmd_unshare</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC_FSL_BOOK3E</span>
<span class="cp">#define HUGEPD_FREELIST_SIZE \</span>
<span class="cp">	((PAGE_SIZE - sizeof(struct hugepd_freelist)) / sizeof(pte_t))</span>

<span class="k">struct</span> <span class="n">hugepd_freelist</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>	<span class="n">rcu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">hugepd_freelist</span> <span class="o">*</span><span class="p">,</span> <span class="n">hugepd_freelist_cur</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hugepd_free_rcu_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hugepd_freelist</span> <span class="o">*</span><span class="n">batch</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hugepd_freelist</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">batch</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">hugepte_cache</span><span class="p">,</span> <span class="n">batch</span><span class="o">-&gt;</span><span class="n">ptes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">batch</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hugepd_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hugepte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hugepd_freelist</span> <span class="o">**</span><span class="n">batchp</span><span class="p">;</span>

	<span class="n">batchp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">hugepd_freelist_cur</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span>
	    <span class="n">cpumask_equal</span><span class="p">(</span><span class="n">mm_cpumask</span><span class="p">(</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">),</span>
			  <span class="n">cpumask_of</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">())))</span> <span class="p">{</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">hugepte_cache</span><span class="p">,</span> <span class="n">hugepte</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">batchp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">batchp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hugepd_freelist</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">batchp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="o">*</span><span class="n">batchp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ptes</span><span class="p">[(</span><span class="o">*</span><span class="n">batchp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">hugepte</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">batchp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">HUGEPD_FREELIST_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">call_rcu_sched</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">batchp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">hugepd_free_rcu_callback</span><span class="p">);</span>
		<span class="o">*</span><span class="n">batchp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_hugepd_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span> <span class="n">hugepd_t</span> <span class="o">*</span><span class="n">hpdp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pdshift</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">floor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ceiling</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">hugepte</span> <span class="o">=</span> <span class="n">hugepd_page</span><span class="p">(</span><span class="o">*</span><span class="n">hpdp</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pdmask</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">pdshift</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_hugepd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC_FSL_BOOK3E</span>
	<span class="cm">/* Note: On fsl the hpdp may be the first of several */</span>
	<span class="n">num_hugepd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">hugepd_shift</span><span class="p">(</span><span class="o">*</span><span class="n">hpdp</span><span class="p">)</span> <span class="o">-</span> <span class="n">pdshift</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">hugepd_shift</span><span class="p">(</span><span class="o">*</span><span class="n">hpdp</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">start</span> <span class="o">&amp;=</span> <span class="n">pdmask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">floor</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ceiling</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ceiling</span> <span class="o">&amp;=</span> <span class="n">pdmask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">ceiling</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">ceiling</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_hugepd</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">hpdp</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hpdp</span><span class="o">-&gt;</span><span class="n">pd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tlb</span><span class="o">-&gt;</span><span class="n">need_flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC_FSL_BOOK3E</span>
	<span class="n">hugepd_free</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">hugepte</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">pgtable_free_tlb</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">hugepte</span><span class="p">,</span> <span class="n">pdshift</span> <span class="o">-</span> <span class="n">shift</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hugetlb_free_pmd_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">floor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ceiling</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pmd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PPC_FSL_BOOK3E</span>
		<span class="cm">/*</span>
<span class="cm">		 * Increment next by the size of the huge mapping since</span>
<span class="cm">		 * there may be more than one entry at this level for a</span>
<span class="cm">		 * single hugepage, but all of them point to</span>
<span class="cm">		 * the same kmem cache that holds the hugepte.</span>
<span class="cm">		 */</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hugepd_shift</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">hugepd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pmd</span><span class="p">));</span>
<span class="cp">#endif</span>
		<span class="n">free_hugepd_range</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="p">(</span><span class="n">hugepd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pmd</span><span class="p">,</span> <span class="n">PMD_SHIFT</span><span class="p">,</span>
				  <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">ceiling</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">start</span> <span class="o">&amp;=</span> <span class="n">PUD_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">floor</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ceiling</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ceiling</span> <span class="o">&amp;=</span> <span class="n">PUD_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ceiling</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">ceiling</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">pud_clear</span><span class="p">(</span><span class="n">pud</span><span class="p">);</span>
	<span class="n">pmd_free_tlb</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hugetlb_free_pud_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">floor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ceiling</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pud_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_hugepd</span><span class="p">(</span><span class="n">pud</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pud_none_or_clear_bad</span><span class="p">(</span><span class="n">pud</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">hugetlb_free_pmd_range</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span>
					       <span class="n">ceiling</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_PPC_FSL_BOOK3E</span>
			<span class="cm">/*</span>
<span class="cm">			 * Increment next by the size of the huge mapping since</span>
<span class="cm">			 * there may be more than one entry at this level for a</span>
<span class="cm">			 * single hugepage, but all of them point to</span>
<span class="cm">			 * the same kmem cache that holds the hugepte.</span>
<span class="cm">			 */</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hugepd_shift</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">hugepd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pud</span><span class="p">));</span>
<span class="cp">#endif</span>
			<span class="n">free_hugepd_range</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="p">(</span><span class="n">hugepd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pud</span><span class="p">,</span> <span class="n">PUD_SHIFT</span><span class="p">,</span>
					  <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">ceiling</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">start</span> <span class="o">&amp;=</span> <span class="n">PGDIR_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">floor</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ceiling</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ceiling</span> <span class="o">&amp;=</span> <span class="n">PGDIR_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ceiling</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">ceiling</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">pgd_clear</span><span class="p">(</span><span class="n">pgd</span><span class="p">);</span>
	<span class="n">pud_free_tlb</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function frees user-level page tables of a process.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with pagetable lock held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">hugetlb_free_pgd_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">floor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ceiling</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Because there are a number of different possible pagetable</span>
<span class="cm">	 * layouts for hugepage ranges, we limit knowledge of how</span>
<span class="cm">	 * things should be laid out to the allocation path</span>
<span class="cm">	 * (huge_pte_alloc(), above).  Everything else works out the</span>
<span class="cm">	 * structure as it goes from information in the hugepd</span>
<span class="cm">	 * pointers.  That means that we can&#39;t here use the</span>
<span class="cm">	 * optimization used in the normal page free_pgd_range(), of</span>
<span class="cm">	 * checking whether we&#39;re actually covering a large enough</span>
<span class="cm">	 * range to have to do anything at the top level of the walk</span>
<span class="cm">	 * instead of at the bottom.</span>
<span class="cm">	 *</span>
<span class="cm">	 * To make sense of this, you should probably go read the big</span>
<span class="cm">	 * block comment at the top of the normal free_pgd_range(),</span>
<span class="cm">	 * too.</span>
<span class="cm">	 */</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pgd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">tlb</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_hugepd</span><span class="p">(</span><span class="n">pgd</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none_or_clear_bad</span><span class="p">(</span><span class="n">pgd</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">hugetlb_free_pud_range</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">ceiling</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_PPC_FSL_BOOK3E</span>
			<span class="cm">/*</span>
<span class="cm">			 * Increment next by the size of the huge mapping since</span>
<span class="cm">			 * there may be more than one entry at the pgd level</span>
<span class="cm">			 * for a single hugepage, but all of them point to the</span>
<span class="cm">			 * same kmem cache that holds the hugepte.</span>
<span class="cm">			 */</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hugepd_shift</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">hugepd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pgd</span><span class="p">));</span>
<span class="cp">#endif</span>
			<span class="n">free_hugepd_range</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="p">(</span><span class="n">hugepd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pgd</span><span class="p">,</span> <span class="n">PGDIR_SHIFT</span><span class="p">,</span>
					  <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">ceiling</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">follow_huge_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">shift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">ptep</span> <span class="o">=</span> <span class="n">find_linux_pte_or_hugepte</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shift</span><span class="p">);</span>

	<span class="cm">/* Verify it is a huge page else bail. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptep</span> <span class="o">||</span> <span class="o">!</span><span class="n">shift</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">pte_page</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="n">page</span> <span class="o">+=</span> <span class="p">(</span><span class="n">address</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pmd_huge</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pud_huge</span><span class="p">(</span><span class="n">pud_t</span> <span class="n">pud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">follow_huge_pmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">gup_hugepte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sz</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte_end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">refs</span><span class="p">;</span>

	<span class="n">pte_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">sz</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">sz</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_end</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">pte_end</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">_PAGE_PRESENT</span> <span class="o">|</span> <span class="n">_PAGE_USER</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">_PAGE_RW</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* hugepages are never &quot;special&quot; */</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">pte_pfn</span><span class="p">(</span><span class="n">pte</span><span class="p">)));</span>

	<span class="n">refs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">pte_page</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sz</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">tail</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">compound_head</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
		<span class="n">pages</span><span class="p">[</span><span class="o">*</span><span class="n">nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">nr</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="n">page</span><span class="o">++</span><span class="p">;</span>
		<span class="n">refs</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_cache_add_speculative</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">refs</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">nr</span> <span class="o">-=</span> <span class="n">refs</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Could be optimized better */</span>
		<span class="o">*</span><span class="n">nr</span> <span class="o">-=</span> <span class="n">refs</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">refs</span><span class="o">--</span><span class="p">)</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Any tail page need their mapcount reference taken before we</span>
<span class="cm">	 * return.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">refs</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageTail</span><span class="p">(</span><span class="n">tail</span><span class="p">))</span>
			<span class="n">get_huge_page_tail</span><span class="p">(</span><span class="n">tail</span><span class="p">);</span>
		<span class="n">tail</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">hugepte_addr_end</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__boundary</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">sz</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">sz</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__boundary</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">__boundary</span> <span class="o">:</span> <span class="n">end</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">gup_hugepd</span><span class="p">(</span><span class="n">hugepd_t</span> <span class="o">*</span><span class="n">hugepd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">pdshift</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
	       <span class="kt">int</span> <span class="n">write</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">hugepd_shift</span><span class="p">(</span><span class="o">*</span><span class="n">hugepd</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">ptep</span> <span class="o">=</span> <span class="n">hugepte_offset</span><span class="p">(</span><span class="n">hugepd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pdshift</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">hugepte_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gup_hugepte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">nr</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ptep</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC_MM_SLICES</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">hugetlb_get_unmapped_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">hstate</span> <span class="o">=</span> <span class="n">hstate_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mmu_psize</span> <span class="o">=</span> <span class="n">shift_to_mmu_psize</span><span class="p">(</span><span class="n">huge_page_shift</span><span class="p">(</span><span class="n">hstate</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">slice_get_unmapped_area</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mmu_psize</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">vma_mmu_pagesize</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PPC_MM_SLICES</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">psize</span> <span class="o">=</span> <span class="n">get_slice_psize</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">mmu_psize_to_shift</span><span class="p">(</span><span class="n">psize</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">huge_page_size</span><span class="p">(</span><span class="n">hstate_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_power_of_4</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">__ilog2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="nb">false</span> <span class="o">:</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">add_huge_page_size</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mmu_psize</span><span class="p">;</span>

	<span class="cm">/* Check that it is a page size supported by the hardware and</span>
<span class="cm">	 * that it fits within pagetable and slice limits. */</span>
<span class="cp">#ifdef CONFIG_PPC_FSL_BOOK3E</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_power_of_4</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&gt;</span> <span class="n">SLICE_HIGH_SHIFT</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&lt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mmu_psize</span> <span class="o">=</span> <span class="n">shift_to_mmu_psize</span><span class="p">(</span><span class="n">shift</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SPU_FS_64K_LS</span>
	<span class="cm">/* Disable support for 64K huge pages when 64K SPU local store</span>
<span class="cm">	 * support is enabled as the current implementation conflicts.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shift</span> <span class="o">==</span> <span class="n">PAGE_SHIFT_64K</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SPU_FS_64K_LS */</span><span class="cp"></span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">mmu_psize</span><span class="p">].</span><span class="n">shift</span> <span class="o">!=</span> <span class="n">shift</span><span class="p">);</span>

	<span class="cm">/* Return if huge page size has already been setup */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size_to_hstate</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hugetlb_add_hstate</span><span class="p">(</span><span class="n">shift</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hugepage_setup_sz</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add_huge_page_size</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Invalid huge page size specified(%llu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;hugepagesz=&quot;</span><span class="p">,</span> <span class="n">hugepage_setup_sz</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC_FSL_BOOK3E</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">hugepte_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hugetlbpage_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">psize</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">psize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">psize</span> <span class="o">&lt;</span> <span class="n">MMU_PAGE_COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">psize</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">shift</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">psize</span><span class="p">].</span><span class="n">shift</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">shift</span> <span class="o">=</span> <span class="n">mmu_psize_to_shift</span><span class="p">(</span><span class="n">psize</span><span class="p">);</span>

		<span class="cm">/* Don&#39;t treat normal page sizes as huge... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shift</span> <span class="o">!=</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">add_huge_page_size</span><span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create a kmem cache for hugeptes.  The bottom bits in the pte have</span>
<span class="cm">	 * size information encoded in them, so align them to allow this</span>
<span class="cm">	 */</span>
	<span class="n">hugepte_cache</span> <span class="o">=</span>  <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;hugepte-cache&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">),</span>
					   <span class="n">HUGEPD_SHIFT_MASK</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hugepte_cache</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: Unable to create kmem cache for hugeptes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Default hpage size = 4M */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">MMU_PAGE_4M</span><span class="p">].</span><span class="n">shift</span><span class="p">)</span>
		<span class="n">HPAGE_SHIFT</span> <span class="o">=</span> <span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">MMU_PAGE_4M</span><span class="p">].</span><span class="n">shift</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: Unable to set default huge page size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>


	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hugetlbpage_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">psize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mmu_has_feature</span><span class="p">(</span><span class="n">MMU_FTR_16M_PAGE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">psize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">psize</span> <span class="o">&lt;</span> <span class="n">MMU_PAGE_COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">psize</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">shift</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">pdshift</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">psize</span><span class="p">].</span><span class="n">shift</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">shift</span> <span class="o">=</span> <span class="n">mmu_psize_to_shift</span><span class="p">(</span><span class="n">psize</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">add_huge_page_size</span><span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&lt;</span> <span class="n">PMD_SHIFT</span><span class="p">)</span>
			<span class="n">pdshift</span> <span class="o">=</span> <span class="n">PMD_SHIFT</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&lt;</span> <span class="n">PUD_SHIFT</span><span class="p">)</span>
			<span class="n">pdshift</span> <span class="o">=</span> <span class="n">PUD_SHIFT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pdshift</span> <span class="o">=</span> <span class="n">PGDIR_SHIFT</span><span class="p">;</span>

		<span class="n">pgtable_cache_add</span><span class="p">(</span><span class="n">pdshift</span> <span class="o">-</span> <span class="n">shift</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PGT_CACHE</span><span class="p">(</span><span class="n">pdshift</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;hugetlbpage_init(): could not create &quot;</span>
			      <span class="s">&quot;pgtable cache for %d bit pagesize</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set default large page size. Currently, we pick 16M or 1M</span>
<span class="cm">	 * depending on what is available</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">MMU_PAGE_16M</span><span class="p">].</span><span class="n">shift</span><span class="p">)</span>
		<span class="n">HPAGE_SHIFT</span> <span class="o">=</span> <span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">MMU_PAGE_16M</span><span class="p">].</span><span class="n">shift</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">MMU_PAGE_1M</span><span class="p">].</span><span class="n">shift</span><span class="p">)</span>
		<span class="n">HPAGE_SHIFT</span> <span class="o">=</span> <span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">MMU_PAGE_1M</span><span class="p">].</span><span class="n">shift</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">hugetlbpage_init</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">flush_dcache_icache_hugepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">));</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__flush_dcache_icache</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">i</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
			<span class="n">__flush_dcache_icache</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
