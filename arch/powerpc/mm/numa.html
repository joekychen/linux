<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › mm › numa.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>numa.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * pSeries NUMA support</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002 Anton Blanchard &lt;anton@au.ibm.com&gt;, IBM</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/mmzone.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/nodemask.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/pfn.h&gt;</span>
<span class="cp">#include &lt;linux/cpuset.h&gt;</span>
<span class="cp">#include &lt;linux/node.h&gt;</span>
<span class="cp">#include &lt;asm/sparsemem.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#include &lt;asm/firmware.h&gt;</span>
<span class="cp">#include &lt;asm/paca.h&gt;</span>
<span class="cp">#include &lt;asm/hvcall.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">numa_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmdline</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">numa_debug</span><span class="p">;</span>
<span class="cp">#define dbg(args...) if (numa_debug) { printk(KERN_INFO args); }</span>

<span class="kt">int</span> <span class="n">numa_cpu_lookup_table</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
<span class="n">cpumask_var_t</span> <span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">node_data</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">numa_cpu_lookup_table</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">node_to_cpumask_map</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">node_data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">min_common_depth</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">n_mem_addr_cells</span><span class="p">,</span> <span class="n">n_mem_size_cells</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">form1_affinity</span><span class="p">;</span>

<span class="cp">#define MAX_DISTANCE_REF_POINTS 4</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">distance_ref_points_depth</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">distance_ref_points</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">distance_lookup_table</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">][</span><span class="n">MAX_DISTANCE_REF_POINTS</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate node_to_cpumask_map based on number of available nodes</span>
<span class="cm"> * Requires node_possible_map to be valid.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: cpumask_of_node() is not valid until after this is done.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_node_to_cpumask_map</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* setup nr_node_ids if not done yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_node_ids</span> <span class="o">==</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node_possible_map</span><span class="p">)</span>
			<span class="n">num</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
		<span class="n">nr_node_ids</span> <span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* allocate the map */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">node</span> <span class="o">&lt;</span> <span class="n">nr_node_ids</span><span class="p">;</span> <span class="n">node</span><span class="o">++</span><span class="p">)</span>
		<span class="n">alloc_bootmem_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>

	<span class="cm">/* cpumask_of_node() will now work */</span>
	<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;Node to cpumask map for %d nodes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nr_node_ids</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">fake_numa_create_new_node</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">mem</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cmdline</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fake_nid</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">curr_boundary</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Modify node id, iff we started creating NUMA nodes</span>
<span class="cm">	 * We want to continue from where we left of the last time</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fake_nid</span><span class="p">)</span>
		<span class="o">*</span><span class="n">nid</span> <span class="o">=</span> <span class="n">fake_nid</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * In case there are no more arguments to parse, the</span>
<span class="cm">	 * node_id should be the same as the last fake node id</span>
<span class="cm">	 * (we&#39;ve handled this above).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mem</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">&lt;</span> <span class="n">curr_boundary</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">curr_boundary</span> <span class="o">=</span> <span class="n">mem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">end_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mem</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Skip commas and spaces</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39;\t&#39;</span><span class="p">)</span>
			<span class="n">p</span><span class="o">++</span><span class="p">;</span>

		<span class="n">cmdline</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">fake_nid</span><span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">nid</span> <span class="o">=</span> <span class="n">fake_nid</span><span class="p">;</span>
		<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;created new fake_node with id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fake_nid</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get_node_active_region - Return active region containing pfn</span>
<span class="cm"> * Active range returned is empty if none found.</span>
<span class="cm"> * @pfn: The page to return the region for</span>
<span class="cm"> * @node_ar: Returned set to the active region containing @pfn</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">get_node_active_region</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">node_active_region</span> <span class="o">*</span><span class="n">node_ar</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">for_each_mem_pfn_range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&gt;=</span> <span class="n">start_pfn</span> <span class="o">&amp;&amp;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">end_pfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">node_ar</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
			<span class="n">node_ar</span><span class="o">-&gt;</span><span class="n">start_pfn</span> <span class="o">=</span> <span class="n">start_pfn</span><span class="p">;</span>
			<span class="n">node_ar</span><span class="o">-&gt;</span><span class="n">end_pfn</span> <span class="o">=</span> <span class="n">end_pfn</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">map_cpu_to_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">numa_cpu_lookup_table</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;adding cpu %d to node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">node</span><span class="p">])))</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_HOTPLUG_CPU) || defined(CONFIG_PPC_SPLPAR)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unmap_cpu_from_node</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">numa_cpu_lookup_table</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;removing cpu %lu from node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">node</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;WARNING: cpu %lu not found in node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">cpu</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU || CONFIG_PPC_SPLPAR */</span><span class="cp"></span>

<span class="cm">/* must hold reference to node during call */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="nf">of_get_associativity</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ibm,associativity&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns the property linux,drconf-usable-memory if</span>
<span class="cm"> * it exists (the property exists only in kexec/kdump kernels,</span>
<span class="cm"> * added by kexec-tools)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="nf">of_get_usable_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">memory</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">prop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="s">&quot;linux,drconf-usable-memory&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">prop</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__node_distance</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">LOCAL_DISTANCE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">form1_affinity</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">distance</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">distance_ref_points_depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">distance_lookup_table</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">distance_lookup_table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Double the distance for each NUMA level */</span>
		<span class="n">distance</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">distance</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">initialize_distance_lookup_table</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">associativity</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">form1_affinity</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">distance_ref_points_depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">distance_lookup_table</span><span class="p">[</span><span class="n">nid</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">associativity</span><span class="p">[</span><span class="n">distance_ref_points</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Returns nid in the range [0..MAX_NUMNODES-1], or -1 if no useful numa</span>
<span class="cm"> * info is found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">associativity_to_nid</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">associativity</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">min_common_depth</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">associativity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_common_depth</span><span class="p">)</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">associativity</span><span class="p">[</span><span class="n">min_common_depth</span><span class="p">];</span>

	<span class="cm">/* POWER4 LPAR uses 0xffff as invalid node */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">==</span> <span class="mh">0xffff</span> <span class="o">||</span> <span class="n">nid</span> <span class="o">&gt;=</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">associativity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">distance_ref_points_depth</span><span class="p">)</span>
		<span class="n">initialize_distance_lookup_table</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">associativity</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns the nid associated with the given device tree node,</span>
<span class="cm"> * or -1 if not found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">of_node_to_nid_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">of_get_associativity</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">associativity_to_nid</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Walk the device tree upwards, looking for an associativity id */</span>
<span class="kt">int</span> <span class="nf">of_node_to_nid</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">of_node_get</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">of_node_to_nid_single</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	        <span class="n">tmp</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
		<span class="n">device</span> <span class="o">=</span> <span class="n">of_get_parent</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_node_to_nid</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">find_min_common_depth</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">chosen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vec5</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_OPAL</span><span class="p">))</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/ibm,opal&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/rtas&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This property is a set of 32-bit integers, each representing</span>
<span class="cm">	 * an index into the ibm,associativity nodes.</span>
<span class="cm">	 *</span>
<span class="cm">	 * With form 0 affinity the first integer is for an SMP configuration</span>
<span class="cm">	 * (should be all 0&#39;s) and the second is for a normal NUMA</span>
<span class="cm">	 * configuration. We have only one level of NUMA.</span>
<span class="cm">	 *</span>
<span class="cm">	 * With form 1 affinity the first integer is the most significant</span>
<span class="cm">	 * NUMA boundary and the following are progressively less significant</span>
<span class="cm">	 * boundaries. There can be more than one level of NUMA.</span>
<span class="cm">	 */</span>
	<span class="n">distance_ref_points</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">root</span><span class="p">,</span>
					<span class="s">&quot;ibm,associativity-reference-points&quot;</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">distance_ref_points_depth</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">distance_ref_points</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;NUMA: ibm,associativity-reference-points not found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">distance_ref_points_depth</span> <span class="o">/=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="cp">#define VEC5_AFFINITY_BYTE	5</span>
<span class="cp">#define VEC5_AFFINITY		0x80</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_OPAL</span><span class="p">))</span>
		<span class="n">form1_affinity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">chosen</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/chosen&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chosen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vec5</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">chosen</span><span class="p">,</span>
					       <span class="s">&quot;ibm,architecture-vec-5&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vec5</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vec5</span><span class="p">[</span><span class="n">VEC5_AFFINITY_BYTE</span><span class="p">]</span> <span class="o">&amp;</span>
							<span class="n">VEC5_AFFINITY</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;Using form 1 affinity</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">form1_affinity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">form1_affinity</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">depth</span> <span class="o">=</span> <span class="n">distance_ref_points</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">distance_ref_points_depth</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;NUMA: &quot;</span>
				<span class="s">&quot;short ibm,associativity-reference-points</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">depth</span> <span class="o">=</span> <span class="n">distance_ref_points</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Warn and cap if the hardware supports more than</span>
<span class="cm">	 * MAX_DISTANCE_REF_POINTS domains.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">distance_ref_points_depth</span> <span class="o">&gt;</span> <span class="n">MAX_DISTANCE_REF_POINTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;NUMA: distance array capped at &quot;</span>
			<span class="s">&quot;%d entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAX_DISTANCE_REF_POINTS</span><span class="p">);</span>
		<span class="n">distance_ref_points_depth</span> <span class="o">=</span> <span class="n">MAX_DISTANCE_REF_POINTS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">of_node_put</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">depth</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">get_n_mem_cells</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">n_addr_cells</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n_size_cells</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">memory</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memory</span> <span class="o">=</span> <span class="n">of_find_node_by_type</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memory</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;numa.c: No memory nodes found!&quot;</span><span class="p">);</span>

	<span class="o">*</span><span class="n">n_addr_cells</span> <span class="o">=</span> <span class="n">of_n_addr_cells</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span>
	<span class="o">*</span><span class="n">n_size_cells</span> <span class="o">=</span> <span class="n">of_n_size_cells</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">read_n_cells</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">**</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="o">**</span><span class="n">buf</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">of_drconf_cell</span> <span class="p">{</span>
	<span class="n">u64</span>	<span class="n">base_addr</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">drc_index</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">reserved</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">aa_index</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DRCONF_MEM_ASSIGNED	0x00000008</span>
<span class="cp">#define DRCONF_MEM_AI_INVALID	0x00000040</span>
<span class="cp">#define DRCONF_MEM_RESERVED	0x00000080</span>

<span class="cm">/*</span>
<span class="cm"> * Read the next memblock list entry from the ibm,dynamic-memory property</span>
<span class="cm"> * and return the information in the provided of_drconf_cell structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_drconf_cell</span><span class="p">(</span><span class="k">struct</span> <span class="n">of_drconf_cell</span> <span class="o">*</span><span class="n">drmem</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="o">**</span><span class="n">cellp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="n">drmem</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">read_n_cells</span><span class="p">(</span><span class="n">n_mem_addr_cells</span><span class="p">,</span> <span class="n">cellp</span><span class="p">);</span>

	<span class="n">cp</span> <span class="o">=</span> <span class="o">*</span><span class="n">cellp</span><span class="p">;</span>
	<span class="n">drmem</span><span class="o">-&gt;</span><span class="n">drc_index</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">drmem</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">drmem</span><span class="o">-&gt;</span><span class="n">aa_index</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">drmem</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="o">*</span><span class="n">cellp</span> <span class="o">=</span> <span class="n">cp</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Retrieve and validate the ibm,dynamic-memory property of the device tree.</span>
<span class="cm"> *</span>
<span class="cm"> * The layout of the ibm,dynamic-memory property is a number N of memblock</span>
<span class="cm"> * list entries followed by N memblock list entries.  Each memblock list entry</span>
<span class="cm"> * contains information as laid out in the of_drconf_cell struct above.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">of_get_drconf_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">memory</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="o">**</span><span class="n">dm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="n">entries</span><span class="p">;</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="s">&quot;ibm,dynamic-memory&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">entries</span> <span class="o">=</span> <span class="o">*</span><span class="n">prop</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Now that we know the number of entries, revalidate the size</span>
<span class="cm">	 * of the property read in to ensure we have everything</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">entries</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_mem_addr_cells</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">dm</span> <span class="o">=</span> <span class="n">prop</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">entries</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Retrieve and validate the ibm,lmb-size property for drconf memory</span>
<span class="cm"> * from the device tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">of_get_lmb_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">memory</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="s">&quot;ibm,lmb-size&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">read_n_cells</span><span class="p">(</span><span class="n">n_mem_size_cells</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prop</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">assoc_arrays</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">n_arrays</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">array_sz</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">arrays</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Retrieve and validate the list of associativity arrays for drconf</span>
<span class="cm"> * memory from the ibm,associativity-lookup-arrays property of the</span>
<span class="cm"> * device tree..</span>
<span class="cm"> *</span>
<span class="cm"> * The layout of the ibm,associativity-lookup-arrays property is a number N</span>
<span class="cm"> * indicating the number of associativity arrays, followed by a number M</span>
<span class="cm"> * indicating the size of each associativity array, followed by a list</span>
<span class="cm"> * of N associativity arrays.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">of_get_assoc_arrays</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">memory</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">assoc_arrays</span> <span class="o">*</span><span class="n">aa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="s">&quot;ibm,associativity-lookup-arrays&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">aa</span><span class="o">-&gt;</span><span class="n">n_arrays</span> <span class="o">=</span> <span class="o">*</span><span class="n">prop</span><span class="o">++</span><span class="p">;</span>
	<span class="n">aa</span><span class="o">-&gt;</span><span class="n">array_sz</span> <span class="o">=</span> <span class="o">*</span><span class="n">prop</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Now that we know the number of arrays and size of each array,</span>
<span class="cm">	 * revalidate the size of the property read in.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">aa</span><span class="o">-&gt;</span><span class="n">n_arrays</span> <span class="o">*</span> <span class="n">aa</span><span class="o">-&gt;</span><span class="n">array_sz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">aa</span><span class="o">-&gt;</span><span class="n">arrays</span> <span class="o">=</span> <span class="n">prop</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is like of_node_to_nid_single() for memory represented in the</span>
<span class="cm"> * ibm,dynamic-reconfiguration-memory node.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">of_drconf_to_nid_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">of_drconf_cell</span> <span class="o">*</span><span class="n">drmem</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">assoc_arrays</span> <span class="o">*</span><span class="n">aa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">default_nid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">default_nid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">min_common_depth</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">min_common_depth</span> <span class="o">&lt;=</span> <span class="n">aa</span><span class="o">-&gt;</span><span class="n">array_sz</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">drmem</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DRCONF_MEM_AI_INVALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">drmem</span><span class="o">-&gt;</span><span class="n">aa_index</span> <span class="o">&lt;</span> <span class="n">aa</span><span class="o">-&gt;</span><span class="n">n_arrays</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">drmem</span><span class="o">-&gt;</span><span class="n">aa_index</span> <span class="o">*</span> <span class="n">aa</span><span class="o">-&gt;</span><span class="n">array_sz</span> <span class="o">+</span> <span class="n">min_common_depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">aa</span><span class="o">-&gt;</span><span class="n">arrays</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">==</span> <span class="mh">0xffff</span> <span class="o">||</span> <span class="n">nid</span> <span class="o">&gt;=</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
			<span class="n">nid</span> <span class="o">=</span> <span class="n">default_nid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Figure out to which domain a cpu belongs and stick it there.</span>
<span class="cm"> * Return the id of the domain used.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">numa_setup_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">of_get_cpu_node</span><span class="p">(</span><span class="n">lcpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nid</span> <span class="o">=</span> <span class="n">of_node_to_nid_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">node_online</span><span class="p">(</span><span class="n">nid</span><span class="p">))</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">first_online_node</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">map_cpu_to_node</span><span class="p">(</span><span class="n">lcpu</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>

	<span class="n">of_node_put</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">cpu_numa_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lcpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE_FROZEN</span>:
		<span class="n">numa_setup_cpu</span><span class="p">(</span><span class="n">lcpu</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD_FROZEN</span>:
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED</span>:
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED_FROZEN</span>:
		<span class="n">unmap_cpu_from_node</span><span class="p">(</span><span class="n">lcpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check and possibly modify a memory region to enforce the memory limit.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the size the region should have to enforce the memory limit.</span>
<span class="cm"> * This will either be the original value of size, a truncated value,</span>
<span class="cm"> * or zero. If the returned value of size is 0 the region should be</span>
<span class="cm"> * discarded as it lies wholly above the memory limit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">numa_enforce_memory_limit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
						      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We use memblock_end_of_DRAM() in here instead of memory_limit because</span>
<span class="cm">	 * we&#39;ve already adjusted it for the limit and it takes care of</span>
<span class="cm">	 * having memory holes below the limit.  Also, in the case of</span>
<span class="cm">	 * iommu_is_off, memory_limit is not set but is implicitly enforced.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="n">memblock_end_of_DRAM</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">memblock_end_of_DRAM</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">memblock_end_of_DRAM</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reads the counter for a given entry in</span>
<span class="cm"> * linux,drconf-usable-memory property</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">read_usm_ranges</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="o">**</span><span class="n">usm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * For each lmb in ibm,dynamic-memory a corresponding</span>
<span class="cm">	 * entry in linux,drconf-usable-memory property contains</span>
<span class="cm">	 * a counter followed by that many (base, size) duple.</span>
<span class="cm">	 * read the counter from linux,drconf-usable-memory</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">read_n_cells</span><span class="p">(</span><span class="n">n_mem_size_cells</span><span class="p">,</span> <span class="n">usm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Extract NUMA information from the ibm,dynamic-reconfiguration-memory</span>
<span class="cm"> * node.  This assumes n_mem_{addr,size}_cells have been set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">parse_drconf_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">memory</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">dm</span><span class="p">),</span> <span class="o">*</span><span class="n">usm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">ranges</span><span class="p">,</span> <span class="n">is_kexec_kdump</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lmb_size</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">sz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">assoc_arrays</span> <span class="n">aa</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">of_get_drconf_memory</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">lmb_size</span> <span class="o">=</span> <span class="n">of_get_lmb_size</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lmb_size</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">of_get_assoc_arrays</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* check if this is a kexec/kdump kernel */</span>
	<span class="n">usm</span> <span class="o">=</span> <span class="n">of_get_usable_memory</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usm</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">is_kexec_kdump</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">of_drconf_cell</span> <span class="n">drmem</span><span class="p">;</span>

		<span class="n">read_drconf_cell</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drmem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dm</span><span class="p">);</span>

		<span class="cm">/* skip this block if the reserved bit is set in flags (0x80)</span>
<span class="cm">		   or if the block is not assigned to this partition (0x8) */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">drmem</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DRCONF_MEM_RESERVED</span><span class="p">)</span>
		    <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">drmem</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DRCONF_MEM_ASSIGNED</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">base</span> <span class="o">=</span> <span class="n">drmem</span><span class="p">.</span><span class="n">base_addr</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">lmb_size</span><span class="p">;</span>
		<span class="n">ranges</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_kexec_kdump</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ranges</span> <span class="o">=</span> <span class="n">read_usm_ranges</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ranges</span><span class="p">)</span> <span class="cm">/* there are no (base, size) duple */</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_kexec_kdump</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">base</span> <span class="o">=</span> <span class="n">read_n_cells</span><span class="p">(</span><span class="n">n_mem_addr_cells</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usm</span><span class="p">);</span>
				<span class="n">size</span> <span class="o">=</span> <span class="n">read_n_cells</span><span class="p">(</span><span class="n">n_mem_size_cells</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usm</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">nid</span> <span class="o">=</span> <span class="n">of_drconf_to_nid_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drmem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aa</span><span class="p">);</span>
			<span class="n">fake_numa_create_new_node</span><span class="p">(</span>
				<span class="p">((</span><span class="n">base</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span>
					   <span class="o">&amp;</span><span class="n">nid</span><span class="p">);</span>
			<span class="n">node_set_online</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
			<span class="n">sz</span> <span class="o">=</span> <span class="n">numa_enforce_memory_limit</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sz</span><span class="p">)</span>
				<span class="n">memblock_set_node</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">ranges</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parse_numa_properties</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">memory</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">default_nid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">numa_enabled</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;NUMA disabled by user</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">min_common_depth</span> <span class="o">=</span> <span class="n">find_min_common_depth</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">min_common_depth</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">min_common_depth</span><span class="p">;</span>

	<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;NUMA associativity depth for CPU/Memory: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">min_common_depth</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Even though we connect cpus to numa domains later in SMP</span>
<span class="cm">	 * init, we need to know the node ids now. This is because</span>
<span class="cm">	 * each node to be onlined must have NODE_DATA etc backing it.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">cpu</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

		<span class="n">cpu</span> <span class="o">=</span> <span class="n">of_get_cpu_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">of_node_to_nid_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t fall back to default_nid yet -- we will plug</span>
<span class="cm">		 * cpus into nodes once the memory scan has discovered</span>
<span class="cm">		 * the topology.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">node_set_online</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">get_n_mem_cells</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_mem_addr_cells</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n_mem_size_cells</span><span class="p">);</span>

	<span class="n">for_each_node_by_type</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ranges</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">memcell_buf</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">memcell_buf</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span>
			<span class="s">&quot;linux,usable-memory&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcell_buf</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">memcell_buf</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcell_buf</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* ranges in cell */</span>
		<span class="n">ranges</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_mem_addr_cells</span> <span class="o">+</span> <span class="n">n_mem_size_cells</span><span class="p">);</span>
<span class="nl">new_range:</span>
		<span class="cm">/* these are order-sensitive, and modify the buffer pointer */</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">read_n_cells</span><span class="p">(</span><span class="n">n_mem_addr_cells</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memcell_buf</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">read_n_cells</span><span class="p">(</span><span class="n">n_mem_size_cells</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memcell_buf</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Assumption: either all memory nodes or none will</span>
<span class="cm">		 * have associativity properties.  If none, then</span>
<span class="cm">		 * everything goes to default_nid.</span>
<span class="cm">		 */</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">of_node_to_nid_single</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">nid</span> <span class="o">=</span> <span class="n">default_nid</span><span class="p">;</span>

		<span class="n">fake_numa_create_new_node</span><span class="p">(((</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">nid</span><span class="p">);</span>
		<span class="n">node_set_online</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="n">numa_enforce_memory_limit</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ranges</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">new_range</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memblock_set_node</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ranges</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">new_range</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now do the same thing for each MEMBLOCK listed in the</span>
<span class="cm">	 * ibm,dynamic-memory property in the</span>
<span class="cm">	 * ibm,dynamic-reconfiguration-memory node.</span>
<span class="cm">	 */</span>
	<span class="n">memory</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/ibm,dynamic-reconfiguration-memory&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memory</span><span class="p">)</span>
		<span class="n">parse_drconf_memory</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_nonnuma</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">top_of_ram</span> <span class="o">=</span> <span class="n">memblock_end_of_DRAM</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_ram</span> <span class="o">=</span> <span class="n">memblock_phys_mem_size</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Top of RAM: 0x%lx, Total RAM: 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">top_of_ram</span><span class="p">,</span> <span class="n">total_ram</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Memory hole size: %ldMB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">top_of_ram</span> <span class="o">-</span> <span class="n">total_ram</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>

	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_pfn</span> <span class="o">=</span> <span class="n">memblock_region_memory_base_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">end_pfn</span> <span class="o">=</span> <span class="n">memblock_region_memory_end_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

		<span class="n">fake_numa_create_new_node</span><span class="p">(</span><span class="n">end_pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nid</span><span class="p">);</span>
		<span class="n">memblock_set_node</span><span class="p">(</span><span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">start_pfn</span><span class="p">),</span>
				  <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">end_pfn</span> <span class="o">-</span> <span class="n">start_pfn</span><span class="p">),</span> <span class="n">nid</span><span class="p">);</span>
		<span class="n">node_set_online</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">dump_numa_cpu_topology</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">min_common_depth</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">numa_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Node %d CPUs:&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we used a CPU iterator here we would miss printing</span>
<span class="cm">		 * the holes in the cpumap.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">;</span> <span class="n">cpu</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span>
					<span class="n">node_to_cpumask_map</span><span class="p">[</span><span class="n">node</span><span class="p">]))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %u&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
				<span class="o">++</span><span class="n">count</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-%u&quot;</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-%u&quot;</span><span class="p">,</span> <span class="n">nr_cpu_ids</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">dump_numa_memory_topology</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">min_common_depth</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">numa_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Node %d Memory:&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">memblock_end_of_DRAM</span><span class="p">();</span>
		     <span class="n">i</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SECTION_SIZE_BITS</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">early_pfn_to_nid</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">==</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot; 0x%lx&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="o">++</span><span class="n">count</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-0x%lx&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-0x%lx&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate some memory, satisfying the memblock or bootmem allocator where</span>
<span class="cm"> * required. nid is the preferred node and end is the physical address of</span>
<span class="cm"> * the highest address in the node.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the virtual address of the memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="o">*</span><span class="nf">careful_zallocation</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_nid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret_paddr</span><span class="p">;</span>

	<span class="n">ret_paddr</span> <span class="o">=</span> <span class="n">__memblock_alloc_base</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">end_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="cm">/* retry over all memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_paddr</span><span class="p">)</span>
		<span class="n">ret_paddr</span> <span class="o">=</span> <span class="n">__memblock_alloc_base</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">memblock_end_of_DRAM</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_paddr</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;numa.c: cannot allocate %lu bytes for node %d&quot;</span><span class="p">,</span>
		      <span class="n">size</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">ret_paddr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We initialize the nodes in numeric order: 0, 1, 2...</span>
<span class="cm">	 * and hand over control from the MEMBLOCK allocator to the</span>
<span class="cm">	 * bootmem allocator.  If this function is called for</span>
<span class="cm">	 * node 5, then we know that all nodes &lt;5 are using the</span>
<span class="cm">	 * bootmem allocator instead of the MEMBLOCK allocator.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So, check the nid from which this allocation came</span>
<span class="cm">	 * and double check to see if we need to use bootmem</span>
<span class="cm">	 * instead of the MEMBLOCK.  We don&#39;t free the MEMBLOCK memory</span>
<span class="cm">	 * since it would be useless.</span>
<span class="cm">	 */</span>
	<span class="n">new_nid</span> <span class="o">=</span> <span class="n">early_pfn_to_nid</span><span class="p">(</span><span class="n">ret_paddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_nid</span> <span class="o">&lt;</span> <span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__alloc_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">new_nid</span><span class="p">),</span>
				<span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;alloc_bootmem %p %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">__cpuinitdata</span> <span class="n">ppc64_numa_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">cpu_numa_callback</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">1</span> <span class="cm">/* Must run before sched domains notifier. */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">mark_reserved_regions_for_nid</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>

	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">reserved</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">physbase</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span> <span class="o">=</span> <span class="n">physbase</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">physbase</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">node_active_region</span> <span class="n">node_ar</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_end_pfn</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">+</span>
					     <span class="n">node</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check to make sure that this memblock.reserved area is</span>
<span class="cm">		 * within the bounds of the node that we care about.</span>
<span class="cm">		 * Checking the nid of the start and end points is not</span>
<span class="cm">		 * sufficient because the reserved area could span the</span>
<span class="cm">		 * entire node.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end_pfn</span> <span class="o">&lt;=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">||</span>
		    <span class="n">start_pfn</span> <span class="o">&gt;=</span> <span class="n">node_end_pfn</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">get_node_active_region</span><span class="p">(</span><span class="n">start_pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_ar</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">start_pfn</span> <span class="o">&lt;</span> <span class="n">end_pfn</span> <span class="o">&amp;&amp;</span>
			<span class="n">node_ar</span><span class="p">.</span><span class="n">start_pfn</span> <span class="o">&lt;</span> <span class="n">node_ar</span><span class="p">.</span><span class="n">end_pfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reserve_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * if reserved region extends past active region</span>
<span class="cm">			 * then trim size to active region</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end_pfn</span> <span class="o">&gt;</span> <span class="n">node_ar</span><span class="p">.</span><span class="n">end_pfn</span><span class="p">)</span>
				<span class="n">reserve_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">node_ar</span><span class="p">.</span><span class="n">end_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span>
					<span class="o">-</span> <span class="n">physbase</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Only worry about *this* node, others may not</span>
<span class="cm">			 * yet have valid NODE_DATA().</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">node_ar</span><span class="p">.</span><span class="n">nid</span> <span class="o">==</span> <span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;reserve_bootmem %lx %lx nid=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">physbase</span><span class="p">,</span> <span class="n">reserve_size</span><span class="p">,</span> <span class="n">node_ar</span><span class="p">.</span><span class="n">nid</span><span class="p">);</span>
				<span class="n">reserve_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">node_ar</span><span class="p">.</span><span class="n">nid</span><span class="p">),</span>
						<span class="n">physbase</span><span class="p">,</span> <span class="n">reserve_size</span><span class="p">,</span>
						<span class="n">BOOTMEM_DEFAULT</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * if reserved region is contained in the active region</span>
<span class="cm">			 * then done.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end_pfn</span> <span class="o">&lt;=</span> <span class="n">node_ar</span><span class="p">.</span><span class="n">end_pfn</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * reserved region extends past the active region</span>
<span class="cm">			 *   get next active region that contains this</span>
<span class="cm">			 *   reserved region</span>
<span class="cm">			 */</span>
			<span class="n">start_pfn</span> <span class="o">=</span> <span class="n">node_ar</span><span class="p">.</span><span class="n">end_pfn</span><span class="p">;</span>
			<span class="n">physbase</span> <span class="o">=</span> <span class="n">start_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">reserve_size</span><span class="p">;</span>
			<span class="n">get_node_active_region</span><span class="p">(</span><span class="n">start_pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_ar</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">__init</span> <span class="nf">do_init_bootmem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">min_low_pfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">max_low_pfn</span> <span class="o">=</span> <span class="n">memblock_end_of_DRAM</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">max_pfn</span> <span class="o">=</span> <span class="n">max_low_pfn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parse_numa_properties</span><span class="p">())</span>
		<span class="n">setup_nonnuma</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">dump_numa_memory_topology</span><span class="p">();</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">bootmem_vaddr</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bootmap_pages</span><span class="p">;</span>

		<span class="n">get_pfn_range_for_nid</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_pfn</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Allocate the node structure node local if possible</span>
<span class="cm">		 *</span>
<span class="cm">		 * Be careful moving this around, as it relies on all</span>
<span class="cm">		 * previous nodes&#39; bootmem to be initialized and have</span>
<span class="cm">		 * all reserved areas marked.</span>
<span class="cm">		 */</span>
		<span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="o">=</span> <span class="n">careful_zallocation</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pglist_data</span><span class="p">),</span>
					<span class="n">SMP_CACHE_BYTES</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">);</span>

  		<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;NODE_DATA() = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">));</span>

		<span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bootmem_node_data</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>
		<span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">=</span> <span class="n">start_pfn</span><span class="p">;</span>
		<span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span> <span class="o">=</span> <span class="n">end_pfn</span> <span class="o">-</span> <span class="n">start_pfn</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  			<span class="k">continue</span><span class="p">;</span>

  		<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;start_paddr = %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
  		<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;end_paddr = %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">end_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

		<span class="n">bootmap_pages</span> <span class="o">=</span> <span class="n">bootmem_bootmap_pages</span><span class="p">(</span><span class="n">end_pfn</span> <span class="o">-</span> <span class="n">start_pfn</span><span class="p">);</span>
		<span class="n">bootmem_vaddr</span> <span class="o">=</span> <span class="n">careful_zallocation</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span>
					<span class="n">bootmap_pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
					<span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">);</span>

		<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;bootmap_vaddr = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bootmem_vaddr</span><span class="p">);</span>

		<span class="n">init_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span>
				  <span class="n">__pa</span><span class="p">(</span><span class="n">bootmem_vaddr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
				  <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">);</span>

		<span class="n">free_bootmem_with_active_regions</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Be very careful about moving this around.  Future</span>
<span class="cm">		 * calls to careful_zallocation() depend on this getting</span>
<span class="cm">		 * done correctly.</span>
<span class="cm">		 */</span>
		<span class="n">mark_reserved_regions_for_nid</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
		<span class="n">sparse_memory_present_with_active_regions</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">init_bootmem_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now bootmem is initialised we can create the node to cpumask</span>
<span class="cm">	 * lookup tables and setup the cpu callback to populate them.</span>
<span class="cm">	 */</span>
	<span class="n">setup_node_to_cpumask_map</span><span class="p">();</span>

	<span class="n">register_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppc64_numa_nb</span><span class="p">);</span>
	<span class="n">cpu_numa_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppc64_numa_nb</span><span class="p">,</span> <span class="n">CPU_UP_PREPARE</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">boot_cpuid</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">paging_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">max_zone_pfns</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">max_zone_pfns</span><span class="p">));</span>
	<span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">ZONE_DMA</span><span class="p">]</span> <span class="o">=</span> <span class="n">memblock_end_of_DRAM</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">free_area_init_nodes</span><span class="p">(</span><span class="n">max_zone_pfns</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_numa</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">))</span>
		<span class="n">numa_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;debug&quot;</span><span class="p">))</span>
		<span class="n">numa_debug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;fake=&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="n">cmdline</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;fake=&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;numa&quot;</span><span class="p">,</span> <span class="n">early_numa</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MEMORY_HOTPLUG</span>
<span class="cm">/*</span>
<span class="cm"> * Find the node associated with a hot added memory section for</span>
<span class="cm"> * memory represented in the device tree by the property</span>
<span class="cm"> * ibm,dynamic-reconfiguration-memory/ibm,dynamic-memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hot_add_drconf_scn_to_nid</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">memory</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scn_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">dm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drconf_cell_cnt</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lmb_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">assoc_arrays</span> <span class="n">aa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">drconf_cell_cnt</span> <span class="o">=</span> <span class="n">of_get_drconf_memory</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drconf_cell_cnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">lmb_size</span> <span class="o">=</span> <span class="n">of_get_lmb_size</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lmb_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">of_get_assoc_arrays</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">drconf_cell_cnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">drconf_cell_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">of_drconf_cell</span> <span class="n">drmem</span><span class="p">;</span>

		<span class="n">read_drconf_cell</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drmem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dm</span><span class="p">);</span>

		<span class="cm">/* skip this block if it is reserved or not assigned to</span>
<span class="cm">		 * this partition */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">drmem</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DRCONF_MEM_RESERVED</span><span class="p">)</span>
		    <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">drmem</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DRCONF_MEM_ASSIGNED</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">scn_addr</span> <span class="o">&lt;</span> <span class="n">drmem</span><span class="p">.</span><span class="n">base_addr</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">scn_addr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">drmem</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">lmb_size</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">nid</span> <span class="o">=</span> <span class="n">of_drconf_to_nid_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drmem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aa</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the node associated with a hot added memory section for memory</span>
<span class="cm"> * represented in the device tree as a node (i.e. memory@XXXX) for</span>
<span class="cm"> * each memblock.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">hot_add_node_scn_to_nid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scn_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">memory</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">for_each_node_by_type</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ranges</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">memcell_buf</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">memcell_buf</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcell_buf</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* ranges in cell */</span>
		<span class="n">ranges</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_mem_addr_cells</span> <span class="o">+</span> <span class="n">n_mem_size_cells</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">ranges</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">read_n_cells</span><span class="p">(</span><span class="n">n_mem_addr_cells</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memcell_buf</span><span class="p">);</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">read_n_cells</span><span class="p">(</span><span class="n">n_mem_size_cells</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memcell_buf</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">scn_addr</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">scn_addr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">nid</span> <span class="o">=</span> <span class="n">of_node_to_nid_single</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">of_node_put</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the node associated with a hot added memory section.  Section</span>
<span class="cm"> * corresponds to a SPARSEMEM section, not an MEMBLOCK.  It is assumed that</span>
<span class="cm"> * sections are fully contained within a single MEMBLOCK.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">hot_add_scn_to_nid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scn_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">memory</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">numa_enabled</span> <span class="o">||</span> <span class="p">(</span><span class="n">min_common_depth</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">first_online_node</span><span class="p">;</span>

	<span class="n">memory</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/ibm,dynamic-reconfiguration-memory&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memory</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">hot_add_drconf_scn_to_nid</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">scn_addr</span><span class="p">);</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">hot_add_node_scn_to_nid</span><span class="p">(</span><span class="n">scn_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">node_online</span><span class="p">(</span><span class="n">nid</span><span class="p">))</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">first_online_node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">hot_add_drconf_memory_max</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">memory</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drconf_cell_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">u64</span> <span class="n">lmb_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">dm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">memory</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/ibm,dynamic-reconfiguration-memory&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">memory</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">drconf_cell_cnt</span> <span class="o">=</span> <span class="n">of_get_drconf_memory</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dm</span><span class="p">);</span>
                <span class="n">lmb_size</span> <span class="o">=</span> <span class="n">of_get_lmb_size</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span>
                <span class="n">of_node_put</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">lmb_size</span> <span class="o">*</span> <span class="n">drconf_cell_cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * memory_hotplug_max - return max address of memory that may be added</span>
<span class="cm"> *</span>
<span class="cm"> * This is currently only used on systems that support drconfig memory</span>
<span class="cm"> * hotplug.</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">memory_hotplug_max</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">hot_add_drconf_memory_max</span><span class="p">(),</span> <span class="n">memblock_end_of_DRAM</span><span class="p">());</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MEMORY_HOTPLUG */</span><span class="cp"></span>

<span class="cm">/* Virtual Processor Home Node (VPHN) support */</span>
<span class="cp">#ifdef CONFIG_PPC_SPLPAR</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">vphn_cpu_change_counts</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">][</span><span class="n">MAX_DISTANCE_REF_POINTS</span><span class="p">];</span>
<span class="k">static</span> <span class="n">cpumask_t</span> <span class="n">cpu_associativity_changes_mask</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">vphn_enabled</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">set_topology_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Store the current values of the associativity change counters in the</span>
<span class="cm"> * hypervisor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_cpu_associativity_change_counters</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* The VPHN feature supports a maximum of 8 reference points */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MAX_DISTANCE_REF_POINTS</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">counts</span> <span class="o">=</span> <span class="n">vphn_cpu_change_counts</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
		<span class="k">volatile</span> <span class="n">u8</span> <span class="o">*</span><span class="n">hypervisor_counts</span> <span class="o">=</span> <span class="n">lppaca</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">vphn_assoc_counts</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">distance_ref_points_depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypervisor_counts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The hypervisor maintains a set of 8 associativity change counters in</span>
<span class="cm"> * the VPA of each cpu that correspond to the associativity levels in the</span>
<span class="cm"> * ibm,associativity-reference-points property. When an associativity</span>
<span class="cm"> * level changes, the corresponding counter is incremented.</span>
<span class="cm"> *</span>
<span class="cm"> * Set a bit in cpu_associativity_changes_mask for each cpu whose home</span>
<span class="cm"> * node associativity levels have changed.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of cpus with unhandled associativity changes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_cpu_associativity_changes_mask</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">nr_cpus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpumask_t</span> <span class="o">*</span><span class="n">changes</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_associativity_changes_mask</span><span class="p">;</span>

	<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">changes</span><span class="p">);</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">counts</span> <span class="o">=</span> <span class="n">vphn_cpu_change_counts</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
		<span class="k">volatile</span> <span class="n">u8</span> <span class="o">*</span><span class="n">hypervisor_counts</span> <span class="o">=</span> <span class="n">lppaca</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">vphn_assoc_counts</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">distance_ref_points_depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hypervisor_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypervisor_counts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">changed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">changes</span><span class="p">);</span>
			<span class="n">nr_cpus</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">nr_cpus</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 6 64-bit registers unpacked into 12 32-bit associativity values. To form</span>
<span class="cm"> * the complete property we have to add the length in the first cell.</span>
<span class="cm"> */</span>
<span class="cp">#define VPHN_ASSOC_BUFSIZE (6*sizeof(u64)/sizeof(u32) + 1)</span>

<span class="cm">/*</span>
<span class="cm"> * Convert the associativity domain numbers returned from the hypervisor</span>
<span class="cm"> * to the sequence they would appear in the ibm,associativity property.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vphn_unpack_associativity</span><span class="p">(</span><span class="k">const</span> <span class="kt">long</span> <span class="o">*</span><span class="n">packed</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">unpacked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nr_assoc_doms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">field</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">u16</span><span class="o">*</span><span class="p">)</span> <span class="n">packed</span><span class="p">;</span>

<span class="cp">#define VPHN_FIELD_UNUSED	(0xffff)</span>
<span class="cp">#define VPHN_FIELD_MSB		(0x8000)</span>
<span class="cp">#define VPHN_FIELD_MASK		(~VPHN_FIELD_MSB)</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">VPHN_ASSOC_BUFSIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">field</span> <span class="o">==</span> <span class="n">VPHN_FIELD_UNUSED</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* All significant fields processed, and remaining</span>
<span class="cm">			 * fields contain the reserved value of all 1&#39;s.</span>
<span class="cm">			 * Just store them.</span>
<span class="cm">			 */</span>
			<span class="n">unpacked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">u32</span><span class="o">*</span><span class="p">)</span><span class="n">field</span><span class="p">);</span>
			<span class="n">field</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">field</span> <span class="o">&amp;</span> <span class="n">VPHN_FIELD_MSB</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Data is in the lower 15 bits of this field */</span>
			<span class="n">unpacked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">field</span> <span class="o">&amp;</span> <span class="n">VPHN_FIELD_MASK</span><span class="p">;</span>
			<span class="n">field</span><span class="o">++</span><span class="p">;</span>
			<span class="n">nr_assoc_doms</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Data is in the lower 15 bits of this field</span>
<span class="cm">			 * concatenated with the next 16 bit field</span>
<span class="cm">			 */</span>
			<span class="n">unpacked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">u32</span><span class="o">*</span><span class="p">)</span><span class="n">field</span><span class="p">);</span>
			<span class="n">field</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">nr_assoc_doms</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* The first cell contains the length of the property */</span>
	<span class="n">unpacked</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nr_assoc_doms</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nr_assoc_doms</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Retrieve the new associativity information for a virtual processor&#39;s</span>
<span class="cm"> * home node.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">hcall_vphn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">associativity</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">retbuf</span><span class="p">[</span><span class="n">PLPAR_HCALL9_BUFSIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">u64</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hwcpu</span> <span class="o">=</span> <span class="n">get_hard_smp_processor_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">plpar_hcall9</span><span class="p">(</span><span class="n">H_HOME_NODE_ASSOCIATIVITY</span><span class="p">,</span> <span class="n">retbuf</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">hwcpu</span><span class="p">);</span>
	<span class="n">vphn_unpack_associativity</span><span class="p">(</span><span class="n">retbuf</span><span class="p">,</span> <span class="n">associativity</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">vphn_get_associativity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">associativity</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">hcall_vphn</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">associativity</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">H_FUNCTION</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			<span class="s">&quot;VPHN is not supported. Disabling polling...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">stop_topology_update</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">H_HARDWARE</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;hcall_vphn() experienced a hardware fault &quot;</span>
			<span class="s">&quot;preventing VPHN. Disabling polling...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">stop_topology_update</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update the node maps and sysfs entries for each cpu whose home node</span>
<span class="cm"> * has changed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">arch_update_cpu_topology</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">old_nid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">associativity</span><span class="p">[</span><span class="n">VPHN_ASSOC_BUFSIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cpu_associativity_changes_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vphn_get_associativity</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">associativity</span><span class="p">);</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">associativity_to_nid</span><span class="p">(</span><span class="n">associativity</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">node_online</span><span class="p">(</span><span class="n">nid</span><span class="p">))</span>
			<span class="n">nid</span> <span class="o">=</span> <span class="n">first_online_node</span><span class="p">;</span>

		<span class="n">old_nid</span> <span class="o">=</span> <span class="n">numa_cpu_lookup_table</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

		<span class="cm">/* Disable hotplug while we update the cpu</span>
<span class="cm">		 * masks and sysfs.</span>
<span class="cm">		 */</span>
		<span class="n">get_online_cpus</span><span class="p">();</span>
		<span class="n">unregister_cpu_under_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">old_nid</span><span class="p">);</span>
		<span class="n">unmap_cpu_from_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">map_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="n">register_cpu_under_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="n">put_online_cpus</span><span class="p">();</span>

		<span class="n">dev</span> <span class="o">=</span> <span class="n">get_cpu_device</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
			<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_CHANGE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">topology_work_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rebuild_sched_domains</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">topology_work</span><span class="p">,</span> <span class="n">topology_work_fn</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">topology_schedule_update</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">topology_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">topology_timer_fn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ignored</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vphn_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">update_cpu_associativity_changes_mask</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">topology_schedule_update</span><span class="p">();</span>
	<span class="n">set_topology_timer</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">topology_timer</span> <span class="o">=</span>
	<span class="n">TIMER_INITIALIZER</span><span class="p">(</span><span class="n">topology_timer_fn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_topology_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">topology_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">topology_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">topology_timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start polling for VPHN associativity changes.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">start_topology_update</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Disabled until races with load balancing are fixed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_VPHN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">get_lppaca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">shared_proc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vphn_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">setup_cpu_associativity_change_counters</span><span class="p">();</span>
		<span class="n">init_timer_deferrable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">topology_timer</span><span class="p">);</span>
		<span class="n">set_topology_timer</span><span class="p">();</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">start_topology_update</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Disable polling for VPHN associativity changes.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">stop_topology_update</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vphn_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">topology_timer</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_SPLPAR */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
