<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › mm › hash_utils_64.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hash_utils_64.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * PowerPC64 port by Mike Corrigan and Dave Engebretsen</span>
<span class="cm"> *   {mikejc|engebret}@us.ibm.com</span>
<span class="cm"> *</span>
<span class="cm"> *    Copyright (c) 2000 Mike Corrigan &lt;mikejc@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * SMP scalability work:</span>
<span class="cm"> *    Copyright (C) 2001 Anton Blanchard &lt;anton@au.ibm.com&gt;, IBM</span>
<span class="cm"> * </span>
<span class="cm"> *    Module name: htab.c</span>
<span class="cm"> *</span>
<span class="cm"> *    Description:</span>
<span class="cm"> *      PowerPC Hashed Page Table functions</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#undef DEBUG</span>
<span class="cp">#undef DEBUG_LOW</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>

<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/mmu.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/abs_addr.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/eeh.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/cputable.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/spu.h&gt;</span>
<span class="cp">#include &lt;asm/udbg.h&gt;</span>
<span class="cp">#include &lt;asm/code-patching.h&gt;</span>
<span class="cp">#include &lt;asm/fadump.h&gt;</span>
<span class="cp">#include &lt;asm/firmware.h&gt;</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define DBG(fmt...) udbg_printf(fmt)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG(fmt...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG_LOW</span>
<span class="cp">#define DBG_LOW(fmt...) udbg_printf(fmt)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_LOW(fmt...)</span>
<span class="cp">#endif</span>

<span class="cp">#define KB (1024)</span>
<span class="cp">#define MB (1024*KB)</span>
<span class="cp">#define GB (1024L*MB)</span>

<span class="cm">/*</span>
<span class="cm"> * Note:  pte   --&gt; Linux PTE</span>
<span class="cm"> *        HPTE  --&gt; PowerPC Hashed Page Table Entry</span>
<span class="cm"> *</span>
<span class="cm"> * Execution context:</span>
<span class="cm"> *   htab_initialize is called with the MMU off (of course), but</span>
<span class="cm"> *   the kernel has been copied down to zero so it can directly</span>
<span class="cm"> *   reference global data.  At this point it is very difficult</span>
<span class="cm"> *   to print debug info.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_U3_DART</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dart_tablebase</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_U3_DART */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_SDR1</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">mmu_psize_def</span> <span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">MMU_PAGE_COUNT</span><span class="p">];</span>

<span class="k">struct</span> <span class="n">hash_pte</span> <span class="o">*</span><span class="n">htab_address</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">htab_size_bytes</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">htab_hash_mask</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">htab_hash_mask</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">mmu_linear_psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_4K</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">mmu_virtual_psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_4K</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">mmu_vmalloc_psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_4K</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SPARSEMEM_VMEMMAP</span>
<span class="kt">int</span> <span class="n">mmu_vmemmap_psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_4K</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="kt">int</span> <span class="n">mmu_io_psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_4K</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">mmu_kernel_ssize</span> <span class="o">=</span> <span class="n">MMU_SEGSIZE_256M</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">mmu_highuser_ssize</span> <span class="o">=</span> <span class="n">MMU_SEGSIZE_256M</span><span class="p">;</span>
<span class="n">u16</span> <span class="n">mmu_slb_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">mmu_slb_size</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PPC_64K_PAGES</span>
<span class="kt">int</span> <span class="n">mmu_ci_restrictions</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
<span class="k">static</span> <span class="n">u8</span> <span class="o">*</span><span class="n">linear_map_hash_slots</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">linear_map_hash_count</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">linear_map_hash_lock</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_PAGEALLOC */</span><span class="cp"></span>

<span class="cm">/* There are definitions of page sizes arrays to be used when none</span>
<span class="cm"> * is provided by the firmware.</span>
<span class="cm"> */</span>

<span class="cm">/* Pre-POWER4 CPUs (4k pages only)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mmu_psize_def</span> <span class="n">mmu_psize_defaults_old</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">MMU_PAGE_4K</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">shift</span>	<span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sllp</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">penc</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">avpnm</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tlbiel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* POWER4, GPUL, POWER5</span>
<span class="cm"> *</span>
<span class="cm"> * Support for 16Mb large pages</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mmu_psize_def</span> <span class="n">mmu_psize_defaults_gp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">MMU_PAGE_4K</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">shift</span>	<span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sllp</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">penc</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">avpnm</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tlbiel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">MMU_PAGE_16M</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">shift</span>	<span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sllp</span>	<span class="o">=</span> <span class="n">SLB_VSID_L</span><span class="p">,</span>
		<span class="p">.</span><span class="n">penc</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">avpnm</span>	<span class="o">=</span> <span class="mh">0x1UL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tlbiel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">htab_convert_pte_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pteflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rflags</span> <span class="o">=</span> <span class="n">pteflags</span> <span class="o">&amp;</span> <span class="mh">0x1fa</span><span class="p">;</span>

	<span class="cm">/* _PAGE_EXEC -&gt; NOEXEC */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pteflags</span> <span class="o">&amp;</span> <span class="n">_PAGE_EXEC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rflags</span> <span class="o">|=</span> <span class="n">HPTE_R_N</span><span class="p">;</span>

	<span class="cm">/* PP bits. PAGE_USER is already PP bit 0x2, so we only</span>
<span class="cm">	 * need to add in 0x1 if it&#39;s a read-only user page</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pteflags</span> <span class="o">&amp;</span> <span class="n">_PAGE_USER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">((</span><span class="n">pteflags</span> <span class="o">&amp;</span> <span class="n">_PAGE_RW</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					 <span class="p">(</span><span class="n">pteflags</span> <span class="o">&amp;</span> <span class="n">_PAGE_DIRTY</span><span class="p">)))</span>
		<span class="n">rflags</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Always add C */</span>
	<span class="k">return</span> <span class="n">rflags</span> <span class="o">|</span> <span class="n">HPTE_R_C</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">htab_bolt_mapping</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vstart</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vend</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pstart</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">psize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ssize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">step</span><span class="p">,</span> <span class="n">shift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">shift</span> <span class="o">=</span> <span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">psize</span><span class="p">].</span><span class="n">shift</span><span class="p">;</span>
	<span class="n">step</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>

	<span class="n">prot</span> <span class="o">=</span> <span class="n">htab_convert_pte_flags</span><span class="p">(</span><span class="n">prot</span><span class="p">);</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;htab_bolt_mapping(%lx..%lx -&gt; %lx (%lx,%d,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">vstart</span><span class="p">,</span> <span class="n">vend</span><span class="p">,</span> <span class="n">pstart</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">ssize</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">vstart</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">=</span> <span class="n">pstart</span><span class="p">;</span> <span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">vend</span><span class="p">;</span>
	     <span class="n">vaddr</span> <span class="o">+=</span> <span class="n">step</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">+=</span> <span class="n">step</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">,</span> <span class="n">hpteg</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vsid</span> <span class="o">=</span> <span class="n">get_kernel_vsid</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">ssize</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span> <span class="o">=</span> <span class="n">hpt_va</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">vsid</span><span class="p">,</span> <span class="n">ssize</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tprot</span> <span class="o">=</span> <span class="n">prot</span><span class="p">;</span>

		<span class="cm">/* Make kernel text executable */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">overlaps_kernel_text</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">step</span><span class="p">))</span>
			<span class="n">tprot</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HPTE_R_N</span><span class="p">;</span>

		<span class="n">hash</span> <span class="o">=</span> <span class="n">hpt_hash</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">ssize</span><span class="p">);</span>
		<span class="n">hpteg</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="n">htab_hash_mask</span><span class="p">)</span> <span class="o">*</span> <span class="n">HPTES_PER_GROUP</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_insert</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_insert</span><span class="p">(</span><span class="n">hpteg</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">tprot</span><span class="p">,</span>
					 <span class="n">HPTE_V_BOLTED</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">ssize</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">paddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">linear_map_hash_count</span><span class="p">)</span>
			<span class="n">linear_map_hash_slots</span><span class="p">[</span><span class="n">paddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">|</span> <span class="mh">0x80</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_PAGEALLOC */</span><span class="cp"></span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MEMORY_HOTPLUG</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">htab_remove_mapping</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vstart</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vend</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">psize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ssize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">step</span><span class="p">,</span> <span class="n">shift</span><span class="p">;</span>

	<span class="n">shift</span> <span class="o">=</span> <span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">psize</span><span class="p">].</span><span class="n">shift</span><span class="p">;</span>
	<span class="n">step</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_removebolted</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Platform doesn&#39;t implement &quot;</span>
				<span class="s">&quot;hpte_removebolted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">vstart</span><span class="p">;</span> <span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">vend</span><span class="p">;</span> <span class="n">vaddr</span> <span class="o">+=</span> <span class="n">step</span><span class="p">)</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_removebolted</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">ssize</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MEMORY_HOTPLUG */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">htab_dt_scan_seg_sizes</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;device_type&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* We are scanning &quot;cpu&quot; nodes only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ibm,processor-segment-sizes&quot;</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">size</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">,</span> <span class="o">++</span><span class="n">prop</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">40</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;1T segment support detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">cur_cpu_spec</span><span class="o">-&gt;</span><span class="n">mmu_features</span> <span class="o">|=</span> <span class="n">MMU_FTR_1T_SEGMENT</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cur_cpu_spec</span><span class="o">-&gt;</span><span class="n">mmu_features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MMU_FTR_NO_SLBIE_B</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">htab_init_seg_sizes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">of_scan_flat_dt</span><span class="p">(</span><span class="n">htab_dt_scan_seg_sizes</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">htab_dt_scan_page_sizes</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;device_type&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* We are scanning &quot;cpu&quot; nodes only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
					  <span class="s">&quot;ibm,segment-page-sizes&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;Page sizes from device-tree:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">/=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">cur_cpu_spec</span><span class="o">-&gt;</span><span class="n">mmu_features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MMU_FTR_16M_PAGE</span><span class="p">);</span>
		<span class="k">while</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">prop</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slbenc</span> <span class="o">=</span> <span class="n">prop</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lpnum</span> <span class="o">=</span> <span class="n">prop</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lpenc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">mmu_psize_def</span> <span class="o">*</span><span class="n">def</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

			<span class="n">size</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">prop</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">while</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">lpnum</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">prop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">shift</span><span class="p">)</span>
					<span class="n">lpenc</span> <span class="o">=</span> <span class="n">prop</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
				<span class="n">prop</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">size</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">lpnum</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">switch</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0xc</span>:
				<span class="n">idx</span> <span class="o">=</span> <span class="n">MMU_PAGE_4K</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mh">0x10</span>:
				<span class="n">idx</span> <span class="o">=</span> <span class="n">MMU_PAGE_64K</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mh">0x14</span>:
				<span class="n">idx</span> <span class="o">=</span> <span class="n">MMU_PAGE_1M</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mh">0x18</span>:
				<span class="n">idx</span> <span class="o">=</span> <span class="n">MMU_PAGE_16M</span><span class="p">;</span>
				<span class="n">cur_cpu_spec</span><span class="o">-&gt;</span><span class="n">mmu_features</span> <span class="o">|=</span> <span class="n">MMU_FTR_16M_PAGE</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mh">0x22</span>:
				<span class="n">idx</span> <span class="o">=</span> <span class="n">MMU_PAGE_16G</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">def</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
			<span class="n">def</span><span class="o">-&gt;</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&lt;=</span> <span class="mi">23</span><span class="p">)</span>
				<span class="n">def</span><span class="o">-&gt;</span><span class="n">avpnm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">def</span><span class="o">-&gt;</span><span class="n">avpnm</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">shift</span> <span class="o">-</span> <span class="mi">23</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">def</span><span class="o">-&gt;</span><span class="n">sllp</span> <span class="o">=</span> <span class="n">slbenc</span><span class="p">;</span>
			<span class="n">def</span><span class="o">-&gt;</span><span class="n">penc</span> <span class="o">=</span> <span class="n">lpenc</span><span class="p">;</span>
			<span class="cm">/* We don&#39;t know for sure what&#39;s up with tlbiel, so</span>
<span class="cm">			 * for now we only set it for 4K and 64K pages</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">MMU_PAGE_4K</span> <span class="o">||</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">MMU_PAGE_64K</span><span class="p">)</span>
				<span class="n">def</span><span class="o">-&gt;</span><span class="n">tlbiel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">def</span><span class="o">-&gt;</span><span class="n">tlbiel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">DBG</span><span class="p">(</span><span class="s">&quot; %d: shift=%02x, sllp=%04lx, avpnm=%08lx, &quot;</span>
			    <span class="s">&quot;tlbiel=%d, penc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">idx</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">def</span><span class="o">-&gt;</span><span class="n">sllp</span><span class="p">,</span> <span class="n">def</span><span class="o">-&gt;</span><span class="n">avpnm</span><span class="p">,</span> <span class="n">def</span><span class="o">-&gt;</span><span class="n">tlbiel</span><span class="p">,</span>
			    <span class="n">def</span><span class="o">-&gt;</span><span class="n">penc</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
<span class="cm">/* Scan for 16G memory blocks that have been set aside for huge pages</span>
<span class="cm"> * and reserve those blocks for 16G huge pages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">htab_dt_scan_hugepage_blocks</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;device_type&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr_prop</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">page_count_prop</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">expected_pages</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">phys_addr</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_size</span><span class="p">;</span>

	<span class="cm">/* We are scanning &quot;memory&quot; nodes only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* This property is the log base 2 of the number of virtual pages that</span>
<span class="cm">	 * will represent this memory block. */</span>
	<span class="n">page_count_prop</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ibm,expected#pages&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_count_prop</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">expected_pages</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">page_count_prop</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">addr_prop</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr_prop</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phys_addr</span> <span class="o">=</span> <span class="n">addr_prop</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">block_size</span> <span class="o">=</span> <span class="n">addr_prop</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_size</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">GB</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Huge page(16GB) memory: &quot;</span>
			<span class="s">&quot;addr = 0x%lX size = 0x%lX pages = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phys_addr</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">expected_pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phys_addr</span> <span class="o">+</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">GB</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">memblock_end_of_DRAM</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">block_size</span> <span class="o">*</span> <span class="n">expected_pages</span><span class="p">);</span>
		<span class="n">add_gpage</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">expected_pages</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HUGETLB_PAGE */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">htab_init_page_sizes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Default to 4K pages only */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">mmu_psize_defs</span><span class="p">,</span> <span class="n">mmu_psize_defaults_old</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">mmu_psize_defaults_old</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to find the available page sizes in the device-tree</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">of_scan_flat_dt</span><span class="p">(</span><span class="n">htab_dt_scan_page_sizes</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>  <span class="cm">/* Found */</span>
		<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Not in the device-tree, let&#39;s fallback on known size</span>
<span class="cm">	 * list for 16M capable GP &amp; GR</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_has_feature</span><span class="p">(</span><span class="n">MMU_FTR_16M_PAGE</span><span class="p">))</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">mmu_psize_defs</span><span class="p">,</span> <span class="n">mmu_psize_defaults_gp</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">mmu_psize_defaults_gp</span><span class="p">));</span>
 <span class="nl">found:</span>
<span class="cp">#ifndef CONFIG_DEBUG_PAGEALLOC</span>
	<span class="cm">/*</span>
<span class="cm">	 * Pick a size for the linear mapping. Currently, we only support</span>
<span class="cm">	 * 16M, 1M and 4K which is the default</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">MMU_PAGE_16M</span><span class="p">].</span><span class="n">shift</span><span class="p">)</span>
		<span class="n">mmu_linear_psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_16M</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">MMU_PAGE_1M</span><span class="p">].</span><span class="n">shift</span><span class="p">)</span>
		<span class="n">mmu_linear_psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_1M</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_PAGEALLOC */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PPC_64K_PAGES</span>
	<span class="cm">/*</span>
<span class="cm">	 * Pick a size for the ordinary pages. Default is 4K, we support</span>
<span class="cm">	 * 64K for user mappings and vmalloc if supported by the processor.</span>
<span class="cm">	 * We only use 64k for ioremap if the processor</span>
<span class="cm">	 * (and firmware) support cache-inhibited large pages.</span>
<span class="cm">	 * If not, we use 4k and set mmu_ci_restrictions so that</span>
<span class="cm">	 * hash_page knows to switch processes that use cache-inhibited</span>
<span class="cm">	 * mappings to 4k pages.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">MMU_PAGE_64K</span><span class="p">].</span><span class="n">shift</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mmu_virtual_psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_64K</span><span class="p">;</span>
		<span class="n">mmu_vmalloc_psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_64K</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mmu_linear_psize</span> <span class="o">==</span> <span class="n">MMU_PAGE_4K</span><span class="p">)</span>
			<span class="n">mmu_linear_psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_64K</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mmu_has_feature</span><span class="p">(</span><span class="n">MMU_FTR_CI_LARGE_PAGE</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Don&#39;t use 64k pages for ioremap on pSeries, since</span>
<span class="cm">			 * that would stop us accessing the HEA ethernet.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">machine_is</span><span class="p">(</span><span class="n">pseries</span><span class="p">))</span>
				<span class="n">mmu_io_psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_64K</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">mmu_ci_restrictions</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_64K_PAGES */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SPARSEMEM_VMEMMAP</span>
	<span class="cm">/* We try to use 16M pages for vmemmap if that is supported</span>
<span class="cm">	 * and we have at least 1G of RAM at boot</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">MMU_PAGE_16M</span><span class="p">].</span><span class="n">shift</span> <span class="o">&amp;&amp;</span>
	    <span class="n">memblock_phys_mem_size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mh">0x40000000</span><span class="p">)</span>
		<span class="n">mmu_vmemmap_psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_16M</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">MMU_PAGE_64K</span><span class="p">].</span><span class="n">shift</span><span class="p">)</span>
		<span class="n">mmu_vmemmap_psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_64K</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mmu_vmemmap_psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_4K</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SPARSEMEM_VMEMMAP */</span><span class="cp"></span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Page orders: linear mapping = %d, &quot;</span>
	       <span class="s">&quot;virtual = %d, io = %d&quot;</span>
<span class="cp">#ifdef CONFIG_SPARSEMEM_VMEMMAP</span>
	       <span class="s">&quot;, vmemmap = %d&quot;</span>
<span class="cp">#endif</span>
	       <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">mmu_linear_psize</span><span class="p">].</span><span class="n">shift</span><span class="p">,</span>
	       <span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">mmu_virtual_psize</span><span class="p">].</span><span class="n">shift</span><span class="p">,</span>
	       <span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">mmu_io_psize</span><span class="p">].</span><span class="n">shift</span>
<span class="cp">#ifdef CONFIG_SPARSEMEM_VMEMMAP</span>
	       <span class="p">,</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">mmu_vmemmap_psize</span><span class="p">].</span><span class="n">shift</span>
<span class="cp">#endif</span>
	       <span class="p">);</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
	<span class="cm">/* Reserve 16G huge page memory sections for huge pages */</span>
	<span class="n">of_scan_flat_dt</span><span class="p">(</span><span class="n">htab_dt_scan_hugepage_blocks</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HUGETLB_PAGE */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">htab_dt_scan_pftsize</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;device_type&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>

	<span class="cm">/* We are scanning &quot;cpu&quot; nodes only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ibm,pft-size&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* pft_size[0] is the NUMA CEC cookie */</span>
		<span class="n">ppc64_pft_size</span> <span class="o">=</span> <span class="n">prop</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">htab_get_table_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">rnd_mem_size</span><span class="p">,</span> <span class="n">pteg_count</span><span class="p">,</span> <span class="n">psize</span><span class="p">;</span>

	<span class="cm">/* If hash size isn&#39;t already provided by the platform, we try to</span>
<span class="cm">	 * retrieve it from the device-tree. If it&#39;s not there neither, we</span>
<span class="cm">	 * calculate it now based on the total RAM size</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppc64_pft_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">of_scan_flat_dt</span><span class="p">(</span><span class="n">htab_dt_scan_pftsize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppc64_pft_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">ppc64_pft_size</span><span class="p">;</span>

	<span class="cm">/* round mem_size up to next power of 2 */</span>
	<span class="n">mem_size</span> <span class="o">=</span> <span class="n">memblock_phys_mem_size</span><span class="p">();</span>
	<span class="n">rnd_mem_size</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">__ilog2</span><span class="p">(</span><span class="n">mem_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rnd_mem_size</span> <span class="o">&lt;</span> <span class="n">mem_size</span><span class="p">)</span>
		<span class="n">rnd_mem_size</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* # pages / 2 */</span>
	<span class="n">psize</span> <span class="o">=</span> <span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">mmu_virtual_psize</span><span class="p">].</span><span class="n">shift</span><span class="p">;</span>
	<span class="n">pteg_count</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">rnd_mem_size</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">psize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pteg_count</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MEMORY_HOTPLUG</span>
<span class="kt">int</span> <span class="nf">create_section_mapping</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">htab_bolt_mapping</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>
				 <span class="n">pgprot_val</span><span class="p">(</span><span class="n">PAGE_KERNEL</span><span class="p">),</span> <span class="n">mmu_linear_psize</span><span class="p">,</span>
				 <span class="n">mmu_kernel_ssize</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">remove_section_mapping</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">htab_remove_mapping</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">mmu_linear_psize</span><span class="p">,</span>
			<span class="n">mmu_kernel_ssize</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MEMORY_HOTPLUG */</span><span class="cp"></span>

<span class="cp">#define FUNCTION_TEXT(A)	((*(unsigned long *)(A)))</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">htab_finish_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">htab_call_hpte_insert1</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">htab_call_hpte_insert2</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">htab_call_hpte_remove</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">htab_call_hpte_updatepp</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC_HAS_HASH_64K</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ht64_call_hpte_insert1</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ht64_call_hpte_insert2</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ht64_call_hpte_remove</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ht64_call_hpte_updatepp</span><span class="p">;</span>

	<span class="n">patch_branch</span><span class="p">(</span><span class="n">ht64_call_hpte_insert1</span><span class="p">,</span>
		<span class="n">FUNCTION_TEXT</span><span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_insert</span><span class="p">),</span>
		<span class="n">BRANCH_SET_LINK</span><span class="p">);</span>
	<span class="n">patch_branch</span><span class="p">(</span><span class="n">ht64_call_hpte_insert2</span><span class="p">,</span>
		<span class="n">FUNCTION_TEXT</span><span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_insert</span><span class="p">),</span>
		<span class="n">BRANCH_SET_LINK</span><span class="p">);</span>
	<span class="n">patch_branch</span><span class="p">(</span><span class="n">ht64_call_hpte_remove</span><span class="p">,</span>
		<span class="n">FUNCTION_TEXT</span><span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_remove</span><span class="p">),</span>
		<span class="n">BRANCH_SET_LINK</span><span class="p">);</span>
	<span class="n">patch_branch</span><span class="p">(</span><span class="n">ht64_call_hpte_updatepp</span><span class="p">,</span>
		<span class="n">FUNCTION_TEXT</span><span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_updatepp</span><span class="p">),</span>
		<span class="n">BRANCH_SET_LINK</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_HAS_HASH_64K */</span><span class="cp"></span>

	<span class="n">patch_branch</span><span class="p">(</span><span class="n">htab_call_hpte_insert1</span><span class="p">,</span>
		<span class="n">FUNCTION_TEXT</span><span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_insert</span><span class="p">),</span>
		<span class="n">BRANCH_SET_LINK</span><span class="p">);</span>
	<span class="n">patch_branch</span><span class="p">(</span><span class="n">htab_call_hpte_insert2</span><span class="p">,</span>
		<span class="n">FUNCTION_TEXT</span><span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_insert</span><span class="p">),</span>
		<span class="n">BRANCH_SET_LINK</span><span class="p">);</span>
	<span class="n">patch_branch</span><span class="p">(</span><span class="n">htab_call_hpte_remove</span><span class="p">,</span>
		<span class="n">FUNCTION_TEXT</span><span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_remove</span><span class="p">),</span>
		<span class="n">BRANCH_SET_LINK</span><span class="p">);</span>
	<span class="n">patch_branch</span><span class="p">(</span><span class="n">htab_call_hpte_updatepp</span><span class="p">,</span>
		<span class="n">FUNCTION_TEXT</span><span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_updatepp</span><span class="p">),</span>
		<span class="n">BRANCH_SET_LINK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">htab_initialize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">table</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pteg_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot; -&gt; htab_initialize()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Initialize segment sizes */</span>
	<span class="n">htab_init_seg_sizes</span><span class="p">();</span>

	<span class="cm">/* Initialize page sizes */</span>
	<span class="n">htab_init_page_sizes</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_has_feature</span><span class="p">(</span><span class="n">MMU_FTR_1T_SEGMENT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mmu_kernel_ssize</span> <span class="o">=</span> <span class="n">MMU_SEGSIZE_1T</span><span class="p">;</span>
		<span class="n">mmu_highuser_ssize</span> <span class="o">=</span> <span class="n">MMU_SEGSIZE_1T</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Using 1TB segments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the required size of the htab.  We want the number of</span>
<span class="cm">	 * PTEGs to equal one half the number of real pages.</span>
<span class="cm">	 */</span> 
	<span class="n">htab_size_bytes</span> <span class="o">=</span> <span class="n">htab_get_table_size</span><span class="p">();</span>
	<span class="n">pteg_count</span> <span class="o">=</span> <span class="n">htab_size_bytes</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">;</span>

	<span class="n">htab_hash_mask</span> <span class="o">=</span> <span class="n">pteg_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_LPAR</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Using a hypervisor which owns the htab */</span>
		<span class="n">htab_address</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">_SDR1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
<span class="cp">#ifdef CONFIG_FA_DUMP</span>
		<span class="cm">/*</span>
<span class="cm">		 * If firmware assisted dump is active firmware preserves</span>
<span class="cm">		 * the contents of htab along with entire partition memory.</span>
<span class="cm">		 * Clear the htab if firmware assisted dump is active so</span>
<span class="cm">		 * that we dont end up using old mappings.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_fadump_active</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_clear_all</span><span class="p">)</span>
			<span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_clear_all</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Find storage for the HPT.  Must be contiguous in</span>
<span class="cm">		 * the absolute address space. On cell we want it to be</span>
<span class="cm">		 * in the first 2 Gig so we can use it for IOMMU hacks.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">machine_is</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
			<span class="n">limit</span> <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">limit</span> <span class="o">=</span> <span class="n">MEMBLOCK_ALLOC_ANYWHERE</span><span class="p">;</span>

		<span class="n">table</span> <span class="o">=</span> <span class="n">memblock_alloc_base</span><span class="p">(</span><span class="n">htab_size_bytes</span><span class="p">,</span> <span class="n">htab_size_bytes</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>

		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;Hash table allocated at %lx, size: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span>
		    <span class="n">htab_size_bytes</span><span class="p">);</span>

		<span class="n">htab_address</span> <span class="o">=</span> <span class="n">abs_to_virt</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>

		<span class="cm">/* htab absolute addr + encoded htabsize */</span>
		<span class="n">_SDR1</span> <span class="o">=</span> <span class="n">table</span> <span class="o">+</span> <span class="n">__ilog2</span><span class="p">(</span><span class="n">pteg_count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">11</span><span class="p">;</span>

		<span class="cm">/* Initialize the HPT with no entries */</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">table</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">htab_size_bytes</span><span class="p">);</span>

		<span class="cm">/* Set SDR1 */</span>
		<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_SDR1</span><span class="p">,</span> <span class="n">_SDR1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">prot</span> <span class="o">=</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">PAGE_KERNEL</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
	<span class="n">linear_map_hash_count</span> <span class="o">=</span> <span class="n">memblock_end_of_DRAM</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">linear_map_hash_slots</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">memblock_alloc_base</span><span class="p">(</span><span class="n">linear_map_hash_count</span><span class="p">,</span>
						    <span class="mi">1</span><span class="p">,</span> <span class="n">ppc64_rma_size</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">linear_map_hash_slots</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">linear_map_hash_count</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_PAGEALLOC */</span><span class="cp"></span>

	<span class="cm">/* On U3 based machines, we need to reserve the DART area and</span>
<span class="cm">	 * _NOT_ map it to avoid cache paradoxes as it&#39;s remapped non</span>
<span class="cm">	 * cacheable later on</span>
<span class="cm">	 */</span>

	<span class="cm">/* create bolted the linear mapping in the hash table */</span>
	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;creating mapping for region: %lx..%lx (prot: %lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_U3_DART</span>
		<span class="cm">/* Do not map the DART space. Fortunately, it will be aligned</span>
<span class="cm">		 * in such a way that it will not cross two memblock regions and</span>
<span class="cm">		 * will fit within a single 16Mb page.</span>
<span class="cm">		 * The DART space is assumed to be a full 16Mb region even if</span>
<span class="cm">		 * we only use 2Mb of that space. We will use more of it later</span>
<span class="cm">		 * for AGP GART. We have to use a full 16Mb large page.</span>
<span class="cm">		 */</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;DART base: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dart_tablebase</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dart_tablebase</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dart_tablebase</span> <span class="o">&gt;=</span> <span class="n">base</span>
		    <span class="o">&amp;&amp;</span> <span class="n">dart_tablebase</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dart_table_end</span> <span class="o">=</span> <span class="n">dart_tablebase</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">MB</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">!=</span> <span class="n">dart_tablebase</span><span class="p">)</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">htab_bolt_mapping</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">dart_tablebase</span><span class="p">,</span>
							<span class="n">__pa</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="n">prot</span><span class="p">,</span>
							<span class="n">mmu_linear_psize</span><span class="p">,</span>
							<span class="n">mmu_kernel_ssize</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">base</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dart_table_end</span><span class="p">)</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">htab_bolt_mapping</span><span class="p">(</span><span class="n">dart_tablebase</span><span class="o">+</span><span class="mi">16</span><span class="o">*</span><span class="n">MB</span><span class="p">,</span>
							<span class="n">base</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span>
							<span class="n">__pa</span><span class="p">(</span><span class="n">dart_table_end</span><span class="p">),</span>
							 <span class="n">prot</span><span class="p">,</span>
							 <span class="n">mmu_linear_psize</span><span class="p">,</span>
							 <span class="n">mmu_kernel_ssize</span><span class="p">));</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_U3_DART */</span><span class="cp"></span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">htab_bolt_mapping</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">base</span><span class="p">),</span>
				<span class="n">prot</span><span class="p">,</span> <span class="n">mmu_linear_psize</span><span class="p">,</span> <span class="n">mmu_kernel_ssize</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">memblock_set_current_limit</span><span class="p">(</span><span class="n">MEMBLOCK_ALLOC_ANYWHERE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have a memory_limit and we&#39;ve allocated TCEs then we need to</span>
<span class="cm">	 * explicitly map the TCE area at the top of RAM. We also cope with the</span>
<span class="cm">	 * case that the TCEs start below memory_limit.</span>
<span class="cm">	 * tce_alloc_start/end are 16MB aligned so the mapping should work</span>
<span class="cm">	 * for either 4K or 16MB pages.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tce_alloc_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tce_alloc_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">tce_alloc_start</span><span class="p">);</span>
		<span class="n">tce_alloc_end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">tce_alloc_end</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="n">tce_alloc_start</span><span class="p">)</span>
			<span class="n">tce_alloc_start</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">htab_bolt_mapping</span><span class="p">(</span><span class="n">tce_alloc_start</span><span class="p">,</span> <span class="n">tce_alloc_end</span><span class="p">,</span>
					 <span class="n">__pa</span><span class="p">(</span><span class="n">tce_alloc_start</span><span class="p">),</span> <span class="n">prot</span><span class="p">,</span>
					 <span class="n">mmu_linear_psize</span><span class="p">,</span> <span class="n">mmu_kernel_ssize</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">htab_finish_init</span><span class="p">();</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot; &lt;- htab_initialize()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#undef KB</span>
<span class="cp">#undef MB</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">early_init_mmu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Setup initial STAB address in the PACA */</span>
	<span class="n">get_paca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">stab_real</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">initial_stab</span><span class="p">);</span>
	<span class="n">get_paca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">stab_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">initial_stab</span><span class="p">;</span>

	<span class="cm">/* Initialize the MMU Hash table and create the linear mapping</span>
<span class="cm">	 * of memory. Has to be done before stab/slb initialization as</span>
<span class="cm">	 * this is currently where the page size encoding is obtained</span>
<span class="cm">	 */</span>
	<span class="n">htab_initialize</span><span class="p">();</span>

	<span class="cm">/* Initialize stab / SLB management */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_has_feature</span><span class="p">(</span><span class="n">MMU_FTR_SLB</span><span class="p">))</span>
		<span class="n">slb_initialize</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">early_init_mmu_secondary</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Initialize hash table for that CPU */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_LPAR</span><span class="p">))</span>
		<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_SDR1</span><span class="p">,</span> <span class="n">_SDR1</span><span class="p">);</span>

	<span class="cm">/* Initialize STAB/SLB. We use a virtual address as it works</span>
<span class="cm">	 * in real mode on pSeries.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_has_feature</span><span class="p">(</span><span class="n">MMU_FTR_SLB</span><span class="p">))</span>
		<span class="n">slb_initialize</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">stab_initialize</span><span class="p">(</span><span class="n">get_paca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">stab_addr</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Called by asm hashtable.S for doing lazy icache flush</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">hash_page_do_lazy_icache</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pp</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">pte_pfn</span><span class="p">(</span><span class="n">pte</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">pp</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">pte_page</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>

	<span class="cm">/* page is dirty */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">PG_arch_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trap</span> <span class="o">==</span> <span class="mh">0x400</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">flush_dcache_icache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">PG_arch_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">pp</span> <span class="o">|=</span> <span class="n">HPTE_R_N</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC_MM_SLICES</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_paca_psize</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span> <span class="n">slices</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">SLICE_LOW_TOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slices</span> <span class="o">=</span> <span class="n">get_paca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">low_slices_psize</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">GET_LOW_SLICE_INDEX</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">slices</span> <span class="o">=</span> <span class="n">get_paca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">high_slices_psize</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">GET_HIGH_SLICE_INDEX</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">slices</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">index</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_paca_psize</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">get_paca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">user_psize</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Demote a segment to using 4k pages.</span>
<span class="cm"> * For now this makes the whole process use 4k pages.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PPC_64K_PAGES</span>
<span class="kt">void</span> <span class="nf">demote_segment_4k</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_slice_psize</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span> <span class="o">==</span> <span class="n">MMU_PAGE_4K</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">slice_set_range_psize</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MMU_PAGE_4K</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SPU_BASE</span>
	<span class="n">spu_flush_all_slbs</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_paca_psize</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MMU_PAGE_4K</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_paca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
		<span class="n">slb_flush_and_rebolt</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_64K_PAGES */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PPC_SUBPAGE_PROT</span>
<span class="cm">/*</span>
<span class="cm"> * This looks up a 2-bit protection code for a 4k subpage of a 64k page.</span>
<span class="cm"> * Userspace sets the subpage permissions using the subpage_prot system call.</span>
<span class="cm"> *</span>
<span class="cm"> * Result is 0: full permissions, _PAGE_RW: read-only,</span>
<span class="cm"> * _PAGE_USER or _PAGE_USER|_PAGE_RW: no access.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">subpage_protection</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ea</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">subpage_prot_table</span> <span class="o">*</span><span class="n">spt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">spt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">spp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">**</span><span class="n">sbpm</span><span class="p">,</span> <span class="o">*</span><span class="n">sbpp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ea</span> <span class="o">&gt;=</span> <span class="n">spt</span><span class="o">-&gt;</span><span class="n">maxaddr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ea</span> <span class="o">&lt;</span> <span class="mh">0x100000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* addresses below 4GB use spt-&gt;low_prot */</span>
		<span class="n">sbpm</span> <span class="o">=</span> <span class="n">spt</span><span class="o">-&gt;</span><span class="n">low_prot</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sbpm</span> <span class="o">=</span> <span class="n">spt</span><span class="o">-&gt;</span><span class="n">protptrs</span><span class="p">[</span><span class="n">ea</span> <span class="o">&gt;&gt;</span> <span class="n">SBP_L3_SHIFT</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbpm</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sbpp</span> <span class="o">=</span> <span class="n">sbpm</span><span class="p">[(</span><span class="n">ea</span> <span class="o">&gt;&gt;</span> <span class="n">SBP_L2_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SBP_L2_COUNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbpp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spp</span> <span class="o">=</span> <span class="n">sbpp</span><span class="p">[(</span><span class="n">ea</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SBP_L1_COUNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)];</span>

	<span class="cm">/* extract 2-bit bitfield for this 4k subpage */</span>
	<span class="n">spp</span> <span class="o">&gt;&gt;=</span> <span class="mi">30</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">ea</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>

	<span class="cm">/* turn 0,1,2,3 into combination of _PAGE_USER and _PAGE_RW */</span>
	<span class="n">spp</span> <span class="o">=</span> <span class="p">((</span><span class="n">spp</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="n">_PAGE_USER</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">spp</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">_PAGE_RW</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">spp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_PPC_SUBPAGE_PROT */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">subpage_protection</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ea</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">hash_failure_debug</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ea</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">access</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vsid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trap</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">ssize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">psize</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">printk_ratelimit</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;mm: Hashing failure ! EA=0x%lx access=0x%lx current=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ea</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;    trap=0x%lx vsid=0x%lx ssize=%d psize=%d pte=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">trap</span><span class="p">,</span> <span class="n">vsid</span><span class="p">,</span> <span class="n">ssize</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Result code is:</span>
<span class="cm"> *  0 - handled</span>
<span class="cm"> *  1 - normal page fault</span>
<span class="cm"> * -1 - critical hash insertion error</span>
<span class="cm"> * -2 - access not permitted by subpage protection mechanism</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">hash_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ea</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">access</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vsid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">hugeshift</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">user_region</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">local</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">psize</span><span class="p">,</span> <span class="n">ssize</span><span class="p">;</span>

	<span class="n">DBG_LOW</span><span class="p">(</span><span class="s">&quot;hash_page(ea=%016lx, access=%lx, trap=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ea</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">trap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ea</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">REGION_MASK</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">PGTABLE_RANGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG_LOW</span><span class="p">(</span><span class="s">&quot; out of pgtable range !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
 		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get region &amp; vsid */</span>
 	<span class="k">switch</span> <span class="p">(</span><span class="n">REGION_ID</span><span class="p">(</span><span class="n">ea</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USER_REGION_ID</span>:
		<span class="n">user_region</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBG_LOW</span><span class="p">(</span><span class="s">&quot; user region with no mm !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">psize</span> <span class="o">=</span> <span class="n">get_slice_psize</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">ea</span><span class="p">);</span>
		<span class="n">ssize</span> <span class="o">=</span> <span class="n">user_segment_size</span><span class="p">(</span><span class="n">ea</span><span class="p">);</span>
		<span class="n">vsid</span> <span class="o">=</span> <span class="n">get_vsid</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">ea</span><span class="p">,</span> <span class="n">ssize</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VMALLOC_REGION_ID</span>:
		<span class="n">mm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">;</span>
		<span class="n">vsid</span> <span class="o">=</span> <span class="n">get_kernel_vsid</span><span class="p">(</span><span class="n">ea</span><span class="p">,</span> <span class="n">mmu_kernel_ssize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ea</span> <span class="o">&lt;</span> <span class="n">VMALLOC_END</span><span class="p">)</span>
			<span class="n">psize</span> <span class="o">=</span> <span class="n">mmu_vmalloc_psize</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">psize</span> <span class="o">=</span> <span class="n">mmu_io_psize</span><span class="p">;</span>
		<span class="n">ssize</span> <span class="o">=</span> <span class="n">mmu_kernel_ssize</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Not a valid range</span>
<span class="cm">		 * Send the problem up to do_page_fault </span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DBG_LOW</span><span class="p">(</span><span class="s">&quot; mm=%p, mm-&gt;pgdir=%p, vsid=%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">,</span> <span class="n">vsid</span><span class="p">);</span>

	<span class="cm">/* Get pgdir */</span>
	<span class="n">pgdir</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgdir</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Check CPU locality */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_region</span> <span class="o">&amp;&amp;</span> <span class="n">cpumask_equal</span><span class="p">(</span><span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">),</span> <span class="n">tmp</span><span class="p">))</span>
		<span class="n">local</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_PPC_64K_PAGES</span>
	<span class="cm">/* If we use 4K pages and our psize is not 4K, then we might</span>
<span class="cm">	 * be hitting a special driver mapping, and need to align the</span>
<span class="cm">	 * address before we fetch the PTE.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It could also be a hugepage mapping, in which case this is</span>
<span class="cm">	 * not necessary, but it&#39;s not harmful, either.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psize</span> <span class="o">!=</span> <span class="n">MMU_PAGE_4K</span><span class="p">)</span>
		<span class="n">ea</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1ul</span> <span class="o">&lt;&lt;</span> <span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">psize</span><span class="p">].</span><span class="n">shift</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_64K_PAGES */</span><span class="cp"></span>

	<span class="cm">/* Get PTE and page size from page tables */</span>
	<span class="n">ptep</span> <span class="o">=</span> <span class="n">find_linux_pte_or_hugepte</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">ea</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hugeshift</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptep</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DBG_LOW</span><span class="p">(</span><span class="s">&quot; no PTE !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Add _PAGE_PRESENT to the required access perm */</span>
	<span class="n">access</span> <span class="o">|=</span> <span class="n">_PAGE_PRESENT</span><span class="p">;</span>

	<span class="cm">/* Pre-check access permissions (will be re-checked atomically</span>
<span class="cm">	 * in __hash_page_XX but this pre-check is a fast path</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">access</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DBG_LOW</span><span class="p">(</span><span class="s">&quot; no access !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hugeshift</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__hash_page_huge</span><span class="p">(</span><span class="n">ea</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">vsid</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">trap</span><span class="p">,</span> <span class="n">local</span><span class="p">,</span>
					<span class="n">ssize</span><span class="p">,</span> <span class="n">hugeshift</span><span class="p">,</span> <span class="n">psize</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HUGETLB_PAGE */</span><span class="cp"></span>

<span class="cp">#ifndef CONFIG_PPC_64K_PAGES</span>
	<span class="n">DBG_LOW</span><span class="p">(</span><span class="s">&quot; i-pte: %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="n">DBG_LOW</span><span class="p">(</span><span class="s">&quot; i-pte: %016lx %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">),</span>
		<span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ptep</span> <span class="o">+</span> <span class="n">PTRS_PER_PTE</span><span class="p">)));</span>
<span class="cp">#endif</span>
	<span class="cm">/* Do actual hashing */</span>
<span class="cp">#ifdef CONFIG_PPC_64K_PAGES</span>
	<span class="cm">/* If _PAGE_4K_PFN is set, make sure this is a 4k segment */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_4K_PFN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">psize</span> <span class="o">==</span> <span class="n">MMU_PAGE_64K</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">demote_segment_4k</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">ea</span><span class="p">);</span>
		<span class="n">psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_4K</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If this PTE is non-cacheable and we have restrictions on</span>
<span class="cm">	 * using non cacheable large pages, then we switch to 4k</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_ci_restrictions</span> <span class="o">&amp;&amp;</span> <span class="n">psize</span> <span class="o">==</span> <span class="n">MMU_PAGE_64K</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_NO_CACHE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user_region</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">demote_segment_4k</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">ea</span><span class="p">);</span>
			<span class="n">psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_4K</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ea</span> <span class="o">&lt;</span> <span class="n">VMALLOC_END</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * some driver did a non-cacheable mapping</span>
<span class="cm">			 * in vmalloc space, so switch vmalloc</span>
<span class="cm">			 * to 4k pages</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;Reducing vmalloc segment &quot;</span>
			       <span class="s">&quot;to 4kB pages because of &quot;</span>
			       <span class="s">&quot;non-cacheable mapping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">psize</span> <span class="o">=</span> <span class="n">mmu_vmalloc_psize</span> <span class="o">=</span> <span class="n">MMU_PAGE_4K</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SPU_BASE</span>
			<span class="n">spu_flush_all_slbs</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_region</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">psize</span> <span class="o">!=</span> <span class="n">get_paca_psize</span><span class="p">(</span><span class="n">ea</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">get_paca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
			<span class="n">slb_flush_and_rebolt</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">get_paca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">vmalloc_sllp</span> <span class="o">!=</span>
		   <span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">mmu_vmalloc_psize</span><span class="p">].</span><span class="n">sllp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_paca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">vmalloc_sllp</span> <span class="o">=</span>
			<span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">mmu_vmalloc_psize</span><span class="p">].</span><span class="n">sllp</span><span class="p">;</span>
		<span class="n">slb_vmalloc_update</span><span class="p">();</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_64K_PAGES */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PPC_HAS_HASH_64K</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psize</span> <span class="o">==</span> <span class="n">MMU_PAGE_64K</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">__hash_page_64K</span><span class="p">(</span><span class="n">ea</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">vsid</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">trap</span><span class="p">,</span> <span class="n">local</span><span class="p">,</span> <span class="n">ssize</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_HAS_HASH_64K */</span><span class="cp"></span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">spp</span> <span class="o">=</span> <span class="n">subpage_protection</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">ea</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">access</span> <span class="o">&amp;</span> <span class="n">spp</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">__hash_page_4K</span><span class="p">(</span><span class="n">ea</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">vsid</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">trap</span><span class="p">,</span>
					    <span class="n">local</span><span class="p">,</span> <span class="n">ssize</span><span class="p">,</span> <span class="n">spp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Dump some info in case of hash insertion failure, they should</span>
<span class="cm">	 * never happen so it is really useful to know if/when they do</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">hash_failure_debug</span><span class="p">(</span><span class="n">ea</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">vsid</span><span class="p">,</span> <span class="n">trap</span><span class="p">,</span> <span class="n">ssize</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span>
				   <span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">));</span>
<span class="cp">#ifndef CONFIG_PPC_64K_PAGES</span>
	<span class="n">DBG_LOW</span><span class="p">(</span><span class="s">&quot; o-pte: %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="n">DBG_LOW</span><span class="p">(</span><span class="s">&quot; o-pte: %016lx %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">),</span>
		<span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ptep</span> <span class="o">+</span> <span class="n">PTRS_PER_PTE</span><span class="p">)));</span>
<span class="cp">#endif</span>
	<span class="n">DBG_LOW</span><span class="p">(</span><span class="s">&quot; -&gt; rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">hash_page</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">hash_preload</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ea</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">access</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vsid</span><span class="p">;</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">ssize</span><span class="p">,</span> <span class="n">local</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">REGION_ID</span><span class="p">(</span><span class="n">ea</span><span class="p">)</span> <span class="o">!=</span> <span class="n">USER_REGION_ID</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC_MM_SLICES</span>
	<span class="cm">/* We only prefault standard pages for now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">get_slice_psize</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">ea</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">user_psize</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">DBG_LOW</span><span class="p">(</span><span class="s">&quot;hash_preload(mm=%p, mm-&gt;pgdir=%p, ea=%016lx, access=%lx,&quot;</span>
		<span class="s">&quot; trap=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">,</span> <span class="n">ea</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">trap</span><span class="p">);</span>

	<span class="cm">/* Get Linux PTE if available */</span>
	<span class="n">pgdir</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgdir</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ptep</span> <span class="o">=</span> <span class="n">find_linux_pte</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">ea</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptep</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC_64K_PAGES</span>
	<span class="cm">/* If either _PAGE_4K_PFN or _PAGE_NO_CACHE is set (and we are on</span>
<span class="cm">	 * a 64K kernel), then we don&#39;t preload, hash_page() will take</span>
<span class="cm">	 * care of it once we actually try to access the page.</span>
<span class="cm">	 * That way we don&#39;t have to duplicate all of the logic for segment</span>
<span class="cm">	 * page size demotion here</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_PAGE_4K_PFN</span> <span class="o">|</span> <span class="n">_PAGE_NO_CACHE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_64K_PAGES */</span><span class="cp"></span>

	<span class="cm">/* Get VSID */</span>
	<span class="n">ssize</span> <span class="o">=</span> <span class="n">user_segment_size</span><span class="p">(</span><span class="n">ea</span><span class="p">);</span>
	<span class="n">vsid</span> <span class="o">=</span> <span class="n">get_vsid</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">ea</span><span class="p">,</span> <span class="n">ssize</span><span class="p">);</span>

	<span class="cm">/* Hash doesn&#39;t like irqs */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Is that local to this CPU ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_equal</span><span class="p">(</span><span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">),</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">())))</span>
		<span class="n">local</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Hash it in */</span>
<span class="cp">#ifdef CONFIG_PPC_HAS_HASH_64K</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">user_psize</span> <span class="o">==</span> <span class="n">MMU_PAGE_64K</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">__hash_page_64K</span><span class="p">(</span><span class="n">ea</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">vsid</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">trap</span><span class="p">,</span> <span class="n">local</span><span class="p">,</span> <span class="n">ssize</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_HAS_HASH_64K */</span><span class="cp"></span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">__hash_page_4K</span><span class="p">(</span><span class="n">ea</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">vsid</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">trap</span><span class="p">,</span> <span class="n">local</span><span class="p">,</span> <span class="n">ssize</span><span class="p">,</span>
				    <span class="n">subpage_protection</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">ea</span><span class="p">));</span>

	<span class="cm">/* Dump some info in case of hash insertion failure, they should</span>
<span class="cm">	 * never happen so it is really useful to know if/when they do</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">hash_failure_debug</span><span class="p">(</span><span class="n">ea</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">vsid</span><span class="p">,</span> <span class="n">trap</span><span class="p">,</span> <span class="n">ssize</span><span class="p">,</span>
				   <span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">user_psize</span><span class="p">,</span> <span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">));</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* WARNING: This is called from hash_low_64.S, if you change this prototype,</span>
<span class="cm"> *          do not forget to update the assembly call site !</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">flush_hash_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span><span class="p">,</span> <span class="n">real_pte_t</span> <span class="n">pte</span><span class="p">,</span> <span class="kt">int</span> <span class="n">psize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ssize</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">hidx</span><span class="p">,</span> <span class="n">slot</span><span class="p">;</span>

	<span class="n">DBG_LOW</span><span class="p">(</span><span class="s">&quot;flush_hash_page(va=%016lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">va</span><span class="p">);</span>
	<span class="n">pte_iterate_hashed_subpages</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">hpt_hash</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">ssize</span><span class="p">);</span>
		<span class="n">hidx</span> <span class="o">=</span> <span class="n">__rpte_to_hidx</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hidx</span> <span class="o">&amp;</span> <span class="n">_PTEIDX_SECONDARY</span><span class="p">)</span>
			<span class="n">hash</span> <span class="o">=</span> <span class="o">~</span><span class="n">hash</span><span class="p">;</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="n">htab_hash_mask</span><span class="p">)</span> <span class="o">*</span> <span class="n">HPTES_PER_GROUP</span><span class="p">;</span>
		<span class="n">slot</span> <span class="o">+=</span> <span class="n">hidx</span> <span class="o">&amp;</span> <span class="n">_PTEIDX_GROUP_IX</span><span class="p">;</span>
		<span class="n">DBG_LOW</span><span class="p">(</span><span class="s">&quot; sub %ld: hash=%lx, hidx=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">hidx</span><span class="p">);</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_invalidate</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">ssize</span><span class="p">,</span> <span class="n">local</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">pte_iterate_hashed_end</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">flush_hash_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">number</span><span class="p">,</span> <span class="kt">int</span> <span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">flush_hash_range</span><span class="p">)</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">flush_hash_range</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">local</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ppc64_tlb_batch</span> <span class="o">*</span><span class="n">batch</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ppc64_tlb_batch</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">flush_hash_page</span><span class="p">(</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">batch</span><span class="o">-&gt;</span><span class="n">pte</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="n">batch</span><span class="o">-&gt;</span><span class="n">psize</span><span class="p">,</span> <span class="n">batch</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">,</span> <span class="n">local</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * low_hash_fault is called when we the low level hash code failed</span>
<span class="cm"> * to instert a PTE due to an hypervisor error</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">low_hash_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_PPC_SUBPAGE_PROT</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
			<span class="n">_exception</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">SEGV_ACCERR</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">else</span>
<span class="cp">#endif</span>
			<span class="n">_exception</span><span class="p">(</span><span class="n">SIGBUS</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">BUS_ADRERR</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">bad_page_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">SIGBUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kernel_map_linear_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lmi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">,</span> <span class="n">hpteg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vsid</span> <span class="o">=</span> <span class="n">get_kernel_vsid</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">mmu_kernel_ssize</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span> <span class="o">=</span> <span class="n">hpt_va</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">vsid</span><span class="p">,</span> <span class="n">mmu_kernel_ssize</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">htab_convert_pte_flags</span><span class="p">(</span><span class="n">PAGE_KERNEL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">hpt_hash</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">mmu_kernel_ssize</span><span class="p">);</span>
	<span class="n">hpteg</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="n">htab_hash_mask</span><span class="p">)</span> <span class="o">*</span> <span class="n">HPTES_PER_GROUP</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_insert</span><span class="p">(</span><span class="n">hpteg</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">vaddr</span><span class="p">),</span>
				 <span class="n">mode</span><span class="p">,</span> <span class="n">HPTE_V_BOLTED</span><span class="p">,</span>
				 <span class="n">mmu_linear_psize</span><span class="p">,</span> <span class="n">mmu_kernel_ssize</span><span class="p">);</span>
	<span class="n">BUG_ON</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">linear_map_hash_lock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">linear_map_hash_slots</span><span class="p">[</span><span class="n">lmi</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">);</span>
	<span class="n">linear_map_hash_slots</span><span class="p">[</span><span class="n">lmi</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">|</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">linear_map_hash_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kernel_unmap_linear_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lmi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">,</span> <span class="n">hidx</span><span class="p">,</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vsid</span> <span class="o">=</span> <span class="n">get_kernel_vsid</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">mmu_kernel_ssize</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span> <span class="o">=</span> <span class="n">hpt_va</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">vsid</span><span class="p">,</span> <span class="n">mmu_kernel_ssize</span><span class="p">);</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">hpt_hash</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">mmu_kernel_ssize</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">linear_map_hash_lock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">linear_map_hash_slots</span><span class="p">[</span><span class="n">lmi</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">));</span>
	<span class="n">hidx</span> <span class="o">=</span> <span class="n">linear_map_hash_slots</span><span class="p">[</span><span class="n">lmi</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="n">linear_map_hash_slots</span><span class="p">[</span><span class="n">lmi</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">linear_map_hash_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hidx</span> <span class="o">&amp;</span> <span class="n">_PTEIDX_SECONDARY</span><span class="p">)</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="o">~</span><span class="n">hash</span><span class="p">;</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="n">htab_hash_mask</span><span class="p">)</span> <span class="o">*</span> <span class="n">HPTES_PER_GROUP</span><span class="p">;</span>
	<span class="n">slot</span> <span class="o">+=</span> <span class="n">hidx</span> <span class="o">&amp;</span> <span class="n">_PTEIDX_GROUP_IX</span><span class="p">;</span>
	<span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_invalidate</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">mmu_linear_psize</span><span class="p">,</span> <span class="n">mmu_kernel_ssize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kernel_map_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">lmi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numpages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">page</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">lmi</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">vaddr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lmi</span> <span class="o">&gt;=</span> <span class="n">linear_map_hash_count</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
			<span class="n">kernel_map_linear_page</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">lmi</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">kernel_unmap_linear_page</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">lmi</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_PAGEALLOC */</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">setup_initial_memory_limit</span><span class="p">(</span><span class="n">phys_addr_t</span> <span class="n">first_memblock_base</span><span class="p">,</span>
				<span class="n">phys_addr_t</span> <span class="n">first_memblock_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We don&#39;t currently support the first MEMBLOCK not mapping 0</span>
<span class="cm">	 * physical on those processors</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">first_memblock_base</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* On LPAR systems, the first entry is our RMA region,</span>
<span class="cm">	 * non-LPAR 64-bit hash MMU systems don&#39;t have a limitation</span>
<span class="cm">	 * on real mode access, but using the first entry works well</span>
<span class="cm">	 * enough. We also clamp it to 1G to avoid some funky things</span>
<span class="cm">	 * such as RTAS bugs etc...</span>
<span class="cm">	 */</span>
	<span class="n">ppc64_rma_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">first_memblock_size</span><span class="p">,</span> <span class="mh">0x40000000</span><span class="p">);</span>

	<span class="cm">/* Finally limit subsequent allocations */</span>
	<span class="n">memblock_set_current_limit</span><span class="p">(</span><span class="n">ppc64_rma_size</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
