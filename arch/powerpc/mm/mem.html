<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › mm › mem.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mem.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  PowerPC version</span>
<span class="cm"> *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)</span>
<span class="cm"> *</span>
<span class="cm"> *  Modifications by Paul Mackerras (PowerMac) (paulus@cs.anu.edu.au)</span>
<span class="cm"> *  and Cort Dougan (PReP) (cort@cs.nmt.edu)</span>
<span class="cm"> *    Copyright (C) 1996 Paul Mackerras</span>
<span class="cm"> *  PPC44x/36-bit changes by Matt Porter (mporter@mvista.com)</span>
<span class="cm"> *</span>
<span class="cm"> *  Derived from &quot;arch/i386/mm/init.c&quot;</span>
<span class="cm"> *    Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or</span>
<span class="cm"> *  modify it under the terms of the GNU General Public License</span>
<span class="cm"> *  as published by the Free Software Foundation; either version</span>
<span class="cm"> *  2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/initrd.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/suspend.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/mmu.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/btext.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/sparsemem.h&gt;</span>
<span class="cp">#include &lt;asm/vdso.h&gt;</span>
<span class="cp">#include &lt;asm/fixmap.h&gt;</span>
<span class="cp">#include &lt;asm/swiotlb.h&gt;</span>
<span class="cp">#include &lt;asm/rtas.h&gt;</span>

<span class="cp">#include &quot;mmu_decl.h&quot;</span>

<span class="cp">#ifndef CPU_FTR_COHERENT_ICACHE</span>
<span class="cp">#define CPU_FTR_COHERENT_ICACHE	0	</span><span class="cm">/* XXX for now */</span><span class="cp"></span>
<span class="cp">#define CPU_FTR_NOEXECUTE	0</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">init_bootmem_done</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">mem_init_done</span><span class="p">;</span>
<span class="n">phys_addr_t</span> <span class="n">memory_limit</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
<span class="n">pte_t</span> <span class="o">*</span><span class="n">kmap_pte</span><span class="p">;</span>
<span class="n">pgprot_t</span> <span class="n">kmap_prot</span><span class="p">;</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmap_prot</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmap_pte</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="o">*</span><span class="nf">virt_to_kpte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">vaddr</span><span class="p">),</span>
			<span class="n">vaddr</span><span class="p">),</span> <span class="n">vaddr</span><span class="p">),</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">page_is_ram</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef CONFIG_PPC64	</span><span class="cm">/* XXX for now */</span><span class="cp"></span>
	<span class="k">return</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">max_pfn</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>

	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">paddr</span> <span class="o">&gt;=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">&amp;&amp;</span> <span class="n">paddr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="n">pgprot_t</span> <span class="nf">phys_mem_access_prot</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">vma_prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">phys_mem_access_prot</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ppc_md</span><span class="p">.</span><span class="n">phys_mem_access_prot</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">vma_prot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_is_ram</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
		<span class="n">vma_prot</span> <span class="o">=</span> <span class="n">pgprot_noncached</span><span class="p">(</span><span class="n">vma_prot</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">vma_prot</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">phys_mem_access_prot</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MEMORY_HOTPLUG</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="kt">int</span> <span class="nf">memory_add_physaddr_to_nid</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hot_add_scn_to_nid</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">arch_add_memory</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">pgdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">pgdata</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>

	<span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">create_section_mapping</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* this should work for most non-highmem platforms */</span>
	<span class="n">zone</span> <span class="o">=</span> <span class="n">pgdata</span><span class="o">-&gt;</span><span class="n">node_zones</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__add_pages</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MEMORY_HOTPLUG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * walk_memory_resource() needs to make sure there is no holes in a given</span>
<span class="cm"> * memory range.  PPC64 does not maintain the memory layout in /proc/iomem.</span>
<span class="cm"> * Instead it maintains it in memblock.memory structures.  Walk through the</span>
<span class="cm"> * memory regions, find holes and callback for contiguous regions.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">walk_system_ram_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span> <span class="o">=</span> <span class="n">start_pfn</span> <span class="o">+</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tstart</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">start_pfn</span><span class="p">,</span> <span class="n">memblock_region_memory_base_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">));</span>
		<span class="n">tend</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">end_pfn</span><span class="p">,</span> <span class="n">memblock_region_memory_end_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tstart</span> <span class="o">&gt;=</span> <span class="n">tend</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">walk_system_ram_range</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the bootmem system and give it all the memory we</span>
<span class="cm"> * have available.  If we are using highmem, we only put the</span>
<span class="cm"> * lowmem into the bootmem system.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_NEED_MULTIPLE_NODES</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">do_init_bootmem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">bootmap_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">boot_mapsize</span><span class="p">;</span>

	<span class="n">max_low_pfn</span> <span class="o">=</span> <span class="n">max_pfn</span> <span class="o">=</span> <span class="n">memblock_end_of_DRAM</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">total_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">memblock_end_of_DRAM</span><span class="p">()</span> <span class="o">-</span> <span class="n">memstart_addr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="n">total_pages</span> <span class="o">=</span> <span class="n">total_lowmem</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">max_low_pfn</span> <span class="o">=</span> <span class="n">lowmem_end_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find an area to use for the bootmem bitmap.  Calculate the size of</span>
<span class="cm">	 * bitmap required as (Total Memory) / PAGE_SIZE / BITS_PER_BYTE.</span>
<span class="cm">	 * Add 1 additional page in case the address isn&#39;t page-aligned.</span>
<span class="cm">	 */</span>
	<span class="n">bootmap_pages</span> <span class="o">=</span> <span class="n">bootmem_bootmap_pages</span><span class="p">(</span><span class="n">total_pages</span><span class="p">);</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">memblock_alloc</span><span class="p">(</span><span class="n">bootmap_pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">min_low_pfn</span> <span class="o">=</span> <span class="n">MEMORY_START</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">boot_mapsize</span> <span class="o">=</span> <span class="n">init_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">min_low_pfn</span><span class="p">,</span> <span class="n">max_low_pfn</span><span class="p">);</span>

	<span class="cm">/* Add active regions with valid PFNs */</span>
	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">;</span>
		<span class="n">start_pfn</span> <span class="o">=</span> <span class="n">memblock_region_memory_base_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">end_pfn</span> <span class="o">=</span> <span class="n">memblock_region_memory_end_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">memblock_set_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">phys_addr_t</span><span class="p">)</span><span class="n">ULLONG_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Add all physical memory to the bootmem map, mark each area</span>
<span class="cm">	 * present.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="n">free_bootmem_with_active_regions</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lowmem_end_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="cm">/* reserve the sections we&#39;re already using */</span>
	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">reserved</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">top</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">top</span> <span class="o">&lt;</span> <span class="n">lowmem_end_addr</span><span class="p">)</span>
			<span class="n">reserve_bootmem</span><span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">BOOTMEM_DEFAULT</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">&lt;</span> <span class="n">lowmem_end_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trunc_size</span> <span class="o">=</span> <span class="n">lowmem_end_addr</span> <span class="o">-</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
			<span class="n">reserve_bootmem</span><span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">trunc_size</span><span class="p">,</span> <span class="n">BOOTMEM_DEFAULT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">free_bootmem_with_active_regions</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_pfn</span><span class="p">);</span>

	<span class="cm">/* reserve the sections we&#39;re already using */</span>
	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">reserved</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
		<span class="n">reserve_bootmem</span><span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">BOOTMEM_DEFAULT</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/* XXX need to clip this if using highmem? */</span>
	<span class="n">sparse_memory_present_with_active_regions</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">init_bootmem_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* mark pages that don&#39;t exist as nosave */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">mark_nonram_nosave</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span>
		    <span class="n">memblock_region_memory_end_pfn</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">memblock_region_memory_base_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">))</span>
			<span class="n">register_nosave_region</span><span class="p">(</span><span class="n">memblock_region_memory_end_pfn</span><span class="p">(</span><span class="n">prev</span><span class="p">),</span>
					       <span class="n">memblock_region_memory_base_pfn</span><span class="p">(</span><span class="n">reg</span><span class="p">));</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">reg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * paging_init() sets up the page tables - in fact we&#39;ve already done this.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">paging_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">total_ram</span> <span class="o">=</span> <span class="n">memblock_phys_mem_size</span><span class="p">();</span>
	<span class="n">phys_addr_t</span> <span class="n">top_of_ram</span> <span class="o">=</span> <span class="n">memblock_end_of_DRAM</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span>

<span class="cp">#ifdef CONFIG_PPC32</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span> <span class="o">=</span> <span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">__end_of_fixed_addresses</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">FIX_HOLE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">v</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">map_page</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* XXX gross */</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="n">map_page</span><span class="p">(</span><span class="n">PKMAP_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* XXX gross */</span>
	<span class="n">pkmap_page_table</span> <span class="o">=</span> <span class="n">virt_to_kpte</span><span class="p">(</span><span class="n">PKMAP_BASE</span><span class="p">);</span>

	<span class="n">kmap_pte</span> <span class="o">=</span> <span class="n">virt_to_kpte</span><span class="p">(</span><span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">FIX_KMAP_BEGIN</span><span class="p">));</span>
	<span class="n">kmap_prot</span> <span class="o">=</span> <span class="n">PAGE_KERNEL</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HIGHMEM */</span><span class="cp"></span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Top of RAM: 0x%llx, Total RAM: 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">top_of_ram</span><span class="p">,</span> <span class="n">total_ram</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Memory hole size: %ldMB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">long</span> <span class="kt">int</span><span class="p">)((</span><span class="n">top_of_ram</span> <span class="o">-</span> <span class="n">total_ram</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">max_zone_pfns</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">max_zone_pfns</span><span class="p">));</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">ZONE_DMA</span><span class="p">]</span> <span class="o">=</span> <span class="n">lowmem_end_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">ZONE_HIGHMEM</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_of_ram</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">ZONE_DMA</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_of_ram</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">free_area_init_nodes</span><span class="p">(</span><span class="n">max_zone_pfns</span><span class="p">);</span>

	<span class="n">mark_nonram_nosave</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* ! CONFIG_NEED_MULTIPLE_NODES */</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">mem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NEED_MULTIPLE_NODES</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reservedpages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">codesize</span><span class="p">,</span> <span class="n">initsize</span><span class="p">,</span> <span class="n">datasize</span><span class="p">,</span> <span class="n">bsssize</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SWIOTLB</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_swiotlb_enable</span><span class="p">)</span>
		<span class="n">swiotlb_init</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">num_physpages</span> <span class="o">=</span> <span class="n">memblock_phys_mem_size</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">high_memory</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">__va</span><span class="p">(</span><span class="n">max_low_pfn</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NEED_MULTIPLE_NODES</span>
        <span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;freeing bootmem node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
			<span class="n">totalram_pages</span> <span class="o">+=</span>
				<span class="n">free_all_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">max_mapnr</span> <span class="o">=</span> <span class="n">max_pfn</span><span class="p">;</span>
	<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="n">free_all_bootmem</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">for_each_online_pgdat</span><span class="p">(</span><span class="n">pgdat</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">pgdat_page_nr</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">reservedpages</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">codesize</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_sdata</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_stext</span><span class="p">;</span>
	<span class="n">datasize</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_edata</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_sdata</span><span class="p">;</span>
	<span class="n">initsize</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__init_end</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__init_begin</span><span class="p">;</span>
	<span class="n">bsssize</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__bss_stop</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__bss_start</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">highmem_mapnr</span><span class="p">;</span>

		<span class="n">highmem_mapnr</span> <span class="o">=</span> <span class="n">lowmem_end_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">highmem_mapnr</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">max_mapnr</span><span class="p">;</span> <span class="o">++</span><span class="n">pfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phys_addr_t</span> <span class="n">paddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">phys_addr_t</span><span class="p">)</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memblock_is_reserved</span><span class="p">(</span><span class="n">paddr</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">init_page_count</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">totalhigh_pages</span><span class="o">++</span><span class="p">;</span>
			<span class="n">reservedpages</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="n">totalhigh_pages</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;High memory: %luk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">totalhigh_pages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HIGHMEM */</span><span class="cp"></span>

<span class="cp">#if defined(CONFIG_PPC_FSL_BOOK3E) &amp;&amp; !defined(CONFIG_SMP)</span>
	<span class="cm">/*</span>
<span class="cm">	 * If smp is enabled, next_tlbcam_idx is initialized in the cpu up</span>
<span class="cm">	 * functions.... do it here for the non-smp case.</span>
<span class="cm">	 */</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">next_tlbcam_idx</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_TLB1CFG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TLBnCFG_N_ENTRY</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Memory: %luk/%luk available (%luk kernel code, &quot;</span>
	       <span class="s">&quot;%luk reserved, %luk data, %luk bss, %luk init)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">nr_free_pages</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="n">num_physpages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="n">codesize</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">reservedpages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="n">datasize</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">bsssize</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">initsize</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC32</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Kernel virtual memory layout:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;  * 0x%08lx..0x%08lx  : fixmap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">FIXADDR_START</span><span class="p">,</span> <span class="n">FIXADDR_TOP</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;  * 0x%08lx..0x%08lx  : highmem PTEs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">PKMAP_BASE</span><span class="p">,</span> <span class="n">PKMAP_ADDR</span><span class="p">(</span><span class="n">LAST_PKMAP</span><span class="p">));</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HIGHMEM */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_NOT_COHERENT_CACHE</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;  * 0x%08lx..0x%08lx  : consistent mem</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">IOREMAP_TOP</span><span class="p">,</span> <span class="n">IOREMAP_TOP</span> <span class="o">+</span> <span class="n">CONFIG_CONSISTENT_SIZE</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NOT_COHERENT_CACHE */</span><span class="cp"></span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;  * 0x%08lx..0x%08lx  : early ioremap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ioremap_bot</span><span class="p">,</span> <span class="n">IOREMAP_TOP</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;  * 0x%08lx..0x%08lx  : vmalloc &amp; ioremap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">VMALLOC_START</span><span class="p">,</span> <span class="n">VMALLOC_END</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC32 */</span><span class="cp"></span>

	<span class="n">mem_init_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_initmem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span> <span class="o">=</span> <span class="n">ppc_printk_progress</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__init_begin</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__init_end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">POISON_FREE_INITMEM</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
		<span class="n">init_page_count</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
		<span class="n">free_page</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">totalram_pages</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Freeing unused kernel memory: %luk freed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__init_end</span> <span class="o">-</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__init_begin</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">free_initrd_mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">_ALIGN_DOWN</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">_ALIGN_UP</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Freeing initrd memory: %ldk freed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">start</span><span class="p">));</span>
		<span class="n">init_page_count</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">start</span><span class="p">));</span>
		<span class="n">free_page</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="n">totalram_pages</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * This is called when a page has been modified by the kernel.</span>
<span class="cm"> * It just marks the page as not i-cache clean.  We do the i-cache</span>
<span class="cm"> * flush later when the page is given to a user process, if necessary.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">flush_dcache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_COHERENT_ICACHE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* avoid an atomic op if possible */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">PG_arch_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">PG_arch_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">flush_dcache_page</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">flush_dcache_icache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">flush_dcache_icache_hugepage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_BOOKE</span>
	<span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">__flush_dcache_icache</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#elif defined(CONFIG_8xx) || defined(CONFIG_PPC64)</span>
	<span class="cm">/* On 8xx there is no need to kmap since highmem is not supported */</span>
	<span class="n">__flush_dcache_icache</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">));</span> 
<span class="cp">#else</span>
	<span class="n">__flush_dcache_icache_phys</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">clear_user_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We shouldn&#39;t have to do this, but some versions of glibc</span>
<span class="cm">	 * require it (ld.so assumes zero filled pages are icache clean)</span>
<span class="cm">	 * - Anton</span>
<span class="cm">	 */</span>
	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">pg</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">clear_user_page</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">copy_user_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vto</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vfrom</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">copy_page</span><span class="p">(</span><span class="n">vto</span><span class="p">,</span> <span class="n">vfrom</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We should be able to use the following optimisation, however</span>
<span class="cm">	 * there are two problems.</span>
<span class="cm">	 * Firstly a bug in some versions of binutils meant PLT sections</span>
<span class="cm">	 * were not marked executable.</span>
<span class="cm">	 * Secondly the first word in the GOT section is blrl, used</span>
<span class="cm">	 * to establish the GOT address. Until recently the GOT was</span>
<span class="cm">	 * not marked executable.</span>
<span class="cm">	 * - Anton</span>
<span class="cm">	 */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	if (!vma-&gt;vm_file &amp;&amp; ((vma-&gt;vm_flags &amp; VM_EXEC) == 0))</span>
<span class="c">		return;</span>
<span class="cp">#endif</span>

	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">pg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">flush_icache_user_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maddr</span><span class="p">;</span>

	<span class="n">maddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">);</span>
	<span class="n">flush_icache_range</span><span class="p">(</span><span class="n">maddr</span><span class="p">,</span> <span class="n">maddr</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">flush_icache_user_range</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This is called at the end of handling a user page fault, when the</span>
<span class="cm"> * fault has been handled by updating a PTE in the linux page tables.</span>
<span class="cm"> * We use it to preload an HPTE into the hash table corresponding to</span>
<span class="cm"> * the updated linux PTE.</span>
<span class="cm"> * </span>
<span class="cm"> * This must always be called with the pte lock held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">update_mmu_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		      <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PPC_STD_MMU</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">access</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trap</span><span class="p">;</span>

	<span class="cm">/* We only want HPTEs for linux PTEs that have _PAGE_ACCESSED set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_young</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">||</span> <span class="n">address</span> <span class="o">&gt;=</span> <span class="n">TASK_SIZE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* We try to figure out if we are coming from an instruction</span>
<span class="cm">	 * access fault and pass that down to __hash_page so we avoid</span>
<span class="cm">	 * double-faulting on execution of fresh text. We have to test</span>
<span class="cm">	 * for regs NULL since init will get here first thing at boot</span>
<span class="cm">	 *</span>
<span class="cm">	 * We also avoid filling the hash if not coming from a fault</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">trap</span> <span class="o">=</span> <span class="n">TRAP</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trap</span> <span class="o">==</span> <span class="mh">0x400</span><span class="p">)</span>
		<span class="n">access</span> <span class="o">|=</span> <span class="n">_PAGE_EXEC</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">trap</span> <span class="o">!=</span> <span class="mh">0x300</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">hash_preload</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">trap</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_STD_MMU */</span><span class="cp"></span>
<span class="cp">#if (defined(CONFIG_PPC_BOOK3E_64) || defined(CONFIG_PPC_FSL_BOOK3E)) \</span>
<span class="cp">	&amp;&amp; defined(CONFIG_HUGETLB_PAGE)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
		<span class="n">book3e_hugetlb_preload</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">*</span><span class="n">ptep</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * System memory should not be in /proc/iomem but various tools expect it</span>
<span class="cm"> * (eg kdump).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_system_ram_resources</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>

	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;System RAM&quot;</span><span class="p">;</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">;</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">request_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">add_system_ram_resources</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_STRICT_DEVMEM</span>
<span class="cm">/*</span>
<span class="cm"> * devmem_is_allowed(): check to see if /dev/mem access to a certain address</span>
<span class="cm"> * is valid. The argument is a physical page number.</span>
<span class="cm"> *</span>
<span class="cm"> * Access has to be given to non-kernel-ram areas as well, these contain the</span>
<span class="cm"> * PCI mmio resources as well as potential bios/acpi data regions.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">devmem_is_allowed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iomem_is_exclusive</span><span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_is_ram</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_is_rtas_user_buf</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_STRICT_DEVMEM */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
