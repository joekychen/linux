f | devres.c | s | 1.1K | 38 | Paul Gortmaker | paul.gortmaker@windriver.com | 1320103844 |  | powerpc: various straight conversions from module.h --> export.h  All these files were including module.h just for the basic EXPORT_SYMBOL infrastructure.  We can shift them off to the export.h header which is a way smaller footprint and thus realize some compile time gains.  Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
f | Makefile | g | 942B |  | Anton Blanchard | anton@samba.org | 1324266040 |  | powerpc: POWER7 optimised copy_to_user/copy_from_user using VMX  Implement a POWER7 optimised copy_to_user/copy_from_user using VMX. For large aligned copies this new loop is over 10% faster, and for large unaligned copies it is over 200% faster.  If we take a fault we fall back to the old version, this keeps things relatively simple and easy to verify.  On POWER7 unaligned stores rarely slow down - they only flush when a store crosses a 4KB page boundary. Furthermore this flush is handled completely in hardware and should be 20-30 cycles.  Unaligned loads on the other hand flush much more often - whenever crossing a 128 byte cache line, or a 32 byte sector if either sector is an L1 miss.  Considering this information we really want to get the loads aligned and not worry about the alignment of the stores. Microbenchmarks confirm that this approach is much faster than the current unaligned copy loop that uses shifts and rotates to ensure both loads and stores are aligned.  We also want to try and do the stores in cacheline aligned, cacheline sized chunks. If the store queue is unable to merge an entire cacheline of stores then the L2 cache will have to do a read/modify/write. Even worse, we will serialise this with the stores in the next iteration of the copy loop since both iterations hit the same cacheline.  Based on this, the new loop does the following things:  1 - 127 bytes Get the source 8 byte aligned and use 8 byte loads and stores. Pretty boring and similar to how the current loop works.  128 - 4095 bytes Get the source 8 byte aligned and use 8 byte loads and stores, 1 cacheline at a time. We aren't doing the stores in cacheline aligned chunks so we will potentially serialise once per cacheline. Even so it is much better than the loop we have today.  4096 - bytes If both source and destination have the same alignment get them both 16 byte aligned, then get the destination cacheline aligned. Do cacheline sized loads and stores using VMX.  If source and destination do not have the same alignment, we get the destination cacheline aligned, and use permute to do aligned loads.  In both cases the VMX loop should be optimal - we always do aligned loads and stores and are always doing stores in cacheline aligned, cacheline sized chunks.  To be able to use VMX we must be careful about interrupts and sleeping. We don't use the VMX loop when in an interrupt (which should be rare anyway) and we wrap the VMX loop in disable/enable_pagefault and fall back to the existing copy_tofrom_user loop if we do need to sleep.  The VMX breakpoint of 4096 bytes was chosen using this microbenchmark:  http://ozlabs.org/~anton/junkcode/copy_to_user.c  Since we are using VMX and there is a cost to saving and restoring the user VMX state there are two broad cases we need to benchmark:  - Best case - userspace never uses VMX  - Worst case - userspace always uses VMX  In reality a userspace process will sit somewhere between these two extremes. Since we need to test both aligned and unaligned copies we end up with 4 combinations. The point at which the VMX loop begins to win is:  0% VMX aligned		2048 bytes unaligned	2048 bytes  100% VMX aligned		16384 bytes unaligned	8192 bytes  Considering this is a microbenchmark, the data is hot in cache and the VMX loop has better store queue merging properties we set the breakpoint to 4096 bytes, a little below the unaligned breakpoints.  Some future optimisations we can look at:  - Looking at the perf data, a significant part of the cost when a   task is always using VMX is the extra exception we take to restore   the VMX state. As such we should do something similar to the x86   optimisation that restores FPU state for heavy users. ie:          /*          * If the task has used fpu the last 5 timeslices, just do a full          * restore of the math state immediately to avoid the trap; the          * chances of needing FPU soon are obviously high now          */         preload_fpu = tsk_used_math(next_p) && next_p->fpu_counter > 5;    and          /*          * fpu_counter contains the number of consecutive context switches          * that the FPU is used. If this is over a threshold, the lazy fpu          * saving becomes unlazy to save the trap. This is an unsigned char          * so that after 256 times the counter wraps and the behavior turns          * lazy again; this to deal with bursty apps that only use FPU for          * a short time          */  - We could create a paca bit to mirror the VMX enabled MSR bit and check   that first, avoiding multiple calls to calling enable_kernel_altivec.   That should help with iovec based system calls like readv.  - We could have two VMX breakpoints, one for when we know the user VMX   state is loaded into the registers and one when it isn't. This could   be a second bit in the paca so we can calculate the break points quickly.  - One suggestion from Ben was to save and restore the VSX registers   we use inline instead of using enable_kernel_altivec.  [BenH: Fixed a problem with preempt and fixed build without CONFIG_ALTIVEC]  Signed-off-by: Anton Blanchard <anton@samba.org> Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
f | copyuser_power7.S | g | 11K |  | Anton Blanchard | anton@samba.org | 1324266040 |  | powerpc: POWER7 optimised copy_to_user/copy_from_user using VMX  Implement a POWER7 optimised copy_to_user/copy_from_user using VMX. For large aligned copies this new loop is over 10% faster, and for large unaligned copies it is over 200% faster.  If we take a fault we fall back to the old version, this keeps things relatively simple and easy to verify.  On POWER7 unaligned stores rarely slow down - they only flush when a store crosses a 4KB page boundary. Furthermore this flush is handled completely in hardware and should be 20-30 cycles.  Unaligned loads on the other hand flush much more often - whenever crossing a 128 byte cache line, or a 32 byte sector if either sector is an L1 miss.  Considering this information we really want to get the loads aligned and not worry about the alignment of the stores. Microbenchmarks confirm that this approach is much faster than the current unaligned copy loop that uses shifts and rotates to ensure both loads and stores are aligned.  We also want to try and do the stores in cacheline aligned, cacheline sized chunks. If the store queue is unable to merge an entire cacheline of stores then the L2 cache will have to do a read/modify/write. Even worse, we will serialise this with the stores in the next iteration of the copy loop since both iterations hit the same cacheline.  Based on this, the new loop does the following things:  1 - 127 bytes Get the source 8 byte aligned and use 8 byte loads and stores. Pretty boring and similar to how the current loop works.  128 - 4095 bytes Get the source 8 byte aligned and use 8 byte loads and stores, 1 cacheline at a time. We aren't doing the stores in cacheline aligned chunks so we will potentially serialise once per cacheline. Even so it is much better than the loop we have today.  4096 - bytes If both source and destination have the same alignment get them both 16 byte aligned, then get the destination cacheline aligned. Do cacheline sized loads and stores using VMX.  If source and destination do not have the same alignment, we get the destination cacheline aligned, and use permute to do aligned loads.  In both cases the VMX loop should be optimal - we always do aligned loads and stores and are always doing stores in cacheline aligned, cacheline sized chunks.  To be able to use VMX we must be careful about interrupts and sleeping. We don't use the VMX loop when in an interrupt (which should be rare anyway) and we wrap the VMX loop in disable/enable_pagefault and fall back to the existing copy_tofrom_user loop if we do need to sleep.  The VMX breakpoint of 4096 bytes was chosen using this microbenchmark:  http://ozlabs.org/~anton/junkcode/copy_to_user.c  Since we are using VMX and there is a cost to saving and restoring the user VMX state there are two broad cases we need to benchmark:  - Best case - userspace never uses VMX  - Worst case - userspace always uses VMX  In reality a userspace process will sit somewhere between these two extremes. Since we need to test both aligned and unaligned copies we end up with 4 combinations. The point at which the VMX loop begins to win is:  0% VMX aligned		2048 bytes unaligned	2048 bytes  100% VMX aligned		16384 bytes unaligned	8192 bytes  Considering this is a microbenchmark, the data is hot in cache and the VMX loop has better store queue merging properties we set the breakpoint to 4096 bytes, a little below the unaligned breakpoints.  Some future optimisations we can look at:  - Looking at the perf data, a significant part of the cost when a   task is always using VMX is the extra exception we take to restore   the VMX state. As such we should do something similar to the x86   optimisation that restores FPU state for heavy users. ie:          /*          * If the task has used fpu the last 5 timeslices, just do a full          * restore of the math state immediately to avoid the trap; the          * chances of needing FPU soon are obviously high now          */         preload_fpu = tsk_used_math(next_p) && next_p->fpu_counter > 5;    and          /*          * fpu_counter contains the number of consecutive context switches          * that the FPU is used. If this is over a threshold, the lazy fpu          * saving becomes unlazy to save the trap. This is an unsigned char          * so that after 256 times the counter wraps and the behavior turns          * lazy again; this to deal with bursty apps that only use FPU for          * a short time          */  - We could create a paca bit to mirror the VMX enabled MSR bit and check   that first, avoiding multiple calls to calling enable_kernel_altivec.   That should help with iovec based system calls like readv.  - We could have two VMX breakpoints, one for when we know the user VMX   state is loaded into the registers and one when it isn't. This could   be a second bit in the paca so we can calculate the break points quickly.  - One suggestion from Ben was to save and restore the VSX registers   we use inline instead of using enable_kernel_altivec.  [BenH: Fixed a problem with preempt and fixed build without CONFIG_ALTIVEC]  Signed-off-by: Anton Blanchard <anton@samba.org> Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
f | usercopy_64.c | s | 1.1K | 36 | Paul Mackerras | paulus@samba.org | 1128945163 |  | powerpc: Rename files to have consistent _32/_64 suffixes  This doesn't change any code, just renames things so we consistently have foo_32.c and foo_64.c where we have separate 32- and 64-bit versions.  Signed-off-by: Paul Mackerras <paulus@samba.org>
f | copyuser_64.S | g | 10K |  | Anton Blanchard | anton@samba.org | 1335764246 |  | powerpc: Remove CONFIG_POWER4_ONLY  Remove CONFIG_POWER4_ONLY, the option is badly named and only does two things:  - It wraps the MMU segment table code. With feature fixups there is   little downside to compiling this in.  - It uses the newer mtocrf instruction in various assembly functions.   Instead of making this a compile option just do it at runtime via   a feature fixup.  Signed-off-by: Anton Blanchard <anton@samba.org> Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
f | feature-fixups.c | s | 11K | 307 | Anton Blanchard | anton@samba.org | 1321415274 |  | powerpc: Copy down exception vectors after feature fixups  kdump fails because we try to execute an HV only instruction. Feature fixups are being applied after we copy the exception vectors down to 0 so they miss out on any updates.  We have always had this issue but it only became critical in v3.0 when we added CFAR support (breaks POWER5) and v3.1 when we added POWERNV (breaks everyone).  Signed-off-by: Anton Blanchard <anton@samba.org> Cc: <stable@kernel.org> [v3.0+] Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
f | rheap.c | s | 16K | 602 | Paul Gortmaker | paul.gortmaker@windriver.com | 1320103844 |  | powerpc: various straight conversions from module.h --> export.h  All these files were including module.h just for the basic EXPORT_SYMBOL infrastructure.  We can shift them off to the export.h header which is a way smaller footprint and thus realize some compile time gains.  Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
f | code-patching.c | s | 12K | 361 | Andrea Righi | righi.andrea@gmail.com | 1216921641 |  | PAGE_ALIGN(): correctly handle 64-bit values on 32-bit architectures  On 32-bit architectures PAGE_ALIGN() truncates 64-bit values to the 32-bit boundary. For example:  	u64 val = PAGE_ALIGN(size);  always returns a value < 4GB even if size is greater than 4GB.  The problem resides in PAGE_MASK definition (from include/asm-x86/page.h for example):  #define PAGE_SHIFT      12 #define PAGE_SIZE       (_AC(1,UL) << PAGE_SHIFT) #define PAGE_MASK       (~(PAGE_SIZE-1)) ... #define PAGE_ALIGN(addr)       (((addr)+PAGE_SIZE-1)&PAGE_MASK)  The "~" is performed on a 32-bit value, so everything in "and" with PAGE_MASK greater than 4GB will be truncated to the 32-bit boundary. Using the ALIGN() macro seems to be the right way, because it uses typeof(addr) for the mask.  Also move the PAGE_ALIGN() definitions out of include/asm-*/page.h in include/linux/mm.h.  See also lkml discussion: http://lkml.org/lkml/2008/6/11/237  [akpm@linux-foundation.org: fix drivers/media/video/uvc/uvc_queue.c] [akpm@linux-foundation.org: fix v850] [akpm@linux-foundation.org: fix powerpc] [akpm@linux-foundation.org: fix arm] [akpm@linux-foundation.org: fix mips] [akpm@linux-foundation.org: fix drivers/media/video/pvrusb2/pvrusb2-dvb.c] [akpm@linux-foundation.org: fix drivers/mtd/maps/uclinux.c] [akpm@linux-foundation.org: fix powerpc] Signed-off-by: Andrea Righi <righi.andrea@gmail.com> Cc: <linux-arch@vger.kernel.org> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | locks.c | s | 2.2K | 73 | Stephen Rothwell | sfr@canb.auug.org.au | 1332288971 |  | powerpc: Remove FW_FEATURE ISERIES from arch code  This is no longer selectable, so just remove all the dependent code.  Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au> Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
f | sstep.c | s | 37K | 1456 | Linus Torvalds | torvalds@linux-foundation.org | 1305923281 |  | Merge branch 'merge' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc  * 'merge' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc: (152 commits)   powerpc: Fix hard CPU IDs detection   powerpc/pmac: Update via-pmu to new syscore_ops   powerpc/kvm: Fix the build for 32-bit Book 3S (classic) processors   powerpc/kvm: Fix kvmppc_core_pending_dec   powerpc: Remove last piece of GEMINI   powerpc: Fix for Pegasos keyboard and mouse   powerpc: Make early memory scan more resilient to out of order nodes   powerpc/pseries/iommu: Cleanup ddw naming   powerpc/pseries/iommu: Find windows after kexec during boot   powerpc/pseries/iommu: Remove ddw property when destroying window   powerpc/pseries/iommu: Add additional checks when changing iommu mask   powerpc/pseries/iommu: Use correct return type in dupe_ddw_if_already_created   powerpc: Remove unused/obsolete CONFIG_XICS   misc: Add CARMA DATA-FPGA Programmer support   misc: Add CARMA DATA-FPGA Access Driver   powerpc: Make IRQ_NOREQUEST last to clear, first to set   powerpc: Integrated Flash controller device tree bindings   powerpc/85xx: Create dts of each core in CAMP mode for P1020RDB   powerpc/85xx: Fix PCIe IDSEL for Px020RDB   powerpc/85xx: P2020 DTS: re-organize dts files   ...
f | ldstfp.S | g | 6.1K |  | Sean MacLennan | smaclennan@pikatech.com | 1283400454 |  | powerpc: mtmsrd not defined  Replace the BOOK3S_64 specific mtmsrd with the generic MTMSRD macro. Only enable ldstfp when CONFIG_PPC_FPU is set.  Signed-off-by: Sean MacLennan <smaclennan@pikatech.com> Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
f | div64.S | g | 1.9K |  | Paul Mackerras | paulus@samba.org | 1129765022 |  | powerpc: Fix a corner case in __div64_32  The code was incorrectly doing a division by 0 in the case where the denominator was 0x100000000 and the divisor was 0xffffffff. Thanks to Fred Liu of Motorola for pointing this out.  Signed-off-by: Paul Mackerras <paulus@samba.org>
f | alloc.c | s | 360B | 18 | David Howells | dhowells@redhat.com | 1332955802 |  | Disintegrate asm/system.h for PowerPC  Disintegrate asm/system.h for PowerPC.  Signed-off-by: David Howells <dhowells@redhat.com> Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org> cc: linuxppc-dev@lists.ozlabs.org
f | checksum_64.S | g | 8.8K |  | Anton Blanchard | anton@samba.org | 1283400450 |  | powerpc: Optimise 64bit csum_partial_copy_generic and add csum_and_copy_from_user  We use the same core loop as the new csum_partial, adding in the stores and exception handling code. To keep things simple we do all the exception fixup in csum_and_copy_from_user. This wrapper function is modelled on the generic checksum code and is careful to always calculate a complete checksum even if we only copied part of the data to userspace.  To test this I forced checksumming on over loopback and ran socklib (a simple TCP benchmark). On a POWER6 575 throughput improved by 19% with this patch. If I forced both the sender and receiver onto the same cpu (with the hope of shifting the benchmark from being cache bandwidth limited to cpu limited), adding this patch improved performance by 55%  Signed-off-by: Anton Blanchard <anton@samba.org> Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
f | memcpy_64.S | g | 3.5K |  | Anton Blanchard | anton@samba.org | 1335764246 |  | powerpc: Remove CONFIG_POWER4_ONLY  Remove CONFIG_POWER4_ONLY, the option is badly named and only does two things:  - It wraps the MMU segment table code. With feature fixups there is   little downside to compiling this in.  - It uses the newer mtocrf instruction in various assembly functions.   Instead of making this a compile option just do it at runtime via   a feature fixup.  Signed-off-by: Anton Blanchard <anton@samba.org> Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
f | crtsavres.S | g | 7.9K |  | Stephen Rothwell | sfr@canb.auug.org.au | 1278576698 |  | powerpc: Fix module building for gcc 4.5 and 64 bit  Gcc 4.5 is now generating out of line register save and restore in the function prefix and postfix when we use -Os.  Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au> Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
f | copyuser_power7_vmx.c | s | 1.5K | 46 | David Howells | dhowells@redhat.com | 1332955802 |  | Disintegrate asm/system.h for PowerPC  Disintegrate asm/system.h for PowerPC.  Signed-off-by: David Howells <dhowells@redhat.com> Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org> cc: linuxppc-dev@lists.ozlabs.org
f | copy_32.S | g | 9.2K |  | Sean MacLennan | smaclennan@pikatech.com | 1283400454 |  | powerpc: Fix incorrect .stabs entry for copy_32.S  Signed-off-by: Sean MacLennan <smaclennan@pikatech.com> Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
f | copypage_64.S | g | 2.0K |  | Anton Blanchard | anton@samba.org | 1305779442 |  | powerpc: Simplify 4k/64k copy_page logic  To make it easier to add optimised versions of copy_page, remove the 4kB loop for 64kB pages and just do all the work in copy_page.  Signed-off-by: Anton Blanchard <anton@samba.org> Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
f | mem_64.S | g | 1.9K |  | Anton Blanchard | anton@samba.org | 1335764246 |  | powerpc: Remove CONFIG_POWER4_ONLY  Remove CONFIG_POWER4_ONLY, the option is badly named and only does two things:  - It wraps the MMU segment table code. With feature fixups there is   little downside to compiling this in.  - It uses the newer mtocrf instruction in various assembly functions.   Instead of making this a compile option just do it at runtime via   a feature fixup.  Signed-off-by: Anton Blanchard <anton@samba.org> Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
f | hweight_64.S | g | 2.3K |  | Anton Blanchard | anton@samba.org | 1291869330 |  | powerpc: Hardcode popcnt instructions for old assemblers  The popcnt instructions went into binutils relatively recently. As with a number of other instructions, create macros and hardcode them.  Signed-off-by: Anton Blanchard <anton@samba.org> Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
f | checksum_wrappers_64.c | s | 2.3K | 83 | Paul Gortmaker | paul.gortmaker@windriver.com | 1320103844 |  | powerpc: various straight conversions from module.h --> export.h  All these files were including module.h just for the basic EXPORT_SYMBOL infrastructure.  We can shift them off to the export.h header which is a way smaller footprint and thus realize some compile time gains.  Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
f | string.S | g | 2.5K |  | Paul Mackerras | paulus@samba.org | 1338177607 |  | powerpc: Use the new generic strncpy_from_user() and strnlen_user()  This is much the same as for SPARC except that we can do the find_zero() function more efficiently using the count-leading-zeroes instructions. Tested on 32-bit and 64-bit PowerPC.  Signed-off-by: Paul Mackerras <paulus@samba.org> Acked-by: David S. Miller <davem@davemloft.net> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | checksum_32.S | g | 4.6K |  | Paul Mackerras | paulus@samba.org | 1128945163 |  | powerpc: Rename files to have consistent _32/_64 suffixes  This doesn't change any code, just renames things so we consistently have foo_32.c and foo_64.c where we have separate 32- and 64-bit versions.  Signed-off-by: Paul Mackerras <paulus@samba.org>
f | feature-fixups-test.S | g | 18K |  | Michael Ellerman | michael@ellerman.id.au | 1295579313 |  | powerpc: Ensure the else case of feature sections will fit  When we create an alternative feature section, the else case must be the same size or smaller than the body. This is because when we patch the else case in we just overwrite the body, so there must be room.  Up to now we just did this by inspection, but it's quite easy to enforce it in the assembler, so we should.  The only change is to add the ifgt block, but that effects the alignment of the tabs and so the whole macro is modified.  Also add a test, but #if 0 it because we don't want to break the build. Anyone who's modifying the feature macros should enable the test.  Signed-off-by: Michael Ellerman <michael@ellerman.id.au> Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
