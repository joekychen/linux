<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › platforms › powermac › smp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>smp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SMP support for power macintosh.</span>
<span class="cm"> *</span>
<span class="cm"> * We support both the old &quot;powersurge&quot; SMP architecture</span>
<span class="cm"> * and the current Core99 (G4 PowerMac) machines.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we don&#39;t support the very first rev. of</span>
<span class="cm"> * Apple/DayStar 2 CPUs board, the one with the funky</span>
<span class="cm"> * watchdog. Hopefully, none of these should be there except</span>
<span class="cm"> * maybe internally to Apple. I should probably still add some</span>
<span class="cm"> * code to detect this card though and disable SMP. --BenH.</span>
<span class="cm"> *</span>
<span class="cm"> * Support Macintosh G4 SMP by Troy Benjegerdes (hozer@drgw.net)</span>
<span class="cm"> * and Ben Herrenschmidt &lt;benh@kernel.crashing.org&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * Support for DayStar quad CPU cards</span>
<span class="cm"> * Copyright (C) XLR8, Inc. 1994-2000</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or</span>
<span class="cm"> *  modify it under the terms of the GNU General Public License</span>
<span class="cm"> *  as published by the Free Software Foundation; either version</span>
<span class="cm"> *  2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>

<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/code-patching.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/pmac_feature.h&gt;</span>
<span class="cp">#include &lt;asm/time.h&gt;</span>
<span class="cp">#include &lt;asm/mpic.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/keylargo.h&gt;</span>
<span class="cp">#include &lt;asm/pmac_low_i2c.h&gt;</span>
<span class="cp">#include &lt;asm/pmac_pfunc.h&gt;</span>

<span class="cp">#include &quot;pmac.h&quot;</span>

<span class="cp">#undef DEBUG</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define DBG(fmt...) udbg_printf(fmt)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG(fmt...)</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__secondary_start_pmac_0</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pmac_pfunc_base_install</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pmac_tb_freeze</span><span class="p">)(</span><span class="kt">int</span> <span class="n">freeze</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">timebase</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">tb_req</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC_PMAC32_PSURGE</span>

<span class="cm">/*</span>
<span class="cm"> * Powersurge (old powermac SMP) support.</span>
<span class="cm"> */</span>

<span class="cm">/* Addresses for powersurge registers */</span>
<span class="cp">#define HAMMERHEAD_BASE		0xf8000000</span>
<span class="cp">#define HHEAD_CONFIG		0x90</span>
<span class="cp">#define HHEAD_SEC_INTR		0xc0</span>

<span class="cm">/* register for interrupting the primary processor on the powersurge */</span>
<span class="cm">/* N.B. this is actually the ethernet ROM! */</span>
<span class="cp">#define PSURGE_PRI_INTR		0xf3019000</span>

<span class="cm">/* register for storing the start address for the secondary processor */</span>
<span class="cm">/* N.B. this is the PCI config space address register for the 1st bridge */</span>
<span class="cp">#define PSURGE_START		0xf2800000</span>

<span class="cm">/* Daystar/XLR8 4-CPU card */</span>
<span class="cp">#define PSURGE_QUAD_REG_ADDR	0xf8800000</span>

<span class="cp">#define PSURGE_QUAD_IRQ_SET	0</span>
<span class="cp">#define PSURGE_QUAD_IRQ_CLR	1</span>
<span class="cp">#define PSURGE_QUAD_IRQ_PRIMARY	2</span>
<span class="cp">#define PSURGE_QUAD_CKSTOP_CTL	3</span>
<span class="cp">#define PSURGE_QUAD_PRIMARY_ARB	4</span>
<span class="cp">#define PSURGE_QUAD_BOARD_ID	6</span>
<span class="cp">#define PSURGE_QUAD_WHICH_CPU	7</span>
<span class="cp">#define PSURGE_QUAD_CKSTOP_RDBK	8</span>
<span class="cp">#define PSURGE_QUAD_RESET_CTL	11</span>

<span class="cp">#define PSURGE_QUAD_OUT(r, v)	(out_8(quad_base + ((r) &lt;&lt; 4) + 4, (v)))</span>
<span class="cp">#define PSURGE_QUAD_IN(r)	(in_8(quad_base + ((r) &lt;&lt; 4) + 4) &amp; 0x0f)</span>
<span class="cp">#define PSURGE_QUAD_BIS(r, v)	(PSURGE_QUAD_OUT((r), PSURGE_QUAD_IN(r) | (v)))</span>
<span class="cp">#define PSURGE_QUAD_BIC(r, v)	(PSURGE_QUAD_OUT((r), PSURGE_QUAD_IN(r) &amp; ~(v)))</span>

<span class="cm">/* virtual addresses for the above */</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="n">u8</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hhead_base</span><span class="p">;</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="n">u8</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">quad_base</span><span class="p">;</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">psurge_pri_intr</span><span class="p">;</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="n">u8</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">psurge_sec_intr</span><span class="p">;</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">psurge_start</span><span class="p">;</span>

<span class="cm">/* values for psurge_type */</span>
<span class="cp">#define PSURGE_NONE		-1</span>
<span class="cp">#define PSURGE_DUAL		0</span>
<span class="cp">#define PSURGE_QUAD_OKEE	1</span>
<span class="cp">#define PSURGE_QUAD_COTTON	2</span>
<span class="cp">#define PSURGE_QUAD_ICEGRASS	3</span>

<span class="cm">/* what sort of powersurge board we have */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">psurge_type</span> <span class="o">=</span> <span class="n">PSURGE_NONE</span><span class="p">;</span>

<span class="cm">/* irq for secondary cpus to report */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_domain</span> <span class="o">*</span><span class="n">psurge_host</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">psurge_secondary_virq</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Set and clear IPIs for powersurge.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">psurge_set_ipi</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psurge_type</span> <span class="o">==</span> <span class="n">PSURGE_NONE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">in_be32</span><span class="p">(</span><span class="n">psurge_pri_intr</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">psurge_type</span> <span class="o">==</span> <span class="n">PSURGE_DUAL</span><span class="p">)</span>
		<span class="n">out_8</span><span class="p">(</span><span class="n">psurge_sec_intr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">PSURGE_QUAD_OUT</span><span class="p">(</span><span class="n">PSURGE_QUAD_IRQ_SET</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">psurge_clr_ipi</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">psurge_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PSURGE_DUAL</span>:
			<span class="n">out_8</span><span class="p">(</span><span class="n">psurge_sec_intr</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">PSURGE_NONE</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">PSURGE_QUAD_OUT</span><span class="p">(</span><span class="n">PSURGE_QUAD_IRQ_CLR</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * On powersurge (old SMP powermac architecture) we don&#39;t have</span>
<span class="cm"> * separate IPIs for separate messages like openpic does.  Instead</span>
<span class="cm"> * use the generic demux helpers</span>
<span class="cm"> *  -- paulus.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">psurge_ipi_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">psurge_clr_ipi</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">smp_ipi_demux</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_psurge_cause_ipi</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">psurge_set_ipi</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">psurge_host_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_domain</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">virq</span><span class="p">,</span>
			 <span class="n">irq_hw_number_t</span> <span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_set_chip_and_handler</span><span class="p">(</span><span class="n">virq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy_irq_chip</span><span class="p">,</span> <span class="n">handle_percpu_irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">irq_domain_ops</span> <span class="n">psurge_host_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">map</span>	<span class="o">=</span> <span class="n">psurge_host_map</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">psurge_secondary_ipi_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">psurge_host</span> <span class="o">=</span> <span class="n">irq_domain_add_nomap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">psurge_host_ops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">psurge_host</span><span class="p">)</span>
		<span class="n">psurge_secondary_virq</span> <span class="o">=</span> <span class="n">irq_create_direct_mapping</span><span class="p">(</span><span class="n">psurge_host</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">psurge_secondary_virq</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">psurge_secondary_virq</span><span class="p">,</span> <span class="n">psurge_ipi_intr</span><span class="p">,</span>
			<span class="n">IRQF_PERCPU</span> <span class="o">|</span> <span class="n">IRQF_NO_THREAD</span><span class="p">,</span> <span class="s">&quot;IPI&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to setup secondary cpu IPI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine a quad card presence. We read the board ID register, we</span>
<span class="cm"> * force the data bus to change to something else, and we read it again.</span>
<span class="cm"> * It it&#39;s stable, then the register probably exist (ugh !)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">psurge_quad_probe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">PSURGE_QUAD_IN</span><span class="p">(</span><span class="n">PSURGE_QUAD_BOARD_ID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">PSURGE_QUAD_OKEE</span> <span class="o">||</span> <span class="n">type</span> <span class="o">&gt;</span> <span class="n">PSURGE_QUAD_ICEGRASS</span>
	    <span class="o">||</span> <span class="n">type</span> <span class="o">!=</span> <span class="n">PSURGE_QUAD_IN</span><span class="p">(</span><span class="n">PSURGE_QUAD_BOARD_ID</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PSURGE_DUAL</span><span class="p">;</span>

	<span class="cm">/* looks OK, try a slightly more rigorous test */</span>
	<span class="cm">/* bogus is not necessarily cacheline-aligned,</span>
<span class="cm">	   though I don&#39;t suppose that really matters.  -- paulus */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">volatile</span> <span class="n">u32</span> <span class="n">bogus</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">bogus</span><span class="p">[(</span><span class="mi">0</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
		<span class="n">bogus</span><span class="p">[(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x55555555</span><span class="p">;</span>
		<span class="n">bogus</span><span class="p">[(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="n">bogus</span><span class="p">[(</span><span class="mi">3</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xAAAAAAAA</span><span class="p">;</span>
		<span class="n">bogus</span><span class="p">[(</span><span class="mi">4</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x33333333</span><span class="p">;</span>
		<span class="n">bogus</span><span class="p">[(</span><span class="mi">5</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xCCCCCCCC</span><span class="p">;</span>
		<span class="n">bogus</span><span class="p">[(</span><span class="mi">6</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xCCCCCCCC</span><span class="p">;</span>
		<span class="n">bogus</span><span class="p">[(</span><span class="mi">7</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x33333333</span><span class="p">;</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;dcbf 0,%0&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">bogus</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
		<span class="n">mb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PSURGE_QUAD_IN</span><span class="p">(</span><span class="n">PSURGE_QUAD_BOARD_ID</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PSURGE_DUAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">psurge_quad_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">procbits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">)</span> <span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">(</span><span class="s">&quot;psurge_quad_init&quot;</span><span class="p">,</span> <span class="mh">0x351</span><span class="p">);</span>
	<span class="n">procbits</span> <span class="o">=</span> <span class="o">~</span><span class="n">PSURGE_QUAD_IN</span><span class="p">(</span><span class="n">PSURGE_QUAD_WHICH_CPU</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psurge_type</span> <span class="o">==</span> <span class="n">PSURGE_QUAD_ICEGRASS</span><span class="p">)</span>
		<span class="n">PSURGE_QUAD_BIS</span><span class="p">(</span><span class="n">PSURGE_QUAD_RESET_CTL</span><span class="p">,</span> <span class="n">procbits</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">PSURGE_QUAD_BIC</span><span class="p">(</span><span class="n">PSURGE_QUAD_CKSTOP_CTL</span><span class="p">,</span> <span class="n">procbits</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span>
	<span class="n">out_8</span><span class="p">(</span><span class="n">psurge_sec_intr</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">PSURGE_QUAD_OUT</span><span class="p">(</span><span class="n">PSURGE_QUAD_IRQ_CLR</span><span class="p">,</span> <span class="n">procbits</span><span class="p">);</span>
	<span class="n">PSURGE_QUAD_BIS</span><span class="p">(</span><span class="n">PSURGE_QUAD_RESET_CTL</span><span class="p">,</span> <span class="n">procbits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psurge_type</span> <span class="o">!=</span> <span class="n">PSURGE_QUAD_ICEGRASS</span><span class="p">)</span>
		<span class="n">PSURGE_QUAD_BIS</span><span class="p">(</span><span class="n">PSURGE_QUAD_CKSTOP_CTL</span><span class="p">,</span> <span class="n">procbits</span><span class="p">);</span>
	<span class="n">PSURGE_QUAD_BIC</span><span class="p">(</span><span class="n">PSURGE_QUAD_PRIMARY_ARB</span><span class="p">,</span> <span class="n">procbits</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span>
	<span class="n">PSURGE_QUAD_BIC</span><span class="p">(</span><span class="n">PSURGE_QUAD_RESET_CTL</span><span class="p">,</span> <span class="n">procbits</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span>
	<span class="n">PSURGE_QUAD_BIS</span><span class="p">(</span><span class="n">PSURGE_QUAD_PRIMARY_ARB</span><span class="p">,</span> <span class="n">procbits</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smp_psurge_probe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ncpus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t do SMP on the PPC601 -- paulus */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PVR_VER</span><span class="p">(</span><span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_PVR</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The powersurge cpu board can be used in the generation</span>
<span class="cm">	 * of powermacs that have a socket for an upgradeable cpu card,</span>
<span class="cm">	 * including the 7500, 8500, 9500, 9600.</span>
<span class="cm">	 * The device tree doesn&#39;t tell you if you have 2 cpus because</span>
<span class="cm">	 * OF doesn&#39;t know anything about the 2nd processor.</span>
<span class="cm">	 * Instead we look for magic bits in magic registers,</span>
<span class="cm">	 * in the hammerhead memory controller in the case of the</span>
<span class="cm">	 * dual-cpu powersurge board.  -- paulus.</span>
<span class="cm">	 */</span>
	<span class="n">dn</span> <span class="o">=</span> <span class="n">of_find_node_by_name</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;hammerhead&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dn</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>

	<span class="n">hhead_base</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">HAMMERHEAD_BASE</span><span class="p">,</span> <span class="mh">0x800</span><span class="p">);</span>
	<span class="n">quad_base</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">PSURGE_QUAD_REG_ADDR</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
	<span class="n">psurge_sec_intr</span> <span class="o">=</span> <span class="n">hhead_base</span> <span class="o">+</span> <span class="n">HHEAD_SEC_INTR</span><span class="p">;</span>

	<span class="n">psurge_type</span> <span class="o">=</span> <span class="n">psurge_quad_probe</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psurge_type</span> <span class="o">!=</span> <span class="n">PSURGE_DUAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">psurge_quad_init</span><span class="p">();</span>
		<span class="cm">/* All released cards using this HW design have 4 CPUs */</span>
		<span class="n">ncpus</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="cm">/* No sure how timebase sync works on those, let&#39;s use SW */</span>
		<span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">give_timebase</span> <span class="o">=</span> <span class="n">smp_generic_give_timebase</span><span class="p">;</span>
		<span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">take_timebase</span> <span class="o">=</span> <span class="n">smp_generic_take_timebase</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">quad_base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">in_8</span><span class="p">(</span><span class="n">hhead_base</span> <span class="o">+</span> <span class="n">HHEAD_CONFIG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* not a dual-cpu card */</span>
			<span class="n">iounmap</span><span class="p">(</span><span class="n">hhead_base</span><span class="p">);</span>
			<span class="n">psurge_type</span> <span class="o">=</span> <span class="n">PSURGE_NONE</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ncpus</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">psurge_secondary_ipi_init</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">psurge_start</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">PSURGE_START</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">psurge_pri_intr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">PSURGE_PRI_INTR</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* This is necessary because OF doesn&#39;t know about the</span>
<span class="cm">	 * secondary cpu(s), and thus there aren&#39;t nodes in the</span>
<span class="cm">	 * device tree for them, and smp_setup_cpu_maps hasn&#39;t</span>
<span class="cm">	 * set their bits in cpu_present_mask.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ncpus</span> <span class="o">&gt;</span> <span class="n">NR_CPUS</span><span class="p">)</span>
		<span class="n">ncpus</span> <span class="o">=</span> <span class="n">NR_CPUS</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ncpus</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">)</span> <span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">(</span><span class="s">&quot;smp_psurge_probe - done&quot;</span><span class="p">,</span> <span class="mh">0x352</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ncpus</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smp_psurge_kick_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">__secondary_start_pmac_0</span><span class="p">)</span> <span class="o">+</span> <span class="n">nr</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="cm">/* Defining this here is evil ... but I prefer hiding that</span>
<span class="cm">	 * crap to avoid giving people ideas that they can do the</span>
<span class="cm">	 * same.</span>
<span class="cm">	 */</span>
	<span class="k">extern</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_callin_map</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

	<span class="cm">/* may need to flush here if secondary bats aren&#39;t setup */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="n">KERNELBASE</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">KERNELBASE</span> <span class="o">+</span> <span class="mh">0x800000</span><span class="p">;</span> <span class="n">a</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">)</span>
		<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;dcbf 0,%0&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;sync&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">)</span> <span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">(</span><span class="s">&quot;smp_psurge_kick_cpu&quot;</span><span class="p">,</span> <span class="mh">0x353</span><span class="p">);</span>

	<span class="cm">/* This is going to freeze the timeebase, we disable interrupts */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">out_be32</span><span class="p">(</span><span class="n">psurge_start</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>

	<span class="n">psurge_set_ipi</span><span class="p">(</span><span class="n">nr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t use udelay here because the timebase is now frozen.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;nop&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
	<span class="n">psurge_clr_ipi</span><span class="p">(</span><span class="n">nr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Also, because the timebase is frozen, we must not return to the</span>
<span class="cm">	 * caller which will try to do udelay&#39;s etc... Instead, we wait -here-</span>
<span class="cm">	 * for the CPU to callin.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_callin_map</span><span class="p">[</span><span class="n">nr</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;nop&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
		<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;sync&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_callin_map</span><span class="p">[</span><span class="n">nr</span><span class="p">])</span>
		<span class="k">goto</span> <span class="n">stuck</span><span class="p">;</span>

	<span class="cm">/* And we do the TB sync here too for standard dual CPU cards */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psurge_type</span> <span class="o">==</span> <span class="n">PSURGE_DUAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">tb_req</span><span class="p">)</span>
			<span class="n">barrier</span><span class="p">();</span>
		<span class="n">tb_req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mb</span><span class="p">();</span>
		<span class="n">timebase</span> <span class="o">=</span> <span class="n">get_tb</span><span class="p">();</span>
		<span class="n">mb</span><span class="p">();</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">timebase</span><span class="p">)</span>
			<span class="n">barrier</span><span class="p">();</span>
		<span class="n">mb</span><span class="p">();</span>
	<span class="p">}</span>
 <span class="nl">stuck:</span>
	<span class="cm">/* now interrupt the secondary, restarting both TBs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psurge_type</span> <span class="o">==</span> <span class="n">PSURGE_DUAL</span><span class="p">)</span>
		<span class="n">psurge_set_ipi</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">)</span> <span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">(</span><span class="s">&quot;smp_psurge_kick_cpu - done&quot;</span><span class="p">,</span> <span class="mh">0x354</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">psurge_irqaction</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span> <span class="o">=</span> <span class="n">psurge_ipi_intr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IRQF_PERCPU</span> <span class="o">|</span> <span class="n">IRQF_NO_THREAD</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;primary IPI&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_psurge_setup_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu_nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_nr</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">psurge_start</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* reset the entry point so if we get another intr we won&#39;t</span>
<span class="cm">	 * try to startup again */</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">psurge_start</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">setup_irq</span><span class="p">(</span><span class="n">irq_create_mapping</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">psurge_irqaction</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Couldn&#39;t get primary IPI interrupt&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_psurge_take_timebase</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psurge_type</span> <span class="o">!=</span> <span class="n">PSURGE_DUAL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tb_req</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">timebase</span><span class="p">)</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">set_tb</span><span class="p">(</span><span class="n">timebase</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">,</span> <span class="n">timebase</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">timebase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">set_dec</span><span class="p">(</span><span class="n">tb_ticks_per_jiffy</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_psurge_give_timebase</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Nothing to do here */</span>
<span class="p">}</span>

<span class="cm">/* PowerSurge-style Macs */</span>
<span class="k">struct</span> <span class="n">smp_ops_t</span> <span class="n">psurge_smp_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">message_pass</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>	<span class="cm">/* Use smp_muxed_ipi_message_pass */</span>
	<span class="p">.</span><span class="n">cause_ipi</span>	<span class="o">=</span> <span class="n">smp_psurge_cause_ipi</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">smp_psurge_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kick_cpu</span>	<span class="o">=</span> <span class="n">smp_psurge_kick_cpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup_cpu</span>	<span class="o">=</span> <span class="n">smp_psurge_setup_cpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">give_timebase</span>	<span class="o">=</span> <span class="n">smp_psurge_give_timebase</span><span class="p">,</span>
	<span class="p">.</span><span class="n">take_timebase</span>	<span class="o">=</span> <span class="n">smp_psurge_take_timebase</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_PMAC32_PSURGE */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Core 99 and later support</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_core99_give_timebase</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">tb_req</span><span class="p">)</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="n">tb_req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">pmac_tb_freeze</span><span class="p">)(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">timebase</span> <span class="o">=</span> <span class="n">get_tb</span><span class="p">();</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">timebase</span><span class="p">)</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="p">(</span><span class="o">*</span><span class="n">pmac_tb_freeze</span><span class="p">)(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">smp_core99_take_timebase</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">tb_req</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">timebase</span><span class="p">)</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">set_tb</span><span class="p">(</span><span class="n">timebase</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">,</span> <span class="n">timebase</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">timebase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cm">/*</span>
<span class="cm"> * G5s enable/disable the timebase via an i2c-connected clock chip.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pmac_i2c_bus</span> <span class="o">*</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">pmac_tb_pulsar_addr</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_core99_cypress_tb_freeze</span><span class="p">(</span><span class="kt">int</span> <span class="n">freeze</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Strangely, the device-tree says address is 0xd2, but darwin</span>
<span class="cm">	 * accesses 0xd0 ...</span>
<span class="cm">	 */</span>
	<span class="n">pmac_i2c_setmode</span><span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">,</span>
			 <span class="n">pmac_i2c_mode_combined</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pmac_i2c_xfer</span><span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">,</span>
			   <span class="mh">0xd0</span> <span class="o">|</span> <span class="n">pmac_i2c_read</span><span class="p">,</span>
			   <span class="mi">1</span><span class="p">,</span> <span class="mh">0x81</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xf3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">freeze</span> <span class="o">?</span> <span class="mh">0x00</span> <span class="o">:</span> <span class="mh">0x0c</span><span class="p">);</span>

       	<span class="n">pmac_i2c_setmode</span><span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">,</span> <span class="n">pmac_i2c_mode_stdsub</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pmac_i2c_xfer</span><span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">,</span>
			   <span class="mh">0xd0</span> <span class="o">|</span> <span class="n">pmac_i2c_write</span><span class="p">,</span>
			   <span class="mi">1</span><span class="p">,</span> <span class="mh">0x81</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

 <span class="nl">bail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Cypress Timebase %s rc: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">freeze</span> <span class="o">?</span> <span class="s">&quot;freeze&quot;</span> <span class="o">:</span> <span class="s">&quot;unfreeze&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Timebase freeze failed !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_core99_pulsar_tb_freeze</span><span class="p">(</span><span class="kt">int</span> <span class="n">freeze</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">pmac_i2c_setmode</span><span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">,</span>
			 <span class="n">pmac_i2c_mode_combined</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pmac_i2c_xfer</span><span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">,</span>
			   <span class="n">pmac_tb_pulsar_addr</span> <span class="o">|</span> <span class="n">pmac_i2c_read</span><span class="p">,</span>
			   <span class="mi">1</span><span class="p">,</span> <span class="mh">0x2e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0x88</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">freeze</span> <span class="o">?</span> <span class="mh">0x11</span> <span class="o">:</span> <span class="mh">0x22</span><span class="p">);</span>

	<span class="n">pmac_i2c_setmode</span><span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">,</span> <span class="n">pmac_i2c_mode_stdsub</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pmac_i2c_xfer</span><span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">,</span>
			   <span class="n">pmac_tb_pulsar_addr</span> <span class="o">|</span> <span class="n">pmac_i2c_write</span><span class="p">,</span>
			   <span class="mi">1</span><span class="p">,</span> <span class="mh">0x2e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
 <span class="nl">bail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Pulsar Timebase %s rc: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">freeze</span> <span class="o">?</span> <span class="s">&quot;freeze&quot;</span> <span class="o">:</span> <span class="s">&quot;unfreeze&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Timebase freeze failed !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_core99_setup_i2c_hwsync</span><span class="p">(</span><span class="kt">int</span> <span class="n">ncpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ok</span><span class="p">;</span>

	<span class="cm">/* Look for the clock chip */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">cc</span> <span class="o">=</span> <span class="n">of_find_node_by_name</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="s">&quot;i2c-hwclock&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">of_get_parent</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
		<span class="n">ok</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;uni-n-i2c&quot;</span><span class="p">);</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pmac_tb_clock_chip_host</span> <span class="o">=</span> <span class="n">pmac_i2c_find_bus</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0xd2</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span><span class="s">&quot;pulsar-legacy-slewing&quot;</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pmac_tb_freeze</span> <span class="o">=</span> <span class="n">smp_core99_pulsar_tb_freeze</span><span class="p">;</span>
				<span class="n">pmac_tb_pulsar_addr</span> <span class="o">=</span> <span class="mh">0xd2</span><span class="p">;</span>
				<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Pulsar&quot;</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="s">&quot;cy28508&quot;</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pmac_tb_freeze</span> <span class="o">=</span> <span class="n">smp_core99_cypress_tb_freeze</span><span class="p">;</span>
				<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Cypress&quot;</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0xd4</span>:
			<span class="n">pmac_tb_freeze</span> <span class="o">=</span> <span class="n">smp_core99_pulsar_tb_freeze</span><span class="p">;</span>
			<span class="n">pmac_tb_pulsar_addr</span> <span class="o">=</span> <span class="mh">0xd4</span><span class="p">;</span>
			<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Pulsar&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmac_tb_freeze</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmac_tb_freeze</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Open i2c bus for synchronous access */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmac_i2c_open</span><span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed top open i2c bus for clock&quot;</span>
			       <span class="s">&quot; sync, fallback to software sync !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">no_i2c_sync</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Processor timebase sync using %s i2c clock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">no_i2c_sync:</span>
	<span class="n">pmac_tb_freeze</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pmac_tb_clock_chip_host</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> * Newer G5s uses a platform function</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_core99_pfunc_tb_freeze</span><span class="p">(</span><span class="kt">int</span> <span class="n">freeze</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">cpus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmf_args</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">cpus</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/cpus&quot;</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpus</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">args</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">v</span> <span class="o">=</span> <span class="o">!</span><span class="n">freeze</span><span class="p">;</span>
	<span class="n">pmf_call_function</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="s">&quot;cpu-timebase&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">cpus</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * SMP G4 use a GPIO to enable/disable the timebase.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">core99_tb_gpio</span><span class="p">;</span>	<span class="cm">/* Timebase freeze GPIO */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smp_core99_gpio_tb_freeze</span><span class="p">(</span><span class="kt">int</span> <span class="n">freeze</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freeze</span><span class="p">)</span>
		<span class="n">pmac_call_feature</span><span class="p">(</span><span class="n">PMAC_FTR_WRITE_GPIO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">core99_tb_gpio</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pmac_call_feature</span><span class="p">(</span><span class="n">PMAC_FTR_WRITE_GPIO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">core99_tb_gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pmac_call_feature</span><span class="p">(</span><span class="n">PMAC_FTR_READ_GPIO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">core99_tb_gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#endif </span><span class="cm">/* !CONFIG_PPC64 */</span><span class="cp"></span>

<span class="cm">/* L2 and L3 cache settings to pass from CPU0 to CPU1 on G4 cpus */</span>
<span class="k">volatile</span> <span class="k">static</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">core99_l2_cache</span><span class="p">;</span>
<span class="k">volatile</span> <span class="k">static</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">core99_l3_cache</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">core99_init_caches</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef CONFIG_PPC64</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_L2CR</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">core99_l2_cache</span> <span class="o">=</span> <span class="n">_get_L2CR</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CPU0: L2CR is %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">core99_l2_cache</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CPU%d: L2CR was %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">_get_L2CR</span><span class="p">());</span>
		<span class="n">_set_L2CR</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">_set_L2CR</span><span class="p">(</span><span class="n">core99_l2_cache</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CPU%d: L2CR set to %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">core99_l2_cache</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_L3CR</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
		<span class="n">core99_l3_cache</span> <span class="o">=</span> <span class="n">_get_L3CR</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CPU0: L3CR is %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">core99_l3_cache</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CPU%d: L3CR was %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">_get_L3CR</span><span class="p">());</span>
		<span class="n">_set_L3CR</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">_set_L3CR</span><span class="p">(</span><span class="n">core99_l3_cache</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CPU%d: L3CR set to %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">core99_l3_cache</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_PPC64 */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_core99_setup</span><span class="p">(</span><span class="kt">int</span> <span class="n">ncpus</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PPC64</span>

	<span class="cm">/* i2c based HW sync on some G5s */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_machine_is_compatible</span><span class="p">(</span><span class="s">&quot;PowerMac7,2&quot;</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">of_machine_is_compatible</span><span class="p">(</span><span class="s">&quot;PowerMac7,3&quot;</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">of_machine_is_compatible</span><span class="p">(</span><span class="s">&quot;RackMac3,1&quot;</span><span class="p">))</span>
		<span class="n">smp_core99_setup_i2c_hwsync</span><span class="p">(</span><span class="n">ncpus</span><span class="p">);</span>

	<span class="cm">/* pfunc based HW sync on recent G5s */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmac_tb_freeze</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">cpus</span> <span class="o">=</span>
			<span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/cpus&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpus</span> <span class="o">&amp;&amp;</span>
		    <span class="n">of_get_property</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="s">&quot;platform-cpu-timebase&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pmac_tb_freeze</span> <span class="o">=</span> <span class="n">smp_core99_pfunc_tb_freeze</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Processor timebase sync using&quot;</span>
			       <span class="s">&quot; platform function</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>

	<span class="cm">/* GPIO based HW sync on ppc32 Core99 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmac_tb_freeze</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">of_machine_is_compatible</span><span class="p">(</span><span class="s">&quot;MacRISC4&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">cpu</span><span class="p">;</span>
		<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">tbprop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">core99_tb_gpio</span> <span class="o">=</span> <span class="n">KL_GPIO_TB_ENABLE</span><span class="p">;</span>	<span class="cm">/* default value */</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">of_find_node_by_type</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tbprop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;timebase-enable&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tbprop</span><span class="p">)</span>
				<span class="n">core99_tb_gpio</span> <span class="o">=</span> <span class="o">*</span><span class="n">tbprop</span><span class="p">;</span>
			<span class="n">of_node_put</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pmac_tb_freeze</span> <span class="o">=</span> <span class="n">smp_core99_gpio_tb_freeze</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Processor timebase sync using&quot;</span>
		       <span class="s">&quot; GPIO 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">core99_tb_gpio</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>

	<span class="cm">/* No timebase sync, fallback to software */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmac_tb_freeze</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">give_timebase</span> <span class="o">=</span> <span class="n">smp_generic_give_timebase</span><span class="p">;</span>
		<span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">take_timebase</span> <span class="o">=</span> <span class="n">smp_generic_take_timebase</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Processor timebase sync using software</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifndef CONFIG_PPC64</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* XXX should get this from reg properties */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ncpus</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">set_hard_smp_processor_id</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* 32 bits SMP can&#39;t NAP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_machine_is_compatible</span><span class="p">(</span><span class="s">&quot;MacRISC4&quot;</span><span class="p">))</span>
		<span class="n">powersave_nap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smp_core99_probe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">cpus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ncpus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">)</span> <span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">(</span><span class="s">&quot;smp_core99_probe&quot;</span><span class="p">,</span> <span class="mh">0x345</span><span class="p">);</span>

	<span class="cm">/* Count CPUs in the device-tree */</span>
       	<span class="k">for</span> <span class="p">(</span><span class="n">cpus</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">(</span><span class="n">cpus</span> <span class="o">=</span> <span class="n">of_find_node_by_type</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;)</span>
	       	<span class="o">++</span><span class="n">ncpus</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;PowerMac SMP probe found %d cpus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ncpus</span><span class="p">);</span>

	<span class="cm">/* Nothing more to do if less than 2 of them */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ncpus</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* We need to perform some early initialisations before we can start</span>
<span class="cm">	 * setting up SMP as we are running before initcalls</span>
<span class="cm">	 */</span>
	<span class="n">pmac_pfunc_base_install</span><span class="p">();</span>
	<span class="n">pmac_i2c_init</span><span class="p">();</span>

	<span class="cm">/* Setup various bits like timebase sync method, ability to nap, ... */</span>
	<span class="n">smp_core99_setup</span><span class="p">(</span><span class="n">ncpus</span><span class="p">);</span>

	<span class="cm">/* Install IPIs */</span>
	<span class="n">mpic_request_ipis</span><span class="p">();</span>

	<span class="cm">/* Collect l2cr and l3cr values from CPU 0 */</span>
	<span class="n">core99_init_caches</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ncpus</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">smp_core99_kick_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">save_vector</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">target</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">vector</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">PAGE_OFFSET</span><span class="o">+</span><span class="mh">0x100</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nr</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">)</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">(</span><span class="s">&quot;smp_core99_kick_cpu&quot;</span><span class="p">,</span> <span class="mh">0x346</span><span class="p">);</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Save reset vector */</span>
	<span class="n">save_vector</span> <span class="o">=</span> <span class="o">*</span><span class="n">vector</span><span class="p">;</span>

	<span class="cm">/* Setup fake reset vector that does</span>
<span class="cm">	 *   b __secondary_start_pmac_0 + nr*8</span>
<span class="cm">	 */</span>
	<span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__secondary_start_pmac_0</span> <span class="o">+</span> <span class="n">nr</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">patch_branch</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">BRANCH_SET_LINK</span><span class="p">);</span>

	<span class="cm">/* Put some life in our friend */</span>
	<span class="n">pmac_call_feature</span><span class="p">(</span><span class="n">PMAC_FTR_RESET_CPU</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* FIXME: We wait a bit for the CPU to take the exception, I should</span>
<span class="cm">	 * instead wait for the entry code to set something for me. Well,</span>
<span class="cm">	 * ideally, all that crap will be done in prom.c and the CPU left</span>
<span class="cm">	 * in a RAM-based wait loop like CHRP.</span>
<span class="cm">	 */</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Restore our exception vector */</span>
	<span class="o">*</span><span class="n">vector</span> <span class="o">=</span> <span class="n">save_vector</span><span class="p">;</span>
	<span class="n">flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">vector</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">vector</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">)</span> <span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">(</span><span class="s">&quot;smp_core99_kick_cpu done&quot;</span><span class="p">,</span> <span class="mh">0x347</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">smp_core99_setup_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu_nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Setup L2/L3 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_nr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">core99_init_caches</span><span class="p">(</span><span class="n">cpu_nr</span><span class="p">);</span>

	<span class="cm">/* Setup openpic */</span>
	<span class="n">mpic_setup_this_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smp_core99_cpu_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE_FROZEN</span>:
		<span class="cm">/* Open i2c bus if it was used for tb sync */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">pmac_i2c_open</span><span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to open i2c bus for time sync</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED</span>:
		<span class="cm">/* Close i2c bus if it was used for tb sync */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">)</span>
			<span class="n">pmac_i2c_close</span><span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">__cpuinitdata</span> <span class="n">smp_core99_cpu_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span>	<span class="o">=</span> <span class="n">smp_core99_cpu_notify</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_core99_bringup_done</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">g5_phy_disable_cpu1</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

	<span class="cm">/* Close i2c bus if it was used for tb sync */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">)</span>
		<span class="n">pmac_i2c_close</span><span class="p">(</span><span class="n">pmac_tb_clock_chip_host</span><span class="p">);</span>

	<span class="cm">/* If we didn&#39;t start the second CPU, we must take</span>
<span class="cm">	 * it off the bus.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_machine_is_compatible</span><span class="p">(</span><span class="s">&quot;MacRISC4&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_cpu_present</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">g5_phy_disable_cpu1</span><span class="p">();</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="n">register_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smp_core99_cpu_nb</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">)</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">progress</span><span class="p">(</span><span class="s">&quot;smp_core99_bringup_done&quot;</span><span class="p">,</span> <span class="mh">0x349</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smp_core99_cpu_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">generic_cpu_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mpic_cpu_set_priority</span><span class="p">(</span><span class="mh">0xf</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC32</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmac_cpu_die</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">idle_task_exit</span><span class="p">();</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;CPU%d offline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">generic_set_cpu_dead</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">low_cpu_die</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_PPC32 */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmac_cpu_die</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">idle_task_exit</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * turn off as much as possible, we&#39;ll be</span>
<span class="cm">	 * kicked out as this will only be invoked</span>
<span class="cm">	 * on core99 platforms for now ...</span>
<span class="cm">	 */</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CPU#%d offline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">generic_set_cpu_dead</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Re-enable interrupts. The NAP code needs to enable them</span>
<span class="cm">	 * anyways, do it now so we deal with the case where one already</span>
<span class="cm">	 * happened while soft-disabled.</span>
<span class="cm">	 * We shouldn&#39;t get any external interrupts, only decrementer, and the</span>
<span class="cm">	 * decrementer handler is safe for use on offline CPUs</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* let&#39;s not take timer interrupts too often ... */</span>
		<span class="n">set_dec</span><span class="p">(</span><span class="mh">0x7fffffff</span><span class="p">);</span>

		<span class="cm">/* Enter NAP mode */</span>
		<span class="n">power4_idle</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* else CONFIG_PPC32 */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="cm">/* Core99 Macs (dual G4s and G5s) */</span>
<span class="k">struct</span> <span class="n">smp_ops_t</span> <span class="n">core99_smp_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">message_pass</span>	<span class="o">=</span> <span class="n">smp_mpic_message_pass</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">smp_core99_probe</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="p">.</span><span class="n">bringup_done</span>	<span class="o">=</span> <span class="n">smp_core99_bringup_done</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">kick_cpu</span>	<span class="o">=</span> <span class="n">smp_core99_kick_cpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup_cpu</span>	<span class="o">=</span> <span class="n">smp_core99_setup_cpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">give_timebase</span>	<span class="o">=</span> <span class="n">smp_core99_give_timebase</span><span class="p">,</span>
	<span class="p">.</span><span class="n">take_timebase</span>	<span class="o">=</span> <span class="n">smp_core99_take_timebase</span><span class="p">,</span>
<span class="cp">#if defined(CONFIG_HOTPLUG_CPU)</span>
	<span class="p">.</span><span class="n">cpu_disable</span>	<span class="o">=</span> <span class="n">smp_core99_cpu_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cpu_die</span>	<span class="o">=</span> <span class="n">generic_cpu_die</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">pmac_setup_smp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>

	<span class="cm">/* Check for Core99 */</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">of_find_node_by_name</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;uni-n&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
		<span class="n">np</span> <span class="o">=</span> <span class="n">of_find_node_by_name</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;u3&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
		<span class="n">np</span> <span class="o">=</span> <span class="n">of_find_node_by_name</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;u4&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="n">smp_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">core99_smp_ops</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_PPC_PMAC32_PSURGE</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We have to set bits in cpu_possible_mask here since the</span>
<span class="cm">		 * secondary CPU(s) aren&#39;t in the device tree. Various</span>
<span class="cm">		 * things won&#39;t be initialized for CPUs not in the possible</span>
<span class="cm">		 * map, so we really need to fix it up here.</span>
<span class="cm">		 */</span>
		<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">cpu</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="o">++</span><span class="n">cpu</span><span class="p">)</span>
			<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">smp_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psurge_smp_ops</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_PMAC32_PSURGE */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="n">ppc_md</span><span class="p">.</span><span class="n">cpu_die</span> <span class="o">=</span> <span class="n">pmac_cpu_die</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
