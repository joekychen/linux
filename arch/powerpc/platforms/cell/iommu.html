<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › platforms › cell › iommu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>iommu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * IOMMU implementation for Cell Broadband Processor Architecture</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright IBM Corporation 2006-2008</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Jeremy Kerr &lt;jk@ozlabs.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#undef DEBUG</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/of_platform.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>

<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/iommu.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/pci-bridge.h&gt;</span>
<span class="cp">#include &lt;asm/udbg.h&gt;</span>
<span class="cp">#include &lt;asm/firmware.h&gt;</span>
<span class="cp">#include &lt;asm/cell-regs.h&gt;</span>

<span class="cp">#include &quot;interrupt.h&quot;</span>

<span class="cm">/* Define CELL_IOMMU_REAL_UNMAP to actually unmap non-used pages</span>
<span class="cm"> * instead of leaving them mapped to some dummy page. This can be</span>
<span class="cm"> * enabled once the appropriate workarounds for spider bugs have</span>
<span class="cm"> * been enabled</span>
<span class="cm"> */</span>
<span class="cp">#define CELL_IOMMU_REAL_UNMAP</span>

<span class="cm">/* Define CELL_IOMMU_STRICT_PROTECTION to enforce protection of</span>
<span class="cm"> * IO PTEs based on the transfer direction. That can be enabled</span>
<span class="cm"> * once spider-net has been fixed to pass the correct direction</span>
<span class="cm"> * to the DMA mapping functions</span>
<span class="cm"> */</span>
<span class="cp">#define CELL_IOMMU_STRICT_PROTECTION</span>


<span class="cp">#define NR_IOMMUS			2</span>

<span class="cm">/* IOC mmap registers */</span>
<span class="cp">#define IOC_Reg_Size			0x2000</span>

<span class="cp">#define IOC_IOPT_CacheInvd		0x908</span>
<span class="cp">#define IOC_IOPT_CacheInvd_NE_Mask	0xffe0000000000000ul</span>
<span class="cp">#define IOC_IOPT_CacheInvd_IOPTE_Mask	0x000003fffffffff8ul</span>
<span class="cp">#define IOC_IOPT_CacheInvd_Busy		0x0000000000000001ul</span>

<span class="cp">#define IOC_IOST_Origin			0x918</span>
<span class="cp">#define IOC_IOST_Origin_E		0x8000000000000000ul</span>
<span class="cp">#define IOC_IOST_Origin_HW		0x0000000000000800ul</span>
<span class="cp">#define IOC_IOST_Origin_HL		0x0000000000000400ul</span>

<span class="cp">#define IOC_IO_ExcpStat			0x920</span>
<span class="cp">#define IOC_IO_ExcpStat_V		0x8000000000000000ul</span>
<span class="cp">#define IOC_IO_ExcpStat_SPF_Mask	0x6000000000000000ul</span>
<span class="cp">#define IOC_IO_ExcpStat_SPF_S		0x6000000000000000ul</span>
<span class="cp">#define IOC_IO_ExcpStat_SPF_P		0x2000000000000000ul</span>
<span class="cp">#define IOC_IO_ExcpStat_ADDR_Mask	0x00000007fffff000ul</span>
<span class="cp">#define IOC_IO_ExcpStat_RW_Mask		0x0000000000000800ul</span>
<span class="cp">#define IOC_IO_ExcpStat_IOID_Mask	0x00000000000007fful</span>

<span class="cp">#define IOC_IO_ExcpMask			0x928</span>
<span class="cp">#define IOC_IO_ExcpMask_SFE		0x4000000000000000ul</span>
<span class="cp">#define IOC_IO_ExcpMask_PFE		0x2000000000000000ul</span>

<span class="cp">#define IOC_IOCmd_Offset		0x1000</span>

<span class="cp">#define IOC_IOCmd_Cfg			0xc00</span>
<span class="cp">#define IOC_IOCmd_Cfg_TE		0x0000800000000000ul</span>


<span class="cm">/* Segment table entries */</span>
<span class="cp">#define IOSTE_V			0x8000000000000000ul </span><span class="cm">/* valid */</span><span class="cp"></span>
<span class="cp">#define IOSTE_H			0x4000000000000000ul </span><span class="cm">/* cache hint */</span><span class="cp"></span>
<span class="cp">#define IOSTE_PT_Base_RPN_Mask  0x3ffffffffffff000ul </span><span class="cm">/* base RPN of IOPT */</span><span class="cp"></span>
<span class="cp">#define IOSTE_NPPT_Mask		0x0000000000000fe0ul </span><span class="cm">/* no. pages in IOPT */</span><span class="cp"></span>
<span class="cp">#define IOSTE_PS_Mask		0x0000000000000007ul </span><span class="cm">/* page size */</span><span class="cp"></span>
<span class="cp">#define IOSTE_PS_4K		0x0000000000000001ul </span><span class="cm">/*   - 4kB  */</span><span class="cp"></span>
<span class="cp">#define IOSTE_PS_64K		0x0000000000000003ul </span><span class="cm">/*   - 64kB */</span><span class="cp"></span>
<span class="cp">#define IOSTE_PS_1M		0x0000000000000005ul </span><span class="cm">/*   - 1MB  */</span><span class="cp"></span>
<span class="cp">#define IOSTE_PS_16M		0x0000000000000007ul </span><span class="cm">/*   - 16MB */</span><span class="cp"></span>


<span class="cm">/* IOMMU sizing */</span>
<span class="cp">#define IO_SEGMENT_SHIFT	28</span>
<span class="cp">#define IO_PAGENO_BITS(shift)	(IO_SEGMENT_SHIFT - (shift))</span>

<span class="cm">/* The high bit needs to be set on every DMA address */</span>
<span class="cp">#define SPIDER_DMA_OFFSET	0x80000000ul</span>

<span class="k">struct</span> <span class="n">iommu_window</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iommu_table</span> <span class="n">table</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define NAMESIZE 8</span>
<span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">NAMESIZE</span><span class="p">];</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">xlate_regs</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">cmd_regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">stab</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptab</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pad_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">windows</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Static array of iommus, one per node</span>
<span class="cm"> *   each contains a list of windows, keyed from dma_window property</span>
<span class="cm"> *   - on bus setup, look for a matching window, or create one</span>
<span class="cm"> *   - on dev setup, assign iommu_table ptr</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="n">iommus</span><span class="p">[</span><span class="n">NR_IOMMUS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cbe_nr_iommus</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">invalidate_tce_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span>
		<span class="kt">long</span> <span class="n">n_ptes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">xlate_regs</span> <span class="o">+</span> <span class="n">IOC_IOPT_CacheInvd</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n_ptes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we can invalidate up to 1 &lt;&lt; 11 PTEs at once */</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">n_ptes</span><span class="p">,</span> <span class="mi">1l</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">(((</span><span class="n">n</span> <span class="cm">/*- 1*/</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">53</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IOC_IOPT_CacheInvd_NE_Mask</span><span class="p">)</span>
			<span class="o">|</span> <span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IOC_IOPT_CacheInvd_IOPTE_Mask</span><span class="p">)</span>
		        <span class="o">|</span> <span class="n">IOC_IOPT_CacheInvd_Busy</span><span class="p">;</span>

		<span class="n">out_be64</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">in_be64</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IOC_IOPT_CacheInvd_Busy</span><span class="p">)</span>
			<span class="p">;</span>

		<span class="n">n_ptes</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">pte</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tce_build_cell</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uaddr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">io_pte</span><span class="p">,</span> <span class="n">base_pte</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iommu_window</span> <span class="o">*</span><span class="n">window</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iommu_window</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>

	<span class="cm">/* implementing proper protection causes problems with the spidernet</span>
<span class="cm">	 * driver - check mapping directions later, but allow read &amp; write by</span>
<span class="cm">	 * default for now.*/</span>
<span class="cp">#ifdef CELL_IOMMU_STRICT_PROTECTION</span>
	<span class="cm">/* to avoid referencing a global, we use a trick here to setup the</span>
<span class="cm">	 * protection bit. &quot;prot&quot; is setup to be 3 fields of 4 bits apprended</span>
<span class="cm">	 * together for each of the 3 supported direction values. It is then</span>
<span class="cm">	 * shifted left so that the fields matching the desired direction</span>
<span class="cm">	 * lands on the appropriate bits, and other bits are masked out.</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span> <span class="o">=</span> <span class="mh">0xc48</span><span class="p">;</span>
	<span class="n">base_pte</span> <span class="o">=</span>
		<span class="p">((</span><span class="n">prot</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">52</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">direction</span><span class="p">))</span> <span class="o">&amp;</span>
		 <span class="p">(</span><span class="n">CBE_IOPTE_PP_W</span> <span class="o">|</span> <span class="n">CBE_IOPTE_PP_R</span><span class="p">))</span> <span class="o">|</span>
		<span class="n">CBE_IOPTE_M</span> <span class="o">|</span> <span class="n">CBE_IOPTE_SO_RW</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">ioid</span> <span class="o">&amp;</span> <span class="n">CBE_IOPTE_IOID_Mask</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">base_pte</span> <span class="o">=</span> <span class="n">CBE_IOPTE_PP_W</span> <span class="o">|</span> <span class="n">CBE_IOPTE_PP_R</span> <span class="o">|</span> <span class="n">CBE_IOPTE_M</span> <span class="o">|</span>
		<span class="n">CBE_IOPTE_SO_RW</span> <span class="o">|</span> <span class="p">(</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">ioid</span> <span class="o">&amp;</span> <span class="n">CBE_IOPTE_IOID_Mask</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dma_get_attr</span><span class="p">(</span><span class="n">DMA_ATTR_WEAK_ORDERING</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)))</span>
		<span class="n">base_pte</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CBE_IOPTE_SO_RW</span><span class="p">;</span>

	<span class="n">io_pte</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_base</span> <span class="o">+</span> <span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_offset</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">uaddr</span> <span class="o">+=</span> <span class="n">IOMMU_PAGE_SIZE</span><span class="p">)</span>
		<span class="n">io_pte</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_pte</span> <span class="o">|</span> <span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">uaddr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CBE_IOPTE_RPN_Mask</span><span class="p">);</span>

	<span class="n">mb</span><span class="p">();</span>

	<span class="n">invalidate_tce_cache</span><span class="p">(</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">,</span> <span class="n">io_pte</span><span class="p">,</span> <span class="n">npages</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;tce_build_cell(index=%lx,n=%lx,dir=%d,base_pte=%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">index</span><span class="p">,</span> <span class="n">npages</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">base_pte</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tce_free_cell</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">io_pte</span><span class="p">,</span> <span class="n">pte</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iommu_window</span> <span class="o">*</span><span class="n">window</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iommu_window</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;tce_free_cell(index=%lx,n=%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">npages</span><span class="p">);</span>

<span class="cp">#ifdef CELL_IOMMU_REAL_UNMAP</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="cm">/* spider bridge does PCI reads after freeing - insert a mapping</span>
<span class="cm">	 * to a scratch page instead of an invalid entry */</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">CBE_IOPTE_PP_R</span> <span class="o">|</span> <span class="n">CBE_IOPTE_M</span> <span class="o">|</span> <span class="n">CBE_IOPTE_SO_RW</span> <span class="o">|</span>
		<span class="n">__pa</span><span class="p">(</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">pad_page</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">ioid</span> <span class="o">&amp;</span> <span class="n">CBE_IOPTE_IOID_Mask</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">io_pte</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_base</span> <span class="o">+</span> <span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_offset</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">io_pte</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pte</span><span class="p">;</span>

	<span class="n">mb</span><span class="p">();</span>

	<span class="n">invalidate_tce_cache</span><span class="p">(</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">,</span> <span class="n">io_pte</span><span class="p">,</span> <span class="n">npages</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ioc_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stat</span><span class="p">,</span> <span class="n">spf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="o">*</span><span class="n">iommu</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">stat</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">xlate_regs</span> <span class="o">+</span> <span class="n">IOC_IO_ExcpStat</span><span class="p">);</span>
	<span class="n">spf</span> <span class="o">=</span> <span class="n">stat</span> <span class="o">&amp;</span> <span class="n">IOC_IO_ExcpStat_SPF_Mask</span><span class="p">;</span>

	<span class="cm">/* Might want to rate limit it */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;iommu: DMA exception 0x%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;  V=%d, SPF=[%c%c], RW=%s, IOID=0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="o">!!</span><span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">IOC_IO_ExcpStat_V</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">spf</span> <span class="o">==</span> <span class="n">IOC_IO_ExcpStat_SPF_S</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;S&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">spf</span> <span class="o">==</span> <span class="n">IOC_IO_ExcpStat_SPF_P</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;P&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">IOC_IO_ExcpStat_RW_Mask</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Read&quot;</span> <span class="o">:</span> <span class="s">&quot;Write&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">IOC_IO_ExcpStat_IOID_Mask</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;  page=0x%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">stat</span> <span class="o">&amp;</span> <span class="n">IOC_IO_ExcpStat_ADDR_Mask</span><span class="p">);</span>

	<span class="cm">/* clear interrupt */</span>
	<span class="n">stat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IOC_IO_ExcpStat_V</span><span class="p">;</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">xlate_regs</span> <span class="o">+</span> <span class="n">IOC_IO_ExcpStat</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cell_iommu_find_ioc</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="n">r</span><span class="p">;</span>

	<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* First look for new style /be nodes */</span>
	<span class="n">for_each_node_by_name</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;ioc&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_node_to_nid</span><span class="p">(</span><span class="n">np</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_address_to_resource</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;iommu: can&#39;t get address for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Ok, let&#39;s try the old way */</span>
	<span class="n">for_each_node_by_type</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nidp</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

		<span class="n">nidp</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;node-id&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nidp</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">nidp</span> <span class="o">==</span> <span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;ioc-translation&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
				<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_iommu_setup_stab</span><span class="p">(</span><span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dbase</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dsize</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fbase</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">segments</span><span class="p">,</span> <span class="n">stab_size</span><span class="p">;</span>

	<span class="n">segments</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dbase</span> <span class="o">+</span> <span class="n">dsize</span><span class="p">,</span> <span class="n">fbase</span> <span class="o">+</span> <span class="n">fsize</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">IO_SEGMENT_SHIFT</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: iommu[%d]: segments: %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="n">segments</span><span class="p">);</span>

	<span class="cm">/* set up the segment table */</span>
	<span class="n">stab_size</span> <span class="o">=</span> <span class="n">segments</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_node</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">stab_size</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">);</span>
	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">stab</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">stab</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stab_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="nf">cell_iommu_alloc_ptab</span><span class="p">(</span><span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gap_base</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gap_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">,</span> <span class="n">segments</span><span class="p">,</span> <span class="n">pages_per_segment</span><span class="p">,</span> <span class="n">ptab_size</span><span class="p">,</span>
		      <span class="n">n_pte_pages</span><span class="p">,</span> <span class="n">start_seg</span><span class="p">,</span> <span class="o">*</span><span class="n">ptab</span><span class="p">;</span>

	<span class="n">start_seg</span> <span class="o">=</span> <span class="n">base</span> <span class="o">&gt;&gt;</span> <span class="n">IO_SEGMENT_SHIFT</span><span class="p">;</span>
	<span class="n">segments</span>  <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">IO_SEGMENT_SHIFT</span><span class="p">;</span>
	<span class="n">pages_per_segment</span> <span class="o">=</span> <span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="n">IO_PAGENO_BITS</span><span class="p">(</span><span class="n">page_shift</span><span class="p">);</span>
	<span class="cm">/* PTEs for each segment must start on a 4K bounday */</span>
	<span class="n">pages_per_segment</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">pages_per_segment</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>

	<span class="n">ptab_size</span> <span class="o">=</span> <span class="n">segments</span> <span class="o">*</span> <span class="n">pages_per_segment</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: iommu[%d]: ptab_size: %lu, order: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="n">ptab_size</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">ptab_size</span><span class="p">));</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_node</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">ptab_size</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">);</span>

	<span class="n">ptab</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ptab</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptab_size</span><span class="p">);</span>

	<span class="cm">/* number of 4K pages needed for a page table */</span>
	<span class="n">n_pte_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">pages_per_segment</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: iommu[%d]: stab at %p, ptab at %p, n_pte_pages: %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">stab</span><span class="p">,</span> <span class="n">ptab</span><span class="p">,</span>
			<span class="n">n_pte_pages</span><span class="p">);</span>

	<span class="cm">/* initialise the STEs */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">IOSTE_V</span> <span class="o">|</span> <span class="p">((</span><span class="n">n_pte_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">page_shift</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">12</span>: <span class="n">reg</span> <span class="o">|=</span> <span class="n">IOSTE_PS_4K</span><span class="p">;</span>  <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">16</span>: <span class="n">reg</span> <span class="o">|=</span> <span class="n">IOSTE_PS_64K</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">20</span>: <span class="n">reg</span> <span class="o">|=</span> <span class="n">IOSTE_PS_1M</span><span class="p">;</span>  <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">24</span>: <span class="n">reg</span> <span class="o">|=</span> <span class="n">IOSTE_PS_16M</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> <span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">gap_base</span> <span class="o">=</span> <span class="n">gap_base</span> <span class="o">&gt;&gt;</span> <span class="n">IO_SEGMENT_SHIFT</span><span class="p">;</span>
	<span class="n">gap_size</span> <span class="o">=</span> <span class="n">gap_size</span> <span class="o">&gt;&gt;</span> <span class="n">IO_SEGMENT_SHIFT</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Setting up IOMMU stab:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start_seg</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">start_seg</span> <span class="o">+</span> <span class="n">segments</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">gap_base</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">gap_base</span> <span class="o">+</span> <span class="n">gap_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">overlap at %d, skipping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">stab</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">|</span> <span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">ptab</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_pte_pages</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">*</span>
					<span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">start_seg</span><span class="p">));</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">[%d] 0x%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">stab</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ptab</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_iommu_enable_hardware</span><span class="p">(</span><span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">,</span> <span class="n">xlate_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">virq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cell_iommu_find_ioc</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xlate_base</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: missing IOC register mappings for node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">__func__</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">);</span>

	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">xlate_regs</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">xlate_base</span><span class="p">,</span> <span class="n">IOC_Reg_Size</span><span class="p">);</span>
	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cmd_regs</span> <span class="o">=</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">xlate_regs</span> <span class="o">+</span> <span class="n">IOC_IOCmd_Offset</span><span class="p">;</span>

	<span class="cm">/* ensure that the STEs have updated */</span>
	<span class="n">mb</span><span class="p">();</span>

	<span class="cm">/* setup interrupts for the iommu. */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">xlate_regs</span> <span class="o">+</span> <span class="n">IOC_IO_ExcpStat</span><span class="p">);</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">xlate_regs</span> <span class="o">+</span> <span class="n">IOC_IO_ExcpStat</span><span class="p">,</span>
			<span class="n">reg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IOC_IO_ExcpStat_V</span><span class="p">);</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">xlate_regs</span> <span class="o">+</span> <span class="n">IOC_IO_ExcpMask</span><span class="p">,</span>
			<span class="n">IOC_IO_ExcpMask_PFE</span> <span class="o">|</span> <span class="n">IOC_IO_ExcpMask_SFE</span><span class="p">);</span>

	<span class="n">virq</span> <span class="o">=</span> <span class="n">irq_create_mapping</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
			<span class="n">IIC_IRQ_IOEX_ATI</span> <span class="o">|</span> <span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">&lt;&lt;</span> <span class="n">IIC_IRQ_NODE_SHIFT</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">virq</span> <span class="o">==</span> <span class="n">NO_IRQ</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">virq</span><span class="p">,</span> <span class="n">ioc_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">iommu</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="cm">/* set the IOC segment table origin register (and turn on the iommu) */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">IOC_IOST_Origin_E</span> <span class="o">|</span> <span class="n">__pa</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">stab</span><span class="p">)</span> <span class="o">|</span> <span class="n">IOC_IOST_Origin_HW</span><span class="p">;</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">xlate_regs</span> <span class="o">+</span> <span class="n">IOC_IOST_Origin</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">in_be64</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">xlate_regs</span> <span class="o">+</span> <span class="n">IOC_IOST_Origin</span><span class="p">);</span>

	<span class="cm">/* turn on IO translation */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cmd_regs</span> <span class="o">+</span> <span class="n">IOC_IOCmd_Cfg</span><span class="p">)</span> <span class="o">|</span> <span class="n">IOC_IOCmd_Cfg_TE</span><span class="p">;</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">cmd_regs</span> <span class="o">+</span> <span class="n">IOC_IOCmd_Cfg</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_iommu_setup_hardware</span><span class="p">(</span><span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cell_iommu_setup_stab</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">ptab</span> <span class="o">=</span> <span class="n">cell_iommu_alloc_ptab</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					    <span class="n">IOMMU_PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">cell_iommu_enable_hardware</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c">/* Unused for now */</span>
<span class="c">static struct iommu_window *find_window(struct cbe_iommu *iommu,</span>
<span class="c">		unsigned long offset, unsigned long size)</span>
<span class="c">{</span>
<span class="c">	struct iommu_window *window;</span>

<span class="c">	/* todo: check for overlapping (but not equal) windows) */</span>

<span class="c">	list_for_each_entry(window, &amp;(iommu-&gt;windows), list) {</span>
<span class="c">		if (window-&gt;offset == offset &amp;&amp; window-&gt;size == size)</span>
<span class="c">			return window;</span>
<span class="c">	}</span>

<span class="c">	return NULL;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">cell_iommu_get_ioid</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ioid</span><span class="p">;</span>

	<span class="n">ioid</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;ioid&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioid</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;iommu: missing ioid for %s using 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">*</span><span class="n">ioid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iommu_window</span> <span class="o">*</span> <span class="n">__init</span>
<span class="nf">cell_iommu_setup_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iommu_window</span> <span class="o">*</span><span class="n">window</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ioid</span><span class="p">;</span>

	<span class="n">ioid</span> <span class="o">=</span> <span class="n">cell_iommu_get_ioid</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="n">window</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">window</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">window</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">window</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">window</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">window</span><span class="o">-&gt;</span><span class="n">ioid</span> <span class="o">=</span> <span class="n">ioid</span><span class="p">;</span>
	<span class="n">window</span><span class="o">-&gt;</span><span class="n">iommu</span> <span class="o">=</span> <span class="n">iommu</span><span class="p">;</span>

	<span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">it_blocksize</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">it_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">ptab</span><span class="p">;</span>
	<span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">it_index</span> <span class="o">=</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">;</span>
	<span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">it_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">IOMMU_PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">pte_offset</span><span class="p">;</span>
	<span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">it_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">IOMMU_PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">iommu_init_table</span><span class="p">(</span><span class="o">&amp;</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">ioid      %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">window</span><span class="o">-&gt;</span><span class="n">ioid</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">blocksize %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">it_blocksize</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">base      0x%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">it_base</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">offset    0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">it_offset</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">size      %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">it_size</span><span class="p">);</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">windows</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">window</span><span class="p">;</span>

	<span class="cm">/* We need to map and reserve the first IOMMU page since it&#39;s used</span>
<span class="cm">	 * by the spider workaround. In theory, we only need to do that when</span>
<span class="cm">	 * running on spider but it doesn&#39;t really matter.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This code also assumes that we have a window that starts at 0,</span>
<span class="cm">	 * which is the case on all spider based blades.</span>
<span class="cm">	 */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_node</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">);</span>
	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">pad_page</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">clear_page</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">pad_page</span><span class="p">);</span>

	<span class="n">__set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">it_map</span><span class="p">);</span>
	<span class="n">tce_build_cell</span><span class="p">(</span><span class="o">&amp;</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">,</span> <span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">it_offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">pad_page</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">it_hint</span> <span class="o">=</span> <span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">.</span><span class="n">it_blocksize</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">window</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="o">*</span><span class="nf">cell_iommu_for_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cbe_nr_iommus</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iommus</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span> <span class="o">==</span> <span class="n">nid</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">iommus</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cell_dma_direct_offset</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dma_iommu_fixed_base</span><span class="p">;</span>

<span class="cm">/* iommu_fixed_is_weak is set if booted with iommu_fixed=weak */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">iommu_fixed_is_weak</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="nf">cell_get_iommu_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iommu_window</span> <span class="o">*</span><span class="n">window</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>

	<span class="cm">/* Current implementation uses the first window available in that</span>
<span class="cm">	 * node&#39;s iommu. We -might- do something smarter later though it may</span>
<span class="cm">	 * never be necessary</span>
<span class="cm">	 */</span>
	<span class="n">iommu</span> <span class="o">=</span> <span class="n">cell_iommu_for_node</span><span class="p">(</span><span class="n">dev_to_node</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iommu</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">windows</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;iommu: missing iommu for %s (node %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">of_node</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="o">-&gt;</span><span class="n">full_name</span> <span class="o">:</span> <span class="s">&quot;?&quot;</span><span class="p">,</span>
		       <span class="n">dev_to_node</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">window</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">windows</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iommu_window</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* A coherent allocation implies strong ordering */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">dma_fixed_alloc_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				      <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flag</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_fixed_is_weak</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">iommu_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cell_get_iommu_table</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span>
					    <span class="n">size</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span>
					    <span class="n">device_to_mask</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">flag</span><span class="p">,</span>
					    <span class="n">dev_to_node</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">dma_direct_ops</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span>
					    <span class="n">attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_fixed_free_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_fixed_is_weak</span><span class="p">)</span>
		<span class="n">iommu_free_coherent</span><span class="p">(</span><span class="n">cell_get_iommu_table</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span>
				    <span class="n">dma_handle</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dma_direct_ops</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="nf">dma_fixed_map_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_fixed_is_weak</span> <span class="o">==</span> <span class="n">dma_get_attr</span><span class="p">(</span><span class="n">DMA_ATTR_WEAK_ORDERING</span><span class="p">,</span> <span class="n">attrs</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">dma_direct_ops</span><span class="p">.</span><span class="n">map_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
					       <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">iommu_map_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cell_get_iommu_table</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">page</span><span class="p">,</span>
				      <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">device_to_mask</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span>
				      <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_fixed_unmap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_fixed_is_weak</span> <span class="o">==</span> <span class="n">dma_get_attr</span><span class="p">(</span><span class="n">DMA_ATTR_WEAK_ORDERING</span><span class="p">,</span> <span class="n">attrs</span><span class="p">))</span>
		<span class="n">dma_direct_ops</span><span class="p">.</span><span class="n">unmap_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span>
					  <span class="n">attrs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">iommu_unmap_page</span><span class="p">(</span><span class="n">cell_get_iommu_table</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				 <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dma_fixed_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_fixed_is_weak</span> <span class="o">==</span> <span class="n">dma_get_attr</span><span class="p">(</span><span class="n">DMA_ATTR_WEAK_ORDERING</span><span class="p">,</span> <span class="n">attrs</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">dma_direct_ops</span><span class="p">.</span><span class="n">map_sg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">iommu_map_sg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cell_get_iommu_table</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span>
				    <span class="n">device_to_mask</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_fixed_unmap_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_fixed_is_weak</span> <span class="o">==</span> <span class="n">dma_get_attr</span><span class="p">(</span><span class="n">DMA_ATTR_WEAK_ORDERING</span><span class="p">,</span> <span class="n">attrs</span><span class="p">))</span>
		<span class="n">dma_direct_ops</span><span class="p">.</span><span class="n">unmap_sg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">iommu_unmap_sg</span><span class="p">(</span><span class="n">cell_get_iommu_table</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span>
			       <span class="n">attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dma_fixed_dma_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mask</span> <span class="o">==</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dma_set_mask_and_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">dma_mask</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="n">dma_iommu_fixed_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc</span>          <span class="o">=</span> <span class="n">dma_fixed_alloc_coherent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free</span>           <span class="o">=</span> <span class="n">dma_fixed_free_coherent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_sg</span>         <span class="o">=</span> <span class="n">dma_fixed_map_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_sg</span>       <span class="o">=</span> <span class="n">dma_fixed_unmap_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_supported</span>  <span class="o">=</span> <span class="n">dma_fixed_dma_supported</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_dma_mask</span>   <span class="o">=</span> <span class="n">dma_set_mask_and_switch</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_page</span>       <span class="o">=</span> <span class="n">dma_fixed_map_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_page</span>     <span class="o">=</span> <span class="n">dma_fixed_unmap_page</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cell_dma_dev_setup_fixed</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_dma_dev_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Order is important here, these are not mutually exclusive */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_dma_ops</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dma_iommu_fixed_ops</span><span class="p">)</span>
		<span class="n">cell_dma_dev_setup_fixed</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">get_pci_dma_ops</span><span class="p">()</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dma_iommu_ops</span><span class="p">)</span>
		<span class="n">set_iommu_table_base</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cell_get_iommu_table</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">get_pci_dma_ops</span><span class="p">()</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dma_direct_ops</span><span class="p">)</span>
		<span class="n">set_dma_offset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cell_dma_direct_offset</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_pci_dma_dev_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cell_dma_dev_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cell_of_bus_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* We are only intereted in device addition */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">!=</span> <span class="n">BUS_NOTIFY_ADD_DEVICE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* We use the PCI DMA ops */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">archdata</span><span class="p">.</span><span class="n">dma_ops</span> <span class="o">=</span> <span class="n">get_pci_dma_ops</span><span class="p">();</span>

	<span class="n">cell_dma_dev_setup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">cell_of_bus_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">cell_of_bus_notify</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cell_iommu_get_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dma_window</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* Use ibm,dma-window if available, else, hard code ! */</span>
	<span class="n">dma_window</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;ibm,dma-window&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_window</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x80000000u</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">of_parse_dma_window</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">dma_window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">cell_iommu_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Get node ID */</span>
	<span class="n">nid</span> <span class="o">=</span> <span class="n">of_node_to_nid</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;iommu: failed to get node for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;iommu: setting up iommu for node %d (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">nid</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>

	<span class="cm">/* XXX todo: If we can have multiple windows on the same IOMMU, which</span>
<span class="cm">	 * isn&#39;t the case today, we probably want here to check wether the</span>
<span class="cm">	 * iommu for that node is already setup.</span>
<span class="cm">	 * However, there might be issue with getting the size right so let&#39;s</span>
<span class="cm">	 * ignore that for now. We might want to completely get rid of the</span>
<span class="cm">	 * multiple window support since the cell iommu supports per-page ioids</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cbe_nr_iommus</span> <span class="o">&gt;=</span> <span class="n">NR_IOMMUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;iommu: too many IOMMUs detected ! (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Init base fields */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">cbe_nr_iommus</span><span class="o">++</span><span class="p">;</span>
	<span class="n">iommu</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iommus</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">stab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;iommu%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu</span><span class="o">-&gt;</span><span class="n">windows</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">iommu</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">cell_iommu_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">iommu</span> <span class="o">=</span> <span class="n">cell_iommu_alloc</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Obtain a window for it */</span>
	<span class="n">cell_iommu_get_window</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">translating window 0x%lx...0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">base</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Initialize the hardware */</span>
	<span class="n">cell_iommu_setup_hardware</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* Setup the iommu_table */</span>
	<span class="n">cell_iommu_setup_window</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				<span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">IOMMU_PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">cell_disable_iommus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">xregs</span><span class="p">,</span> <span class="o">*</span><span class="n">cregs</span><span class="p">;</span>

	<span class="cm">/* Make sure IOC translation is disabled on all nodes */</span>
	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cell_iommu_find_ioc</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">xregs</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">IOC_Reg_Size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xregs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">cregs</span> <span class="o">=</span> <span class="n">xregs</span> <span class="o">+</span> <span class="n">IOC_IOCmd_Offset</span><span class="p">;</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;iommu: cleaning up iommu on node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="n">out_be64</span><span class="p">(</span><span class="n">xregs</span> <span class="o">+</span> <span class="n">IOC_IOST_Origin</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">in_be64</span><span class="p">(</span><span class="n">xregs</span> <span class="o">+</span> <span class="n">IOC_IOST_Origin</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="n">cregs</span> <span class="o">+</span> <span class="n">IOC_IOCmd_Cfg</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IOC_IOCmd_Cfg_TE</span><span class="p">;</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="n">cregs</span> <span class="o">+</span> <span class="n">IOC_IOCmd_Cfg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">in_be64</span><span class="p">(</span><span class="n">cregs</span> <span class="o">+</span> <span class="n">IOC_IOCmd_Cfg</span><span class="p">);</span>

		<span class="n">iounmap</span><span class="p">(</span><span class="n">xregs</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cell_iommu_init_disabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* When no iommu is present, we use direct DMA ops */</span>
	<span class="n">set_pci_dma_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_direct_ops</span><span class="p">);</span>

	<span class="cm">/* First make sure all IOC translation is turned off */</span>
	<span class="n">cell_disable_iommus</span><span class="p">();</span>

	<span class="cm">/* If we have no Axon, we set up the spider DMA magic offset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_find_node_by_name</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;axon&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">cell_dma_direct_offset</span> <span class="o">=</span> <span class="n">SPIDER_DMA_OFFSET</span><span class="p">;</span>

	<span class="cm">/* Now we need to check to see where the memory is mapped</span>
<span class="cm">	 * in PCI space. We assume that all busses use the same dma</span>
<span class="cm">	 * window which is always the case so far on Cell, thus we</span>
<span class="cm">	 * pick up the first pci-internal node we can find and check</span>
<span class="cm">	 * the DMA window from there.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_node_by_name</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;axon&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cell_iommu_get_window</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_node_by_name</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;pci-internal&quot;</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cell_iommu_get_window</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="cm">/* If we found a DMA window, we check if it&#39;s big enough to enclose</span>
<span class="cm">	 * all of physical memory. If not, we force enable IOMMU</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">memblock_end_of_DRAM</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;iommu: force-enabled, dma window&quot;</span>
		       <span class="s">&quot; (%ldMB) smaller than total memory (%lldMB)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">,</span> <span class="n">memblock_end_of_DRAM</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cell_dma_direct_offset</span> <span class="o">+=</span> <span class="n">base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cell_dma_direct_offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">pci_dma_dev_setup</span> <span class="o">=</span> <span class="n">cell_pci_dma_dev_setup</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;iommu: disabled, direct DMA offset is 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">cell_dma_direct_offset</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Fixed IOMMU mapping support</span>
<span class="cm"> *</span>
<span class="cm"> *  This code adds support for setting up a fixed IOMMU mapping on certain</span>
<span class="cm"> *  cell machines. For 64-bit devices this avoids the performance overhead of</span>
<span class="cm"> *  mapping and unmapping pages at runtime. 32-bit devices are unable to use</span>
<span class="cm"> *  the fixed mapping.</span>
<span class="cm"> *</span>
<span class="cm"> *  The fixed mapping is established at boot, and maps all of physical memory</span>
<span class="cm"> *  1:1 into device space at some offset. On machines with &lt; 30 GB of memory</span>
<span class="cm"> *  we setup the fixed mapping immediately above the normal IOMMU window.</span>
<span class="cm"> *</span>
<span class="cm"> *  For example a machine with 4GB of memory would end up with the normal</span>
<span class="cm"> *  IOMMU window from 0-2GB and the fixed mapping window from 2GB to 6GB. In</span>
<span class="cm"> *  this case a 64-bit device wishing to DMA to 1GB would be told to DMA to</span>
<span class="cm"> *  3GB, plus any offset required by firmware. The firmware offset is encoded</span>
<span class="cm"> *  in the &quot;dma-ranges&quot; property.</span>
<span class="cm"> *</span>
<span class="cm"> *  On machines with 30GB or more of memory, we are unable to place the fixed</span>
<span class="cm"> *  mapping above the normal IOMMU window as we would run out of address space.</span>
<span class="cm"> *  Instead we move the normal IOMMU window to coincide with the hash page</span>
<span class="cm"> *  table, this region does not need to be part of the fixed mapping as no</span>
<span class="cm"> *  device should ever be DMA&#39;ing to it. We then setup the fixed mapping</span>
<span class="cm"> *  from 0 to 32GB.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">cell_iommu_get_fixed_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">cpu_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">best_size</span><span class="p">,</span> <span class="n">dev_addr</span> <span class="o">=</span> <span class="n">OF_BAD_ADDR</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ranges</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">best</span><span class="p">,</span> <span class="n">naddr</span><span class="p">,</span> <span class="n">nsize</span><span class="p">,</span> <span class="n">pna</span><span class="p">,</span> <span class="n">range_size</span><span class="p">;</span>

	<span class="n">np</span> <span class="o">=</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">naddr</span> <span class="o">=</span> <span class="n">of_n_addr_cells</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="n">nsize</span> <span class="o">=</span> <span class="n">of_n_size_cells</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="n">np</span> <span class="o">=</span> <span class="n">of_get_next_parent</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ranges</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;dma-ranges&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

		<span class="cm">/* Ignore empty ranges, they imply no translation required */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ranges</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ranges</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;iommu: no dma-ranges found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">/=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>

	<span class="n">pna</span> <span class="o">=</span> <span class="n">of_n_addr_cells</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="n">range_size</span> <span class="o">=</span> <span class="n">naddr</span> <span class="o">+</span> <span class="n">nsize</span> <span class="o">+</span> <span class="n">pna</span><span class="p">;</span>

	<span class="cm">/* dma-ranges format:</span>
<span class="cm">	 * child addr	: naddr cells</span>
<span class="cm">	 * parent addr	: pna cells</span>
<span class="cm">	 * size		: nsize cells</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">best</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">best_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">range_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_addr</span> <span class="o">=</span> <span class="n">of_translate_dma_address</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">ranges</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="n">naddr</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">of_read_number</span><span class="p">(</span><span class="n">ranges</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="n">naddr</span> <span class="o">+</span> <span class="n">pna</span><span class="p">,</span> <span class="n">nsize</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_addr</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">best_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">best</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">best_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">best</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_addr</span> <span class="o">=</span> <span class="n">of_read_number</span><span class="p">(</span><span class="n">ranges</span> <span class="o">+</span> <span class="n">best</span><span class="p">,</span> <span class="n">naddr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;iommu: no suitable range found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dev_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dma_set_mask_and_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">dma_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">||</span> <span class="o">!</span><span class="n">dma_supported</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_mask</span> <span class="o">==</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">cell_iommu_get_fixed_address</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">OF_BAD_ADDR</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;iommu: 64-bit OK, using fixed ops</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">set_dma_ops</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_iommu_fixed_ops</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;iommu: not 64-bit, using default ops</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">set_dma_ops</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">get_pci_dma_ops</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="n">cell_dma_dev_setup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="o">*</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="n">dma_mask</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_dma_dev_setup_fixed</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">cell_iommu_get_fixed_address</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">+</span> <span class="n">dma_iommu_fixed_base</span><span class="p">;</span>
	<span class="n">set_dma_offset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;iommu: fixed addr = %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">insert_16M_pte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptab</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">segment</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">segment</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">IO_SEGMENT_SHIFT</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">segment</span> <span class="o">&lt;&lt;</span> <span class="n">IO_PAGENO_BITS</span><span class="p">(</span><span class="mi">24</span><span class="p">));</span>
	<span class="n">ptab</span> <span class="o">=</span> <span class="n">ptab</span> <span class="o">+</span> <span class="p">(</span><span class="n">segment</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;iommu: addr %lx ptab %p segment %lx offset %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">addr</span><span class="p">,</span> <span class="n">ptab</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">ptab</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_pte</span> <span class="o">|</span> <span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CBE_IOPTE_RPN_Mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_iommu_setup_fixed_ptab</span><span class="p">(</span><span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dbase</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dsize</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fbase</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base_pte</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span> <span class="n">ioaddr</span><span class="p">,</span> <span class="o">*</span><span class="n">ptab</span><span class="p">;</span>

	<span class="n">ptab</span> <span class="o">=</span> <span class="n">cell_iommu_alloc_ptab</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">fbase</span><span class="p">,</span> <span class="n">fsize</span><span class="p">,</span> <span class="n">dbase</span><span class="p">,</span> <span class="n">dsize</span><span class="p">,</span> <span class="mi">24</span><span class="p">);</span>

	<span class="n">dma_iommu_fixed_base</span> <span class="o">=</span> <span class="n">fbase</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;iommu: mapping 0x%lx pages from 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fsize</span><span class="p">,</span> <span class="n">fbase</span><span class="p">);</span>

	<span class="n">base_pte</span> <span class="o">=</span> <span class="n">CBE_IOPTE_PP_W</span> <span class="o">|</span> <span class="n">CBE_IOPTE_PP_R</span> <span class="o">|</span> <span class="n">CBE_IOPTE_M</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">cell_iommu_get_ioid</span><span class="p">(</span><span class="n">np</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CBE_IOPTE_IOID_Mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_fixed_is_weak</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;IOMMU: Using weak ordering for fixed mapping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;IOMMU: Using strong ordering for fixed mapping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">base_pte</span> <span class="o">|=</span> <span class="n">CBE_IOPTE_SO_RW</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">uaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">uaddr</span> <span class="o">&lt;</span> <span class="n">fsize</span><span class="p">;</span> <span class="n">uaddr</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Don&#39;t touch the dynamic region */</span>
		<span class="n">ioaddr</span> <span class="o">=</span> <span class="n">uaddr</span> <span class="o">+</span> <span class="n">fbase</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioaddr</span> <span class="o">&gt;=</span> <span class="n">dbase</span> <span class="o">&amp;&amp;</span> <span class="n">ioaddr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">dbase</span> <span class="o">+</span> <span class="n">dsize</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;iommu: fixed/dynamic overlap, skipping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">insert_16M_pte</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">ptab</span><span class="p">,</span> <span class="n">base_pte</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cell_iommu_fixed_mapping_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dbase</span><span class="p">,</span> <span class="n">dsize</span><span class="p">,</span> <span class="n">fbase</span><span class="p">,</span> <span class="n">fsize</span><span class="p">,</span> <span class="n">hbase</span><span class="p">,</span> <span class="n">hend</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cbe_iommu</span> <span class="o">*</span><span class="n">iommu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>

	<span class="cm">/* The fixed mapping is only supported on axon machines */</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">of_find_node_by_name</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;axon&quot;</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;iommu: fixed mapping disabled, no axons found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We must have dma-ranges properties for fixed mapping to work */</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">of_find_node_with_property</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;dma-ranges&quot;</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;iommu: no dma-ranges found, no fixed mapping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The default setup is to have the fixed mapping sit after the</span>
<span class="cm">	 * dynamic region, so find the top of the largest IOMMU window</span>
<span class="cm">	 * on any axon, then add the size of RAM and that&#39;s our max value.</span>
<span class="cm">	 * If that is &gt; 32GB we have to do other shennanigans.</span>
<span class="cm">	 */</span>
	<span class="n">fbase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_node_by_name</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;axon&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cell_iommu_get_window</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dsize</span><span class="p">);</span>
		<span class="n">fbase</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">fbase</span><span class="p">,</span> <span class="n">dbase</span> <span class="o">+</span> <span class="n">dsize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">fbase</span> <span class="o">=</span> <span class="n">_ALIGN_UP</span><span class="p">(</span><span class="n">fbase</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IO_SEGMENT_SHIFT</span><span class="p">);</span>
	<span class="n">fsize</span> <span class="o">=</span> <span class="n">memblock_phys_mem_size</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fbase</span> <span class="o">+</span> <span class="n">fsize</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0x800000000ul</span><span class="p">)</span>
		<span class="n">hbase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* use the device tree window */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* If we&#39;re over 32 GB we need to cheat. We can&#39;t map all of</span>
<span class="cm">		 * RAM with the fixed mapping, and also fit the dynamic</span>
<span class="cm">		 * region. So try to place the dynamic region where the hash</span>
<span class="cm">		 * table sits, drivers never need to DMA to it, we don&#39;t</span>
<span class="cm">		 * need a fixed mapping for that area.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">htab_address</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;iommu: htab is NULL, on LPAR? Huh?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hbase</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">htab_address</span><span class="p">);</span>
		<span class="n">hend</span>  <span class="o">=</span> <span class="n">hbase</span> <span class="o">+</span> <span class="n">htab_size_bytes</span><span class="p">;</span>

		<span class="cm">/* The window must start and end on a segment boundary */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">hbase</span> <span class="o">!=</span> <span class="n">_ALIGN_UP</span><span class="p">(</span><span class="n">hbase</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IO_SEGMENT_SHIFT</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">hend</span> <span class="o">!=</span> <span class="n">_ALIGN_UP</span><span class="p">(</span><span class="n">hend</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IO_SEGMENT_SHIFT</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;iommu: hash window not segment aligned</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Check the hash window fits inside the real DMA window */</span>
		<span class="n">for_each_node_by_name</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;axon&quot;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cell_iommu_get_window</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dsize</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">hbase</span> <span class="o">&lt;</span> <span class="n">dbase</span> <span class="o">||</span> <span class="p">(</span><span class="n">hend</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">dbase</span> <span class="o">+</span> <span class="n">dsize</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;iommu: hash window doesn&#39;t fit in&quot;</span>
					 <span class="s">&quot;real DMA window</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">fbase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Setup the dynamic regions */</span>
	<span class="n">for_each_node_by_name</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;axon&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iommu</span> <span class="o">=</span> <span class="n">cell_iommu_alloc</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">iommu</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hbase</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">cell_iommu_get_window</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dsize</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">dbase</span> <span class="o">=</span> <span class="n">hbase</span><span class="p">;</span>
			<span class="n">dsize</span> <span class="o">=</span> <span class="n">htab_size_bytes</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;iommu: node %d, dynamic window 0x%lx-0x%lx &quot;</span>
			<span class="s">&quot;fixed window 0x%lx-0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iommu</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="n">dbase</span><span class="p">,</span>
			 <span class="n">dbase</span> <span class="o">+</span> <span class="n">dsize</span><span class="p">,</span> <span class="n">fbase</span><span class="p">,</span> <span class="n">fbase</span> <span class="o">+</span> <span class="n">fsize</span><span class="p">);</span>

		<span class="n">cell_iommu_setup_stab</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">dbase</span><span class="p">,</span> <span class="n">dsize</span><span class="p">,</span> <span class="n">fbase</span><span class="p">,</span> <span class="n">fsize</span><span class="p">);</span>
		<span class="n">iommu</span><span class="o">-&gt;</span><span class="n">ptab</span> <span class="o">=</span> <span class="n">cell_iommu_alloc_ptab</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">dbase</span><span class="p">,</span> <span class="n">dsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						    <span class="n">IOMMU_PAGE_SHIFT</span><span class="p">);</span>
		<span class="n">cell_iommu_setup_fixed_ptab</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span> <span class="n">dbase</span><span class="p">,</span> <span class="n">dsize</span><span class="p">,</span>
					     <span class="n">fbase</span><span class="p">,</span> <span class="n">fsize</span><span class="p">);</span>
		<span class="n">cell_iommu_enable_hardware</span><span class="p">(</span><span class="n">iommu</span><span class="p">);</span>
		<span class="n">cell_iommu_setup_window</span><span class="p">(</span><span class="n">iommu</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span> <span class="n">dbase</span><span class="p">,</span> <span class="n">dsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dma_iommu_ops</span><span class="p">.</span><span class="n">set_dma_mask</span> <span class="o">=</span> <span class="n">dma_set_mask_and_switch</span><span class="p">;</span>
	<span class="n">set_pci_dma_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_iommu_ops</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">iommu_fixed_disabled</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_iommu_fixed</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">pciep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">iommu_fixed_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* If we can find a pcie-endpoint in the device tree assume that</span>
<span class="cm">	 * we&#39;re on a triblade or a CAB so by default the fixed mapping</span>
<span class="cm">	 * should be set to be weakly ordered; but only if the boot</span>
<span class="cm">	 * option WASN&#39;T set for strong ordering</span>
<span class="cm">	 */</span>
	<span class="n">pciep</span> <span class="o">=</span> <span class="n">of_find_node_by_type</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;pcie-endpoint&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;weak&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">pciep</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;strong&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">iommu_fixed_is_weak</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">of_node_put</span><span class="p">(</span><span class="n">pciep</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;iommu_fixed=&quot;</span><span class="p">,</span> <span class="n">setup_iommu_fixed</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">cell_dma_get_required_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="o">*</span><span class="n">dma_ops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu_fixed_disabled</span> <span class="o">&amp;&amp;</span>
			<span class="n">cell_iommu_get_fixed_address</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">OF_BAD_ADDR</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>

	<span class="n">dma_ops</span> <span class="o">=</span> <span class="n">get_dma_ops</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">get_required_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dma_ops</span><span class="o">-&gt;</span><span class="n">get_required_mask</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;no get_required_mask in %p ops&quot;</span><span class="p">,</span> <span class="n">dma_ops</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cell_iommu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>

	<span class="cm">/* If IOMMU is disabled or we have little enough RAM to not need</span>
<span class="cm">	 * to enable it, we setup a direct mapping.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: should we make sure we have the IOMMU actually disabled ?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_is_off</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">iommu_force_on</span> <span class="o">&amp;&amp;</span> <span class="n">memblock_end_of_DRAM</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mh">0x80000000ull</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cell_iommu_init_disabled</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="cm">/* Setup various ppc_md. callbacks */</span>
	<span class="n">ppc_md</span><span class="p">.</span><span class="n">pci_dma_dev_setup</span> <span class="o">=</span> <span class="n">cell_pci_dma_dev_setup</span><span class="p">;</span>
	<span class="n">ppc_md</span><span class="p">.</span><span class="n">dma_get_required_mask</span> <span class="o">=</span> <span class="n">cell_dma_get_required_mask</span><span class="p">;</span>
	<span class="n">ppc_md</span><span class="p">.</span><span class="n">tce_build</span> <span class="o">=</span> <span class="n">tce_build_cell</span><span class="p">;</span>
	<span class="n">ppc_md</span><span class="p">.</span><span class="n">tce_free</span> <span class="o">=</span> <span class="n">tce_free_cell</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iommu_fixed_disabled</span> <span class="o">&amp;&amp;</span> <span class="n">cell_iommu_fixed_mapping_init</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="cm">/* Create an iommu for each /axon node.  */</span>
	<span class="n">for_each_node_by_name</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;axon&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">cell_iommu_init_one</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Create an iommu for each toplevel /pci-internal node for</span>
<span class="cm">	 * old hardware/firmware</span>
<span class="cm">	 */</span>
	<span class="n">for_each_node_by_name</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;pci-internal&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">cell_iommu_init_one</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SPIDER_DMA_OFFSET</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Setup default PCI iommu ops */</span>
	<span class="n">set_pci_dma_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_iommu_ops</span><span class="p">);</span>

 <span class="nl">bail:</span>
	<span class="cm">/* Register callbacks on OF platform device addition/removal</span>
<span class="cm">	 * to handle linking them to the right DMA operations</span>
<span class="cm">	 */</span>
	<span class="n">bus_register_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">platform_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cell_of_bus_notifier</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">machine_arch_initcall</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">cell_iommu_init</span><span class="p">);</span>
<span class="n">machine_arch_initcall</span><span class="p">(</span><span class="n">celleb_native</span><span class="p">,</span> <span class="n">cell_iommu_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
