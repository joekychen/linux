<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › platforms › cell › spufs › file.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>file.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SPU file system -- file contents</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright IBM Deutschland Entwicklung GmbH 2005</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Arnd Bergmann &lt;arndb@de.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#undef DEBUG</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/time.h&gt;</span>
<span class="cp">#include &lt;asm/spu.h&gt;</span>
<span class="cp">#include &lt;asm/spu_info.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &quot;spufs.h&quot;</span>
<span class="cp">#include &quot;sputrace.h&quot;</span>

<span class="cp">#define SPUFS_MMAP_4K (PAGE_SIZE == 0x1000)</span>

<span class="cm">/* Simple attribute files */</span>
<span class="k">struct</span> <span class="n">spufs_attr</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">get_buf</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>       <span class="cm">/* enough to store a u64 and &quot;\n\0&quot; */</span>
	<span class="kt">char</span> <span class="n">set_buf</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>        <span class="cm">/* format for read operation */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>     <span class="cm">/* protects access to these buffers */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_attr_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="p">),</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span><span class="p">),</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>

	<span class="n">attr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">attr</span><span class="o">-&gt;</span><span class="n">get</span> <span class="o">=</span> <span class="n">get</span><span class="p">;</span>
	<span class="n">attr</span><span class="o">-&gt;</span><span class="n">set</span> <span class="o">=</span> <span class="n">set</span><span class="p">;</span>
	<span class="n">attr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
	<span class="n">attr</span><span class="o">-&gt;</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">attr</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_attr_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
       <span class="n">kfree</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_attr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">attr</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* continued read */</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">get_buf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* first read */</span>
		<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">get_buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">get_buf</span><span class="p">),</span>
				 <span class="n">attr</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">get_buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_attr_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">attr</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">set_buf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">set_buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span> <span class="cm">/* claim we got the whole input */</span>
	<span class="n">attr</span><span class="o">-&gt;</span><span class="n">set_buf</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">simple_strtol</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">set_buf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">attr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define DEFINE_SPUFS_SIMPLE_ATTRIBUTE(__fops, __get, __set, __fmt)	\</span>
<span class="cp">static int __fops ## _open(struct inode *inode, struct file *file)	\</span>
<span class="cp">{									\</span>
<span class="cp">	__simple_attr_check_format(__fmt, 0ull);			\</span>
<span class="cp">	return spufs_attr_open(inode, file, __get, __set, __fmt);	\</span>
<span class="cp">}									\</span>
<span class="cp">static const struct file_operations __fops = {				\</span>
<span class="cp">	.owner	 = THIS_MODULE,						\</span>
<span class="cp">	.open	 = __fops ## _open,					\</span>
<span class="cp">	.release = spufs_attr_release,					\</span>
<span class="cp">	.read	 = spufs_attr_read,					\</span>
<span class="cp">	.write	 = spufs_attr_write,					\</span>
<span class="cp">	.llseek  = generic_file_llseek,					\</span>
<span class="cp">};</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spufs_mem_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_openers</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">local_store</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spufs_mem_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_openers</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">local_store</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">__spufs_mem_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">local_store</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_ls</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">local_store</span><span class="p">,</span>
					<span class="n">LS_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">spufs_mem_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__spufs_mem_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">spufs_mem_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">local_store</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">LS_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">local_store</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_ls</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">simple_write_to_buffer</span><span class="p">(</span><span class="n">local_store</span><span class="p">,</span> <span class="n">LS_SIZE</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spufs_mem_mmap_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span>	<span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">virtual_address</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SPU_FS_64K_LS</span>
	<span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">psize</span><span class="p">;</span>

	<span class="cm">/* Check what page size we are using */</span>
	<span class="n">psize</span> <span class="o">=</span> <span class="n">get_slice_psize</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

	<span class="cm">/* Some sanity checking */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">use_big_pages</span> <span class="o">!=</span> <span class="p">(</span><span class="n">psize</span> <span class="o">==</span> <span class="n">MMU_PAGE_64K</span><span class="p">));</span>

	<span class="cm">/* Wow, 64K, cool, we need to align the address though */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">use_big_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
		<span class="n">address</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0xfffful</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SPU_FS_64K_LS */</span><span class="cp"></span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">LS_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;spufs_mem_mmap_fault address=0x%lx, offset=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">address</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">VM_FAULT_NOPAGE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SPU_STATE_SAVED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">pgprot_cached</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
		<span class="n">pfn</span> <span class="o">=</span> <span class="n">vmalloc_to_pfn</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">ls</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">pgprot_noncached_wc</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
		<span class="n">pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">local_store_phys</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vm_insert_pfn</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>

	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">VM_FAULT_NOPAGE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_mem_mmap_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">address</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">local_store</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">local_store</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_ls</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span>
		<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">local_store</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">local_store</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">spufs_mem_mmap_vmops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span> <span class="o">=</span> <span class="n">spufs_mem_mmap_fault</span><span class="p">,</span>
	<span class="p">.</span><span class="n">access</span> <span class="o">=</span> <span class="n">spufs_mem_mmap_access</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_mem_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SPU_FS_64K_LS</span>
	<span class="k">struct</span> <span class="n">spu_context</span>	<span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_state</span>	<span class="o">*</span><span class="n">csa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">;</span>

	<span class="cm">/* Sanity check VMA alignment */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">use_big_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;spufs_mem_mmap 64K, start=0x%lx, end=0x%lx,&quot;</span>
			 <span class="s">&quot; pgoff=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span>
			 <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SPU_FS_64K_LS */</span><span class="cp"></span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">pgprot_noncached_wc</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spufs_mem_mmap_vmops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SPU_FS_64K_LS</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">spufs_get_unmapped_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span>	<span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_state</span>	<span class="o">*</span><span class="n">csa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">;</span>

	<span class="cm">/* If not using big pages, fallback to normal MM g_u_a */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">use_big_pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">get_unmapped_area</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
						      <span class="n">pgoff</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Else, try to obtain a 64K pages slice */</span>
	<span class="k">return</span> <span class="n">slice_get_unmapped_area</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
				       <span class="n">MMU_PAGE_64K</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SPU_FS_64K_LS */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_mem_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>			<span class="o">=</span> <span class="n">spufs_mem_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">spufs_mem_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>			<span class="o">=</span> <span class="n">spufs_mem_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>			<span class="o">=</span> <span class="n">spufs_mem_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>			<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>			<span class="o">=</span> <span class="n">spufs_mem_mmap</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_SPU_FS_64K_LS</span>
	<span class="p">.</span><span class="n">get_unmapped_area</span>	<span class="o">=</span> <span class="n">spufs_get_unmapped_area</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_ps_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ps_offs</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ps_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">area</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spu_context_nospu_trace</span><span class="p">(</span><span class="n">spufs_ps_fault__enter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">ps_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Because we release the mmap_sem, the context may be destroyed while</span>
<span class="cm">	 * we&#39;re in spu_wait. Grab an extra reference so it isn&#39;t destroyed</span>
<span class="cm">	 * in the meantime.</span>
<span class="cm">	 */</span>
	<span class="n">get_spu_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to wait for context to be loaded before we have</span>
<span class="cm">	 * pages to hand out to the user, but we don&#39;t want to wait</span>
<span class="cm">	 * with the mmap_sem held.</span>
<span class="cm">	 * It is possible to drop the mmap_sem here, but then we need</span>
<span class="cm">	 * to return VM_FAULT_NOPAGE because the mappings may have</span>
<span class="cm">	 * hanged.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">refault</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SPU_STATE_SAVED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="n">spu_context_nospu_trace</span><span class="p">(</span><span class="n">spufs_ps_fault__sleep</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">spufs_wait</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">run_wq</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SPU_STATE_RUNNABLE</span><span class="p">);</span>
		<span class="n">spu_context_trace</span><span class="p">(</span><span class="n">spufs_ps_fault__wake</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span><span class="p">);</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">area</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem_phys</span> <span class="o">+</span> <span class="n">ps_offs</span><span class="p">;</span>
		<span class="n">vm_insert_pfn</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">virtual_address</span><span class="p">,</span>
					<span class="p">(</span><span class="n">area</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="n">spu_context_trace</span><span class="p">(</span><span class="n">spufs_ps_fault__insert</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

<span class="nl">refault:</span>
	<span class="n">put_spu_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">VM_FAULT_NOPAGE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if SPUFS_MMAP_4K</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_cntl_mmap_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">spufs_ps_fault</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="p">,</span> <span class="mh">0x4000</span><span class="p">,</span> <span class="n">SPUFS_CNTL_MAP_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">spufs_cntl_mmap_vmops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span> <span class="o">=</span> <span class="n">spufs_cntl_mmap_fault</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * mmap support for problem state control area [0x4000 - 0x4fff].</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_cntl_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">pgprot_noncached</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spufs_cntl_mmap_vmops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* SPUFS_MMAP_4K */</span><span class="cp"></span>
<span class="cp">#define spufs_cntl_mmap NULL</span>
<span class="cp">#endif </span><span class="cm">/* !SPUFS_MMAP_4K */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_cntl_get</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">status_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_cntl_set</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">runcntl_write</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_cntl_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_openers</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cntl</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">simple_attr_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">spufs_cntl_get</span><span class="p">,</span>
					<span class="n">spufs_cntl_set</span><span class="p">,</span> <span class="s">&quot;0x%08lx&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spufs_cntl_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="n">simple_attr_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_openers</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cntl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_cntl_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">spufs_cntl_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">spufs_cntl_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">simple_attr_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">simple_attr_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>	<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">spufs_cntl_mmap</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spufs_regs_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">__spufs_regs_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_lscsa</span> <span class="o">*</span><span class="n">lscsa</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">lscsa</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
				      <span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">gprs</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">gprs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">spufs_regs_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="cm">/* pre-check for file position: if we&#39;d return EOF, there&#39;s no point</span>
<span class="cm">	 * causing a deschedule */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">gprs</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__spufs_regs_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">spu_release_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">spufs_regs_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
		 <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_lscsa</span> <span class="o">*</span><span class="n">lscsa</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">lscsa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">gprs</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">simple_write_to_buffer</span><span class="p">(</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">gprs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">gprs</span><span class="p">),</span> <span class="n">pos</span><span class="p">,</span>
					<span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">spu_release_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_regs_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>	 <span class="o">=</span> <span class="n">spufs_regs_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>    <span class="o">=</span> <span class="n">spufs_regs_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>   <span class="o">=</span> <span class="n">spufs_regs_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">__spufs_fpcr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_lscsa</span> <span class="o">*</span><span class="n">lscsa</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">lscsa</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">fpcr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">fpcr</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">spufs_fpcr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__spufs_fpcr_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">spu_release_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">spufs_fpcr_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">,</span>
		 <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_lscsa</span> <span class="o">*</span><span class="n">lscsa</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">lscsa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">fpcr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">simple_write_to_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">fpcr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">fpcr</span><span class="p">),</span> <span class="n">pos</span><span class="p">,</span>
					<span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">spu_release_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_fpcr_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">spufs_regs_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">spufs_fpcr_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">spufs_fpcr_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* generic open function for all pipe-like files */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_pipe_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read as many bytes from the mailbox as possible, until</span>
<span class="cm"> * one of the conditions becomes true:</span>
<span class="cm"> *</span>
<span class="cm"> * - no more data available in the mailbox</span>
<span class="cm"> * - end of the user provided buffer</span>
<span class="cm"> * - end of the mapped area</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_mbox_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mbox_data</span><span class="p">,</span> <span class="n">__user</span> <span class="o">*</span><span class="n">udata</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">udata</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">;</span> <span class="n">count</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">udata</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mbox_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbox_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * at the end of the mapped area, we can fault</span>
<span class="cm">		 * but still need to return the data we have</span>
<span class="cm">		 * read successfully so far.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">mbox_data</span><span class="p">,</span> <span class="n">udata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
				<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_mbox_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>	<span class="o">=</span> <span class="n">spufs_pipe_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>	<span class="o">=</span> <span class="n">spufs_mbox_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>	<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_mbox_stat_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mbox_stat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mbox_stat</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mbox_stat_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbox_stat</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">mbox_stat</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_mbox_stat_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>	<span class="o">=</span> <span class="n">spufs_pipe_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>	<span class="o">=</span> <span class="n">spufs_mbox_stat_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* low-level ibox access function */</span>
<span class="kt">size_t</span> <span class="nf">spu_ibox_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ibox_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_ibox_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">fasync_helper</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ibox_fasync</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* interrupt-level ibox callback function. */</span>
<span class="kt">void</span> <span class="nf">spufs_ibox_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ibox_wq</span><span class="p">);</span>
	<span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ibox_fasync</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">POLLIN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read as many bytes from the interrupt mailbox as possible, until</span>
<span class="cm"> * one of the conditions becomes true:</span>
<span class="cm"> *</span>
<span class="cm"> * - no more data available in the mailbox</span>
<span class="cm"> * - end of the user provided buffer</span>
<span class="cm"> * - end of the mapped area</span>
<span class="cm"> *</span>
<span class="cm"> * If the file is opened without O_NONBLOCK, we wait here until</span>
<span class="cm"> * any data is available, but return when we have been able to</span>
<span class="cm"> * read something.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_ibox_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ibox_data</span><span class="p">,</span> <span class="n">__user</span> <span class="o">*</span><span class="n">udata</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">udata</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* wait only for the first element */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spu_ibox_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ibox_data</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">spufs_wait</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ibox_wq</span><span class="p">,</span> <span class="n">spu_ibox_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ibox_data</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if we can&#39;t write at all, return -EFAULT */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">ibox_data</span><span class="p">,</span> <span class="n">udata</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">udata</span><span class="o">++</span><span class="p">;</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">;</span> <span class="n">count</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">udata</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ibox_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ibox_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * at the end of the mapped area, we can fault</span>
<span class="cm">		 * but still need to return the data we have</span>
<span class="cm">		 * read successfully so far.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">ibox_data</span><span class="p">,</span> <span class="n">udata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">spufs_ibox_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ibox_wq</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For now keep this uninterruptible and also ignore the rule</span>
<span class="cm">	 * that poll should not sleep.  Will be fixed later.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mbox_stat_poll</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">);</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_ibox_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>	<span class="o">=</span> <span class="n">spufs_pipe_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>	<span class="o">=</span> <span class="n">spufs_ibox_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>	<span class="o">=</span> <span class="n">spufs_ibox_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fasync</span>	<span class="o">=</span> <span class="n">spufs_ibox_fasync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_ibox_stat_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ibox_stat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ibox_stat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mbox_stat_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ibox_stat</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">ibox_stat</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_ibox_stat_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>	<span class="o">=</span> <span class="n">spufs_pipe_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>	<span class="o">=</span> <span class="n">spufs_ibox_stat_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* low-level mailbox write */</span>
<span class="kt">size_t</span> <span class="nf">spu_wbox_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">wbox_write</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_wbox_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">fasync_helper</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wbox_fasync</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* interrupt-level wbox callback function. */</span>
<span class="kt">void</span> <span class="nf">spufs_wbox_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wbox_wq</span><span class="p">);</span>
	<span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wbox_fasync</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">POLLOUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write as many bytes to the interrupt mailbox as possible, until</span>
<span class="cm"> * one of the conditions becomes true:</span>
<span class="cm"> *</span>
<span class="cm"> * - the mailbox is full</span>
<span class="cm"> * - end of the user provided buffer</span>
<span class="cm"> * - end of the mapped area</span>
<span class="cm"> *</span>
<span class="cm"> * If the file is opened without O_NONBLOCK, we wait here until</span>
<span class="cm"> * space is availabyl, but return when we have been able to</span>
<span class="cm"> * write something.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_wbox_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wbox_data</span><span class="p">,</span> <span class="n">__user</span> <span class="o">*</span><span class="n">udata</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">udata</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">wbox_data</span><span class="p">,</span> <span class="n">udata</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * make sure we can at least write one element, by waiting</span>
<span class="cm">	 * in case of !O_NONBLOCK</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spu_wbox_write</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">wbox_data</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">spufs_wait</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wbox_wq</span><span class="p">,</span> <span class="n">spu_wbox_write</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">wbox_data</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* write as much as possible */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">udata</span><span class="o">++</span><span class="p">;</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">;</span> <span class="n">count</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">udata</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">wbox_data</span><span class="p">,</span> <span class="n">udata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_wbox_write</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">wbox_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">spufs_wbox_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wbox_wq</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For now keep this uninterruptible and also ignore the rule</span>
<span class="cm">	 * that poll should not sleep.  Will be fixed later.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mbox_stat_poll</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">);</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_wbox_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>	<span class="o">=</span> <span class="n">spufs_pipe_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>	<span class="o">=</span> <span class="n">spufs_wbox_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>	<span class="o">=</span> <span class="n">spufs_wbox_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fasync</span>	<span class="o">=</span> <span class="n">spufs_wbox_fasync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_wbox_stat_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wbox_stat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">wbox_stat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mbox_stat_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wbox_stat</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">wbox_stat</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_wbox_stat_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>	<span class="o">=</span> <span class="n">spufs_pipe_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>	<span class="o">=</span> <span class="n">spufs_wbox_stat_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_signal1_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_openers</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">signal1</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spufs_signal1_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_openers</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">signal1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__spufs_signal1_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">spu_chnldata_RW</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_signal1_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__spufs_signal1_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">spu_release_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_signal1_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">signal1_write</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spufs_signal1_mmap_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if SPUFS_SIGNAL_MAP_SIZE == 0x1000</span>
	<span class="k">return</span> <span class="n">spufs_ps_fault</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="p">,</span> <span class="mh">0x14000</span><span class="p">,</span> <span class="n">SPUFS_SIGNAL_MAP_SIZE</span><span class="p">);</span>
<span class="cp">#elif SPUFS_SIGNAL_MAP_SIZE == 0x10000</span>
	<span class="cm">/* For 64k pages, both signal1 and signal2 can be used to mmap the whole</span>
<span class="cm">	 * signal 1 and 2 area</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">spufs_ps_fault</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="p">,</span> <span class="mh">0x10000</span><span class="p">,</span> <span class="n">SPUFS_SIGNAL_MAP_SIZE</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#error unsupported page size</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">spufs_signal1_mmap_vmops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span> <span class="o">=</span> <span class="n">spufs_signal1_mmap_fault</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_signal1_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">pgprot_noncached</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spufs_signal1_mmap_vmops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_signal1_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">spufs_signal1_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">spufs_signal1_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">spufs_signal1_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">spufs_signal1_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">spufs_signal1_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_signal1_nosched_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">spufs_signal1_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">spufs_signal1_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">spufs_signal1_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">spufs_signal1_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_signal2_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_openers</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">signal2</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spufs_signal2_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_openers</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">signal2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__spufs_signal2_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span>  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">spu_chnldata_RW</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_signal2_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__spufs_signal2_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">spu_release_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_signal2_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">signal2_write</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if SPUFS_MMAP_4K</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spufs_signal2_mmap_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if SPUFS_SIGNAL_MAP_SIZE == 0x1000</span>
	<span class="k">return</span> <span class="n">spufs_ps_fault</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="p">,</span> <span class="mh">0x1c000</span><span class="p">,</span> <span class="n">SPUFS_SIGNAL_MAP_SIZE</span><span class="p">);</span>
<span class="cp">#elif SPUFS_SIGNAL_MAP_SIZE == 0x10000</span>
	<span class="cm">/* For 64k pages, both signal1 and signal2 can be used to mmap the whole</span>
<span class="cm">	 * signal 1 and 2 area</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">spufs_ps_fault</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="p">,</span> <span class="mh">0x10000</span><span class="p">,</span> <span class="n">SPUFS_SIGNAL_MAP_SIZE</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#error unsupported page size</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">spufs_signal2_mmap_vmops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span> <span class="o">=</span> <span class="n">spufs_signal2_mmap_fault</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_signal2_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">pgprot_noncached</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spufs_signal2_mmap_vmops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* SPUFS_MMAP_4K */</span><span class="cp"></span>
<span class="cp">#define spufs_signal2_mmap NULL</span>
<span class="cp">#endif </span><span class="cm">/* !SPUFS_MMAP_4K */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_signal2_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">spufs_signal2_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">spufs_signal2_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">spufs_signal2_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">spufs_signal2_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">spufs_signal2_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_signal2_nosched_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">spufs_signal2_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">spufs_signal2_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">spufs_signal2_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">spufs_signal2_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This is a wrapper around DEFINE_SIMPLE_ATTRIBUTE which does the</span>
<span class="cm"> * work of acquiring (or not) the SPU context before calling through</span>
<span class="cm"> * to the actual get routine. The set routine is called directly.</span>
<span class="cm"> */</span>
<span class="cp">#define SPU_ATTR_NOACQUIRE	0</span>
<span class="cp">#define SPU_ATTR_ACQUIRE	1</span>
<span class="cp">#define SPU_ATTR_ACQUIRE_SAVED	2</span>

<span class="cp">#define DEFINE_SPUFS_ATTRIBUTE(__name, __get, __set, __fmt, __acquire)	\</span>
<span class="cp">static int __##__get(void *data, u64 *val)				\</span>
<span class="cp">{									\</span>
<span class="cp">	struct spu_context *ctx = data;					\</span>
<span class="cp">	int ret = 0;							\</span>
<span class="cp">									\</span>
<span class="cp">	if (__acquire == SPU_ATTR_ACQUIRE) {				\</span>
<span class="cp">		ret = spu_acquire(ctx);					\</span>
<span class="cp">		if (ret)						\</span>
<span class="cp">			return ret;					\</span>
<span class="cp">		*val = __get(ctx);					\</span>
<span class="cp">		spu_release(ctx);					\</span>
<span class="cp">	} else if (__acquire == SPU_ATTR_ACQUIRE_SAVED)	{		\</span>
<span class="cp">		ret = spu_acquire_saved(ctx);				\</span>
<span class="cp">		if (ret)						\</span>
<span class="cp">			return ret;					\</span>
<span class="cp">		*val = __get(ctx);					\</span>
<span class="cp">		spu_release_saved(ctx);					\</span>
<span class="cp">	} else								\</span>
<span class="cp">		*val = __get(ctx);					\</span>
<span class="cp">									\</span>
<span class="cp">	return 0;							\</span>
<span class="cp">}									\</span>
<span class="cp">DEFINE_SPUFS_SIMPLE_ATTRIBUTE(__name, __##__get, __set, __fmt);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_signal1_type_set</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">signal1_type_set</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">spufs_signal1_type_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">signal1_type_get</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DEFINE_SPUFS_ATTRIBUTE</span><span class="p">(</span><span class="n">spufs_signal1_type</span><span class="p">,</span> <span class="n">spufs_signal1_type_get</span><span class="p">,</span>
		       <span class="n">spufs_signal1_type_set</span><span class="p">,</span> <span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SPU_ATTR_ACQUIRE</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_signal2_type_set</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">signal2_type_set</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">spufs_signal2_type_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">signal2_type_get</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DEFINE_SPUFS_ATTRIBUTE</span><span class="p">(</span><span class="n">spufs_signal2_type</span><span class="p">,</span> <span class="n">spufs_signal2_type_get</span><span class="p">,</span>
		       <span class="n">spufs_signal2_type_set</span><span class="p">,</span> <span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SPU_ATTR_ACQUIRE</span><span class="p">);</span>

<span class="cp">#if SPUFS_MMAP_4K</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spufs_mss_mmap_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">spufs_ps_fault</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="n">SPUFS_MSS_MAP_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">spufs_mss_mmap_vmops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span> <span class="o">=</span> <span class="n">spufs_mss_mmap_fault</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * mmap support for problem state MFC DMA area [0x0000 - 0x0fff].</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_mss_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">pgprot_noncached</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spufs_mss_mmap_vmops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* SPUFS_MMAP_4K */</span><span class="cp"></span>
<span class="cp">#define spufs_mss_mmap NULL</span>
<span class="cp">#endif </span><span class="cm">/* !SPUFS_MMAP_4K */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_mss_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_openers</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mss</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spufs_mss_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_openers</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mss</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_mss_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>	 <span class="o">=</span> <span class="n">spufs_mss_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">spufs_mss_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>	 <span class="o">=</span> <span class="n">spufs_mss_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spufs_psmap_mmap_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">spufs_ps_fault</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="n">SPUFS_PS_MAP_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">spufs_psmap_mmap_vmops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span> <span class="o">=</span> <span class="n">spufs_psmap_mmap_fault</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * mmap support for full problem state area [0x00000 - 0x1ffff].</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_psmap_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">pgprot_noncached</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spufs_psmap_mmap_vmops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_psmap_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_openers</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">psmap</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spufs_psmap_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_openers</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">psmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_psmap_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>	 <span class="o">=</span> <span class="n">spufs_psmap_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">spufs_psmap_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>	 <span class="o">=</span> <span class="n">spufs_psmap_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>


<span class="cp">#if SPUFS_MMAP_4K</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spufs_mfc_mmap_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">spufs_ps_fault</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="p">,</span> <span class="mh">0x3000</span><span class="p">,</span> <span class="n">SPUFS_MFC_MAP_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">spufs_mfc_mmap_vmops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span> <span class="o">=</span> <span class="n">spufs_mfc_mmap_fault</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * mmap support for problem state MFC DMA area [0x0000 - 0x0fff].</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_mfc_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">pgprot_noncached</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spufs_mfc_mmap_vmops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* SPUFS_MMAP_4K */</span><span class="cp"></span>
<span class="cp">#define spufs_mfc_mmap NULL</span>
<span class="cp">#endif </span><span class="cm">/* !SPUFS_MMAP_4K */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_mfc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="cm">/* we don&#39;t want to deal with DMA into other processes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_openers</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mfc</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">spufs_mfc_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_openers</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mfc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mapping_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* interrupt-level mfc callback function. */</span>
<span class="kt">void</span> <span class="nf">spufs_mfc_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mfc_wq</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mfc_fasync</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">free_elements</span><span class="p">,</span> <span class="n">tagstatus</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>

		<span class="cm">/* no need for spu_acquire in interrupt context */</span>
		<span class="n">free_elements</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_mfc_free_elements</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">tagstatus</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read_mfc_tagstatus</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

		<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">free_elements</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tagstatus</span> <span class="o">&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tagwait</span><span class="p">)</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span><span class="p">;</span>

		<span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mfc_fasync</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_read_mfc_tagstatus</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* See if there is one tag group is complete */</span>
	<span class="cm">/* FIXME we need locking around tagwait */</span>
	<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read_mfc_tagstatus</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tagwait</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tagwait</span> <span class="o">&amp;=</span> <span class="o">~*</span><span class="n">status</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* enable interrupt waiting for any tag group,</span>
<span class="cm">	   may silently fail if interrupts are already enabled */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_mfc_query</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tagwait</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_mfc_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read_mfc_tagstatus</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tagwait</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* XXX(hch): shouldn&#39;t we clear ret here? */</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tagwait</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">status</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">spufs_wait</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mfc_wq</span><span class="p">,</span>
			   <span class="n">spufs_read_mfc_tagstatus</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_check_valid_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mfc_dma_command</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;queueing DMA %x %llx %x %x %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lsa</span><span class="p">,</span>
		 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ea</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MFC_PUT_CMD</span>:
	<span class="k">case</span> <span class="n">MFC_PUTF_CMD</span>:
	<span class="k">case</span> <span class="n">MFC_PUTB_CMD</span>:
	<span class="k">case</span> <span class="n">MFC_GET_CMD</span>:
	<span class="k">case</span> <span class="n">MFC_GETF_CMD</span>:
	<span class="k">case</span> <span class="n">MFC_GETB_CMD</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;invalid DMA opcode %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lsa</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ea</span> <span class="o">&amp;</span><span class="mh">0xf</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;invalid DMA alignment, ea %llx lsa %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ea</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lsa</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lsa</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lsa</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lsa</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lsa</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">error:</span>
	<span class="nl">default:</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;invalid DMA alignment %x for size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">lsa</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;invalid DMA size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">&amp;</span> <span class="mh">0xfff0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we reserve the higher tag numbers for kernel use */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;invalid DMA tag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* not supported in this version */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;invalid DMA class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spu_send_mfc_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mfc_dma_command</span> <span class="n">cmd</span><span class="p">,</span>
				<span class="kt">int</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">send_mfc_command</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* wait for any tag group to complete</span>
<span class="cm">		   so we have space for the new command */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_mfc_query</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tagwait</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* try again, because the queue might be</span>
<span class="cm">		   empty again */</span>
		<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">send_mfc_command</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_mfc_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mfc_dma_command</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="n">cmd</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">cmd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spufs_check_valid_dma</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spufs_wait</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">run_wq</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SPU_STATE_RUNNABLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">send_mfc_command</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">spufs_wait</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mfc_wq</span><span class="p">,</span>
				 <span class="n">spu_send_mfc_command</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tagwait</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="p">.</span><span class="n">tag</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">spufs_mfc_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span><span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">free_elements</span><span class="p">,</span> <span class="n">tagstatus</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mfc_wq</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For now keep this uninterruptible and also ignore the rule</span>
<span class="cm">	 * that poll should not sleep.  Will be fixed later.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_mfc_query</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tagwait</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">free_elements</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_mfc_free_elements</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">tagstatus</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read_mfc_tagstatus</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free_elements</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tagstatus</span> <span class="o">&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tagwait</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: free %d tagstatus %d tagwait %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">free_elements</span><span class="p">,</span> <span class="n">tagstatus</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tagwait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_mfc_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">fl_owner_t</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/* this currently hangs */</span>
<span class="c">	ret = spufs_wait(ctx-&gt;mfc_wq,</span>
<span class="c">			 ctx-&gt;ops-&gt;set_mfc_query(ctx, ctx-&gt;tagwait, 2));</span>
<span class="c">	if (ret)</span>
<span class="c">		goto out;</span>
<span class="c">	ret = spufs_wait(ctx-&gt;mfc_wq,</span>
<span class="c">			 ctx-&gt;ops-&gt;read_mfc_tagstatus(ctx) == ctx-&gt;tagwait);</span>
<span class="c">	if (ret)</span>
<span class="c">		goto out;</span>
<span class="cp">#else</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_mfc_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">spufs_mfc_flush</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_mfc_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">fasync_helper</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mfc_fasync</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_mfc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>	 <span class="o">=</span> <span class="n">spufs_mfc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">spufs_mfc_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>	 <span class="o">=</span> <span class="n">spufs_mfc_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>	 <span class="o">=</span> <span class="n">spufs_mfc_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>	 <span class="o">=</span> <span class="n">spufs_mfc_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush</span>	 <span class="o">=</span> <span class="n">spufs_mfc_flush</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span>	 <span class="o">=</span> <span class="n">spufs_mfc_fsync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fasync</span>	 <span class="o">=</span> <span class="n">spufs_mfc_fasync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>	 <span class="o">=</span> <span class="n">spufs_mfc_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_npc_set</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">npc_write</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">spufs_npc_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">npc_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DEFINE_SPUFS_ATTRIBUTE</span><span class="p">(</span><span class="n">spufs_npc_ops</span><span class="p">,</span> <span class="n">spufs_npc_get</span><span class="p">,</span> <span class="n">spufs_npc_set</span><span class="p">,</span>
		       <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SPU_ATTR_ACQUIRE</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_decr_set</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_lscsa</span> <span class="o">*</span><span class="n">lscsa</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">lscsa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">decr</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">spu_release_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">spufs_decr_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_lscsa</span> <span class="o">*</span><span class="n">lscsa</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">lscsa</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">decr</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">DEFINE_SPUFS_ATTRIBUTE</span><span class="p">(</span><span class="n">spufs_decr_ops</span><span class="p">,</span> <span class="n">spufs_decr_get</span><span class="p">,</span> <span class="n">spufs_decr_set</span><span class="p">,</span>
		       <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SPU_ATTR_ACQUIRE_SAVED</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_decr_status_set</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">priv2</span><span class="p">.</span><span class="n">mfc_control_RW</span> <span class="o">|=</span> <span class="n">MFC_CNTL_DECREMENTER_RUNNING</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">priv2</span><span class="p">.</span><span class="n">mfc_control_RW</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MFC_CNTL_DECREMENTER_RUNNING</span><span class="p">;</span>
	<span class="n">spu_release_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">spufs_decr_status_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">priv2</span><span class="p">.</span><span class="n">mfc_control_RW</span> <span class="o">&amp;</span> <span class="n">MFC_CNTL_DECREMENTER_RUNNING</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SPU_DECR_STATUS_RUNNING</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DEFINE_SPUFS_ATTRIBUTE</span><span class="p">(</span><span class="n">spufs_decr_status_ops</span><span class="p">,</span> <span class="n">spufs_decr_status_get</span><span class="p">,</span>
		       <span class="n">spufs_decr_status_set</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">SPU_ATTR_ACQUIRE_SAVED</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_event_mask_set</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_lscsa</span> <span class="o">*</span><span class="n">lscsa</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">lscsa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">event_mask</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">spu_release_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">spufs_event_mask_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_lscsa</span> <span class="o">*</span><span class="n">lscsa</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">lscsa</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">event_mask</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">DEFINE_SPUFS_ATTRIBUTE</span><span class="p">(</span><span class="n">spufs_event_mask_ops</span><span class="p">,</span> <span class="n">spufs_event_mask_get</span><span class="p">,</span>
		       <span class="n">spufs_event_mask_set</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">SPU_ATTR_ACQUIRE_SAVED</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">spufs_event_status_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">stat</span><span class="p">;</span>
	<span class="n">stat</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DEFINE_SPUFS_ATTRIBUTE</span><span class="p">(</span><span class="n">spufs_event_status_ops</span><span class="p">,</span> <span class="n">spufs_event_status_get</span><span class="p">,</span>
		       <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SPU_ATTR_ACQUIRE_SAVED</span><span class="p">)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">spufs_srr0_set</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_lscsa</span> <span class="o">*</span><span class="n">lscsa</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">lscsa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">srr0</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">spu_release_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">spufs_srr0_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_lscsa</span> <span class="o">*</span><span class="n">lscsa</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">lscsa</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">srr0</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">DEFINE_SPUFS_ATTRIBUTE</span><span class="p">(</span><span class="n">spufs_srr0_ops</span><span class="p">,</span> <span class="n">spufs_srr0_get</span><span class="p">,</span> <span class="n">spufs_srr0_set</span><span class="p">,</span>
		       <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SPU_ATTR_ACQUIRE_SAVED</span><span class="p">)</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">spufs_id_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">num</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SPU_STATE_RUNNABLE</span><span class="p">)</span>
		<span class="n">num</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DEFINE_SPUFS_ATTRIBUTE</span><span class="p">(</span><span class="n">spufs_id_ops</span><span class="p">,</span> <span class="n">spufs_id_get</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">SPU_ATTR_ACQUIRE</span><span class="p">)</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">spufs_object_id_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* FIXME: Should there really be no locking here? */</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">object_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">spufs_object_id_set</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">object_id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">DEFINE_SPUFS_ATTRIBUTE</span><span class="p">(</span><span class="n">spufs_object_id_ops</span><span class="p">,</span> <span class="n">spufs_object_id_get</span><span class="p">,</span>
		       <span class="n">spufs_object_id_set</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SPU_ATTR_NOACQUIRE</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">spufs_lslr_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_lslr_RW</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DEFINE_SPUFS_ATTRIBUTE</span><span class="p">(</span><span class="n">spufs_lslr_ops</span><span class="p">,</span> <span class="n">spufs_lslr_get</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">SPU_ATTR_ACQUIRE_SAVED</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_info_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spufs_inode_info</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_caps_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPU_CREATE_NOSCHED</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;sched</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPU_CREATE_ISOLATE</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;step</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_caps_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">spufs_caps_show</span><span class="p">,</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_caps_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">spufs_caps_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__spufs_mbox_info_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* EOF if there&#39;s no entry in the mbox */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">prob</span><span class="p">.</span><span class="n">mb_stat_R</span> <span class="o">&amp;</span> <span class="mh">0x0000ff</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">prob</span><span class="p">.</span><span class="n">pu_mb_R</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_mbox_info_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__spufs_mbox_info_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="n">spu_release_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_mbox_info_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">spufs_info_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">spufs_mbox_info_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__spufs_ibox_info_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* EOF if there&#39;s no entry in the ibox */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">prob</span><span class="p">.</span><span class="n">mb_stat_R</span> <span class="o">&amp;</span> <span class="mh">0xff0000</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">priv2</span><span class="p">.</span><span class="n">puint_mb_R</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_ibox_info_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__spufs_ibox_info_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="n">spu_release_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_ibox_info_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">spufs_info_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">spufs_ibox_info_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__spufs_wbox_info_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">wbox_stat</span><span class="p">;</span>

	<span class="n">wbox_stat</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">prob</span><span class="p">.</span><span class="n">mb_stat_R</span><span class="p">;</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">-</span> <span class="p">((</span><span class="n">wbox_stat</span> <span class="o">&amp;</span> <span class="mh">0x00ff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">spu_mailbox_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span>
				<span class="n">cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_wbox_info_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__spufs_wbox_info_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="n">spu_release_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_wbox_info_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">spufs_info_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">spufs_wbox_info_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__spufs_dma_info_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_dma_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mfc_cq_sr</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span> <span class="o">*</span><span class="n">spuqp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">info</span><span class="p">.</span><span class="n">dma_info_type</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_tag_status_query_RW</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">dma_info_mask</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">tag_mask</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">info</span><span class="p">.</span><span class="n">dma_info_status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">spu_chnldata_RW</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
	<span class="n">info</span><span class="p">.</span><span class="n">dma_info_stall_and_notify</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">spu_chnldata_RW</span><span class="p">[</span><span class="mi">25</span><span class="p">];</span>
	<span class="n">info</span><span class="p">.</span><span class="n">dma_info_atomic_command_status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">spu_chnldata_RW</span><span class="p">[</span><span class="mi">27</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">dma_info_command_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">spuqp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">priv2</span><span class="p">.</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">qp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data0_RW</span> <span class="o">=</span> <span class="n">spuqp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data0_RW</span><span class="p">;</span>
		<span class="n">qp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data1_RW</span> <span class="o">=</span> <span class="n">spuqp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data1_RW</span><span class="p">;</span>
		<span class="n">qp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data2_RW</span> <span class="o">=</span> <span class="n">spuqp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data2_RW</span><span class="p">;</span>
		<span class="n">qp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data3_RW</span> <span class="o">=</span> <span class="n">spuqp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data3_RW</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span>
				<span class="k">sizeof</span> <span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_dma_info_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__spufs_dma_info_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="n">spu_release_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_dma_info_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">spufs_info_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">spufs_dma_info_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__spufs_proxydma_info_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_proxydma_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mfc_cq_sr</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span> <span class="o">*</span><span class="n">puqp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">info</span><span class="p">.</span><span class="n">proxydma_info_type</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">prob</span><span class="p">.</span><span class="n">dma_querytype_RW</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">proxydma_info_mask</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">prob</span><span class="p">.</span><span class="n">dma_querymask_RW</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">proxydma_info_status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">prob</span><span class="p">.</span><span class="n">dma_tagstatus_R</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">proxydma_info_command_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">puqp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">priv2</span><span class="p">.</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">qp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data0_RW</span> <span class="o">=</span> <span class="n">puqp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data0_RW</span><span class="p">;</span>
		<span class="n">qp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data1_RW</span> <span class="o">=</span> <span class="n">puqp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data1_RW</span><span class="p">;</span>
		<span class="n">qp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data2_RW</span> <span class="o">=</span> <span class="n">puqp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data2_RW</span><span class="p">;</span>
		<span class="n">qp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data3_RW</span> <span class="o">=</span> <span class="n">puqp</span><span class="o">-&gt;</span><span class="n">mfc_cq_data3_RW</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span>
				<span class="k">sizeof</span> <span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_proxydma_info_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__spufs_proxydma_info_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="n">spu_release_saved</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_proxydma_info_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">spufs_info_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">spufs_proxydma_info_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_show_tid</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_tid_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">spufs_show_tid</span><span class="p">,</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_tid_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">spufs_tid_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ctx_state_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;user&quot;</span><span class="p">,</span> <span class="s">&quot;system&quot;</span><span class="p">,</span> <span class="s">&quot;iowait&quot;</span><span class="p">,</span> <span class="s">&quot;loaded&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">spufs_acct_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">spu_utilization_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">time</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">times</span><span class="p">[</span><span class="n">state</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * In general, utilization statistics are updated by the controlling</span>
<span class="cm">	 * thread as the spu context moves through various well defined</span>
<span class="cm">	 * state transitions, but if the context is lazily loaded its</span>
<span class="cm">	 * utilization statistics are not updated as the controlling thread</span>
<span class="cm">	 * is not tightly coupled with the execution of the spu context.  We</span>
<span class="cm">	 * calculate and apply the time delta from the last recorded state</span>
<span class="cm">	 * of the spu context.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">util_state</span> <span class="o">==</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ktime_get_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
		<span class="n">time</span> <span class="o">+=</span> <span class="n">timespec_to_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">)</span> <span class="o">-</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tstamp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">time</span> <span class="o">/</span> <span class="n">NSEC_PER_MSEC</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">spufs_slb_flts</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">slb_flts</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">slb_flt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SPU_STATE_RUNNABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slb_flts</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">slb_flt</span> <span class="o">-</span>
			     <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">slb_flt_base</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">slb_flts</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">spufs_class2_intrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">class2_intrs</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">class2_intr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SPU_STATE_RUNNABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">class2_intrs</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">class2_intr</span> <span class="o">-</span>
				 <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">class2_intr_base</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">class2_intrs</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_show_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%s %llu %llu %llu %llu &quot;</span>
		      <span class="s">&quot;%llu %llu %llu %llu %llu %llu %llu %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ctx_state_names</span><span class="p">[</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">util_state</span><span class="p">],</span>
		<span class="n">spufs_acct_time</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SPU_UTIL_USER</span><span class="p">),</span>
		<span class="n">spufs_acct_time</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SPU_UTIL_SYSTEM</span><span class="p">),</span>
		<span class="n">spufs_acct_time</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SPU_UTIL_IOWAIT</span><span class="p">),</span>
		<span class="n">spufs_acct_time</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SPU_UTIL_IDLE_LOADED</span><span class="p">),</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">vol_ctx_switch</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">invol_ctx_switch</span><span class="p">,</span>
		<span class="n">spufs_slb_flts</span><span class="p">(</span><span class="n">ctx</span><span class="p">),</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">hash_flt</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">min_flt</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">maj_flt</span><span class="p">,</span>
		<span class="n">spufs_class2_intrs</span><span class="p">(</span><span class="n">ctx</span><span class="p">),</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">libassist</span><span class="p">);</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_stat_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">spufs_show_stat</span><span class="p">,</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_stat_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">spufs_stat_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">spufs_switch_log_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">-</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span> <span class="o">%</span>
		<span class="n">SWITCH_LOG_BUFSIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">spufs_switch_log_avail</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">SWITCH_LOG_BUFSIZE</span> <span class="o">-</span> <span class="n">spufs_switch_log_used</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_switch_log_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">switch_log</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">SWITCH_LOG_BUFSIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">switch_log_entry</span><span class="p">),</span>
		<span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_switch_log_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">switch_log_sprint</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">switch_log_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">log</span> <span class="o">+</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">%</span> <span class="n">SWITCH_LOG_BUFSIZE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">tbuf</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s">&quot;%u.%09u %d %u %u %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">,</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">spu_id</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">timebase</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">spufs_switch_log_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">tbuf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">width</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">spufs_switch_log_used</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* If there&#39;s data ready to go, we can</span>
<span class="cm">				 * just return straight away */</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* spufs_wait will drop the mutex and</span>
<span class="cm">				 * re-acquire, but since we&#39;re in read(), the</span>
<span class="cm">				 * file cannot be _released (and so</span>
<span class="cm">				 * ctx-&gt;switch_log is stable).</span>
<span class="cm">				 */</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">spufs_wait</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span>
						<span class="n">spufs_switch_log_used</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

				<span class="cm">/* On error, spufs_wait returns without the</span>
<span class="cm">				 * state mutex held */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

				<span class="cm">/* We may have had entries read from underneath</span>
<span class="cm">				 * us while we dropped the mutex in spufs_wait,</span>
<span class="cm">				 * so re-check */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">spufs_switch_log_used</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">width</span> <span class="o">=</span> <span class="n">switch_log_sprint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">tbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tbuf</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">width</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span>
				 <span class="n">SWITCH_LOG_BUFSIZE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* If the record is greater than space available return</span>
<span class="cm">			 * partial buffer (so far) */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">tbuf</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cnt</span> <span class="o">+=</span> <span class="n">width</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">error</span> <span class="o">:</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">spufs_switch_log_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spufs_switch_log_used</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span><span class="p">;</span>

	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_switch_log_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">spufs_switch_log_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">spufs_switch_log_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">spufs_switch_log_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">spufs_switch_log_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Log a context switch event to a switch log reader.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with ctx-&gt;state_mutex held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">spu_switch_log_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spufs_switch_log_avail</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">switch_log_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="n">p</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">log</span> <span class="o">+</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
		<span class="n">ktime_get_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">timebase</span> <span class="o">=</span> <span class="n">get_tb</span><span class="p">();</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">spu_id</span> <span class="o">=</span> <span class="n">spu</span> <span class="o">?</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">SWITCH_LOG_BUFSIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">switch_log</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_show_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mfc_control_RW</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>
		<span class="n">mfc_control_RW</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">;</span>

		<span class="n">mfc_control_RW</span> <span class="o">=</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">mfc_control_RW</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%c flgs(%lx) sflgs(%lx) pri(%d) ts(%d) spu(%02d)&quot;</span>
		<span class="s">&quot; %c %llx %llx %llx %llx %x %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SPU_STATE_SAVED</span> <span class="o">?</span> <span class="sc">&#39;S&#39;</span> <span class="o">:</span> <span class="sc">&#39;R&#39;</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sched_flags</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">time_slice</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span> <span class="o">?</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		<span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;q&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">class_0_pending</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">class_0_dar</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">.</span><span class="n">class_1_dsisr</span><span class="p">,</span>
		<span class="n">mfc_control_RW</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">runcntl_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">),</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">status_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">));</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spufs_ctx_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">spufs_show_ctx</span><span class="p">,</span> <span class="n">SPUFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spufs_ctx_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">spufs_ctx_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>           <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">spufs_tree_descr</span> <span class="n">spufs_dir_contents</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;capabilities&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_caps_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mem&quot;</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">spufs_mem_fops</span><span class="p">,</span>  <span class="mo">0666</span><span class="p">,</span> <span class="n">LS_SIZE</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;regs&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_regs_fops</span><span class="p">,</span>  <span class="mo">0666</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_reg128</span><span class="p">[</span><span class="mi">128</span><span class="p">]),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mbox&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_mbox_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ibox&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_ibox_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;wbox&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_wbox_fops</span><span class="p">,</span> <span class="mo">0222</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mbox_stat&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_mbox_stat_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ibox_stat&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_ibox_stat_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;wbox_stat&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_wbox_stat_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;signal1&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_signal1_fops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;signal2&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_signal2_fops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;signal1_type&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_signal1_type</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;signal2_type&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_signal2_type</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;cntl&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_cntl_fops</span><span class="p">,</span>  <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;fpcr&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_fpcr_fops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_reg128</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;lslr&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_lslr_ops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mfc&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_mfc_fops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mss&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_mss_fops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;npc&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_npc_ops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;srr0&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_srr0_ops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;decr&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_decr_ops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;decr_status&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_decr_status_ops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;event_mask&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_event_mask_ops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;event_status&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_event_status_ops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;psmap&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_psmap_fops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="n">SPUFS_PS_MAP_SIZE</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;phys-id&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_id_ops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;object-id&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_object_id_ops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mbox_info&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_mbox_info_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ibox_info&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_ibox_info_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;wbox_info&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_wbox_info_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;dma_info&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_dma_info_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_dma_info</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;proxydma_info&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_proxydma_info_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_proxydma_info</span><span class="p">)},</span>
	<span class="p">{</span> <span class="s">&quot;tid&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_tid_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;stat&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_stat_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;switch_log&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_switch_log_fops</span><span class="p">,</span> <span class="mo">0444</span> <span class="p">},</span>
	<span class="p">{},</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">spufs_tree_descr</span> <span class="n">spufs_dir_nosched_contents</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;capabilities&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_caps_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mem&quot;</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">spufs_mem_fops</span><span class="p">,</span>  <span class="mo">0666</span><span class="p">,</span> <span class="n">LS_SIZE</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mbox&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_mbox_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ibox&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_ibox_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;wbox&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_wbox_fops</span><span class="p">,</span> <span class="mo">0222</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mbox_stat&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_mbox_stat_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ibox_stat&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_ibox_stat_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;wbox_stat&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_wbox_stat_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;signal1&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_signal1_nosched_fops</span><span class="p">,</span> <span class="mo">0222</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;signal2&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_signal2_nosched_fops</span><span class="p">,</span> <span class="mo">0222</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;signal1_type&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_signal1_type</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;signal2_type&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_signal2_type</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mss&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_mss_fops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mfc&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_mfc_fops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;cntl&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_cntl_fops</span><span class="p">,</span>  <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;npc&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_npc_ops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;psmap&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_psmap_fops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="n">SPUFS_PS_MAP_SIZE</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;phys-id&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_id_ops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;object-id&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_object_id_ops</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;tid&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_tid_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;stat&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_stat_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{},</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">spufs_tree_descr</span> <span class="n">spufs_dir_debug_contents</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;.ctx&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spufs_ctx_fops</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{},</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">spufs_coredump_reader</span> <span class="n">spufs_coredump_read</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;regs&quot;</span><span class="p">,</span> <span class="n">__spufs_regs_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_reg128</span><span class="p">[</span><span class="mi">128</span><span class="p">])},</span>
	<span class="p">{</span> <span class="s">&quot;fpcr&quot;</span><span class="p">,</span> <span class="n">__spufs_fpcr_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_reg128</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;lslr&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">spufs_lslr_get</span><span class="p">,</span> <span class="mi">19</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;decr&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">spufs_decr_get</span><span class="p">,</span> <span class="mi">19</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;decr_status&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">spufs_decr_status_get</span><span class="p">,</span> <span class="mi">19</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mem&quot;</span><span class="p">,</span> <span class="n">__spufs_mem_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">LS_SIZE</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;signal1&quot;</span><span class="p">,</span> <span class="n">__spufs_signal1_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;signal1_type&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">spufs_signal1_type_get</span><span class="p">,</span> <span class="mi">19</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;signal2&quot;</span><span class="p">,</span> <span class="n">__spufs_signal2_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;signal2_type&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">spufs_signal2_type_get</span><span class="p">,</span> <span class="mi">19</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;event_mask&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">spufs_event_mask_get</span><span class="p">,</span> <span class="mi">19</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;event_status&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">spufs_event_status_get</span><span class="p">,</span> <span class="mi">19</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mbox_info&quot;</span><span class="p">,</span> <span class="n">__spufs_mbox_info_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ibox_info&quot;</span><span class="p">,</span> <span class="n">__spufs_ibox_info_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;wbox_info&quot;</span><span class="p">,</span> <span class="n">__spufs_wbox_info_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)},</span>
	<span class="p">{</span> <span class="s">&quot;dma_info&quot;</span><span class="p">,</span> <span class="n">__spufs_dma_info_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_dma_info</span><span class="p">)},</span>
	<span class="p">{</span> <span class="s">&quot;proxydma_info&quot;</span><span class="p">,</span> <span class="n">__spufs_proxydma_info_read</span><span class="p">,</span>
			   <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_proxydma_info</span><span class="p">)},</span>
	<span class="p">{</span> <span class="s">&quot;object-id&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">spufs_object_id_get</span><span class="p">,</span> <span class="mi">19</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;npc&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">spufs_npc_get</span><span class="p">,</span> <span class="mi">19</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
