<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › platforms › cell › spufs › switch.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>switch.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * spu_switch.c</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright IBM Corp. 2005</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Mark Nutter &lt;mnutter@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Host-side part of SPU context switch sequence outlined in</span>
<span class="cm"> * Synergistic Processor Element, Book IV.</span>
<span class="cm"> *</span>
<span class="cm"> * A fully premptive switch of an SPE is very expensive in terms</span>
<span class="cm"> * of time and system resources.  SPE Book IV indicates that SPE</span>
<span class="cm"> * allocation should follow a &quot;serially reusable device&quot; model,</span>
<span class="cm"> * in which the SPE is assigned a task until it completes.  When</span>
<span class="cm"> * this is not possible, this sequence may be used to premptively</span>
<span class="cm"> * save, and then later (optionally) restore the context of a</span>
<span class="cm"> * program executing on an SPE.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/spu.h&gt;</span>
<span class="cp">#include &lt;asm/spu_priv1.h&gt;</span>
<span class="cp">#include &lt;asm/spu_csa.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>

<span class="cp">#include &quot;spufs.h&quot;</span>

<span class="cp">#include &quot;spu_save_dump.h&quot;</span>
<span class="cp">#include &quot;spu_restore_dump.h&quot;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define POLL_WHILE_TRUE(_c) {				\</span>
<span class="c">    do {						\</span>
<span class="c">    } while (_c);					\</span>
<span class="c">  }</span>
<span class="cp">#else</span>
<span class="cp">#define RELAX_SPIN_COUNT				1000</span>
<span class="cp">#define POLL_WHILE_TRUE(_c) {				\</span>
<span class="cp">    do {						\</span>
<span class="cp">	int _i;						\</span>
<span class="cp">	for (_i=0; _i&lt;RELAX_SPIN_COUNT &amp;&amp; (_c); _i++) { \</span>
<span class="cp">	    cpu_relax();				\</span>
<span class="cp">	}						\</span>
<span class="cp">	if (unlikely(_c)) yield();			\</span>
<span class="cp">	else break;					\</span>
<span class="cp">    } while (_c);					\</span>
<span class="cp">  }</span>
<span class="cp">#endif				</span><span class="cm">/* debug */</span><span class="cp"></span>

<span class="cp">#define POLL_WHILE_FALSE(_c)	POLL_WHILE_TRUE(!(_c))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">acquire_spu_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 1:</span>
<span class="cm">	 * Restore, Step 1:</span>
<span class="cm">	 *    Acquire SPU-specific mutual exclusion lock.</span>
<span class="cm">	 *    TBD.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">release_spu_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restore, Step 76:</span>
<span class="cm">	 *    Release SPU-specific mutual exclusion lock.</span>
<span class="cm">	 *    TBD.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_spu_isolate</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">isolate_state</span><span class="p">;</span>

	<span class="cm">/* Save, Step 2:</span>
<span class="cm">	 * Save, Step 6:</span>
<span class="cm">	 *     If SPU_Status[E,L,IS] any field is &#39;1&#39;, this</span>
<span class="cm">	 *     SPU is in isolate state and cannot be context</span>
<span class="cm">	 *     saved at this time.</span>
<span class="cm">	 */</span>
	<span class="n">isolate_state</span> <span class="o">=</span> <span class="n">SPU_STATUS_ISOLATED_STATE</span> <span class="o">|</span>
	    <span class="n">SPU_STATUS_ISOLATED_LOAD_STATUS</span> <span class="o">|</span> <span class="n">SPU_STATUS_ISOLATED_EXIT_STATUS</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">isolate_state</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">disable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 3:</span>
<span class="cm">	 * Restore, Step 2:</span>
<span class="cm">	 *     Save INT_Mask_class0 in CSA.</span>
<span class="cm">	 *     Write INT_MASK_class0 with value of 0.</span>
<span class="cm">	 *     Save INT_Mask_class1 in CSA.</span>
<span class="cm">	 *     Write INT_MASK_class1 with value of 0.</span>
<span class="cm">	 *     Save INT_Mask_class2 in CSA.</span>
<span class="cm">	 *     Write INT_MASK_class2 with value of 0.</span>
<span class="cm">	 *     Synchronize all three interrupts to be sure</span>
<span class="cm">	 *     we no longer execute a handler on another CPU.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csa</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">int_mask_class0_RW</span> <span class="o">=</span> <span class="n">spu_int_mask_get</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">int_mask_class1_RW</span> <span class="o">=</span> <span class="n">spu_int_mask_get</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">int_mask_class2_RW</span> <span class="o">=</span> <span class="n">spu_int_mask_get</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spu_int_mask_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0ul</span><span class="p">);</span>
	<span class="n">spu_int_mask_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0ul</span><span class="p">);</span>
	<span class="n">spu_int_mask_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0ul</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This flag needs to be set before calling synchronize_irq so</span>
<span class="cm">	 * that the update will be visible to the relevant handlers</span>
<span class="cm">	 * via a simple load.</span>
<span class="cm">	 */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">SPU_CONTEXT_SWITCH_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">SPU_CONTEXT_FAULT_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">irqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">irqs</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">irqs</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_watchdog_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 4:</span>
<span class="cm">	 * Restore, Step 25.</span>
<span class="cm">	 *    Set a software watchdog timer, which specifies the</span>
<span class="cm">	 *    maximum allowable time for a context save sequence.</span>
<span class="cm">	 *</span>
<span class="cm">	 *    For present, this implementation will not set a global</span>
<span class="cm">	 *    watchdog timer, as virtualization &amp; variable system load</span>
<span class="cm">	 *    may cause unpredictable execution times.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inhibit_user_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 5:</span>
<span class="cm">	 * Restore, Step 3:</span>
<span class="cm">	 *     Inhibit user-space access (if provided) to this</span>
<span class="cm">	 *     SPU by unmapping the virtual pages assigned to</span>
<span class="cm">	 *     the SPU memory-mapped I/O (MMIO) for problem</span>
<span class="cm">	 *     state. TBD.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_switch_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 7:</span>
<span class="cm">	 * Restore, Step 5:</span>
<span class="cm">	 *     Set a software context switch pending flag.</span>
<span class="cm">	 *     Done above in Step 3 - disable_interrupts().</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_mfc_cntl</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Save, Step 8:</span>
<span class="cm">	 *     Suspend DMA and save MFC_CNTL.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">)</span> <span class="o">&amp;</span>
	       <span class="n">MFC_CNTL_SUSPEND_DMA_STATUS_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MFC_CNTL_SUSPEND_IN_PROGRESS</span>:
		<span class="n">POLL_WHILE_FALSE</span><span class="p">((</span><span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">)</span> <span class="o">&amp;</span>
				  <span class="n">MFC_CNTL_SUSPEND_DMA_STATUS_MASK</span><span class="p">)</span> <span class="o">==</span>
				 <span class="n">MFC_CNTL_SUSPEND_COMPLETE</span><span class="p">);</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">MFC_CNTL_SUSPEND_COMPLETE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">csa</span><span class="p">)</span>
			<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">mfc_control_RW</span> <span class="o">=</span>
				<span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">MFC_CNTL_SUSPEND_DMA_QUEUE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MFC_CNTL_NORMAL_DMA_QUEUE_OPERATION</span>:
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">,</span> <span class="n">MFC_CNTL_SUSPEND_DMA_QUEUE</span><span class="p">);</span>
		<span class="n">POLL_WHILE_FALSE</span><span class="p">((</span><span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">)</span> <span class="o">&amp;</span>
				  <span class="n">MFC_CNTL_SUSPEND_DMA_STATUS_MASK</span><span class="p">)</span> <span class="o">==</span>
				 <span class="n">MFC_CNTL_SUSPEND_COMPLETE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csa</span><span class="p">)</span>
			<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">mfc_control_RW</span> <span class="o">=</span>
				<span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="o">~</span><span class="n">MFC_CNTL_SUSPEND_DMA_QUEUE</span> <span class="o">&amp;</span>
				<span class="o">~</span><span class="n">MFC_CNTL_SUSPEND_MASK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_spu_runcntl</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Save, Step 9:</span>
<span class="cm">	 *     Save SPU_Runcntl in the CSA.  This value contains</span>
<span class="cm">	 *     the &quot;Application Desired State&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_runcntl_RW</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_runcntl_RW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_mfc_sr1</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 10:</span>
<span class="cm">	 *     Save MFC_SR1 in the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">mfc_sr1_RW</span> <span class="o">=</span> <span class="n">spu_mfc_sr1_get</span><span class="p">(</span><span class="n">spu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_spu_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Save, Step 11:</span>
<span class="cm">	 *     Read SPU_Status[R], and save to CSA.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SPU_STATUS_RUNNING</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">stopped</span><span class="p">;</span>

		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_runcntl_RW</span><span class="p">,</span> <span class="n">SPU_RUNCNTL_STOP</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
		<span class="n">POLL_WHILE_TRUE</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">SPU_STATUS_RUNNING</span><span class="p">);</span>
		<span class="n">stopped</span> <span class="o">=</span>
		    <span class="n">SPU_STATUS_INVALID_INSTR</span> <span class="o">|</span> <span class="n">SPU_STATUS_SINGLE_STEP</span> <span class="o">|</span>
		    <span class="n">SPU_STATUS_STOPPED_BY_HALT</span> <span class="o">|</span> <span class="n">SPU_STATUS_STOPPED_BY_STOP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">stopped</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">=</span> <span class="n">SPU_STATUS_RUNNING</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_mfc_stopped_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u64</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">MFC_CNTL_DECREMENTER_RUNNING</span> <span class="o">|</span>
			<span class="n">MFC_CNTL_DMA_QUEUES_EMPTY</span><span class="p">;</span>

	<span class="cm">/* Save, Step 12:</span>
<span class="cm">	 *     Read MFC_CNTL[Ds].  Update saved copy of</span>
<span class="cm">	 *     CSA.MFC_CNTL[Ds].</span>
<span class="cm">	 *</span>
<span class="cm">	 * update: do the same with MFC_CNTL[Q].</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">mfc_control_RW</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">mfc_control_RW</span> <span class="o">|=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">halt_mfc_decr</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Save, Step 13:</span>
<span class="cm">	 *     Write MFC_CNTL[Dh] set to a &#39;1&#39; to halt</span>
<span class="cm">	 *     the decrementer.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">,</span>
		 <span class="n">MFC_CNTL_DECREMENTER_HALTED</span> <span class="o">|</span> <span class="n">MFC_CNTL_SUSPEND_MASK</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_timebase</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 14:</span>
<span class="cm">	 *    Read PPE Timebase High and Timebase low registers</span>
<span class="cm">	 *    and save in CSA.  TBD.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">suspend_time</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">remove_other_spu_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 15:</span>
<span class="cm">	 *     Remove other SPU access to this SPU by unmapping</span>
<span class="cm">	 *     this SPU&#39;s pages from their address space.  TBD.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">do_mfc_mssync</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Save, Step 16:</span>
<span class="cm">	 * Restore, Step 11.</span>
<span class="cm">	 *     Write SPU_MSSync register. Poll SPU_MSSync[P]</span>
<span class="cm">	 *     for a value of 0.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spc_mssync_RW</span><span class="p">,</span> <span class="mi">1UL</span><span class="p">);</span>
	<span class="n">POLL_WHILE_TRUE</span><span class="p">(</span><span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spc_mssync_RW</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MS_SYNC_PENDING</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">issue_mfc_tlbie</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 17:</span>
<span class="cm">	 * Restore, Step 12.</span>
<span class="cm">	 * Restore, Step 48.</span>
<span class="cm">	 *     Write TLB_Invalidate_Entry[IS,VPN,L,Lp]=0 register.</span>
<span class="cm">	 *     Then issue a PPE sync instruction.</span>
<span class="cm">	 */</span>
	<span class="n">spu_tlb_invalidate</span><span class="p">(</span><span class="n">spu</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">handle_pending_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 18:</span>
<span class="cm">	 *     Handle any pending interrupts from this SPU</span>
<span class="cm">	 *     here.  This is OS or hypervisor specific.  One</span>
<span class="cm">	 *     option is to re-enable interrupts to handle any</span>
<span class="cm">	 *     pending interrupts, with the interrupt handlers</span>
<span class="cm">	 *     recognizing the software Context Switch Pending</span>
<span class="cm">	 *     flag, to ensure the SPU execution or MFC command</span>
<span class="cm">	 *     queue is not restarted.  TBD.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_mfc_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Save, Step 19:</span>
<span class="cm">	 *     If MFC_Cntl[Se]=0 then save</span>
<span class="cm">	 *     MFC command queues.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MFC_CNTL_DMA_QUEUES_EMPTY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data0_RW</span> <span class="o">=</span>
			    <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data0_RW</span><span class="p">);</span>
			<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data1_RW</span> <span class="o">=</span>
			    <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data1_RW</span><span class="p">);</span>
			<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data2_RW</span> <span class="o">=</span>
			    <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data2_RW</span><span class="p">);</span>
			<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data3_RW</span> <span class="o">=</span>
			    <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data3_RW</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data0_RW</span> <span class="o">=</span>
			    <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data0_RW</span><span class="p">);</span>
			<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data1_RW</span> <span class="o">=</span>
			    <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data1_RW</span><span class="p">);</span>
			<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data2_RW</span> <span class="o">=</span>
			    <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data2_RW</span><span class="p">);</span>
			<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data3_RW</span> <span class="o">=</span>
			    <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data3_RW</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_ppu_querymask</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Save, Step 20:</span>
<span class="cm">	 *     Save the PPU_QueryMask register</span>
<span class="cm">	 *     in the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">dma_querymask_RW</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">dma_querymask_RW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_ppu_querytype</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Save, Step 21:</span>
<span class="cm">	 *     Save the PPU_QueryType register</span>
<span class="cm">	 *     in the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">dma_querytype_RW</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">dma_querytype_RW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_ppu_tagstatus</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Save the Prxy_TagStatus register in the CSA.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It is unnecessary to restore dma_tagstatus_R, however,</span>
<span class="cm">	 * dma_tagstatus_R in the CSA is accessed via backing_ops, so</span>
<span class="cm">	 * we must save it.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">dma_tagstatus_R</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">dma_tagstatus_R</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_mfc_csr_tsq</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Save, Step 22:</span>
<span class="cm">	 *     Save the MFC_CSR_TSQ register</span>
<span class="cm">	 *     in the LSCSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_tag_status_query_RW</span> <span class="o">=</span>
	    <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_tag_status_query_RW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_mfc_csr_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Save, Step 23:</span>
<span class="cm">	 *     Save the MFC_CSR_CMD1 and MFC_CSR_CMD2</span>
<span class="cm">	 *     registers in the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_cmd_buf1_RW</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_cmd_buf1_RW</span><span class="p">);</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_cmd_buf2_RW</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_cmd_buf2_RW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_mfc_csr_ato</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Save, Step 24:</span>
<span class="cm">	 *     Save the MFC_CSR_ATO register in</span>
<span class="cm">	 *     the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_atomic_status_RW</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_atomic_status_RW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_mfc_tclass_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 25:</span>
<span class="cm">	 *     Save the MFC_TCLASS_ID register in</span>
<span class="cm">	 *     the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">mfc_tclass_id_RW</span> <span class="o">=</span> <span class="n">spu_mfc_tclass_id_get</span><span class="p">(</span><span class="n">spu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_mfc_tclass_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 26:</span>
<span class="cm">	 * Restore, Step 23.</span>
<span class="cm">	 *     Write the MFC_TCLASS_ID register with</span>
<span class="cm">	 *     the value 0x10000000.</span>
<span class="cm">	 */</span>
	<span class="n">spu_mfc_tclass_id_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mh">0x10000000</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">purge_mfc_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Save, Step 27:</span>
<span class="cm">	 * Restore, Step 14.</span>
<span class="cm">	 *     Write MFC_CNTL[Pc]=1 (purge queue).</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">,</span>
			<span class="n">MFC_CNTL_PURGE_DMA_REQUEST</span> <span class="o">|</span>
			<span class="n">MFC_CNTL_SUSPEND_MASK</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wait_purge_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Save, Step 28:</span>
<span class="cm">	 *     Poll MFC_CNTL[Ps] until value &#39;11&#39; is read</span>
<span class="cm">	 *     (purge complete).</span>
<span class="cm">	 */</span>
	<span class="n">POLL_WHILE_FALSE</span><span class="p">((</span><span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">)</span> <span class="o">&amp;</span>
			 <span class="n">MFC_CNTL_PURGE_DMA_STATUS_MASK</span><span class="p">)</span> <span class="o">==</span>
			 <span class="n">MFC_CNTL_PURGE_DMA_COMPLETE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setup_mfc_sr1</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 30:</span>
<span class="cm">	 * Restore, Step 18:</span>
<span class="cm">	 *     Write MFC_SR1 with MFC_SR1[D=0,S=1] and</span>
<span class="cm">	 *     MFC_SR1[TL,R,Pr,T] set correctly for the</span>
<span class="cm">	 *     OS specific environment.</span>
<span class="cm">	 *</span>
<span class="cm">	 *     Implementation note: The SPU-side code</span>
<span class="cm">	 *     for save/restore is privileged, so the</span>
<span class="cm">	 *     MFC_SR1[Pr] bit is not set.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="n">spu_mfc_sr1_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="p">(</span><span class="n">MFC_STATE1_MASTER_RUN_CONTROL_MASK</span> <span class="o">|</span>
			      <span class="n">MFC_STATE1_RELOCATE_MASK</span> <span class="o">|</span>
			      <span class="n">MFC_STATE1_BUS_TLBIE_MASK</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_spu_npc</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Save, Step 31:</span>
<span class="cm">	 *     Save SPU_NPC in the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_npc_RW</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_npc_RW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_spu_privcntl</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Save, Step 32:</span>
<span class="cm">	 *     Save SPU_PrivCntl in the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_privcntl_RW</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_privcntl_RW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reset_spu_privcntl</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Save, Step 33:</span>
<span class="cm">	 * Restore, Step 16:</span>
<span class="cm">	 *     Write SPU_PrivCntl[S,Le,A] fields reset to 0.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_privcntl_RW</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_spu_lslr</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Save, Step 34:</span>
<span class="cm">	 *     Save SPU_LSLR in the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_lslr_RW</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_lslr_RW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reset_spu_lslr</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Save, Step 35:</span>
<span class="cm">	 * Restore, Step 17.</span>
<span class="cm">	 *     Reset SPU_LSLR.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_lslr_RW</span><span class="p">,</span> <span class="n">LS_ADDR_MASK</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_spu_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Save, Step 36:</span>
<span class="cm">	 *     Save SPU_Cfg in the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_cfg_RW</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_cfg_RW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_pm_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 37:</span>
<span class="cm">	 *     Save PM_Trace_Tag_Wait_Mask in the CSA.</span>
<span class="cm">	 *     Not performed by this implementation.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_mfc_rag</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 38:</span>
<span class="cm">	 *     Save RA_GROUP_ID register and the</span>
<span class="cm">	 *     RA_ENABLE reigster in the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">resource_allocation_groupID_RW</span> <span class="o">=</span>
		<span class="n">spu_resource_allocation_groupID_get</span><span class="p">(</span><span class="n">spu</span><span class="p">);</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">resource_allocation_enable_RW</span> <span class="o">=</span>
		<span class="n">spu_resource_allocation_enable_get</span><span class="p">(</span><span class="n">spu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_ppu_mb_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Save, Step 39:</span>
<span class="cm">	 *     Save MB_Stat register in the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">mb_stat_R</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">mb_stat_R</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_ppu_mb</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Save, Step 40:</span>
<span class="cm">	 *     Save the PPU_MB register in the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">pu_mb_R</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">pu_mb_R</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_ppuint_mb</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Save, Step 41:</span>
<span class="cm">	 *     Save the PPUINT_MB register in the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">puint_mb_R</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">puint_mb_R</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_ch_part1</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ch_indices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0UL</span><span class="p">,</span> <span class="mi">3UL</span><span class="p">,</span> <span class="mi">4UL</span><span class="p">,</span> <span class="mi">24UL</span><span class="p">,</span> <span class="mi">25UL</span><span class="p">,</span> <span class="mi">27UL</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Save, Step 42:</span>
<span class="cm">	 */</span>

	<span class="cm">/* Save CH 1, without channel count */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcntptr_RW</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">);</span>

	<span class="cm">/* Save the following CH: [0,3,4,24,25,27] */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ch_indices</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">ch_indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcntptr_RW</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">);</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">);</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_spu_mb</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Save, Step 43:</span>
<span class="cm">	 *     Save SPU Read Mailbox Channel.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcntptr_RW</span><span class="p">,</span> <span class="mi">29UL</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">29</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_mailbox_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_mfc_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Save, Step 44:</span>
<span class="cm">	 *     Save MFC_CMD Channel.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcntptr_RW</span><span class="p">,</span> <span class="mi">21UL</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reset_ch</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ch_indices</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">21UL</span><span class="p">,</span> <span class="mi">23UL</span><span class="p">,</span> <span class="mi">28UL</span><span class="p">,</span> <span class="mi">30UL</span> <span class="p">};</span>
	<span class="n">u64</span> <span class="n">ch_counts</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">16UL</span><span class="p">,</span> <span class="mi">1UL</span><span class="p">,</span> <span class="mi">1UL</span><span class="p">,</span> <span class="mi">1UL</span> <span class="p">};</span>
	<span class="n">u64</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Save, Step 45:</span>
<span class="cm">	 *     Reset the following CH: [21, 23, 28, 30]</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">ch_indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcntptr_RW</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">,</span> <span class="n">ch_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">eieio</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">resume_mfc_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Save, Step 46:</span>
<span class="cm">	 * Restore, Step 25.</span>
<span class="cm">	 *     Write MFC_CNTL[Sc]=0 (resume queue processing).</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">,</span> <span class="n">MFC_CNTL_RESUME_DMA_QUEUE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setup_mfc_slbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">code_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 47:</span>
<span class="cm">	 * Restore, Step 30.</span>
<span class="cm">	 *     If MFC_SR1[R]=1, write 0 to SLB_Invalidate_All</span>
<span class="cm">	 *     register, then initialize SLB_VSID and SLB_ESID</span>
<span class="cm">	 *     to provide access to SPU context save code and</span>
<span class="cm">	 *     LSCSA.</span>
<span class="cm">	 *</span>
<span class="cm">	 *     This implementation places both the context</span>
<span class="cm">	 *     switch code and LSCSA in kernel address space.</span>
<span class="cm">	 *</span>
<span class="cm">	 *     Further this implementation assumes that the</span>
<span class="cm">	 *     MFC_SR1[R]=1 (in other words, assume that</span>
<span class="cm">	 *     translation is desired by OS environment).</span>
<span class="cm">	 */</span>
	<span class="n">spu_invalidate_slbs</span><span class="p">(</span><span class="n">spu</span><span class="p">);</span>
	<span class="n">spu_setup_kernel_slbs</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">code_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_switch_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save, Step 48:</span>
<span class="cm">	 * Restore, Step 23.</span>
<span class="cm">	 *     Change the software context switch pending flag</span>
<span class="cm">	 *     to context switch active.  This implementation does</span>
<span class="cm">	 *     not uses a switch active flag.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Now that we have saved the mfc in the csa, we can add in the</span>
<span class="cm">	 * restart command if an exception occurred.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SPU_CONTEXT_FAULT_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">mfc_control_RW</span> <span class="o">|=</span> <span class="n">MFC_CNTL_RESTART_DMA_COMMAND</span><span class="p">;</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">SPU_CONTEXT_SWITCH_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">class1_mask</span> <span class="o">=</span> <span class="n">CLASS1_ENABLE_SEGMENT_FAULT_INTR</span> <span class="o">|</span>
	    <span class="n">CLASS1_ENABLE_STORAGE_FAULT_INTR</span><span class="p">;</span>

	<span class="cm">/* Save, Step 49:</span>
<span class="cm">	 * Restore, Step 22:</span>
<span class="cm">	 *     Reset and then enable interrupts, as</span>
<span class="cm">	 *     needed by OS.</span>
<span class="cm">	 *</span>
<span class="cm">	 *     This implementation enables only class1</span>
<span class="cm">	 *     (translation) interrupts.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="n">spu_int_stat_clear</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CLASS0_INTR_MASK</span><span class="p">);</span>
	<span class="n">spu_int_stat_clear</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">CLASS1_INTR_MASK</span><span class="p">);</span>
	<span class="n">spu_int_stat_clear</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">CLASS2_INTR_MASK</span><span class="p">);</span>
	<span class="n">spu_int_mask_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0ul</span><span class="p">);</span>
	<span class="n">spu_int_mask_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">class1_mask</span><span class="p">);</span>
	<span class="n">spu_int_mask_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0ul</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">send_mfc_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ea</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ls_offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rclass</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">mfc_tag_size_class_cmd</span> <span class="n">command</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">transfer_size</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transfer_size</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">MFC_MAX_DMA_SIZE</span><span class="p">)</span> <span class="o">?</span> <span class="n">MFC_MAX_DMA_SIZE</span> <span class="o">:</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">command</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">mfc_size</span> <span class="o">=</span> <span class="n">transfer_size</span><span class="p">;</span>
		<span class="n">command</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">mfc_tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
		<span class="n">command</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">mfc_rclassid</span> <span class="o">=</span> <span class="n">rclass</span><span class="p">;</span>
		<span class="n">command</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">mfc_cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">mfc_lsa_W</span><span class="p">,</span> <span class="n">ls_offset</span><span class="p">);</span>
			<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">mfc_ea_W</span><span class="p">,</span> <span class="n">ea</span><span class="p">);</span>
			<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">mfc_union_W</span><span class="p">.</span><span class="n">all64</span><span class="p">,</span> <span class="n">command</span><span class="p">.</span><span class="n">all64</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">mfc_union_W</span><span class="p">.</span><span class="n">by32</span><span class="p">.</span><span class="n">mfc_class_cmd32</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">cpu_relax</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">transfer_size</span><span class="p">;</span>
		<span class="n">ea</span> <span class="o">+=</span> <span class="n">transfer_size</span><span class="p">;</span>
		<span class="n">ls_offset</span> <span class="o">+=</span> <span class="n">transfer_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_ls_16kb</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">ls</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ls_offset</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rclass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">MFC_PUT_CMD</span><span class="p">;</span>

	<span class="cm">/* Save, Step 50:</span>
<span class="cm">	 *     Issue a DMA command to copy the first 16K bytes</span>
<span class="cm">	 *     of local storage to the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">send_mfc_dma</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ls_offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">rclass</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_spu_npc</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Save, Step 51:</span>
<span class="cm">	 * Restore, Step 31.</span>
<span class="cm">	 *     Write SPU_NPC[IE]=0 and SPU_NPC[LSA] to entry</span>
<span class="cm">	 *     point address of context save code in local</span>
<span class="cm">	 *     storage.</span>
<span class="cm">	 *</span>
<span class="cm">	 *     This implementation uses SPU-side save/restore</span>
<span class="cm">	 *     programs with entry points at LSA of 0.</span>
<span class="cm">	 */</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_npc_RW</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_signot1</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">ull</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">ui</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">addr64</span><span class="p">;</span>

	<span class="cm">/* Save, Step 52:</span>
<span class="cm">	 * Restore, Step 32:</span>
<span class="cm">	 *    Write SPU_Sig_Notify_1 register with upper 32-bits</span>
<span class="cm">	 *    of the CSA.LSCSA effective address.</span>
<span class="cm">	 */</span>
	<span class="n">addr64</span><span class="p">.</span><span class="n">ull</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="p">;</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">signal_notify1</span><span class="p">,</span> <span class="n">addr64</span><span class="p">.</span><span class="n">ui</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_signot2</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">ull</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">ui</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">addr64</span><span class="p">;</span>

	<span class="cm">/* Save, Step 53:</span>
<span class="cm">	 * Restore, Step 33:</span>
<span class="cm">	 *    Write SPU_Sig_Notify_2 register with lower 32-bits</span>
<span class="cm">	 *    of the CSA.LSCSA effective address.</span>
<span class="cm">	 */</span>
	<span class="n">addr64</span><span class="p">.</span><span class="n">ull</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="p">;</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">signal_notify2</span><span class="p">,</span> <span class="n">addr64</span><span class="p">.</span><span class="n">ui</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">send_save_code</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">spu_save_code</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ls_offset</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">spu_save_code</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rclass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">MFC_GETFS_CMD</span><span class="p">;</span>

	<span class="cm">/* Save, Step 54:</span>
<span class="cm">	 *     Issue a DMA command to copy context save code</span>
<span class="cm">	 *     to local storage and start SPU.</span>
<span class="cm">	 */</span>
	<span class="n">send_mfc_dma</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ls_offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">rclass</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_ppu_querymask</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Save, Step 55:</span>
<span class="cm">	 * Restore, Step 38.</span>
<span class="cm">	 *     Write PPU_QueryMask=1 (enable Tag Group 0)</span>
<span class="cm">	 *     and issue eieio instruction.</span>
<span class="cm">	 */</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">dma_querymask_RW</span><span class="p">,</span> <span class="n">MFC_TAGID_TO_TAGMASK</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wait_tag_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">MFC_TAGID_TO_TAGMASK</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Save, Step 56:</span>
<span class="cm">	 * Restore, Step 39.</span>
<span class="cm">	 * Restore, Step 39.</span>
<span class="cm">	 * Restore, Step 46.</span>
<span class="cm">	 *     Poll PPU_TagStatus[gn] until 01 (Tag group 0 complete)</span>
<span class="cm">	 *     or write PPU_QueryType[TS]=01 and wait for Tag Group</span>
<span class="cm">	 *     Complete Interrupt.  Write INT_Stat_Class0 or</span>
<span class="cm">	 *     INT_Stat_Class2 with value of &#39;handled&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">POLL_WHILE_FALSE</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">dma_tagstatus_R</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">spu_int_stat_clear</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CLASS0_INTR_MASK</span><span class="p">);</span>
	<span class="n">spu_int_stat_clear</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">CLASS2_INTR_MASK</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wait_spu_stopped</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Save, Step 57:</span>
<span class="cm">	 * Restore, Step 40.</span>
<span class="cm">	 *     Poll until SPU_Status[R]=0 or wait for SPU Class 0</span>
<span class="cm">	 *     or SPU Class 2 interrupt.  Write INT_Stat_class0</span>
<span class="cm">	 *     or INT_Stat_class2 with value of handled.</span>
<span class="cm">	 */</span>
	<span class="n">POLL_WHILE_TRUE</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SPU_STATUS_RUNNING</span><span class="p">);</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">spu_int_stat_clear</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CLASS0_INTR_MASK</span><span class="p">);</span>
	<span class="n">spu_int_stat_clear</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">CLASS2_INTR_MASK</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_save_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">complete</span><span class="p">;</span>

	<span class="cm">/* Save, Step 54:</span>
<span class="cm">	 *     If SPU_Status[P]=1 and SPU_Status[SC] = &quot;success&quot;,</span>
<span class="cm">	 *     context save succeeded, otherwise context save</span>
<span class="cm">	 *     failed.</span>
<span class="cm">	 */</span>
	<span class="n">complete</span> <span class="o">=</span> <span class="p">((</span><span class="n">SPU_SAVE_COMPLETE</span> <span class="o">&lt;&lt;</span> <span class="n">SPU_STOP_STATUS_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		    <span class="n">SPU_STATUS_STOPPED_BY_STOP</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">!=</span> <span class="n">complete</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">terminate_spu_app</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restore, Step 4:</span>
<span class="cm">	 *    If required, notify the &quot;using application&quot; that</span>
<span class="cm">	 *    the SPU task has been terminated.  TBD.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">suspend_mfc_and_halt_decr</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 7:</span>
<span class="cm">	 *     Write MFC_Cntl[Dh,Sc,Sm]=&#39;1&#39;,&#39;1&#39;,&#39;0&#39; to suspend</span>
<span class="cm">	 *     the queue and halt the decrementer.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">,</span> <span class="n">MFC_CNTL_SUSPEND_DMA_QUEUE</span> <span class="o">|</span>
		 <span class="n">MFC_CNTL_DECREMENTER_HALTED</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wait_suspend_mfc_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 8:</span>
<span class="cm">	 * Restore, Step 47.</span>
<span class="cm">	 *     Poll MFC_CNTL[Ss] until 11 is returned.</span>
<span class="cm">	 */</span>
	<span class="n">POLL_WHILE_FALSE</span><span class="p">((</span><span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">)</span> <span class="o">&amp;</span>
			 <span class="n">MFC_CNTL_SUSPEND_DMA_STATUS_MASK</span><span class="p">)</span> <span class="o">==</span>
			 <span class="n">MFC_CNTL_SUSPEND_COMPLETE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">suspend_spe</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 9:</span>
<span class="cm">	 *    If SPU_Status[R]=1, stop SPU execution</span>
<span class="cm">	 *    and wait for stop to complete.</span>
<span class="cm">	 *</span>
<span class="cm">	 *    Returns       1 if SPU_Status[R]=1 on entry.</span>
<span class="cm">	 *                  0 otherwise</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SPU_STATUS_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
		    <span class="n">SPU_STATUS_ISOLATED_EXIT_STATUS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">POLL_WHILE_TRUE</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
					<span class="n">SPU_STATUS_RUNNING</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
		     <span class="n">SPU_STATUS_ISOLATED_LOAD_STATUS</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="n">SPU_STATUS_ISOLATED_STATE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_runcntl_RW</span><span class="p">,</span> <span class="n">SPU_RUNCNTL_STOP</span><span class="p">);</span>
			<span class="n">eieio</span><span class="p">();</span>
			<span class="n">POLL_WHILE_TRUE</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
					<span class="n">SPU_STATUS_RUNNING</span><span class="p">);</span>
			<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_runcntl_RW</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">);</span>
			<span class="n">eieio</span><span class="p">();</span>
			<span class="n">POLL_WHILE_TRUE</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
					<span class="n">SPU_STATUS_RUNNING</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
		    <span class="n">SPU_STATUS_WAITING_FOR_CHANNEL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_runcntl_RW</span><span class="p">,</span> <span class="n">SPU_RUNCNTL_STOP</span><span class="p">);</span>
			<span class="n">eieio</span><span class="p">();</span>
			<span class="n">POLL_WHILE_TRUE</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
					<span class="n">SPU_STATUS_RUNNING</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_spu_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 10:</span>
<span class="cm">	 *    If SPU_Status[R]=0 and SPU_Status[E,L,IS]=1,</span>
<span class="cm">	 *    release SPU from isolate state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SPU_STATUS_RUNNING</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
		    <span class="n">SPU_STATUS_ISOLATED_EXIT_STATUS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spu_mfc_sr1_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span>
					<span class="n">MFC_STATE1_MASTER_RUN_CONTROL_MASK</span><span class="p">);</span>
			<span class="n">eieio</span><span class="p">();</span>
			<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_runcntl_RW</span><span class="p">,</span> <span class="n">SPU_RUNCNTL_RUNNABLE</span><span class="p">);</span>
			<span class="n">eieio</span><span class="p">();</span>
			<span class="n">POLL_WHILE_TRUE</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
					<span class="n">SPU_STATUS_RUNNING</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
		     <span class="n">SPU_STATUS_ISOLATED_LOAD_STATUS</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="n">SPU_STATUS_ISOLATED_STATE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spu_mfc_sr1_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span>
					<span class="n">MFC_STATE1_MASTER_RUN_CONTROL_MASK</span><span class="p">);</span>
			<span class="n">eieio</span><span class="p">();</span>
			<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_runcntl_RW</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">);</span>
			<span class="n">eieio</span><span class="p">();</span>
			<span class="n">POLL_WHILE_TRUE</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
					<span class="n">SPU_STATUS_RUNNING</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reset_ch_part1</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ch_indices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0UL</span><span class="p">,</span> <span class="mi">3UL</span><span class="p">,</span> <span class="mi">4UL</span><span class="p">,</span> <span class="mi">24UL</span><span class="p">,</span> <span class="mi">25UL</span><span class="p">,</span> <span class="mi">27UL</span> <span class="p">};</span>
	<span class="n">u64</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 20:</span>
<span class="cm">	 */</span>

	<span class="cm">/* Reset CH 1 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcntptr_RW</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>

	<span class="cm">/* Reset the following CH: [0,3,4,24,25,27] */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ch_indices</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">ch_indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcntptr_RW</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reset_ch_part2</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ch_indices</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">21UL</span><span class="p">,</span> <span class="mi">23UL</span><span class="p">,</span> <span class="mi">28UL</span><span class="p">,</span> <span class="mi">29UL</span><span class="p">,</span> <span class="mi">30UL</span> <span class="p">};</span>
	<span class="n">u64</span> <span class="n">ch_counts</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">16UL</span><span class="p">,</span> <span class="mi">1UL</span><span class="p">,</span> <span class="mi">1UL</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">,</span> <span class="mi">1UL</span> <span class="p">};</span>
	<span class="n">u64</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 21:</span>
<span class="cm">	 *     Reset the following CH: [21, 23, 28, 29, 30]</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">ch_indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcntptr_RW</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">,</span> <span class="n">ch_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">eieio</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setup_spu_status_part1</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status_P</span> <span class="o">=</span> <span class="n">SPU_STATUS_STOPPED_BY_STOP</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status_I</span> <span class="o">=</span> <span class="n">SPU_STATUS_INVALID_INSTR</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status_H</span> <span class="o">=</span> <span class="n">SPU_STATUS_STOPPED_BY_HALT</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status_S</span> <span class="o">=</span> <span class="n">SPU_STATUS_SINGLE_STEP</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status_S_I</span> <span class="o">=</span> <span class="n">SPU_STATUS_SINGLE_STEP</span> <span class="o">|</span> <span class="n">SPU_STATUS_INVALID_INSTR</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status_S_P</span> <span class="o">=</span> <span class="n">SPU_STATUS_SINGLE_STEP</span> <span class="o">|</span> <span class="n">SPU_STATUS_STOPPED_BY_STOP</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status_P_H</span> <span class="o">=</span> <span class="n">SPU_STATUS_STOPPED_BY_HALT</span> <span class="o">|</span><span class="n">SPU_STATUS_STOPPED_BY_STOP</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status_P_I</span> <span class="o">=</span> <span class="n">SPU_STATUS_STOPPED_BY_STOP</span> <span class="o">|</span><span class="n">SPU_STATUS_INVALID_INSTR</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status_code</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 27:</span>
<span class="cm">	 *     If the CSA.SPU_Status[I,S,H,P]=1 then add the correct</span>
<span class="cm">	 *     instruction sequence to the end of the SPU based restore</span>
<span class="cm">	 *     code (after the &quot;context restored&quot; stop and signal) to</span>
<span class="cm">	 *     restore the correct SPU status.</span>
<span class="cm">	 *</span>
<span class="cm">	 *     NOTE: Rather than modifying the SPU executable, we</span>
<span class="cm">	 *     instead add a new &#39;stopped_status&#39; field to the</span>
<span class="cm">	 *     LSCSA.  The SPU-side restore reads this field and</span>
<span class="cm">	 *     takes the appropriate action when exiting.</span>
<span class="cm">	 */</span>

	<span class="n">status_code</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">&gt;&gt;</span> <span class="n">SPU_STOP_STATUS_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">&amp;</span> <span class="n">status_P_I</span><span class="p">)</span> <span class="o">==</span> <span class="n">status_P_I</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* SPU_Status[P,I]=1 - Illegal Instruction followed</span>
<span class="cm">		 * by Stop and Signal instruction, followed by &#39;br -4&#39;.</span>
<span class="cm">		 *</span>
<span class="cm">		 */</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">stopped_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPU_STOPPED_STATUS_P_I</span><span class="p">;</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">stopped_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">status_code</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">&amp;</span> <span class="n">status_P_H</span><span class="p">)</span> <span class="o">==</span> <span class="n">status_P_H</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* SPU_Status[P,H]=1 - Halt Conditional, followed</span>
<span class="cm">		 * by Stop and Signal instruction, followed by</span>
<span class="cm">		 * &#39;br -4&#39;.</span>
<span class="cm">		 */</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">stopped_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPU_STOPPED_STATUS_P_H</span><span class="p">;</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">stopped_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">status_code</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">&amp;</span> <span class="n">status_S_P</span><span class="p">)</span> <span class="o">==</span> <span class="n">status_S_P</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* SPU_Status[S,P]=1 - Stop and Signal instruction</span>
<span class="cm">		 * followed by &#39;br -4&#39;.</span>
<span class="cm">		 */</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">stopped_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPU_STOPPED_STATUS_S_P</span><span class="p">;</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">stopped_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">status_code</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">&amp;</span> <span class="n">status_S_I</span><span class="p">)</span> <span class="o">==</span> <span class="n">status_S_I</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* SPU_Status[S,I]=1 - Illegal instruction followed</span>
<span class="cm">		 * by &#39;br -4&#39;.</span>
<span class="cm">		 */</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">stopped_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPU_STOPPED_STATUS_S_I</span><span class="p">;</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">stopped_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">status_code</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">&amp;</span> <span class="n">status_P</span><span class="p">)</span> <span class="o">==</span> <span class="n">status_P</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* SPU_Status[P]=1 - Stop and Signal instruction</span>
<span class="cm">		 * followed by &#39;br -4&#39;.</span>
<span class="cm">		 */</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">stopped_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPU_STOPPED_STATUS_P</span><span class="p">;</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">stopped_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">status_code</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">&amp;</span> <span class="n">status_H</span><span class="p">)</span> <span class="o">==</span> <span class="n">status_H</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* SPU_Status[H]=1 - Halt Conditional, followed</span>
<span class="cm">		 * by &#39;br -4&#39;.</span>
<span class="cm">		 */</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">stopped_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPU_STOPPED_STATUS_H</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">&amp;</span> <span class="n">status_S</span><span class="p">)</span> <span class="o">==</span> <span class="n">status_S</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* SPU_Status[S]=1 - Two nop instructions.</span>
<span class="cm">		 */</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">stopped_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPU_STOPPED_STATUS_S</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">&amp;</span> <span class="n">status_I</span><span class="p">)</span> <span class="o">==</span> <span class="n">status_I</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* SPU_Status[I]=1 - Illegal instruction followed</span>
<span class="cm">		 * by &#39;br -4&#39;.</span>
<span class="cm">		 */</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">stopped_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPU_STOPPED_STATUS_I</span><span class="p">;</span>

	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setup_spu_status_part2</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 28:</span>
<span class="cm">	 *     If the CSA.SPU_Status[I,S,H,P,R]=0 then</span>
<span class="cm">	 *     add a &#39;br *&#39; instruction to the end of</span>
<span class="cm">	 *     the SPU based restore code.</span>
<span class="cm">	 *</span>
<span class="cm">	 *     NOTE: Rather than modifying the SPU executable, we</span>
<span class="cm">	 *     instead add a new &#39;stopped_status&#39; field to the</span>
<span class="cm">	 *     LSCSA.  The SPU-side restore reads this field and</span>
<span class="cm">	 *     takes the appropriate action when exiting.</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">SPU_STATUS_INVALID_INSTR</span> <span class="o">|</span>
	    <span class="n">SPU_STATUS_SINGLE_STEP</span> <span class="o">|</span>
	    <span class="n">SPU_STATUS_STOPPED_BY_HALT</span> <span class="o">|</span>
	    <span class="n">SPU_STATUS_STOPPED_BY_STOP</span> <span class="o">|</span> <span class="n">SPU_STATUS_RUNNING</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">stopped_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPU_STOPPED_STATUS_R</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_mfc_rag</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restore, Step 29:</span>
<span class="cm">	 *     Restore RA_GROUP_ID register and the</span>
<span class="cm">	 *     RA_ENABLE reigster from the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">spu_resource_allocation_groupID_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span>
			<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">resource_allocation_groupID_RW</span><span class="p">);</span>
	<span class="n">spu_resource_allocation_enable_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span>
			<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">resource_allocation_enable_RW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">send_restore_code</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">spu_restore_code</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ls_offset</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">spu_restore_code</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rclass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">MFC_GETFS_CMD</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 37:</span>
<span class="cm">	 *     Issue MFC DMA command to copy context</span>
<span class="cm">	 *     restore code to local storage.</span>
<span class="cm">	 */</span>
	<span class="n">send_mfc_dma</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ls_offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">rclass</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setup_decr</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restore, Step 34:</span>
<span class="cm">	 *     If CSA.MFC_CNTL[Ds]=1 (decrementer was</span>
<span class="cm">	 *     running) then adjust decrementer, set</span>
<span class="cm">	 *     decrementer running status in LSCSA,</span>
<span class="cm">	 *     and set decrementer &quot;wrapped&quot; status</span>
<span class="cm">	 *     in LSCSA.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">mfc_control_RW</span> <span class="o">&amp;</span> <span class="n">MFC_CNTL_DECREMENTER_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cycles_t</span> <span class="n">resume_time</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>
		<span class="n">cycles_t</span> <span class="n">delta_time</span> <span class="o">=</span> <span class="n">resume_time</span> <span class="o">-</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">suspend_time</span><span class="p">;</span>

		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">decr_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPU_DECR_STATUS_RUNNING</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">decr</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">delta_time</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">decr_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span>
				 <span class="n">SPU_DECR_STATUS_WRAPPED</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">decr</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">delta_time</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">decr_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setup_ppu_mb</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restore, Step 35:</span>
<span class="cm">	 *     Copy the CSA.PU_MB data into the LSCSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">ppu_mb</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">pu_mb_R</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setup_ppuint_mb</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restore, Step 36:</span>
<span class="cm">	 *     Copy the CSA.PUINT_MB data into the LSCSA.</span>
<span class="cm">	 */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">ppuint_mb</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">puint_mb_R</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_restore_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">complete</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 40:</span>
<span class="cm">	 *     If SPU_Status[P]=1 and SPU_Status[SC] = &quot;success&quot;,</span>
<span class="cm">	 *     context restore succeeded, otherwise context restore</span>
<span class="cm">	 *     failed.</span>
<span class="cm">	 */</span>
	<span class="n">complete</span> <span class="o">=</span> <span class="p">((</span><span class="n">SPU_RESTORE_COMPLETE</span> <span class="o">&lt;&lt;</span> <span class="n">SPU_STOP_STATUS_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		    <span class="n">SPU_STATUS_STOPPED_BY_STOP</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">!=</span> <span class="n">complete</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_spu_privcntl</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 41:</span>
<span class="cm">	 *     Restore SPU_PrivCntl from the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_privcntl_RW</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_privcntl_RW</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_status_part1</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 42:</span>
<span class="cm">	 *     If any CSA.SPU_Status[I,S,H,P]=1, then</span>
<span class="cm">	 *     restore the error or single step state.</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">SPU_STATUS_INVALID_INSTR</span> <span class="o">|</span>
	    <span class="n">SPU_STATUS_SINGLE_STEP</span> <span class="o">|</span>
	    <span class="n">SPU_STATUS_STOPPED_BY_HALT</span> <span class="o">|</span> <span class="n">SPU_STATUS_STOPPED_BY_STOP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_runcntl_RW</span><span class="p">,</span> <span class="n">SPU_RUNCNTL_RUNNABLE</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
		<span class="n">POLL_WHILE_TRUE</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">SPU_STATUS_RUNNING</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_status_part2</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 43:</span>
<span class="cm">	 *     If all CSA.SPU_Status[I,S,H,P,R]=0 then write</span>
<span class="cm">	 *     SPU_RunCntl[R0R1]=&#39;01&#39;, wait for SPU_Status[R]=1,</span>
<span class="cm">	 *     then write &#39;00&#39; to SPU_RunCntl[R0R1] and wait</span>
<span class="cm">	 *     for SPU_Status[R]=0.</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">SPU_STATUS_INVALID_INSTR</span> <span class="o">|</span>
	    <span class="n">SPU_STATUS_SINGLE_STEP</span> <span class="o">|</span>
	    <span class="n">SPU_STATUS_STOPPED_BY_HALT</span> <span class="o">|</span>
	    <span class="n">SPU_STATUS_STOPPED_BY_STOP</span> <span class="o">|</span> <span class="n">SPU_STATUS_RUNNING</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_runcntl_RW</span><span class="p">,</span> <span class="n">SPU_RUNCNTL_RUNNABLE</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
		<span class="n">POLL_WHILE_FALSE</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
				 <span class="n">SPU_STATUS_RUNNING</span><span class="p">);</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_runcntl_RW</span><span class="p">,</span> <span class="n">SPU_RUNCNTL_STOP</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
		<span class="n">POLL_WHILE_TRUE</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">SPU_STATUS_RUNNING</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_ls_16kb</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">ls</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ls_offset</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rclass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">MFC_GET_CMD</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 44:</span>
<span class="cm">	 *     Issue a DMA command to restore the first</span>
<span class="cm">	 *     16kb of local storage from CSA.</span>
<span class="cm">	 */</span>
	<span class="n">send_mfc_dma</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ls_offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">rclass</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">suspend_mfc</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 47.</span>
<span class="cm">	 *     Write MFC_Cntl[Sc,Sm]=&#39;1&#39;,&#39;0&#39; to suspend</span>
<span class="cm">	 *     the queue.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">,</span> <span class="n">MFC_CNTL_SUSPEND_DMA_QUEUE</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restore, Step 49:</span>
<span class="cm">	 *     Write INT_MASK_class0 with value of 0.</span>
<span class="cm">	 *     Write INT_MASK_class1 with value of 0.</span>
<span class="cm">	 *     Write INT_MASK_class2 with value of 0.</span>
<span class="cm">	 *     Write INT_STAT_class0 with value of -1.</span>
<span class="cm">	 *     Write INT_STAT_class1 with value of -1.</span>
<span class="cm">	 *     Write INT_STAT_class2 with value of -1.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="n">spu_int_mask_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0ul</span><span class="p">);</span>
	<span class="n">spu_int_mask_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0ul</span><span class="p">);</span>
	<span class="n">spu_int_mask_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0ul</span><span class="p">);</span>
	<span class="n">spu_int_stat_clear</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CLASS0_INTR_MASK</span><span class="p">);</span>
	<span class="n">spu_int_stat_clear</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">CLASS1_INTR_MASK</span><span class="p">);</span>
	<span class="n">spu_int_stat_clear</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">CLASS2_INTR_MASK</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_mfc_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 50:</span>
<span class="cm">	 *     If MFC_Cntl[Se]!=0 then restore</span>
<span class="cm">	 *     MFC command queues.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">mfc_control_RW</span> <span class="o">&amp;</span> <span class="n">MFC_CNTL_DMA_QUEUES_EMPTY_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data0_RW</span><span class="p">,</span>
				 <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data0_RW</span><span class="p">);</span>
			<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data1_RW</span><span class="p">,</span>
				 <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data1_RW</span><span class="p">);</span>
			<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data2_RW</span><span class="p">,</span>
				 <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data2_RW</span><span class="p">);</span>
			<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data3_RW</span><span class="p">,</span>
				 <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">puq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data3_RW</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data0_RW</span><span class="p">,</span>
				 <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data0_RW</span><span class="p">);</span>
			<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data1_RW</span><span class="p">,</span>
				 <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data1_RW</span><span class="p">);</span>
			<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data2_RW</span><span class="p">,</span>
				 <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data2_RW</span><span class="p">);</span>
			<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data3_RW</span><span class="p">,</span>
				 <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spuq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mfc_cq_data3_RW</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_ppu_querymask</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 51:</span>
<span class="cm">	 *     Restore the PPU_QueryMask register from CSA.</span>
<span class="cm">	 */</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">dma_querymask_RW</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">dma_querymask_RW</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_ppu_querytype</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 52:</span>
<span class="cm">	 *     Restore the PPU_QueryType register from CSA.</span>
<span class="cm">	 */</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">dma_querytype_RW</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">dma_querytype_RW</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_mfc_csr_tsq</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 53:</span>
<span class="cm">	 *     Restore the MFC_CSR_TSQ register from CSA.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_tag_status_query_RW</span><span class="p">,</span>
		 <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_tag_status_query_RW</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_mfc_csr_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 54:</span>
<span class="cm">	 *     Restore the MFC_CSR_CMD1 and MFC_CSR_CMD2</span>
<span class="cm">	 *     registers from CSA.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_cmd_buf1_RW</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_cmd_buf1_RW</span><span class="p">);</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_cmd_buf2_RW</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_cmd_buf2_RW</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_mfc_csr_ato</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 55:</span>
<span class="cm">	 *     Restore the MFC_CSR_ATO register from CSA.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_atomic_status_RW</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_atomic_status_RW</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_mfc_tclass_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restore, Step 56:</span>
<span class="cm">	 *     Restore the MFC_TCLASS_ID register from CSA.</span>
<span class="cm">	 */</span>
	<span class="n">spu_mfc_tclass_id_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">mfc_tclass_id_RW</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_llr_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ch0_cnt</span><span class="p">,</span> <span class="n">ch0_data</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ch1_data</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 57:</span>
<span class="cm">	 *    Set the Lock Line Reservation Lost Event by:</span>
<span class="cm">	 *      1. OR CSA.SPU_Event_Status with bit 21 (Lr) set to 1.</span>
<span class="cm">	 *      2. If CSA.SPU_Channel_0_Count=0 and</span>
<span class="cm">	 *         CSA.SPU_Wr_Event_Mask[Lr]=1 and</span>
<span class="cm">	 *         CSA.SPU_Event_Status[Lr]=0 then set</span>
<span class="cm">	 *         CSA.SPU_Event_Status_Count=1.</span>
<span class="cm">	 */</span>
	<span class="n">ch0_cnt</span> <span class="o">=</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ch0_data</span> <span class="o">=</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ch1_data</span> <span class="o">=</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">MFC_LLR_LOST_EVENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ch0_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ch0_data</span> <span class="o">&amp;</span> <span class="n">MFC_LLR_LOST_EVENT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ch1_data</span> <span class="o">&amp;</span> <span class="n">MFC_LLR_LOST_EVENT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_decr_wrapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restore, Step 58:</span>
<span class="cm">	 *     If the status of the CSA software decrementer</span>
<span class="cm">	 *     &quot;wrapped&quot; flag is set, OR in a &#39;1&#39; to</span>
<span class="cm">	 *     CSA.SPU_Event_Status[Tm].</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">lscsa</span><span class="o">-&gt;</span><span class="n">decr_status</span><span class="p">.</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">SPU_DECR_STATUS_WRAPPED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">))</span>
		<span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x20</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_ch_part1</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ch_indices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0UL</span><span class="p">,</span> <span class="mi">3UL</span><span class="p">,</span> <span class="mi">4UL</span><span class="p">,</span> <span class="mi">24UL</span><span class="p">,</span> <span class="mi">25UL</span><span class="p">,</span> <span class="mi">27UL</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 59:</span>
<span class="cm">	 *	Restore the following CH: [0,3,4,24,25,27]</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ch_indices</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">ch_indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcntptr_RW</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
		<span class="n">eieio</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_ch_part2</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ch_indices</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">9UL</span><span class="p">,</span> <span class="mi">21UL</span><span class="p">,</span> <span class="mi">23UL</span> <span class="p">};</span>
	<span class="n">u64</span> <span class="n">ch_counts</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1UL</span><span class="p">,</span> <span class="mi">16UL</span><span class="p">,</span> <span class="mi">1UL</span> <span class="p">};</span>
	<span class="n">u64</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 60:</span>
<span class="cm">	 *     Restore the following CH: [9,21,23].</span>
<span class="cm">	 */</span>
	<span class="n">ch_counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1UL</span><span class="p">;</span>
	<span class="n">ch_counts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">21</span><span class="p">];</span>
	<span class="n">ch_counts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1UL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">ch_indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcntptr_RW</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">,</span> <span class="n">ch_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">eieio</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_spu_lslr</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 61:</span>
<span class="cm">	 *     Restore the SPU_LSLR register from CSA.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_lslr_RW</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_lslr_RW</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_spu_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 62:</span>
<span class="cm">	 *     Restore the SPU_Cfg register from CSA.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_cfg_RW</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_cfg_RW</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_pm_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restore, Step 63:</span>
<span class="cm">	 *     Restore PM_Trace_Tag_Wait_Mask from CSA.</span>
<span class="cm">	 *     Not performed by this implementation.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_spu_npc</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 64:</span>
<span class="cm">	 *     Restore SPU_NPC from CSA.</span>
<span class="cm">	 */</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_npc_RW</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_npc_RW</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_spu_mb</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 65:</span>
<span class="cm">	 *     Restore MFC_RdSPU_MB from CSA.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcntptr_RW</span><span class="p">,</span> <span class="mi">29UL</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">29</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_chnldata_RW</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_mailbox_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">check_ppu_mb_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dummy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 66:</span>
<span class="cm">	 *     If CSA.MB_Stat[P]=0 (mailbox empty) then</span>
<span class="cm">	 *     read from the PPU_MB register.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">mb_stat_R</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">pu_mb_R</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">check_ppuint_mb_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dummy</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 66:</span>
<span class="cm">	 *     If CSA.MB_Stat[I]=0 (mailbox empty) then</span>
<span class="cm">	 *     read from the PPUINT_MB register.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">mb_stat_R</span> <span class="o">&amp;</span> <span class="mh">0xFF0000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">in_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">puint_mb_R</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
		<span class="n">spu_int_stat_clear</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">CLASS2_ENABLE_MAILBOX_INTR</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_mfc_sr1</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restore, Step 69:</span>
<span class="cm">	 *     Restore the MFC_SR1 register from CSA.</span>
<span class="cm">	 */</span>
	<span class="n">spu_mfc_sr1_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">mfc_sr1_RW</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_int_route</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>

	<span class="n">spu_cpu_affinity_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_ran</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_other_spu_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restore, Step 70:</span>
<span class="cm">	 *     Restore other SPU mappings to this SPU. TBD.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_spu_runcntl</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 71:</span>
<span class="cm">	 *     If CSA.SPU_Status[R]=1 then write</span>
<span class="cm">	 *     SPU_RunCntl[R0R1]=&#39;01&#39;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_status_R</span> <span class="o">&amp;</span> <span class="n">SPU_STATUS_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_runcntl_RW</span><span class="p">,</span> <span class="n">SPU_RUNCNTL_RUNNABLE</span><span class="p">);</span>
		<span class="n">eieio</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_mfc_cntl</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Restore, Step 72:</span>
<span class="cm">	 *    Restore the MFC_CNTL register for the CSA.</span>
<span class="cm">	 */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">mfc_control_RW</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">mfc_control_RW</span><span class="p">);</span>
	<span class="n">eieio</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * The queue is put back into the same state that was evident prior to</span>
<span class="cm">	 * the context switch. The suspend flag is added to the saved state in</span>
<span class="cm">	 * the csa, if the operational state was suspending or suspended. In</span>
<span class="cm">	 * this case, the code that suspended the mfc is responsible for</span>
<span class="cm">	 * continuing it. Note that SPE faults do not change the operational</span>
<span class="cm">	 * state of the spu.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enable_user_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restore, Step 73:</span>
<span class="cm">	 *     Enable user-space access (if provided) to this</span>
<span class="cm">	 *     SPU by mapping the virtual pages assigned to</span>
<span class="cm">	 *     the SPU memory-mapped I/O (MMIO) for problem</span>
<span class="cm">	 *     state. TBD.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reset_switch_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restore, Step 74:</span>
<span class="cm">	 *     Reset the &quot;context switch active&quot; flag.</span>
<span class="cm">	 *     Not performed by this implementation.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reenable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Restore, Step 75:</span>
<span class="cm">	 *     Re-enable SPU interrupts.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="n">spu_int_mask_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">int_mask_class0_RW</span><span class="p">);</span>
	<span class="n">spu_int_mask_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">int_mask_class1_RW</span><span class="p">);</span>
	<span class="n">spu_int_mask_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">int_mask_class2_RW</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">quiece_spu</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Combined steps 2-18 of SPU context save sequence, which</span>
<span class="cm">	 * quiesce the SPU state (disable SPU execution, MFC command</span>
<span class="cm">	 * queues, decrementer, SPU interrupts, etc.).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Returns      0 on success.</span>
<span class="cm">	 *              2 if failed step 2.</span>
<span class="cm">	 *              6 if failed step 6.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_spu_isolate</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* Step 2. */</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">disable_interrupts</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 3. */</span>
	<span class="n">set_watchdog_timer</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 4. */</span>
	<span class="n">inhibit_user_access</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 5. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_spu_isolate</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* Step 6. */</span>
		<span class="k">return</span> <span class="mi">6</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">set_switch_pending</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 7. */</span>
	<span class="n">save_mfc_cntl</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>		<span class="cm">/* Step 8. */</span>
	<span class="n">save_spu_runcntl</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 9. */</span>
	<span class="n">save_mfc_sr1</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 10. */</span>
	<span class="n">save_spu_status</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 11. */</span>
	<span class="n">save_mfc_stopped_status</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>     <span class="cm">/* Step 12. */</span>
	<span class="n">halt_mfc_decr</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 13. */</span>
	<span class="n">save_timebase</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>		<span class="cm">/* Step 14. */</span>
	<span class="n">remove_other_spu_access</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 15. */</span>
	<span class="n">do_mfc_mssync</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 16. */</span>
	<span class="n">issue_mfc_tlbie</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 17. */</span>
	<span class="n">handle_pending_interrupts</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 18. */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">save_csa</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Combine steps 19-44 of SPU context save sequence, which</span>
<span class="cm">	 * save regions of the privileged &amp; problem state areas.</span>
<span class="cm">	 */</span>

	<span class="n">save_mfc_queues</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 19. */</span>
	<span class="n">save_ppu_querymask</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 20. */</span>
	<span class="n">save_ppu_querytype</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 21. */</span>
	<span class="n">save_ppu_tagstatus</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>  <span class="cm">/* NEW.     */</span>
	<span class="n">save_mfc_csr_tsq</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 22. */</span>
	<span class="n">save_mfc_csr_cmd</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 23. */</span>
	<span class="n">save_mfc_csr_ato</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 24. */</span>
	<span class="n">save_mfc_tclass_id</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 25. */</span>
	<span class="n">set_mfc_tclass_id</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 26. */</span>
	<span class="n">save_mfc_cmd</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 26a - moved from 44. */</span>
	<span class="n">purge_mfc_queue</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 27. */</span>
	<span class="n">wait_purge_complete</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 28. */</span>
	<span class="n">setup_mfc_sr1</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 30. */</span>
	<span class="n">save_spu_npc</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 31. */</span>
	<span class="n">save_spu_privcntl</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 32. */</span>
	<span class="n">reset_spu_privcntl</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 33. */</span>
	<span class="n">save_spu_lslr</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 34. */</span>
	<span class="n">reset_spu_lslr</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 35. */</span>
	<span class="n">save_spu_cfg</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 36. */</span>
	<span class="n">save_pm_trace</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 37. */</span>
	<span class="n">save_mfc_rag</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 38. */</span>
	<span class="n">save_ppu_mb_stat</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 39. */</span>
	<span class="n">save_ppu_mb</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 40. */</span>
	<span class="n">save_ppuint_mb</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 41. */</span>
	<span class="n">save_ch_part1</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 42. */</span>
	<span class="n">save_spu_mb</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 43. */</span>
	<span class="n">reset_ch</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 45. */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">save_lscsa</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Perform steps 46-57 of SPU context save sequence,</span>
<span class="cm">	 * which save regions of the local store and register</span>
<span class="cm">	 * file.</span>
<span class="cm">	 */</span>

	<span class="n">resume_mfc_queue</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 46. */</span>
	<span class="cm">/* Step 47. */</span>
	<span class="n">setup_mfc_slbs</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">,</span> <span class="n">spu_save_code</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">spu_save_code</span><span class="p">));</span>
	<span class="n">set_switch_active</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 48. */</span>
	<span class="n">enable_interrupts</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 49. */</span>
	<span class="n">save_ls_16kb</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 50. */</span>
	<span class="n">set_spu_npc</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 51. */</span>
	<span class="n">set_signot1</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>		<span class="cm">/* Step 52. */</span>
	<span class="n">set_signot2</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>		<span class="cm">/* Step 53. */</span>
	<span class="n">send_save_code</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 54. */</span>
	<span class="n">set_ppu_querymask</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 55. */</span>
	<span class="n">wait_tag_complete</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 56. */</span>
	<span class="n">wait_spu_stopped</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 57. */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">force_spu_isolate_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_priv2</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">priv2</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">;</span>

	<span class="cm">/* Stop SPE execution and wait for completion. */</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_runcntl_RW</span><span class="p">,</span> <span class="n">SPU_RUNCNTL_STOP</span><span class="p">);</span>
	<span class="n">iobarrier_rw</span><span class="p">();</span>
	<span class="n">POLL_WHILE_TRUE</span><span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SPU_STATUS_RUNNING</span><span class="p">);</span>

	<span class="cm">/* Restart SPE master runcntl. */</span>
	<span class="n">spu_mfc_sr1_set</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">MFC_STATE1_MASTER_RUN_CONTROL_MASK</span><span class="p">);</span>
	<span class="n">iobarrier_w</span><span class="p">();</span>

	<span class="cm">/* Initiate isolate exit request and wait for completion. */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_privcntl_RW</span><span class="p">,</span> <span class="mi">4LL</span><span class="p">);</span>
	<span class="n">iobarrier_w</span><span class="p">();</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_runcntl_RW</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">iobarrier_rw</span><span class="p">();</span>
	<span class="n">POLL_WHILE_FALSE</span><span class="p">((</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span>
				<span class="o">&amp;</span> <span class="n">SPU_STATUS_STOPPED_BY_STOP</span><span class="p">));</span>

	<span class="cm">/* Reset load request to normal. */</span>
	<span class="n">out_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv2</span><span class="o">-&gt;</span><span class="n">spu_privcntl_RW</span><span class="p">,</span> <span class="n">SPU_PRIVCNT_LOAD_REQUEST_NORMAL</span><span class="p">);</span>
	<span class="n">iobarrier_w</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * stop_spu_isolate</span>
<span class="cm"> *	Check SPU run-control state and force isolated</span>
<span class="cm"> *	exit function as necessary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">stop_spu_isolate</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_problem</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">prob</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">problem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prob</span><span class="o">-&gt;</span><span class="n">spu_status_R</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SPU_STATUS_ISOLATED_STATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The SPU is in isolated state; the only way</span>
<span class="cm">		 * to get it out is to perform an isolated</span>
<span class="cm">		 * exit (clean) operation.</span>
<span class="cm">		 */</span>
		<span class="n">force_spu_isolate_exit</span><span class="p">(</span><span class="n">spu</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">harvest</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Perform steps 2-25 of SPU context restore sequence,</span>
<span class="cm">	 * which resets an SPU either after a failed save, or</span>
<span class="cm">	 * when using SPU for first time.</span>
<span class="cm">	 */</span>

	<span class="n">disable_interrupts</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 2.  */</span>
	<span class="n">inhibit_user_access</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 3.  */</span>
	<span class="n">terminate_spu_app</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 4.  */</span>
	<span class="n">set_switch_pending</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 5.  */</span>
	<span class="n">stop_spu_isolate</span><span class="p">(</span><span class="n">spu</span><span class="p">);</span>			<span class="cm">/* NEW.     */</span>
	<span class="n">remove_other_spu_access</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 6.  */</span>
	<span class="n">suspend_mfc_and_halt_decr</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 7.  */</span>
	<span class="n">wait_suspend_mfc_complete</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 8.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">suspend_spe</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">))</span>	        <span class="cm">/* Step 9.  */</span>
		<span class="n">clear_spu_status</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 10. */</span>
	<span class="n">do_mfc_mssync</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 11. */</span>
	<span class="n">issue_mfc_tlbie</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 12. */</span>
	<span class="n">handle_pending_interrupts</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 13. */</span>
	<span class="n">purge_mfc_queue</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 14. */</span>
	<span class="n">wait_purge_complete</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 15. */</span>
	<span class="n">reset_spu_privcntl</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 16. */</span>
	<span class="n">reset_spu_lslr</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>              <span class="cm">/* Step 17. */</span>
	<span class="n">setup_mfc_sr1</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 18. */</span>
	<span class="n">spu_invalidate_slbs</span><span class="p">(</span><span class="n">spu</span><span class="p">);</span>		<span class="cm">/* Step 19. */</span>
	<span class="n">reset_ch_part1</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 20. */</span>
	<span class="n">reset_ch_part2</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 21. */</span>
	<span class="n">enable_interrupts</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 22. */</span>
	<span class="n">set_switch_active</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 23. */</span>
	<span class="n">set_mfc_tclass_id</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 24. */</span>
	<span class="n">resume_mfc_queue</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 25. */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">restore_lscsa</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Perform steps 26-40 of SPU context restore sequence,</span>
<span class="cm">	 * which restores regions of the local store and register</span>
<span class="cm">	 * file.</span>
<span class="cm">	 */</span>

	<span class="n">set_watchdog_timer</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 26. */</span>
	<span class="n">setup_spu_status_part1</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 27. */</span>
	<span class="n">setup_spu_status_part2</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 28. */</span>
	<span class="n">restore_mfc_rag</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 29. */</span>
	<span class="cm">/* Step 30. */</span>
	<span class="n">setup_mfc_slbs</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">,</span> <span class="n">spu_restore_code</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">spu_restore_code</span><span class="p">));</span>
	<span class="n">set_spu_npc</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	                <span class="cm">/* Step 31. */</span>
	<span class="n">set_signot1</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	                <span class="cm">/* Step 32. */</span>
	<span class="n">set_signot2</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	                <span class="cm">/* Step 33. */</span>
	<span class="n">setup_decr</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	                <span class="cm">/* Step 34. */</span>
	<span class="n">setup_ppu_mb</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 35. */</span>
	<span class="n">setup_ppuint_mb</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 36. */</span>
	<span class="n">send_restore_code</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 37. */</span>
	<span class="n">set_ppu_querymask</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 38. */</span>
	<span class="n">wait_tag_complete</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 39. */</span>
	<span class="n">wait_spu_stopped</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 40. */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">restore_csa</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Combine steps 41-76 of SPU context restore sequence, which</span>
<span class="cm">	 * restore regions of the privileged &amp; problem state areas.</span>
<span class="cm">	 */</span>

	<span class="n">restore_spu_privcntl</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 41. */</span>
	<span class="n">restore_status_part1</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 42. */</span>
	<span class="n">restore_status_part2</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 43. */</span>
	<span class="n">restore_ls_16kb</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 44. */</span>
	<span class="n">wait_tag_complete</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 45. */</span>
	<span class="n">suspend_mfc</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	                <span class="cm">/* Step 46. */</span>
	<span class="n">wait_suspend_mfc_complete</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 47. */</span>
	<span class="n">issue_mfc_tlbie</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 48. */</span>
	<span class="n">clear_interrupts</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 49. */</span>
	<span class="n">restore_mfc_queues</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 50. */</span>
	<span class="n">restore_ppu_querymask</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 51. */</span>
	<span class="n">restore_ppu_querytype</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 52. */</span>
	<span class="n">restore_mfc_csr_tsq</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 53. */</span>
	<span class="n">restore_mfc_csr_cmd</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 54. */</span>
	<span class="n">restore_mfc_csr_ato</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 55. */</span>
	<span class="n">restore_mfc_tclass_id</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 56. */</span>
	<span class="n">set_llr_event</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 57. */</span>
	<span class="n">restore_decr_wrapped</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 58. */</span>
	<span class="n">restore_ch_part1</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 59. */</span>
	<span class="n">restore_ch_part2</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 60. */</span>
	<span class="n">restore_spu_lslr</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 61. */</span>
	<span class="n">restore_spu_cfg</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 62. */</span>
	<span class="n">restore_pm_trace</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 63. */</span>
	<span class="n">restore_spu_npc</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 64. */</span>
	<span class="n">restore_spu_mb</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 65. */</span>
	<span class="n">check_ppu_mb_stat</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 66. */</span>
	<span class="n">check_ppuint_mb_stat</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 67. */</span>
	<span class="n">spu_invalidate_slbs</span><span class="p">(</span><span class="n">spu</span><span class="p">);</span>		<span class="cm">/* Modified Step 68. */</span>
	<span class="n">restore_mfc_sr1</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 69. */</span>
	<span class="n">set_int_route</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>		<span class="cm">/* NEW      */</span>
	<span class="n">restore_other_spu_access</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 70. */</span>
	<span class="n">restore_spu_runcntl</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 71. */</span>
	<span class="n">restore_mfc_cntl</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 72. */</span>
	<span class="n">enable_user_access</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 73. */</span>
	<span class="n">reset_switch_active</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 74. */</span>
	<span class="n">reenable_interrupts</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 75. */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__do_spu_save</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * SPU context save can be broken into three phases:</span>
<span class="cm">	 *</span>
<span class="cm">	 *     (a) quiesce [steps 2-16].</span>
<span class="cm">	 *     (b) save of CSA, performed by PPE [steps 17-42]</span>
<span class="cm">	 *     (c) save of LSCSA, mostly performed by SPU [steps 43-52].</span>
<span class="cm">	 *</span>
<span class="cm">	 * Returns      0 on success.</span>
<span class="cm">	 *              2,6 if failed to quiece SPU</span>
<span class="cm">	 *              53 if SPU-side of save failed.</span>
<span class="cm">	 */</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">quiece_spu</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Steps 2-16. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="mi">2</span>:
	<span class="k">case</span> <span class="mi">6</span>:
		<span class="n">harvest</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">save_csa</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	                <span class="cm">/* Steps 17-43. */</span>
	<span class="n">save_lscsa</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	                <span class="cm">/* Steps 44-53. */</span>
	<span class="k">return</span> <span class="n">check_save_status</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 54.     */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__do_spu_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * SPU context restore can be broken into three phases:</span>
<span class="cm">	 *</span>
<span class="cm">	 *    (a) harvest (or reset) SPU [steps 2-24].</span>
<span class="cm">	 *    (b) restore LSCSA [steps 25-40], mostly performed by SPU.</span>
<span class="cm">	 *    (c) restore CSA [steps 41-76], performed by PPE.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The &#39;harvest&#39; step is not performed here, but rather</span>
<span class="cm">	 * as needed below.</span>
<span class="cm">	 */</span>

	<span class="n">restore_lscsa</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Steps 24-39. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">check_restore_status</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Step 40.     */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="cm">/* Failed. Return now. */</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/* Fall through to next step. */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">restore_csa</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spu_save - SPU context save, with locking.</span>
<span class="cm"> * @prev: pointer to SPU context save area, to be saved.</span>
<span class="cm"> * @spu: pointer to SPU iomem structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Acquire locks, perform the save operation then return.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spu_save</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">acquire_spu_lock</span><span class="p">(</span><span class="n">spu</span><span class="p">);</span>	        <span class="cm">/* Step 1.     */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">__do_spu_save</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>	<span class="cm">/* Steps 2-53. */</span>
	<span class="n">release_spu_lock</span><span class="p">(</span><span class="n">spu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s failed on SPU[%d], rc=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">__func__</span><span class="p">,</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spu_save</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * spu_restore - SPU context restore, with harvest and locking.</span>
<span class="cm"> * @new: pointer to SPU context save area, to be restored.</span>
<span class="cm"> * @spu: pointer to SPU iomem structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Perform harvest + restore, as we may not be coming</span>
<span class="cm"> * from a previous successful save operation, and the</span>
<span class="cm"> * hardware state is unknown.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spu_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">acquire_spu_lock</span><span class="p">(</span><span class="n">spu</span><span class="p">);</span>
	<span class="n">harvest</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">slb_replace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">__do_spu_restore</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>
	<span class="n">release_spu_lock</span><span class="p">(</span><span class="n">spu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s failed on SPU[%d] rc=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spu_restore</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_prob</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">28</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">spu_chnlcnt_RW</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">spu_runcntl_RW</span> <span class="o">=</span> <span class="n">SPU_RUNCNTL_STOP</span><span class="p">;</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">prob</span><span class="p">.</span><span class="n">mb_stat_R</span> <span class="o">=</span> <span class="mh">0x000400</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_priv1</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Enable decode, relocate, tlbie response, master runcntl. */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">mfc_sr1_RW</span> <span class="o">=</span> <span class="n">MFC_STATE1_LOCAL_STORAGE_DECODE_MASK</span> <span class="o">|</span>
	    <span class="n">MFC_STATE1_MASTER_RUN_CONTROL_MASK</span> <span class="o">|</span>
	    <span class="n">MFC_STATE1_PROBLEM_STATE_MASK</span> <span class="o">|</span>
	    <span class="n">MFC_STATE1_RELOCATE_MASK</span> <span class="o">|</span> <span class="n">MFC_STATE1_BUS_TLBIE_MASK</span><span class="p">;</span>

	<span class="cm">/* Enable OS-specific set of interrupts. */</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">int_mask_class0_RW</span> <span class="o">=</span> <span class="n">CLASS0_ENABLE_DMA_ALIGNMENT_INTR</span> <span class="o">|</span>
	    <span class="n">CLASS0_ENABLE_INVALID_DMA_COMMAND_INTR</span> <span class="o">|</span>
	    <span class="n">CLASS0_ENABLE_SPU_ERROR_INTR</span><span class="p">;</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">int_mask_class1_RW</span> <span class="o">=</span> <span class="n">CLASS1_ENABLE_SEGMENT_FAULT_INTR</span> <span class="o">|</span>
	    <span class="n">CLASS1_ENABLE_STORAGE_FAULT_INTR</span><span class="p">;</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv1</span><span class="p">.</span><span class="n">int_mask_class2_RW</span> <span class="o">=</span> <span class="n">CLASS2_ENABLE_SPU_STOP_INTR</span> <span class="o">|</span>
	    <span class="n">CLASS2_ENABLE_SPU_HALT_INTR</span> <span class="o">|</span>
	    <span class="n">CLASS2_ENABLE_SPU_DMA_TAG_GROUP_COMPLETE_INTR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_priv2</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">spu_lslr_RW</span> <span class="o">=</span> <span class="n">LS_ADDR_MASK</span><span class="p">;</span>
	<span class="n">csa</span><span class="o">-&gt;</span><span class="n">priv2</span><span class="p">.</span><span class="n">mfc_control_RW</span> <span class="o">=</span> <span class="n">MFC_CNTL_RESUME_DMA_QUEUE</span> <span class="o">|</span>
	    <span class="n">MFC_CNTL_NORMAL_DMA_QUEUE_OPERATION</span> <span class="o">|</span>
	    <span class="n">MFC_CNTL_DMA_QUEUES_EMPTY_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spu_alloc_csa - allocate and initialize an SPU context save area.</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate and initialize the contents of an SPU context save area.</span>
<span class="cm"> * This includes enabling address translation, interrupt masks, etc.,</span>
<span class="cm"> * as appropriate for the given OS environment.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that storage for the &#39;lscsa&#39; is allocated separately,</span>
<span class="cm"> * as it is by far the largest of the context save regions,</span>
<span class="cm"> * and may need to be pinned or otherwise specially aligned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spu_init_csa</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">csa</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">csa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span><span class="p">));</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">spu_alloc_lscsa</span><span class="p">(</span><span class="n">csa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">csa</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>

	<span class="n">init_prob</span><span class="p">(</span><span class="n">csa</span><span class="p">);</span>
	<span class="n">init_priv1</span><span class="p">(</span><span class="n">csa</span><span class="p">);</span>
	<span class="n">init_priv2</span><span class="p">(</span><span class="n">csa</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">spu_fini_csa</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_state</span> <span class="o">*</span><span class="n">csa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spu_free_lscsa</span><span class="p">(</span><span class="n">csa</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
