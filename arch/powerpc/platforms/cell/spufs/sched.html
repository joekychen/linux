<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › platforms › cell › spufs › sched.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>sched.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* sched.c - SPU scheduler.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) IBM 2005</span>
<span class="cm"> * Author: Mark Nutter &lt;mnutter@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * 2006-03-31	NUMA domains added.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#undef DEBUG</span>

<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/numa.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/pid_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/spu.h&gt;</span>
<span class="cp">#include &lt;asm/spu_csa.h&gt;</span>
<span class="cp">#include &lt;asm/spu_priv1.h&gt;</span>
<span class="cp">#include &quot;spufs.h&quot;</span>
<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &quot;sputrace.h&quot;</span>

<span class="k">struct</span> <span class="n">spu_prio_array</span> <span class="p">{</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">MAX_PRIO</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">runq</span><span class="p">[</span><span class="n">MAX_PRIO</span><span class="p">];</span>
	<span class="n">spinlock_t</span> <span class="n">runq_lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_waiting</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spu_avenrun</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">spu_prio_array</span> <span class="o">*</span><span class="n">spu_prio</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">spusched_task</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">spusched_timer</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">spuloadavg_timer</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Priority of a normal, non-rt, non-niced&#39;d process (aka nice level 0).</span>
<span class="cm"> */</span>
<span class="cp">#define NORMAL_PRIO		120</span>

<span class="cm">/*</span>
<span class="cm"> * Frequency of the spu scheduler tick.  By default we do one SPU scheduler</span>
<span class="cm"> * tick for every 10 CPU scheduler ticks.</span>
<span class="cm"> */</span>
<span class="cp">#define SPUSCHED_TICK		(10)</span>

<span class="cm">/*</span>
<span class="cm"> * These are the &#39;tuning knobs&#39; of the scheduler:</span>
<span class="cm"> *</span>
<span class="cm"> * Minimum timeslice is 5 msecs (or 1 spu scheduler tick, whichever is</span>
<span class="cm"> * larger), default timeslice is 100 msecs, maximum timeslice is 800 msecs.</span>
<span class="cm"> */</span>
<span class="cp">#define MIN_SPU_TIMESLICE	max(5 * HZ / (1000 * SPUSCHED_TICK), 1)</span>
<span class="cp">#define DEF_SPU_TIMESLICE	(100 * HZ / (1000 * SPUSCHED_TICK))</span>

<span class="cp">#define MAX_USER_PRIO		(MAX_PRIO - MAX_RT_PRIO)</span>
<span class="cp">#define SCALE_PRIO(x, prio) \</span>
<span class="cp">	max(x * (MAX_PRIO - prio) / (MAX_USER_PRIO / 2), MIN_SPU_TIMESLICE)</span>

<span class="cm">/*</span>
<span class="cm"> * scale user-nice values [ -20 ... 0 ... 19 ] to time slice values:</span>
<span class="cm"> * [800ms ... 100ms ... 5ms]</span>
<span class="cm"> *</span>
<span class="cm"> * The higher a thread&#39;s priority, the bigger timeslices</span>
<span class="cm"> * it gets during one round of execution. But even the lowest</span>
<span class="cm"> * priority thread gets MIN_TIMESLICE worth of execution time.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">spu_set_timeslice</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="n">NORMAL_PRIO</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">time_slice</span> <span class="o">=</span> <span class="n">SCALE_PRIO</span><span class="p">(</span><span class="n">DEF_SPU_TIMESLICE</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">time_slice</span> <span class="o">=</span> <span class="n">SCALE_PRIO</span><span class="p">(</span><span class="n">DEF_SPU_TIMESLICE</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update scheduling information from the owning thread.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__spu_update_sched_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * assert that the context is not on the runqueue, so it is safe</span>
<span class="cm">	 * to change its scheduling parameters.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * 32-Bit assignments are atomic on powerpc, and we don&#39;t care about</span>
<span class="cm">	 * memory ordering here because retrieving the controlling thread is</span>
<span class="cm">	 * per definition racy.</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We do our own priority calculations, so we normally want</span>
<span class="cm">	 * -&gt;static_prio to start with. Unfortunately this field</span>
<span class="cm">	 * contains junk for threads with a realtime scheduling</span>
<span class="cm">	 * policy so we have to look at -&gt;prio in this case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt_prio</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">static_prio</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * TO DO: the context may be loaded, so we may need to activate</span>
<span class="cm">	 * it again on a different node. But it shouldn&#39;t hurt anything</span>
<span class="cm">	 * to update its parameters, because we know that the scheduler</span>
<span class="cm">	 * is not actively looking at this field, since it is not on the</span>
<span class="cm">	 * runqueue. The context will be rescheduled on the proper node</span>
<span class="cm">	 * if it is timesliced or preempted.</span>
<span class="cm">	 */</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">tsk_cpus_allowed</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>

	<span class="cm">/* Save the current cpu id for spu interrupt routing. */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_ran</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">spu_update_sched_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SPU_STATE_RUNNABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Take list_mutex to sync with find_victim().</span>
<span class="cm">		 */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
		<span class="n">__spu_update_sched_info</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__spu_update_sched_info</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__node_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_cpus_node</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span> <span class="o">=</span> <span class="n">cpumask_of_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">node_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq_lock</span><span class="p">);</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">__node_allowed</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">do_notify_spus_active</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wake up the active spu_contexts.</span>
<span class="cm">	 *</span>
<span class="cm">	 * When the awakened processes see their &quot;notify_active&quot; flag is set,</span>
<span class="cm">	 * they will call spu_switch_notify().</span>
<span class="cm">	 */</span>
	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">spus</span><span class="p">,</span> <span class="n">cbe_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">alloc_state</span> <span class="o">!=</span> <span class="n">SPU_FREE</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">SPU_SCHED_NOTIFY_ACTIVE</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sched_flags</span><span class="p">);</span>
				<span class="n">mb</span><span class="p">();</span>
				<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stop_wq</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spu_bind_context - bind spu context to physical spu</span>
<span class="cm"> * @spu:	physical spu to bind to</span>
<span class="cm"> * @ctx:	context to bind</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">spu_bind_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spu_context_trace</span><span class="p">(</span><span class="n">spu_bind_context__enter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>

	<span class="n">spuctx_switch_state</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SPU_UTIL_SYSTEM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPU_CREATE_NOSCHED</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">].</span><span class="n">reserved_spus</span><span class="p">);</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">slb_flt_base</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">slb_flt</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">class2_intr_base</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">class2_intr</span><span class="p">;</span>

	<span class="n">spu_associate_mm</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span> <span class="o">=</span> <span class="n">spu</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spu_hw_ops</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">tgid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">ibox_callback</span> <span class="o">=</span> <span class="n">spufs_ibox_callback</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">wbox_callback</span> <span class="o">=</span> <span class="n">spufs_wbox_callback</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">stop_callback</span> <span class="o">=</span> <span class="n">spufs_stop_callback</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">mfc_callback</span> <span class="o">=</span> <span class="n">spufs_mfc_callback</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>

	<span class="n">spu_unmap_mappings</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="n">spu_switch_log_notify</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">SWITCH_LOG_START</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spu_restore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">spu_switch_notify</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SPU_STATE_RUNNABLE</span><span class="p">;</span>

	<span class="n">spuctx_switch_state</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SPU_UTIL_USER</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Must be used with the list_mutex held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sched_spu</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">));</span>

	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPU_CREATE_NOSCHED</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">aff_merge_remaining_ctxs</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_gang</span> <span class="o">*</span><span class="n">gang</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_list_head</span><span class="p">,</span> <span class="n">aff_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">aff_list</span><span class="p">))</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">aff_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_list_head</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_flags</span> <span class="o">|=</span> <span class="n">AFF_MERGED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">aff_set_offsets</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_gang</span> <span class="o">*</span><span class="n">gang</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_ref_ctx</span><span class="o">-&gt;</span><span class="n">aff_list</span><span class="p">,</span>
								<span class="n">aff_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">aff_list</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_list_head</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">aff_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_ref_ctx</span><span class="o">-&gt;</span><span class="n">aff_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">aff_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">aff_list</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_list_head</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">aff_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_flags</span> <span class="o">|=</span> <span class="n">AFF_OFFSETS_SET</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="nf">aff_ref_location</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mem_aff</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">group_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lowest_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * TODO: A better algorithm could be used to find a good spu to be</span>
<span class="cm">	 *       used as reference location for the ctxs chain.</span>
<span class="cm">	 */</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">());</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">node</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * &quot;available_spus&quot; counts how many spus are not potentially</span>
<span class="cm">		 * going to be used by other affinity gangs whose reference</span>
<span class="cm">		 * context is already in place. Although this code seeks to</span>
<span class="cm">		 * avoid having affinity gangs with a summed amount of</span>
<span class="cm">		 * contexts bigger than the amount of spus in the node,</span>
<span class="cm">		 * this may happen sporadically. In this case, available_spus</span>
<span class="cm">		 * becomes negative, which is harmless.</span>
<span class="cm">		 */</span>
		<span class="kt">int</span> <span class="n">available_spus</span><span class="p">;</span>

		<span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span> <span class="o">?</span> <span class="n">node</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_allowed</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">available_spus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">spus</span><span class="p">,</span> <span class="n">cbe_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">&amp;&amp;</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">aff_offset</span>
					<span class="o">&amp;&amp;</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_ref_spu</span><span class="p">)</span>
				<span class="n">available_spus</span> <span class="o">-=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">contexts</span><span class="p">;</span>
			<span class="n">available_spus</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">available_spus</span> <span class="o">&lt;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">contexts</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">spus</span><span class="p">,</span> <span class="n">cbe_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">mem_aff</span> <span class="o">||</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">has_mem_affinity</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
							<span class="n">sched_spu</span><span class="p">(</span><span class="n">spu</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">spu</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">aff_set_ref_point_location</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_gang</span> <span class="o">*</span><span class="n">gang</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mem_aff</span><span class="p">,</span> <span class="n">gs</span><span class="p">,</span> <span class="n">lowest_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">mem_aff</span> <span class="o">=</span> <span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_ref_ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPU_CREATE_AFFINITY_MEM</span><span class="p">;</span>
	<span class="n">lowest_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">gs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_list_head</span><span class="p">,</span> <span class="n">aff_list</span><span class="p">)</span>
		<span class="n">gs</span><span class="o">++</span><span class="p">;</span>

	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_ref_ctx</span><span class="o">-&gt;</span><span class="n">aff_list</span><span class="p">,</span>
								<span class="n">aff_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">aff_list</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_list_head</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">lowest_offset</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">aff_offset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_ref_spu</span> <span class="o">=</span> <span class="n">aff_ref_location</span><span class="p">(</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_ref_ctx</span><span class="p">,</span> <span class="n">mem_aff</span><span class="p">,</span> <span class="n">gs</span><span class="p">,</span>
							<span class="n">lowest_offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="nf">ctx_location</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">ref</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">;</span>

	<span class="n">spu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">aff_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">aff_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">!=</span> <span class="n">node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sched_spu</span><span class="p">(</span><span class="n">spu</span><span class="p">))</span>
				<span class="n">offset</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">aff_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">aff_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">!=</span> <span class="n">node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sched_spu</span><span class="p">(</span><span class="n">spu</span><span class="p">))</span>
				<span class="n">offset</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">spu</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * affinity_check is called each time a context is going to be scheduled.</span>
<span class="cm"> * It returns the spu ptr on which the context must run.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">has_affinity</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_gang</span> <span class="o">*</span><span class="n">gang</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">aff_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_sched_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_ref_spu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_ref_spu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_flags</span> <span class="o">&amp;</span> <span class="n">AFF_MERGED</span><span class="p">))</span>
			<span class="n">aff_merge_remaining_ctxs</span><span class="p">(</span><span class="n">gang</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_flags</span> <span class="o">&amp;</span> <span class="n">AFF_OFFSETS_SET</span><span class="p">))</span>
			<span class="n">aff_set_offsets</span><span class="p">(</span><span class="n">gang</span><span class="p">);</span>
		<span class="n">aff_set_ref_point_location</span><span class="p">(</span><span class="n">gang</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_ref_spu</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spu_unbind_context - unbind spu context from physical spu</span>
<span class="cm"> * @spu:	physical spu to unbind from</span>
<span class="cm"> * @ctx:	context to unbind</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">spu_unbind_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">spu_context_trace</span><span class="p">(</span><span class="n">spu_unbind_context__enter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>

	<span class="n">spuctx_switch_state</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SPU_UTIL_SYSTEM</span><span class="p">);</span>

 	<span class="k">if</span> <span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPU_CREATE_NOSCHED</span><span class="p">)</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">].</span><span class="n">reserved_spus</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * If ctx-&gt;gang-&gt;aff_sched_count is positive, SPU affinity is</span>
<span class="cm">		 * being considered in this gang. Using atomic_dec_if_positive</span>
<span class="cm">		 * allow us to skip an explicit check for affinity in this gang</span>
<span class="cm">		 */</span>
		<span class="n">atomic_dec_if_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_sched_count</span><span class="p">);</span>

	<span class="n">spu_switch_notify</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spu_unmap_mappings</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">spu_save</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">csa</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>
	<span class="n">spu_switch_log_notify</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">SWITCH_LOG_STOP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SPU_STATE_SAVED</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">ibox_callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">wbox_callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">stop_callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">mfc_callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">tgid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spu_backing_ops</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">register_lock</span><span class="p">);</span>

	<span class="n">spu_associate_mm</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">slb_flt</span> <span class="o">+=</span>
		<span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">slb_flt</span> <span class="o">-</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">slb_flt_base</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">class2_intr</span> <span class="o">+=</span>
		<span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">class2_intr</span> <span class="o">-</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">class2_intr_base</span><span class="p">);</span>

	<span class="cm">/* This maps the underlying spu state to idle */</span>
	<span class="n">spuctx_switch_state</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SPU_UTIL_IDLE_LOADED</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spu_stopped</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">))</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stop_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spu_add_to_rq - add a context to the runqueue</span>
<span class="cm"> * @ctx:       context to add</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__spu_add_to_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Unfortunately this code path can be called from multiple threads</span>
<span class="cm">	 * on behalf of a single context due to the way the problem state</span>
<span class="cm">	 * mmap support works.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Fortunately we need to wake up all these threads at the same time</span>
<span class="cm">	 * and can simply skip the runqueue addition for every but the first</span>
<span class="cm">	 * thread getting into this codepath.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It&#39;s still quite hacky, and long-term we should proxy all other</span>
<span class="cm">	 * threads through the owner thread so that spu_run is in control</span>
<span class="cm">	 * of all the scheduling activity for a given context.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq</span><span class="p">[</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">]);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">,</span> <span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">nr_waiting</span><span class="o">++</span><span class="p">)</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spusched_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">SPUSCHED_TICK</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">spu_add_to_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq_lock</span><span class="p">);</span>
	<span class="n">__spu_add_to_rq</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__spu_del_from_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">prio</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">nr_waiting</span><span class="p">)</span>
			<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spusched_timer</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq</span><span class="p">[</span><span class="n">prio</span><span class="p">]))</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">prio</span><span class="p">,</span> <span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">spu_del_from_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq_lock</span><span class="p">);</span>
	<span class="n">__spu_del_from_rq</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">spu_prio_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The caller must explicitly wait for a context to be loaded</span>
<span class="cm">	 * if the nosched flag is set.  If NOSCHED is not set, the caller</span>
<span class="cm">	 * queues the context and waits for an spu event or error.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPU_CREATE_NOSCHED</span><span class="p">));</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq_lock</span><span class="p">);</span>
	<span class="n">prepare_to_wait_exclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stop_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__spu_add_to_rq</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq_lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq_lock</span><span class="p">);</span>
		<span class="n">__spu_del_from_rq</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq_lock</span><span class="p">);</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stop_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="nf">spu_get_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span> <span class="o">*</span><span class="n">aff_ref_spu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">spu_context_nospu_trace</span><span class="p">(</span><span class="n">spu_get_idle__enter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">has_affinity</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">aff_ref_spu</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_ref_spu</span><span class="p">;</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_sched_count</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_mutex</span><span class="p">);</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">aff_ref_spu</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>

			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
			<span class="n">spu</span> <span class="o">=</span> <span class="n">ctx_location</span><span class="p">(</span><span class="n">aff_ref_spu</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">aff_offset</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">spu</span> <span class="o">&amp;&amp;</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">alloc_state</span> <span class="o">==</span> <span class="n">SPU_FREE</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>

			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_sched_count</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">not_found</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gang</span><span class="o">-&gt;</span><span class="n">aff_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">());</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">node</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span> <span class="o">?</span> <span class="n">node</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_allowed</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">spus</span><span class="p">,</span> <span class="n">cbe_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">alloc_state</span> <span class="o">==</span> <span class="n">SPU_FREE</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
	<span class="p">}</span>

 <span class="nl">not_found:</span>
	<span class="n">spu_context_nospu_trace</span><span class="p">(</span><span class="n">spu_get_idle__not_found</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

 <span class="nl">found:</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">alloc_state</span> <span class="o">=</span> <span class="n">SPU_USED</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
	<span class="n">spu_context_trace</span><span class="p">(</span><span class="n">spu_get_idle__found</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>
	<span class="n">spu_init_channels</span><span class="p">(</span><span class="n">spu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">spu</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_victim - find a lower priority context to preempt</span>
<span class="cm"> * @ctx:	canidate context for running</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the freed physical spu to run the new context on.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="nf">find_victim</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">victim</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">spu_context_nospu_trace</span><span class="p">(</span><span class="n">spu_find_victim__enter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look for a possible preemption candidate on the local node first.</span>
<span class="cm">	 * If there is no candidate look at the other nodes.  This isn&#39;t</span>
<span class="cm">	 * exactly fair, but so far the whole spu scheduler tries to keep</span>
<span class="cm">	 * a strong node affinity.  We might want to fine-tune this in</span>
<span class="cm">	 * the future.</span>
<span class="cm">	 */</span>
 <span class="nl">restart:</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">());</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">node</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span> <span class="o">?</span> <span class="n">node</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_allowed</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">spus</span><span class="p">,</span> <span class="n">cbe_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&gt;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPU_CREATE_NOSCHED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">victim</span> <span class="o">||</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&gt;</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">victim</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">victim</span><span class="p">)</span>
			<span class="n">get_spu_context</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">victim</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This nests ctx-&gt;state_mutex, but we always lock</span>
<span class="cm">			 * higher priority contexts before lower priority</span>
<span class="cm">			 * ones, so this is safe until we introduce</span>
<span class="cm">			 * priority inheritance schemes.</span>
<span class="cm">			 *</span>
<span class="cm">			 * XXX if the highest priority context is locked,</span>
<span class="cm">			 * this can loop a long time.  Might be better to</span>
<span class="cm">			 * look at another context or give up after X retries.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">put_spu_context</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
				<span class="n">victim</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">spu</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">spu</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spu</span> <span class="o">||</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&lt;=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * This race can happen because we&#39;ve dropped</span>
<span class="cm">				 * the active list mutex.  Not a problem, just</span>
<span class="cm">				 * restart the search.</span>
<span class="cm">				 */</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
				<span class="n">put_spu_context</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
				<span class="n">victim</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">spu_context_trace</span><span class="p">(</span><span class="n">__spu_deactivate__unload</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>

			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
			<span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">nr_active</span><span class="o">--</span><span class="p">;</span>
			<span class="n">spu_unbind_context</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">victim</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>

			<span class="n">victim</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">invol_ctx_switch</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spu</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">invol_ctx_switch</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SPU_SCHED_SPU_RUN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">sched_flags</span><span class="p">))</span>
				<span class="n">spu_add_to_rq</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>

			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
			<span class="n">put_spu_context</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">spu</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__spu_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">success</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spu_set_timeslice</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spu_bind_context</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">nr_active</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spu</span><span class="o">-&gt;</span><span class="n">alloc_state</span> <span class="o">=</span> <span class="n">SPU_USED</span><span class="p">;</span>
		<span class="n">success</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">run_wq</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">spu_add_to_rq</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">spu_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* not a candidate for interruptible because it&#39;s called either</span>
<span class="cm">	   from the scheduler thread or from spu_deactivate */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SPU_STATE_SAVED</span><span class="p">)</span>
		<span class="n">__spu_schedule</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spu_unschedule - remove a context from a spu, and possibly release it.</span>
<span class="cm"> * @spu:	The SPU to unschedule from</span>
<span class="cm"> * @ctx:	The context currently scheduled on the SPU</span>
<span class="cm"> * @free_spu	Whether to free the SPU for other contexts</span>
<span class="cm"> *</span>
<span class="cm"> * Unbinds the context @ctx from the SPU @spu. If @free_spu is non-zero, the</span>
<span class="cm"> * SPU is made available for other contexts (ie, may be returned by</span>
<span class="cm"> * spu_get_idle). If this is zero, the caller is expected to schedule another</span>
<span class="cm"> * context to this spu.</span>
<span class="cm"> *</span>
<span class="cm"> * Should be called with ctx-&gt;state_mutex held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">spu_unschedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">free_spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
	<span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">nr_active</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free_spu</span><span class="p">)</span>
		<span class="n">spu</span><span class="o">-&gt;</span><span class="n">alloc_state</span> <span class="o">=</span> <span class="n">SPU_FREE</span><span class="p">;</span>
	<span class="n">spu_unbind_context</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">invol_ctx_switch</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spu</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">invol_ctx_switch</span><span class="o">++</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spu_activate - find a free spu for a context and execute it</span>
<span class="cm"> * @ctx:	spu context to schedule</span>
<span class="cm"> * @flags:	flags (currently ignored)</span>
<span class="cm"> *</span>
<span class="cm"> * Tries to find a free spu to run @ctx.  If no free spu is available</span>
<span class="cm"> * add the context to the runqueue so it gets woken up once an spu</span>
<span class="cm"> * is available.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spu_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are multiple threads waiting for a single context</span>
<span class="cm">	 * only one actually binds the context while the others will</span>
<span class="cm">	 * only be able to acquire the state_mutex once the context</span>
<span class="cm">	 * already is in runnable state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">spu_activate_top:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>

	<span class="n">spu</span> <span class="o">=</span> <span class="n">spu_get_idle</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this is a realtime thread we try to get it running by</span>
<span class="cm">	 * preempting a lower priority thread.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spu</span> <span class="o">&amp;&amp;</span> <span class="n">rt_prio</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span>
		<span class="n">spu</span> <span class="o">=</span> <span class="n">find_victim</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spu</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">runcntl</span><span class="p">;</span>

		<span class="n">runcntl</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">runcntl_read</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">__spu_schedule</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">runcntl</span> <span class="o">&amp;</span> <span class="n">SPU_RUNCNTL_RUNNABLE</span><span class="p">)</span>
			<span class="n">spuctx_switch_state</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SPU_UTIL_USER</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPU_CREATE_NOSCHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spu_prio_wait</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">spu_activate_top</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spu_add_to_rq</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * grab_runnable_context - try to find a runnable context</span>
<span class="cm"> *</span>
<span class="cm"> * Remove the highest priority context on the runqueue and return it</span>
<span class="cm"> * to the caller.  Returns %NULL if no runnable context was found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="nf">grab_runnable_context</span><span class="p">(</span><span class="kt">int</span> <span class="n">prio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">best</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq_lock</span><span class="p">);</span>
	<span class="n">best</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">best</span> <span class="o">&lt;</span> <span class="n">prio</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq</span><span class="p">[</span><span class="n">best</span><span class="p">];</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">rq</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* XXX(hch): check for affinity here as well */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__node_allowed</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">__spu_del_from_rq</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">best</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
 <span class="nl">found:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__spu_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_prio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">grab_runnable_context</span><span class="p">(</span><span class="n">max_prio</span><span class="p">,</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span> <span class="o">||</span> <span class="n">force</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spu_unschedule</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">new</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPU_CREATE_NOSCHED</span><span class="p">)</span>
					<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">stop_wq</span><span class="p">);</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
					<span class="n">spu_schedule</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
					<span class="cm">/* this one can&#39;t easily be made</span>
<span class="cm">					   interruptible */</span>
					<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">new</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spu_deactivate - unbind a context from it&#39;s physical spu</span>
<span class="cm"> * @ctx:	spu context to unbind</span>
<span class="cm"> *</span>
<span class="cm"> * Unbind @ctx from the physical spu it is running on and schedule</span>
<span class="cm"> * the highest priority context to run on the freed physical spu.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">spu_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spu_context_nospu_trace</span><span class="p">(</span><span class="n">spu_deactivate__enter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">__spu_deactivate</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MAX_PRIO</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spu_yield -	yield a physical spu if others are waiting</span>
<span class="cm"> * @ctx:	spu context to yield</span>
<span class="cm"> *</span>
<span class="cm"> * Check if there is a higher priority context waiting and if yes</span>
<span class="cm"> * unbind @ctx from the physical spu and schedule the highest</span>
<span class="cm"> * priority context to run on the freed physical spu instead.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">spu_yield</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spu_context_nospu_trace</span><span class="p">(</span><span class="n">spu_yield__enter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPU_CREATE_NOSCHED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
		<span class="n">__spu_deactivate</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAX_PRIO</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">spusched_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spu_acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>	<span class="cm">/* a kernel thread never has signals pending */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SPU_STATE_RUNNABLE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPU_CREATE_NOSCHED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">==</span> <span class="n">SCHED_FIFO</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">time_slice</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">SPU_SCHED_SPU_RUN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sched_flags</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">spu</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span><span class="p">;</span>

	<span class="n">spu_context_trace</span><span class="p">(</span><span class="n">spusched_tick__preempt</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">grab_runnable_context</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spu_unschedule</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SPU_SCHED_SPU_RUN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sched_flags</span><span class="p">))</span>
			<span class="n">spu_add_to_rq</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spu_context_nospu_trace</span><span class="p">(</span><span class="n">spusched_tick__newslice</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">time_slice</span><span class="p">)</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">time_slice</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">spu_release</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span>
		<span class="n">spu_schedule</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * count_active_contexts - count nr of active tasks</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of tasks currently running or waiting to run.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we don&#39;t take runq_lock / list_mutex here.  Reading</span>
<span class="cm"> * a single 32bit value is atomic on powerpc, and we don&#39;t care</span>
<span class="cm"> * about memory ordering issues here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">count_active_contexts</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">node</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="n">node</span><span class="o">++</span><span class="p">)</span>
		<span class="n">nr_active</span> <span class="o">+=</span> <span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">nr_active</span><span class="p">;</span>
	<span class="n">nr_active</span> <span class="o">+=</span> <span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">nr_waiting</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nr_active</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spu_calc_load - update the avenrun load estimates.</span>
<span class="cm"> *</span>
<span class="cm"> * No locking against reading these values from userspace, as for</span>
<span class="cm"> * the CPU loadavg code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">spu_calc_load</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active_tasks</span><span class="p">;</span> <span class="cm">/* fixed-point */</span>

	<span class="n">active_tasks</span> <span class="o">=</span> <span class="n">count_active_contexts</span><span class="p">()</span> <span class="o">*</span> <span class="n">FIXED_1</span><span class="p">;</span>
	<span class="n">CALC_LOAD</span><span class="p">(</span><span class="n">spu_avenrun</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">EXP_1</span><span class="p">,</span> <span class="n">active_tasks</span><span class="p">);</span>
	<span class="n">CALC_LOAD</span><span class="p">(</span><span class="n">spu_avenrun</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">EXP_5</span><span class="p">,</span> <span class="n">active_tasks</span><span class="p">);</span>
	<span class="n">CALC_LOAD</span><span class="p">(</span><span class="n">spu_avenrun</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">EXP_15</span><span class="p">,</span> <span class="n">active_tasks</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">spusched_wake</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spusched_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">SPUSCHED_TICK</span><span class="p">);</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">spusched_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">spuloadavg_wake</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spuloadavg_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">LOAD_FREQ</span><span class="p">);</span>
	<span class="n">spu_calc_load</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spusched_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">node</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="n">node</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">mtx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">;</span>

			<span class="n">mutex_lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">spus</span><span class="p">,</span>
					<span class="n">cbe_list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">get_spu_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
					<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
					<span class="n">spusched_tick</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
					<span class="n">mutex_lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
					<span class="n">put_spu_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">spuctx_switch_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">spu_utilization_state</span> <span class="n">new_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">curtime</span><span class="p">;</span>
	<span class="kt">signed</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">spu_utilization_state</span> <span class="n">old_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">ktime_get_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
	<span class="n">curtime</span> <span class="o">=</span> <span class="n">timespec_to_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">curtime</span> <span class="o">-</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tstamp</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">spu</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">spu</span><span class="p">;</span>
	<span class="n">old_state</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">util_state</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">util_state</span> <span class="o">=</span> <span class="n">new_state</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tstamp</span> <span class="o">=</span> <span class="n">curtime</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the physical SPU utilization statistics.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">times</span><span class="p">[</span><span class="n">old_state</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="n">spu</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">times</span><span class="p">[</span><span class="n">old_state</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="n">spu</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">util_state</span> <span class="o">=</span> <span class="n">new_state</span><span class="p">;</span>
		<span class="n">spu</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tstamp</span> <span class="o">=</span> <span class="n">curtime</span><span class="p">;</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_state</span> <span class="o">==</span> <span class="n">SPU_UTIL_USER</span><span class="p">)</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">busy_spus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="o">==</span> <span class="n">SPU_UTIL_USER</span><span class="p">)</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">busy_spus</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define LOAD_INT(x) ((x) &gt;&gt; FSHIFT)</span>
<span class="cp">#define LOAD_FRAC(x) LOAD_INT(((x) &amp; (FIXED_1-1)) * 100)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">show_spu_loadavg</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>

	<span class="n">a</span> <span class="o">=</span> <span class="n">spu_avenrun</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">FIXED_1</span><span class="o">/</span><span class="mi">200</span><span class="p">);</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">spu_avenrun</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">FIXED_1</span><span class="o">/</span><span class="mi">200</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">spu_avenrun</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">FIXED_1</span><span class="o">/</span><span class="mi">200</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note that last_pid doesn&#39;t really make much sense for the</span>
<span class="cm">	 * SPU loadavg (it even seems very odd on the CPU side...),</span>
<span class="cm">	 * but we include it here to have a 100% compatible interface.</span>
<span class="cm">	 */</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%d.%02d %d.%02d %d.%02d %ld/%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">LOAD_INT</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">LOAD_FRAC</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
		<span class="n">LOAD_INT</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">LOAD_FRAC</span><span class="p">(</span><span class="n">b</span><span class="p">),</span>
		<span class="n">LOAD_INT</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">LOAD_FRAC</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
		<span class="n">count_active_contexts</span><span class="p">(),</span>
		<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_spu_contexts</span><span class="p">),</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">pid_ns</span><span class="o">-&gt;</span><span class="n">last_pid</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spu_loadavg_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">show_spu_loadavg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">spu_loadavg_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">spu_loadavg_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">spu_sched_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spu_prio</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu_prio_array</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spu_prio</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_PRIO</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_prio</span><span class="o">-&gt;</span><span class="n">runq_lock</span><span class="p">);</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spusched_timer</span><span class="p">,</span> <span class="n">spusched_wake</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spuloadavg_timer</span><span class="p">,</span> <span class="n">spuloadavg_wake</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">spusched_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">spusched_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;spusched&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">spusched_task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">spusched_task</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_spu_prio</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spuloadavg_timer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;spu_loadavg&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spu_loadavg_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_stop_kthread</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;spusched: tick: %d, min ticks: %d, default ticks: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">SPUSCHED_TICK</span><span class="p">,</span> <span class="n">MIN_SPU_TIMESLICE</span><span class="p">,</span> <span class="n">DEF_SPU_TIMESLICE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_stop_kthread:</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">spusched_task</span><span class="p">);</span>
 <span class="nl">out_free_spu_prio:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">spu_prio</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">spu_sched_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;spu_loadavg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spusched_timer</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spuloadavg_timer</span><span class="p">);</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">spusched_task</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">node</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="n">node</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">spus</span><span class="p">,</span> <span class="n">cbe_list</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">alloc_state</span> <span class="o">!=</span> <span class="n">SPU_FREE</span><span class="p">)</span>
				<span class="n">spu</span><span class="o">-&gt;</span><span class="n">alloc_state</span> <span class="o">=</span> <span class="n">SPU_FREE</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cbe_spu_info</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">list_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">spu_prio</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
