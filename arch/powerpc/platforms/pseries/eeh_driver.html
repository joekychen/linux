<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › platforms › pseries › eeh_driver.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>eeh_driver.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * PCI Error Recovery Driver for RPA-compliant PPC64 platform.</span>
<span class="cm"> * Copyright IBM Corp. 2004 2005</span>
<span class="cm"> * Copyright Linas Vepstas &lt;linas@linas.org&gt; 2004, 2005</span>
<span class="cm"> *</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or (at</span>
<span class="cm"> * your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> * NON INFRINGEMENT.  See the GNU General Public License for more</span>
<span class="cm"> * details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Send comments and feedback to Linas Vepstas &lt;linas@austin.ibm.com&gt;</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;asm/eeh.h&gt;</span>
<span class="cp">#include &lt;asm/eeh_event.h&gt;</span>
<span class="cp">#include &lt;asm/ppc-pci.h&gt;</span>
<span class="cp">#include &lt;asm/pci-bridge.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/rtas.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_pcid_name - Retrieve name of PCI device driver</span>
<span class="cm"> * @pdev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to retrieve the name of PCI device driver</span>
<span class="cm"> * if that&#39;s valid.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">eeh_pcid_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">&amp;&amp;</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static void print_device_node_tree(struct pci_dn *pdn, int dent)</span>
<span class="c">{</span>
<span class="c">	int i;</span>
<span class="c">	struct device_node *pc;</span>

<span class="c">	if (!pdn)</span>
<span class="c">		return;</span>
<span class="c">	for (i = 0; i &lt; dent; i++)</span>
<span class="c">		printk(&quot; &quot;);</span>
<span class="c">	printk(&quot;dn=%s mode=%x \tcfg_addr=%x pe_addr=%x \tfull=%s\n&quot;,</span>
<span class="c">		pdn-&gt;node-&gt;name, pdn-&gt;eeh_mode, pdn-&gt;eeh_config_addr,</span>
<span class="c">		pdn-&gt;eeh_pe_config_addr, pdn-&gt;node-&gt;full_name);</span>
<span class="c">	dent += 3;</span>
<span class="c">	pc = pdn-&gt;node-&gt;child;</span>
<span class="c">	while (pc) {</span>
<span class="c">		print_device_node_tree(PCI_DN(pc), dent);</span>
<span class="c">		pc = pc-&gt;sibling;</span>
<span class="c">	}</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_disable_irq - Disable interrupt for the recovering device</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine must be called when reporting temporary or permanent</span>
<span class="cm"> * error to the particular PCI device to disable interrupt of that</span>
<span class="cm"> * device. If the device has enabled MSI or MSI-X interrupt, we needn&#39;t</span>
<span class="cm"> * do real work because EEH should freeze DMA transfers for those PCI</span>
<span class="cm"> * devices encountering EEH errors, which includes MSI or MSI-X.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">eeh_disable_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span> <span class="o">=</span> <span class="n">pci_dev_to_eeh_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t disable MSI and MSI-X interrupts. They are</span>
<span class="cm">	 * effectively disabled by the DMA Stopped state</span>
<span class="cm">	 * when an EEH error occurs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">msi_enabled</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">msix_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irq_has_action</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">edev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">EEH_MODE_IRQ_DISABLED</span><span class="p">;</span>
	<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_enable_irq - Enable interrupt for the recovering device</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine must be called to enable interrupt while failed</span>
<span class="cm"> * device could be resumed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">eeh_enable_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span> <span class="o">=</span> <span class="n">pci_dev_to_eeh_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EEH_MODE_IRQ_DISABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">edev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EEH_MODE_IRQ_DISABLED</span><span class="p">;</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_report_error - Report pci error to each device driver</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> * @userdata: return value</span>
<span class="cm"> * </span>
<span class="cm"> * Report an EEH error to each device driver, collect up and </span>
<span class="cm"> * merge the device driver responses. Cumulative response </span>
<span class="cm"> * passed back in &quot;userdata&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">eeh_report_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">pci_ers_result</span> <span class="n">rc</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">userdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">error_state</span> <span class="o">=</span> <span class="n">pci_channel_io_frozen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">eeh_disable_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">err_handler</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">err_handler</span><span class="o">-&gt;</span><span class="n">error_detected</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">err_handler</span><span class="o">-&gt;</span><span class="n">error_detected</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_channel_io_frozen</span><span class="p">);</span>

	<span class="cm">/* A driver that needs a reset trumps all others */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">PCI_ERS_RESULT_NEED_RESET</span><span class="p">)</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">res</span> <span class="o">==</span> <span class="n">PCI_ERS_RESULT_NONE</span><span class="p">)</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_report_mmio_enabled - Tell drivers that MMIO has been enabled</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> * @userdata: return value</span>
<span class="cm"> *</span>
<span class="cm"> * Tells each device driver that IO ports, MMIO and config space I/O</span>
<span class="cm"> * are now enabled. Collects up and merges the device driver responses.</span>
<span class="cm"> * Cumulative response passed back in &quot;userdata&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">eeh_report_mmio_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">pci_ers_result</span> <span class="n">rc</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">userdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">err_handler</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">err_handler</span><span class="o">-&gt;</span><span class="n">mmio_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">err_handler</span><span class="o">-&gt;</span><span class="n">mmio_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* A driver that needs a reset trumps all others */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">PCI_ERS_RESULT_NEED_RESET</span><span class="p">)</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">res</span> <span class="o">==</span> <span class="n">PCI_ERS_RESULT_NONE</span><span class="p">)</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_report_reset - Tell device that slot has been reset</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> * @userdata: return value</span>
<span class="cm"> *</span>
<span class="cm"> * This routine must be called while EEH tries to reset particular</span>
<span class="cm"> * PCI device so that the associated PCI device driver could take</span>
<span class="cm"> * some actions, usually to save data the driver needs so that the</span>
<span class="cm"> * driver can work again while the device is recovered.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">eeh_report_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">pci_ers_result</span> <span class="n">rc</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">userdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">error_state</span> <span class="o">=</span> <span class="n">pci_channel_io_normal</span><span class="p">;</span>

	<span class="n">eeh_enable_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">err_handler</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">err_handler</span><span class="o">-&gt;</span><span class="n">slot_reset</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">err_handler</span><span class="o">-&gt;</span><span class="n">slot_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">res</span> <span class="o">==</span> <span class="n">PCI_ERS_RESULT_NONE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">*</span><span class="n">res</span> <span class="o">==</span> <span class="n">PCI_ERS_RESULT_RECOVERED</span><span class="p">))</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">res</span> <span class="o">==</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span> <span class="o">&amp;&amp;</span>
	     <span class="n">rc</span> <span class="o">==</span> <span class="n">PCI_ERS_RESULT_NEED_RESET</span><span class="p">)</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_report_resume - Tell device to resume normal operations</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> * @userdata: return value</span>
<span class="cm"> *</span>
<span class="cm"> * This routine must be called to notify the device driver that it</span>
<span class="cm"> * could resume so that the device driver can do some initialization</span>
<span class="cm"> * to make the recovered device work again.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">eeh_report_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">error_state</span> <span class="o">=</span> <span class="n">pci_channel_io_normal</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">eeh_enable_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">err_handler</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">err_handler</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">err_handler</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_report_failure - Tell device driver that device is dead.</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> * @userdata: return value</span>
<span class="cm"> *</span>
<span class="cm"> * This informs the device driver that the device is permanently</span>
<span class="cm"> * dead, and that no further recovery attempts will be made on it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">eeh_report_failure</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">error_state</span> <span class="o">=</span> <span class="n">pci_channel_io_perm_failure</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">eeh_disable_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">err_handler</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">err_handler</span><span class="o">-&gt;</span><span class="n">error_detected</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">err_handler</span><span class="o">-&gt;</span><span class="n">error_detected</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_channel_io_perm_failure</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_reset_device - Perform actual reset of a pci slot</span>
<span class="cm"> * @edev: PE associated EEH device</span>
<span class="cm"> * @bus: PCI bus corresponding to the isolcated slot</span>
<span class="cm"> *</span>
<span class="cm"> * This routine must be called to do reset on the indicated PE.</span>
<span class="cm"> * During the reset, udev might be invoked because those affected</span>
<span class="cm"> * PCI devices will be removed and then added.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">eeh_reset_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* pcibios will clear the counter; save the value */</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="n">edev</span><span class="o">-&gt;</span><span class="n">freeze_count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="p">)</span>
		<span class="n">pcibios_remove_pci_devices</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>

	<span class="cm">/* Reset the pci controller. (Asserts RST#; resets config space).</span>
<span class="cm">	 * Reconfigure bridges and devices. Don&#39;t try to bring the system</span>
<span class="cm">	 * up if the reset failed for some reason.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">eeh_reset_pe</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Walk over all functions on this device. */</span>
	<span class="n">dn</span> <span class="o">=</span> <span class="n">eeh_dev_to_of_node</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcibios_find_pci_bus</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">))</span>
		<span class="n">dn</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">dn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">pedev</span> <span class="o">=</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>

		<span class="cm">/* On Power4, always true because eeh_pe_config_addr=0 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">pe_config_addr</span> <span class="o">==</span> <span class="n">pedev</span><span class="o">-&gt;</span><span class="n">pe_config_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">configure_bridge</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
			<span class="n">eeh_restore_bars</span><span class="p">(</span><span class="n">pedev</span><span class="p">);</span>
 		<span class="p">}</span>
		<span class="n">dn</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Give the system 5 seconds to finish running the user-space</span>
<span class="cm">	 * hotplug shutdown scripts, e.g. ifdown for ethernet.  Yes, </span>
<span class="cm">	 * this is a hack, but if we don&#39;t do this, and try to bring </span>
<span class="cm">	 * the device up before the scripts have taken it down, </span>
<span class="cm">	 * potentially weird things happen.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ssleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
		<span class="n">pcibios_add_pci_devices</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">edev</span><span class="o">-&gt;</span><span class="n">freeze_count</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The longest amount of time to wait for a pci device</span>
<span class="cm"> * to come back on line, in seconds.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_WAIT_FOR_RECOVERY 150</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_handle_event - Reset a PCI device after hard lockup.</span>
<span class="cm"> * @event: EEH event</span>
<span class="cm"> *</span>
<span class="cm"> * While PHB detects address or data parity errors on particular PCI</span>
<span class="cm"> * slot, the associated PE will be frozen. Besides, DMA&#39;s occurring</span>
<span class="cm"> * to wild addresses (which usually happen due to bugs in device</span>
<span class="cm"> * drivers or in PCI adapter firmware) can cause EEH error. #SERR,</span>
<span class="cm"> * #PERR or other misc PCI-related errors also can trigger EEH errors.</span>
<span class="cm"> *</span>
<span class="cm"> * Recovery process consists of unplugging the device driver (which</span>
<span class="cm"> * generated hotplug events to userspace), then issuing a PCI #RST to</span>
<span class="cm"> * the device, then reconfiguring the PCI config space for all bridges</span>
<span class="cm"> * &amp; devices under this slot, and then finally restarting the device</span>
<span class="cm"> * drivers (which cause a second set of hotplug events to go out to</span>
<span class="cm"> * userspace).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="nf">handle_eeh_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">eeh_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">frozen_dn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">frozen_edev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">frozen_bus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">pci_ers_result</span> <span class="n">result</span> <span class="o">=</span> <span class="n">PCI_ERS_RESULT_NONE</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="o">*</span><span class="n">pci_str</span><span class="p">,</span> <span class="o">*</span><span class="n">drv_str</span><span class="p">,</span> <span class="o">*</span><span class="n">bus_pci_str</span><span class="p">,</span> <span class="o">*</span><span class="n">bus_drv_str</span><span class="p">;</span>

	<span class="n">frozen_dn</span> <span class="o">=</span> <span class="n">eeh_find_device_pe</span><span class="p">(</span><span class="n">eeh_dev_to_of_node</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">edev</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frozen_dn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">location</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">eeh_dev_to_of_node</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">edev</span><span class="p">),</span> <span class="s">&quot;ibm,loc-code&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">location</span> <span class="o">=</span> <span class="n">location</span> <span class="o">?</span> <span class="n">location</span> <span class="o">:</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;EEH: Error: Cannot find partition endpoint &quot;</span>
		                <span class="s">&quot;for location=%s pci addr=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">location</span><span class="p">,</span> <span class="n">eeh_pci_name</span><span class="p">(</span><span class="n">eeh_dev_to_pci_dev</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">edev</span><span class="p">)));</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">frozen_bus</span> <span class="o">=</span> <span class="n">pcibios_find_pci_bus</span><span class="p">(</span><span class="n">frozen_dn</span><span class="p">);</span>
	<span class="n">location</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">frozen_dn</span><span class="p">,</span> <span class="s">&quot;ibm,loc-code&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">location</span> <span class="o">=</span> <span class="n">location</span> <span class="o">?</span> <span class="n">location</span> <span class="o">:</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>

	<span class="cm">/* There are two different styles for coming up with the PE.</span>
<span class="cm">	 * In the old style, it was the highest EEH-capable device</span>
<span class="cm">	 * which was always an EADS pci bridge.  In the new style,</span>
<span class="cm">	 * there might not be any EADS bridges, and even when there are,</span>
<span class="cm">	 * the firmware marks them as &quot;EEH incapable&quot;. So another</span>
<span class="cm">	 * two-step is needed to find the pci bus..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frozen_bus</span><span class="p">)</span>
		<span class="n">frozen_bus</span> <span class="o">=</span> <span class="n">pcibios_find_pci_bus</span><span class="p">(</span><span class="n">frozen_dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frozen_bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;EEH: Cannot find PCI bus &quot;</span>
		        <span class="s">&quot;for location=%s dn=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		        <span class="n">location</span><span class="p">,</span> <span class="n">frozen_dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">frozen_edev</span> <span class="o">=</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">frozen_dn</span><span class="p">);</span>
	<span class="n">frozen_edev</span><span class="o">-&gt;</span><span class="n">freeze_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">pci_str</span> <span class="o">=</span> <span class="n">eeh_pci_name</span><span class="p">(</span><span class="n">eeh_dev_to_pci_dev</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">edev</span><span class="p">));</span>
	<span class="n">drv_str</span> <span class="o">=</span> <span class="n">eeh_pcid_name</span><span class="p">(</span><span class="n">eeh_dev_to_pci_dev</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">edev</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frozen_edev</span><span class="o">-&gt;</span><span class="n">freeze_count</span> <span class="o">&gt;</span> <span class="n">EEH_MAX_ALLOWED_FREEZES</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">excess_failures</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
	   <span class="s">&quot;EEH: This PCI device has failed %d times in the last hour:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">frozen_edev</span><span class="o">-&gt;</span><span class="n">freeze_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frozen_edev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bus_pci_str</span> <span class="o">=</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">frozen_edev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">bus_drv_str</span> <span class="o">=</span> <span class="n">eeh_pcid_name</span><span class="p">(</span><span class="n">frozen_edev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;EEH: Bus location=%s driver=%s pci addr=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">location</span><span class="p">,</span> <span class="n">bus_drv_str</span><span class="p">,</span> <span class="n">bus_pci_str</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		<span class="s">&quot;EEH: Device location=%s driver=%s pci addr=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">location</span><span class="p">,</span> <span class="n">drv_str</span><span class="p">,</span> <span class="n">pci_str</span><span class="p">);</span>

	<span class="cm">/* Walk the various device drivers attached to this slot through</span>
<span class="cm">	 * a reset sequence, giving each an opportunity to do what it needs</span>
<span class="cm">	 * to accomplish the reset.  Each child gets a report of the</span>
<span class="cm">	 * status ... if any child can&#39;t handle the reset, then the entire</span>
<span class="cm">	 * slot is dlpar removed and added.</span>
<span class="cm">	 */</span>
	<span class="n">pci_walk_bus</span><span class="p">(</span><span class="n">frozen_bus</span><span class="p">,</span> <span class="n">eeh_report_error</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>

	<span class="cm">/* Get the current PCI slot state. This can take a long time,</span>
<span class="cm">	 * sometimes over 3 seconds for certain systems.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">wait_state</span><span class="p">(</span><span class="n">eeh_dev_to_of_node</span><span class="p">(</span><span class="n">frozen_edev</span><span class="p">),</span> <span class="n">MAX_WAIT_FOR_RECOVERY</span><span class="o">*</span><span class="mi">1000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">rc</span> <span class="o">==</span> <span class="n">EEH_STATE_NOT_SUPPORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: Permanent failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">hard_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Since rtas may enable MMIO when posting the error log,</span>
<span class="cm">	 * don&#39;t post the error log until after all dev drivers</span>
<span class="cm">	 * have been informed.</span>
<span class="cm">	 */</span>
	<span class="n">eeh_slot_error_detail</span><span class="p">(</span><span class="n">frozen_edev</span><span class="p">,</span> <span class="n">EEH_LOG_TEMP</span><span class="p">);</span>

	<span class="cm">/* If all device drivers were EEH-unaware, then shut</span>
<span class="cm">	 * down all of the device drivers, and hope they</span>
<span class="cm">	 * go down willingly, without panicing the system.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">PCI_ERS_RESULT_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">eeh_reset_device</span><span class="p">(</span><span class="n">frozen_edev</span><span class="p">,</span> <span class="n">frozen_bus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: Unable to reset, rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">hard_fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If all devices reported they can proceed, then re-enable MMIO */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">PCI_ERS_RESULT_CAN_RECOVER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">eeh_pci_enable</span><span class="p">(</span><span class="n">frozen_edev</span><span class="p">,</span> <span class="n">EEH_OPT_THAW_MMIO</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">hard_fail</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">PCI_ERS_RESULT_NEED_RESET</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">PCI_ERS_RESULT_NONE</span><span class="p">;</span>
			<span class="n">pci_walk_bus</span><span class="p">(</span><span class="n">frozen_bus</span><span class="p">,</span> <span class="n">eeh_report_mmio_enabled</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If all devices reported they can proceed, then re-enable DMA */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">PCI_ERS_RESULT_CAN_RECOVER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">eeh_pci_enable</span><span class="p">(</span><span class="n">frozen_edev</span><span class="p">,</span> <span class="n">EEH_OPT_THAW_DMA</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">hard_fail</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">PCI_ERS_RESULT_NEED_RESET</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">PCI_ERS_RESULT_RECOVERED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If any device has a hard failure, then shut off everything. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: Device driver gave up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">hard_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If any device called out for a reset, then reset the slot */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">PCI_ERS_RESULT_NEED_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">eeh_reset_device</span><span class="p">(</span><span class="n">frozen_edev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: Cannot reset, rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">hard_fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">PCI_ERS_RESULT_NONE</span><span class="p">;</span>
		<span class="n">pci_walk_bus</span><span class="p">(</span><span class="n">frozen_bus</span><span class="p">,</span> <span class="n">eeh_report_reset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* All devices should claim they have recovered by now. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">result</span> <span class="o">!=</span> <span class="n">PCI_ERS_RESULT_RECOVERED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">PCI_ERS_RESULT_NONE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: Not recovered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">hard_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Tell all device drivers that they can resume operations */</span>
	<span class="n">pci_walk_bus</span><span class="p">(</span><span class="n">frozen_bus</span><span class="p">,</span> <span class="n">eeh_report_resume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">frozen_edev</span><span class="p">;</span>
	
<span class="nl">excess_failures:</span>
	<span class="cm">/*</span>
<span class="cm">	 * About 90% of all real-life EEH failures in the field</span>
<span class="cm">	 * are due to poorly seated PCI cards. Only 10% or so are</span>
<span class="cm">	 * due to actual, failed cards.</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
	   <span class="s">&quot;EEH: PCI device at location=%s driver=%s pci addr=%s</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;has failed %d times in the last hour &quot;</span>
		<span class="s">&quot;and has been permanently disabled.</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;Please try reseating this device or replacing it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">location</span><span class="p">,</span> <span class="n">drv_str</span><span class="p">,</span> <span class="n">pci_str</span><span class="p">,</span> <span class="n">frozen_edev</span><span class="o">-&gt;</span><span class="n">freeze_count</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">perm_error</span><span class="p">;</span>

<span class="nl">hard_fail:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
	   <span class="s">&quot;EEH: Unable to recover from failure of PCI device &quot;</span>
	   <span class="s">&quot;at location=%s driver=%s pci addr=%s</span><span class="se">\n</span><span class="s">&quot;</span>
	   <span class="s">&quot;Please try reseating this device or replacing it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">location</span><span class="p">,</span> <span class="n">drv_str</span><span class="p">,</span> <span class="n">pci_str</span><span class="p">);</span>

<span class="nl">perm_error:</span>
	<span class="n">eeh_slot_error_detail</span><span class="p">(</span><span class="n">frozen_edev</span><span class="p">,</span> <span class="n">EEH_LOG_PERM</span><span class="p">);</span>

	<span class="cm">/* Notify all devices that they&#39;re about to go down. */</span>
	<span class="n">pci_walk_bus</span><span class="p">(</span><span class="n">frozen_bus</span><span class="p">,</span> <span class="n">eeh_report_failure</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Shut down the device drivers for good. */</span>
	<span class="n">pcibios_remove_pci_devices</span><span class="p">(</span><span class="n">frozen_bus</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
