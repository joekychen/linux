<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › platforms › pseries › hotplug-cpu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>hotplug-cpu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * pseries CPU Hotplug infrastructure.</span>
<span class="cm"> *</span>
<span class="cm"> * Split out from arch/powerpc/platforms/pseries/setup.c</span>
<span class="cm"> *  arch/powerpc/kernel/rtas.c, and arch/powerpc/platforms/pseries/smp.c</span>
<span class="cm"> *</span>
<span class="cm"> * Peter Bergner, IBM	March 2001.</span>
<span class="cm"> * Copyright (C) 2001 IBM.</span>
<span class="cm"> * Dave Engebretsen, Peter Bergner, and</span>
<span class="cm"> * Mike Corrigan {engebret|bergner|mikec}@us.ibm.com</span>
<span class="cm"> * Plus various changes from other IBM teams...</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006 Michael Ellerman, IBM Corporation</span>
<span class="cm"> *</span>
<span class="cm"> *      This program is free software; you can redistribute it and/or</span>
<span class="cm"> *      modify it under the terms of the GNU General Public License</span>
<span class="cm"> *      as published by the Free Software Foundation; either version</span>
<span class="cm"> *      2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;	</span><span class="cm">/* for idle_task_exit */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/rtas.h&gt;</span>
<span class="cp">#include &lt;asm/firmware.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/vdso_datapage.h&gt;</span>
<span class="cp">#include &lt;asm/pSeries_reconfig.h&gt;</span>
<span class="cp">#include &lt;asm/xics.h&gt;</span>
<span class="cp">#include &quot;plpar_wrappers.h&quot;</span>
<span class="cp">#include &quot;offline_states.h&quot;</span>

<span class="cm">/* This version can&#39;t take the spinlock, because it never returns */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rtas_args</span> <span class="n">rtas_stop_self_args</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">token</span> <span class="o">=</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nargs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rets</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rtas_stop_self_args</span><span class="p">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">enum</span> <span class="n">cpu_state_vals</span><span class="p">,</span> <span class="n">preferred_offline_state</span><span class="p">)</span> <span class="o">=</span>
							<span class="n">CPU_STATE_OFFLINE</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">enum</span> <span class="n">cpu_state_vals</span><span class="p">,</span> <span class="n">current_state</span><span class="p">)</span> <span class="o">=</span> <span class="n">CPU_STATE_OFFLINE</span><span class="p">;</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">cpu_state_vals</span> <span class="n">default_offline_state</span> <span class="o">=</span> <span class="n">CPU_STATE_OFFLINE</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cede_offline_enabled</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Enable/disable cede_offline when available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_cede_offline</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">))</span>
		<span class="n">cede_offline_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">))</span>
		<span class="n">cede_offline_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;cede_offline=&quot;</span><span class="p">,</span> <span class="n">setup_cede_offline</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">cpu_state_vals</span> <span class="nf">get_cpu_current_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_cpu_current_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">enum</span> <span class="n">cpu_state_vals</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">cpu_state_vals</span> <span class="nf">get_preferred_offline_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">preferred_offline_state</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_preferred_offline_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">enum</span> <span class="n">cpu_state_vals</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">preferred_offline_state</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_default_offline_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">preferred_offline_state</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">default_offline_state</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rtas_stop_self</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rtas_args</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rtas_stop_self_args</span><span class="p">;</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">token</span> <span class="o">==</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;cpu %u (hwid %u) Ready to die...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">hard_smp_processor_id</span><span class="p">());</span>
	<span class="n">enter_rtas</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">args</span><span class="p">));</span>

	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Alas, I survived.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pseries_mach_cpu_die</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hwcpu</span> <span class="o">=</span> <span class="n">hard_smp_processor_id</span><span class="p">();</span>
	<span class="n">u8</span> <span class="n">cede_latency_hint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">idle_task_exit</span><span class="p">();</span>
	<span class="n">xics_teardown_cpu</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_preferred_offline_state</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPU_STATE_INACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_cpu_current_state</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">CPU_STATE_INACTIVE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">suspend_disable_cpu</span><span class="p">)</span>
			<span class="n">ppc_md</span><span class="p">.</span><span class="n">suspend_disable_cpu</span><span class="p">();</span>

		<span class="n">cede_latency_hint</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">get_lppaca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_lppaca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">shared_proc</span><span class="p">)</span>
			<span class="n">get_lppaca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">donate_dedicated_cpu</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">get_preferred_offline_state</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPU_STATE_INACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">extended_cede_processor</span><span class="p">(</span><span class="n">cede_latency_hint</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_lppaca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">shared_proc</span><span class="p">)</span>
			<span class="n">get_lppaca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">donate_dedicated_cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">get_lppaca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">get_preferred_offline_state</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPU_STATE_ONLINE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unregister_slb_shadow</span><span class="p">(</span><span class="n">hwcpu</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Call to start_secondary_resume() will not return.</span>
<span class="cm">			 * Kernel stack will be reset and start_secondary()</span>
<span class="cm">			 * will be called to continue the online operation.</span>
<span class="cm">			 */</span>
			<span class="n">start_secondary_resume</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Requested state is CPU_STATE_OFFLINE at this point */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">get_preferred_offline_state</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CPU_STATE_OFFLINE</span><span class="p">);</span>

	<span class="n">set_cpu_current_state</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">CPU_STATE_OFFLINE</span><span class="p">);</span>
	<span class="n">unregister_slb_shadow</span><span class="p">(</span><span class="n">hwcpu</span><span class="p">);</span>
	<span class="n">rtas_stop_self</span><span class="p">();</span>

	<span class="cm">/* Should never get here... */</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">for</span><span class="p">(;;);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pseries_cpu_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">processorCount</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/*fix boot_cpuid here*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">boot_cpuid</span><span class="p">)</span>
		<span class="n">boot_cpuid</span> <span class="o">=</span> <span class="n">cpumask_any</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">);</span>

	<span class="cm">/* FIXME: abstract this to not be platform specific later on */</span>
	<span class="n">xics_migrate_irqs_away</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pseries_cpu_die: Wait for the cpu to die.</span>
<span class="cm"> * @cpu: logical processor id of the CPU whose death we&#39;re awaiting.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from the context of the thread which is performing</span>
<span class="cm"> * the cpu-offline. Here we wait for long enough to allow the cpu in question</span>
<span class="cm"> * to self-destroy so that the cpu-offline thread can send the CPU_DEAD</span>
<span class="cm"> * notifications.</span>
<span class="cm"> *</span>
<span class="cm"> * OTOH, pseries_mach_cpu_die() is called by the @cpu when it wants to</span>
<span class="cm"> * self-destruct.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pseries_cpu_die</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pcpu</span> <span class="o">=</span> <span class="n">get_hard_smp_processor_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_preferred_offline_state</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPU_STATE_INACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tries</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">tries</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">get_cpu_current_state</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPU_STATE_INACTIVE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cpu_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">get_preferred_offline_state</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPU_STATE_OFFLINE</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tries</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">;</span> <span class="n">tries</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpu_status</span> <span class="o">=</span> <span class="n">smp_query_cpu_stopped</span><span class="p">(</span><span class="n">pcpu</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_status</span> <span class="o">==</span> <span class="n">QCSS_STOPPED</span> <span class="o">||</span>
			    <span class="n">cpu_status</span> <span class="o">==</span> <span class="n">QCSS_HARDWARE_ERROR</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Querying DEAD? cpu %i (%i) shows %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">cpu</span><span class="p">,</span> <span class="n">pcpu</span><span class="p">,</span> <span class="n">cpu_status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Isolation and deallocation are definitely done by</span>
<span class="cm">	 * drslot_chrp_cpu.  If they were not they would be</span>
<span class="cm">	 * done here.  Change isolate state to Isolate and</span>
<span class="cm">	 * change allocation-state to Unusable.</span>
<span class="cm">	 */</span>
	<span class="n">paca</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">cpu_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update cpu_present_mask and paca(s) for a new cpu node.  The wrinkle</span>
<span class="cm"> * here is that a cpu device node may represent up to two logical cpus</span>
<span class="cm"> * in the SMT case.  We must honor the assumption in other code that</span>
<span class="cm"> * the logical ids for sibling SMT threads x and y are adjacent, such</span>
<span class="cm"> * that x^1 == y and y^1 == x.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pseries_add_processor</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">cpumask_var_t</span> <span class="n">candidate_mask</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">nthreads</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">intserv</span><span class="p">;</span>

	<span class="n">intserv</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;ibm,ppc-interrupt-server#s&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intserv</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">candidate_mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">nthreads</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="n">cpu_maps_update_begin</span><span class="p">();</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cpumask_subset</span><span class="p">(</span><span class="n">cpu_present_mask</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">));</span>

	<span class="cm">/* Get a bitmap of unoccupied slots. */</span>
	<span class="n">cpumask_xor</span><span class="p">(</span><span class="n">candidate_mask</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">,</span> <span class="n">cpu_present_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">candidate_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* If we get here, it most likely means that NR_CPUS is</span>
<span class="cm">		 * less than the partition&#39;s max processors setting.</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Cannot add cpu %s; this system configuration&quot;</span>
		       <span class="s">&quot; supports %d logical cpus.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span>
		       <span class="n">cpumask_weight</span><span class="p">(</span><span class="n">cpu_possible_mask</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_subset</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">candidate_mask</span><span class="p">))</span>
			<span class="cm">/* Found a range where we can insert the new cpu(s) */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">cpumask_shift_left</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">nthreads</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unable to find space in cpu_present_mask for&quot;</span>
		       <span class="s">&quot; processor %s with %d thread(s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		       <span class="n">nthreads</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu_present</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">set_hard_smp_processor_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">*</span><span class="n">intserv</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">cpu_maps_update_done</span><span class="p">();</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">candidate_mask</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update the present map for a cpu node which is going away, and set</span>
<span class="cm"> * the hard id in the paca(s) to -1 to be consistent with boot time</span>
<span class="cm"> * convention for non-present cpus.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pseries_remove_processor</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">nthreads</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">intserv</span><span class="p">;</span>

	<span class="n">intserv</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;ibm,ppc-interrupt-server#s&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intserv</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">nthreads</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>

	<span class="n">cpu_maps_update_begin</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">get_hard_smp_processor_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">!=</span> <span class="n">intserv</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
			<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="n">set_hard_smp_processor_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Could not find cpu to remove &quot;</span>
			       <span class="s">&quot;with physical id 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">intserv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">cpu_maps_update_done</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pseries_smp_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PSERIES_RECONFIG_ADD</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">pseries_add_processor</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PSERIES_RECONFIG_REMOVE</span>:
		<span class="n">pseries_remove_processor</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">pseries_smp_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">pseries_smp_notifier</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define MAX_CEDE_LATENCY_LEVELS		4</span>
<span class="cp">#define	CEDE_LATENCY_PARAM_LENGTH	10</span>
<span class="cp">#define CEDE_LATENCY_PARAM_MAX_LENGTH	\</span>
<span class="cp">	(MAX_CEDE_LATENCY_LEVELS * CEDE_LATENCY_PARAM_LENGTH * sizeof(char))</span>
<span class="cp">#define CEDE_LATENCY_TOKEN		45</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">cede_parameters</span><span class="p">[</span><span class="n">CEDE_LATENCY_PARAM_MAX_LENGTH</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_cede_parameters</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cede_parameters</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CEDE_LATENCY_PARAM_MAX_LENGTH</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">rtas_token</span><span class="p">(</span><span class="s">&quot;ibm,get-system-parameter&quot;</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			 <span class="nb">NULL</span><span class="p">,</span>
			 <span class="n">CEDE_LATENCY_TOKEN</span><span class="p">,</span>
			 <span class="n">__pa</span><span class="p">(</span><span class="n">cede_parameters</span><span class="p">),</span>
			 <span class="n">CEDE_LATENCY_PARAM_MAX_LENGTH</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pseries_cpu_hotplug_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">typep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">qcss_tok</span><span class="p">;</span>

	<span class="n">for_each_node_by_name</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;interrupt-controller&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">typep</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;compatible&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">typep</span><span class="p">,</span> <span class="s">&quot;open-pic&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CPU Hotplug not supported on &quot;</span>
				<span class="s">&quot;systems using MPIC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rtas_stop_self_args</span><span class="p">.</span><span class="n">token</span> <span class="o">=</span> <span class="n">rtas_token</span><span class="p">(</span><span class="s">&quot;stop-self&quot;</span><span class="p">);</span>
	<span class="n">qcss_tok</span> <span class="o">=</span> <span class="n">rtas_token</span><span class="p">(</span><span class="s">&quot;query-cpu-stopped-state&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rtas_stop_self_args</span><span class="p">.</span><span class="n">token</span> <span class="o">==</span> <span class="n">RTAS_UNKNOWN_SERVICE</span> <span class="o">||</span>
			<span class="n">qcss_tok</span> <span class="o">==</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CPU Hotplug not supported by firmware &quot;</span>
				<span class="s">&quot;- disabling.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ppc_md</span><span class="p">.</span><span class="n">cpu_die</span> <span class="o">=</span> <span class="n">pseries_mach_cpu_die</span><span class="p">;</span>
	<span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">cpu_disable</span> <span class="o">=</span> <span class="n">pseries_cpu_disable</span><span class="p">;</span>
	<span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">cpu_die</span> <span class="o">=</span> <span class="n">pseries_cpu_die</span><span class="p">;</span>

	<span class="cm">/* Processors can be added/removed only on LPAR */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_LPAR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pSeries_reconfig_notifier_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pseries_smp_nb</span><span class="p">);</span>
		<span class="n">cpu_maps_update_begin</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cede_offline_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">parse_cede_parameters</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">default_offline_state</span> <span class="o">=</span> <span class="n">CPU_STATE_INACTIVE</span><span class="p">;</span>
			<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
				<span class="n">set_default_offline_state</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cpu_maps_update_done</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">arch_initcall</span><span class="p">(</span><span class="n">pseries_cpu_hotplug_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
