<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › platforms › pseries › eeh.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>eeh.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright IBM Corporation 2001, 2005, 2006</span>
<span class="cm"> * Copyright Dave Engebretsen &amp; Todd Inglett 2001</span>
<span class="cm"> * Copyright Linas Vepstas 2005, 2006</span>
<span class="cm"> * Copyright 2001-2012 IBM Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Please address comments and feedback to Linas Vepstas &lt;linas@austin.ibm.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/eeh.h&gt;</span>
<span class="cp">#include &lt;asm/eeh_event.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/ppc-pci.h&gt;</span>
<span class="cp">#include &lt;asm/rtas.h&gt;</span>


<span class="cm">/** Overview:</span>
<span class="cm"> *  EEH, or &quot;Extended Error Handling&quot; is a PCI bridge technology for</span>
<span class="cm"> *  dealing with PCI bus errors that can&#39;t be dealt with within the</span>
<span class="cm"> *  usual PCI framework, except by check-stopping the CPU.  Systems</span>
<span class="cm"> *  that are designed for high-availability/reliability cannot afford</span>
<span class="cm"> *  to crash due to a &quot;mere&quot; PCI error, thus the need for EEH.</span>
<span class="cm"> *  An EEH-capable bridge operates by converting a detected error</span>
<span class="cm"> *  into a &quot;slot freeze&quot;, taking the PCI adapter off-line, making</span>
<span class="cm"> *  the slot behave, from the OS&#39;es point of view, as if the slot</span>
<span class="cm"> *  were &quot;empty&quot;: all reads return 0xff&#39;s and all writes are silently</span>
<span class="cm"> *  ignored.  EEH slot isolation events can be triggered by parity</span>
<span class="cm"> *  errors on the address or data busses (e.g. during posted writes),</span>
<span class="cm"> *  which in turn might be caused by low voltage on the bus, dust,</span>
<span class="cm"> *  vibration, humidity, radioactivity or plain-old failed hardware.</span>
<span class="cm"> *</span>
<span class="cm"> *  Note, however, that one of the leading causes of EEH slot</span>
<span class="cm"> *  freeze events are buggy device drivers, buggy device microcode,</span>
<span class="cm"> *  or buggy device hardware.  This is because any attempt by the</span>
<span class="cm"> *  device to bus-master data to a memory address that is not</span>
<span class="cm"> *  assigned to the device will trigger a slot freeze.   (The idea</span>
<span class="cm"> *  is to prevent devices-gone-wild from corrupting system memory).</span>
<span class="cm"> *  Buggy hardware/drivers will have a miserable time co-existing</span>
<span class="cm"> *  with EEH.</span>
<span class="cm"> *</span>
<span class="cm"> *  Ideally, a PCI device driver, when suspecting that an isolation</span>
<span class="cm"> *  event has occurred (e.g. by reading 0xff&#39;s), will then ask EEH</span>
<span class="cm"> *  whether this is the case, and then take appropriate steps to</span>
<span class="cm"> *  reset the PCI slot, the PCI device, and then resume operations.</span>
<span class="cm"> *  However, until that day,  the checking is done here, with the</span>
<span class="cm"> *  eeh_check_failure() routine embedded in the MMIO macros.  If</span>
<span class="cm"> *  the slot is found to be isolated, an &quot;EEH Event&quot; is synthesized</span>
<span class="cm"> *  and sent out for processing.</span>
<span class="cm"> */</span>

<span class="cm">/* If a device driver keeps reading an MMIO register in an interrupt</span>
<span class="cm"> * handler after a slot isolation event, it might be broken.</span>
<span class="cm"> * This sets the threshold for how many read attempts we allow</span>
<span class="cm"> * before printing an error message.</span>
<span class="cm"> */</span>
<span class="cp">#define EEH_MAX_FAILS	2100000</span>

<span class="cm">/* Time to wait for a PCI slot to report status, in milliseconds */</span>
<span class="cp">#define PCI_BUS_RESET_WAIT_MSEC (60*1000)</span>

<span class="cm">/* Platform dependent EEH operations */</span>
<span class="k">struct</span> <span class="n">eeh_ops</span> <span class="o">*</span><span class="n">eeh_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">eeh_subsystem_enabled</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">eeh_subsystem_enabled</span><span class="p">);</span>

<span class="cm">/* Lock to avoid races due to multiple reports of an error */</span>
<span class="k">static</span> <span class="n">DEFINE_RAW_SPINLOCK</span><span class="p">(</span><span class="n">confirm_error_lock</span><span class="p">);</span>

<span class="cm">/* Buffer for reporting pci register dumps. Its here in BSS, and</span>
<span class="cm"> * not dynamically alloced, so that it ends up in RMO where RTAS</span>
<span class="cm"> * can access it.</span>
<span class="cm"> */</span>
<span class="cp">#define EEH_PCI_REGS_LOG_LEN 4096</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pci_regs_buf</span><span class="p">[</span><span class="n">EEH_PCI_REGS_LOG_LEN</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * The struct is used to maintain the EEH global statistic</span>
<span class="cm"> * information. Besides, the EEH global statistics will be</span>
<span class="cm"> * exported to user space through procfs</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">eeh_stats</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">no_device</span><span class="p">;</span>		<span class="cm">/* PCI device not found		*/</span>
	<span class="n">u64</span> <span class="n">no_dn</span><span class="p">;</span>		<span class="cm">/* OF node not found		*/</span>
	<span class="n">u64</span> <span class="n">no_cfg_addr</span><span class="p">;</span>	<span class="cm">/* Config address not found	*/</span>
	<span class="n">u64</span> <span class="n">ignored_check</span><span class="p">;</span>	<span class="cm">/* EEH check skipped		*/</span>
	<span class="n">u64</span> <span class="n">total_mmio_ffs</span><span class="p">;</span>	<span class="cm">/* Total EEH checks		*/</span>
	<span class="n">u64</span> <span class="n">false_positives</span><span class="p">;</span>	<span class="cm">/* Unnecessary EEH checks	*/</span>
	<span class="n">u64</span> <span class="n">slot_resets</span><span class="p">;</span>	<span class="cm">/* PE reset			*/</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">eeh_stats</span> <span class="n">eeh_stats</span><span class="p">;</span>

<span class="cp">#define IS_BRIDGE(class_code) (((class_code)&lt;&lt;16) == PCI_BASE_CLASS_BRIDGE)</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_gather_pci_data - Copy assorted PCI config space registers to buff</span>
<span class="cm"> * @edev: device to report data for</span>
<span class="cm"> * @buf: point to buffer in which to log</span>
<span class="cm"> * @len: amount of room in buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This routine captures assorted PCI configuration space data,</span>
<span class="cm"> * and puts them into a buffer for RTAS error logging.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">eeh_gather_pci_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span> <span class="o">=</span> <span class="n">eeh_dev_to_of_node</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">eeh_dev_to_pci_dev</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">cfg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cap</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: of node=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>

	<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">read_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">PCI_VENDOR_ID</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="s">&quot;dev/vend:%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: PCI device/vendor: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>

	<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">read_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="s">&quot;cmd/stat:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: PCI cmd/status register: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: no PCI device for this of node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Gather bridge-specific registers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="o">==</span> <span class="n">PCI_BASE_CLASS_BRIDGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">read_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">PCI_SEC_STATUS</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="s">&quot;sec stat:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: Bridge secondary status: %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>

		<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">read_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">PCI_BRIDGE_CONTROL</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="s">&quot;brdg ctl:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: Bridge control: %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Dump out the PCI-X command and status regs */</span>
	<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_PCIX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">read_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="s">&quot;pcix-cmd:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: PCI-X cmd: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>

		<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">read_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">cap</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="s">&quot;pcix-stat:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: PCI-X status: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If PCI-E capable, dump PCI-E cap 10, and the AER */</span>
	<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_EXP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="s">&quot;pci-e cap10:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;EEH: PCI-E capabilities and status follow:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">read_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">cap</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>
			<span class="n">n</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="s">&quot;%02x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: PCI-E %02x: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_find_ext_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_EXT_CAP_ID_ERR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="s">&quot;pci-e AER:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;EEH: PCI-E AER capability register set follows:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">14</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">read_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">cap</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>
				<span class="n">n</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="s">&quot;%02x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: PCI-E AER %02x: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Gather status on devices under the bridge */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="o">==</span> <span class="n">PCI_BASE_CLASS_BRIDGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>

		<span class="n">for_each_child_of_node</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
				<span class="n">n</span> <span class="o">+=</span> <span class="n">eeh_gather_pci_data</span><span class="p">(</span><span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">child</span><span class="p">),</span> <span class="n">buf</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">n</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_slot_error_detail - Generate combined log including driver log and error log</span>
<span class="cm"> * @edev: device to report error log for</span>
<span class="cm"> * @severity: temporary or permanent error log</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should be called to generate the combined log, which</span>
<span class="cm"> * is comprised of driver log and error log. The driver log is figured</span>
<span class="cm"> * out from the config space of the corresponding PCI device, while</span>
<span class="cm"> * the error log is fetched through platform dependent function call.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">eeh_slot_error_detail</span><span class="p">(</span><span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">severity</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">loglen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pci_regs_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">eeh_pci_enable</span><span class="p">(</span><span class="n">edev</span><span class="p">,</span> <span class="n">EEH_OPT_THAW_MMIO</span><span class="p">);</span>
	<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">configure_bridge</span><span class="p">(</span><span class="n">eeh_dev_to_of_node</span><span class="p">(</span><span class="n">edev</span><span class="p">));</span>
	<span class="n">eeh_restore_bars</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span>
	<span class="n">loglen</span> <span class="o">=</span> <span class="n">eeh_gather_pci_data</span><span class="p">(</span><span class="n">edev</span><span class="p">,</span> <span class="n">pci_regs_buf</span><span class="p">,</span> <span class="n">EEH_PCI_REGS_LOG_LEN</span><span class="p">);</span>

	<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">get_log</span><span class="p">(</span><span class="n">eeh_dev_to_of_node</span><span class="p">(</span><span class="n">edev</span><span class="p">),</span> <span class="n">severity</span><span class="p">,</span> <span class="n">pci_regs_buf</span><span class="p">,</span> <span class="n">loglen</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_token_to_phys - Convert EEH address token to phys address</span>
<span class="cm"> * @token: I/O token, should be address in the form 0xA....</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should be called to convert virtual I/O address</span>
<span class="cm"> * to physical one.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">eeh_token_to_phys</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pa</span><span class="p">;</span>

	<span class="n">ptep</span> <span class="o">=</span> <span class="n">find_linux_pte</span><span class="p">(</span><span class="n">init_mm</span><span class="p">.</span><span class="n">pgd</span><span class="p">,</span> <span class="n">token</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptep</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">token</span><span class="p">;</span>
	<span class="n">pa</span> <span class="o">=</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pa</span> <span class="o">|</span> <span class="p">(</span><span class="n">token</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_find_device_pe - Retrieve the PE for the given device</span>
<span class="cm"> * @dn: device node</span>
<span class="cm"> *</span>
<span class="cm"> * Return the PE under which this device lies</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">eeh_find_device_pe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">EEH_MODE_SUPPORTED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dn</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __eeh_mark_slot - Mark all child devices as failed</span>
<span class="cm"> * @parent: parent device</span>
<span class="cm"> * @mode_flag: failure flag</span>
<span class="cm"> *</span>
<span class="cm"> * Mark all devices that are children of this device as failed.</span>
<span class="cm"> * Mark the device driver too, so that it can see the failure</span>
<span class="cm"> * immediately; this is critical, since some drivers poll</span>
<span class="cm"> * status registers in interrupts ... If a driver is polling,</span>
<span class="cm"> * and the slot is frozen, then the driver can deadlock in</span>
<span class="cm"> * an interrupt context, which is bad.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__eeh_mark_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode_flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>

	<span class="n">for_each_child_of_node</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">dn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Mark the pci device driver too */</span>
			<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

			<span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">mode_flag</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">error_state</span> <span class="o">=</span> <span class="n">pci_channel_io_frozen</span><span class="p">;</span>

			<span class="n">__eeh_mark_slot</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">mode_flag</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_mark_slot - Mark the indicated device and its children as failed</span>
<span class="cm"> * @dn: parent device</span>
<span class="cm"> * @mode_flag: failure flag</span>
<span class="cm"> *</span>
<span class="cm"> * Mark the indicated device and its child devices as failed.</span>
<span class="cm"> * The device drivers are marked as failed as well.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">eeh_mark_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode_flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">dn</span> <span class="o">=</span> <span class="n">eeh_find_device_pe</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>

	<span class="cm">/* Back up one, since config addrs might be shared */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcibios_find_pci_bus</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">))</span>
		<span class="n">dn</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">mode_flag</span><span class="p">;</span>

	<span class="cm">/* Mark the pci device too */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">error_state</span> <span class="o">=</span> <span class="n">pci_channel_io_frozen</span><span class="p">;</span>

	<span class="n">__eeh_mark_slot</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">mode_flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __eeh_clear_slot - Clear failure flag for the child devices</span>
<span class="cm"> * @parent: parent device</span>
<span class="cm"> * @mode_flag: flag to be cleared</span>
<span class="cm"> *</span>
<span class="cm"> * Clear failure flag for the child devices.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__eeh_clear_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode_flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>

	<span class="n">for_each_child_of_node</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">dn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mode_flag</span><span class="p">;</span>
			<span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">__eeh_clear_slot</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">mode_flag</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_clear_slot - Clear failure flag for the indicated device and its children</span>
<span class="cm"> * @dn: parent device</span>
<span class="cm"> * @mode_flag: flag to be cleared</span>
<span class="cm"> *</span>
<span class="cm"> * Clear failure flag for the indicated device and its children.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">eeh_clear_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode_flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">confirm_error_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	
	<span class="n">dn</span> <span class="o">=</span> <span class="n">eeh_find_device_pe</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
	
	<span class="cm">/* Back up one, since config addrs might be shared */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcibios_find_pci_bus</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">))</span>
		<span class="n">dn</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mode_flag</span><span class="p">;</span>
	<span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__eeh_clear_slot</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">mode_flag</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">confirm_error_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_dn_check_failure - Check if all 1&#39;s data is due to EEH slot freeze</span>
<span class="cm"> * @dn: device node</span>
<span class="cm"> * @dev: pci device, if known</span>
<span class="cm"> *</span>
<span class="cm"> * Check for an EEH failure for the given device node.  Call this</span>
<span class="cm"> * routine if the result of a read was all 0xff&#39;s and you want to</span>
<span class="cm"> * find out if this is due to an EEH slot freeze.  This routine</span>
<span class="cm"> * will query firmware for the EEH status.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if there has not been an EEH error; otherwise returns</span>
<span class="cm"> * a non-zero value and queues up a slot isolation event notification.</span>
<span class="cm"> *</span>
<span class="cm"> * It is safe to call this routine in an interrupt context.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">eeh_dn_check_failure</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">location</span><span class="p">;</span>

	<span class="n">eeh_stats</span><span class="p">.</span><span class="n">total_mmio_ffs</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eeh_subsystem_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eeh_stats</span><span class="p">.</span><span class="n">no_dn</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dn</span> <span class="o">=</span> <span class="n">eeh_find_device_pe</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
	<span class="n">edev</span> <span class="o">=</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>

	<span class="cm">/* Access to IO BARs might get this far and still not want checking. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">EEH_MODE_SUPPORTED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">edev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">EEH_MODE_NOCHECK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eeh_stats</span><span class="p">.</span><span class="n">ignored_check</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EEH: Ignored check (%x) for %s %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">edev</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">,</span> <span class="n">eeh_pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">config_addr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">pe_config_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eeh_stats</span><span class="p">.</span><span class="n">no_cfg_addr</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we already have a pending isolation event for this</span>
<span class="cm">	 * slot, we know it&#39;s bad already, we don&#39;t need to check.</span>
<span class="cm">	 * Do this checking under a lock; as multiple PCI devices</span>
<span class="cm">	 * in one slot might report errors simultaneously, and we</span>
<span class="cm">	 * only want one error recovery routine running.</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">confirm_error_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">EEH_MODE_ISOLATED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">edev</span><span class="o">-&gt;</span><span class="n">check_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">check_count</span> <span class="o">%</span> <span class="n">EEH_MAX_FAILS</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">location</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="s">&quot;ibm,loc-code&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;EEH: %d reads ignored for recovering device at &quot;</span>
				<span class="s">&quot;location=%s driver=%s pci addr=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">edev</span><span class="o">-&gt;</span><span class="n">check_count</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span>
				<span class="n">eeh_driver_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">eeh_pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;EEH: Might be infinite loop in %s driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">eeh_driver_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
			<span class="n">dump_stack</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">dn_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now test for an EEH failure.  This is VERY expensive.</span>
<span class="cm">	 * Note that the eeh_config_addr may be a parent device</span>
<span class="cm">	 * in the case of a device behind a bridge, or it may be</span>
<span class="cm">	 * function zero of a multi-function device.</span>
<span class="cm">	 * In any case they must share a common PHB.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">get_state</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Note that config-io to empty slots may fail;</span>
<span class="cm">	 * they are empty when they don&#39;t have children.</span>
<span class="cm">	 * We will punt with the following conditions: Failure to get</span>
<span class="cm">	 * PE&#39;s state, EEH not support and Permanently unavailable</span>
<span class="cm">	 * state, PE is in good state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">EEH_STATE_NOT_SUPPORT</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EEH_STATE_MMIO_ACTIVE</span> <span class="o">|</span> <span class="n">EEH_STATE_DMA_ACTIVE</span><span class="p">))</span> <span class="o">==</span>
	    <span class="p">(</span><span class="n">EEH_STATE_MMIO_ACTIVE</span> <span class="o">|</span> <span class="n">EEH_STATE_DMA_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">eeh_stats</span><span class="p">.</span><span class="n">false_positives</span><span class="o">++</span><span class="p">;</span>
		<span class="n">edev</span><span class="o">-&gt;</span><span class="n">false_positives</span> <span class="o">++</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">dn_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">eeh_stats</span><span class="p">.</span><span class="n">slot_resets</span><span class="o">++</span><span class="p">;</span>
 
	<span class="cm">/* Avoid repeated reports of this failure, including problems</span>
<span class="cm">	 * with other functions on this device, and functions under</span>
<span class="cm">	 * bridges.</span>
<span class="cm">	 */</span>
	<span class="n">eeh_mark_slot</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">EEH_MODE_ISOLATED</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">confirm_error_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">eeh_send_failure_event</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span>

	<span class="cm">/* Most EEH events are due to device driver bugs.  Having</span>
<span class="cm">	 * a stack trace will help the device-driver authors figure</span>
<span class="cm">	 * out what happened.  So print that out.</span>
<span class="cm">	 */</span>
	<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;EEH: failure detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">dn_unlock:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">confirm_error_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">eeh_dn_check_failure</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_check_failure - Check if all 1&#39;s data is due to EEH slot freeze</span>
<span class="cm"> * @token: I/O token, should be address in the form 0xA....</span>
<span class="cm"> * @val: value, should be all 1&#39;s (XXX why do we need this arg??)</span>
<span class="cm"> *</span>
<span class="cm"> * Check for an EEH failure at the given token address.  Call this</span>
<span class="cm"> * routine if the result of a read was all 0xff&#39;s and you want to</span>
<span class="cm"> * find out if this is due to an EEH slot freeze event.  This routine</span>
<span class="cm"> * will query firmware for the EEH status.</span>
<span class="cm"> *</span>
<span class="cm"> * Note this routine is safe to call in an interrupt context.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">eeh_check_failure</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">token</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>

	<span class="cm">/* Finding the phys addr + pci device; this is pretty quick. */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">eeh_token_to_phys</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__force</span><span class="p">)</span> <span class="n">token</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">pci_addr_cache_get_device</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eeh_stats</span><span class="p">.</span><span class="n">no_device</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dn</span> <span class="o">=</span> <span class="n">pci_device_to_OF_node</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">eeh_dn_check_failure</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">eeh_check_failure</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * eeh_pci_enable - Enable MMIO or DMA transfers for this slot</span>
<span class="cm"> * @edev: pci device node</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should be called to reenable frozen MMIO or DMA</span>
<span class="cm"> * so that it would work correctly again. It&#39;s useful while doing</span>
<span class="cm"> * recovery or log collection on the indicated device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">eeh_pci_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span> <span class="o">=</span> <span class="n">eeh_dev_to_of_node</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">set_option</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">function</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: Unexpected state change %d, err=%d dn=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		        <span class="n">function</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">wait_state</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">PCI_BUS_RESET_WAIT_MSEC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;</span> <span class="n">EEH_STATE_MMIO_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="p">(</span><span class="n">function</span> <span class="o">==</span> <span class="n">EEH_OPT_THAW_MMIO</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcibios_set_pcie_slot_reset - Set PCI-E reset state</span>
<span class="cm"> * @dev: pci device struct</span>
<span class="cm"> * @state: reset state to enter</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> * 	0 if success</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pcibios_set_pcie_reset_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pcie_reset_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span> <span class="o">=</span> <span class="n">pci_device_to_OF_node</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">pcie_deassert_reset</span>:
		<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">EEH_RESET_DEACTIVATE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">pcie_hot_reset</span>:
		<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">EEH_RESET_HOT</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">pcie_warm_reset</span>:
		<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">EEH_RESET_FUNDAMENTAL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __eeh_set_pe_freset - Check the required reset for child devices</span>
<span class="cm"> * @parent: parent device</span>
<span class="cm"> * @freset: return value</span>
<span class="cm"> *</span>
<span class="cm"> * Each device might have its preferred reset type: fundamental or</span>
<span class="cm"> * hot reset. The routine is used to collect the information from</span>
<span class="cm"> * the child devices so that they could be reset accordingly.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__eeh_set_pe_freset</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">freset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>

	<span class="n">for_each_child_of_node</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">dn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
				<span class="o">*</span><span class="n">freset</span> <span class="o">|=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">needs_freset</span><span class="p">;</span>

			<span class="n">__eeh_set_pe_freset</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">freset</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_set_pe_freset - Check the required reset for the indicated device and its children</span>
<span class="cm"> * @dn: parent device</span>
<span class="cm"> * @freset: return value</span>
<span class="cm"> *</span>
<span class="cm"> * Each device might have its preferred reset type: fundamental or</span>
<span class="cm"> * hot reset. The routine is used to collected the information for</span>
<span class="cm"> * the indicated device and its children so that the bunch of the</span>
<span class="cm"> * devices could be reset properly.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">eeh_set_pe_freset</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">freset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">dn</span> <span class="o">=</span> <span class="n">eeh_find_device_pe</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>

	<span class="cm">/* Back up one, since config addrs might be shared */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcibios_find_pci_bus</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">))</span>
		<span class="n">dn</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="o">*</span><span class="n">freset</span> <span class="o">|=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">needs_freset</span><span class="p">;</span>

	<span class="n">__eeh_set_pe_freset</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">freset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_reset_pe_once - Assert the pci #RST line for 1/4 second</span>
<span class="cm"> * @edev: pci device node to be reset.</span>
<span class="cm"> *</span>
<span class="cm"> * Assert the PCI #RST line for 1/4 second.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">eeh_reset_pe_once</span><span class="p">(</span><span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span> <span class="o">=</span> <span class="n">eeh_dev_to_of_node</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span>

	<span class="cm">/* Determine type of EEH reset required for</span>
<span class="cm">	 * Partitionable Endpoint, a hot-reset (1)</span>
<span class="cm">	 * or a fundamental reset (3).</span>
<span class="cm">	 * A fundamental reset required by any device under</span>
<span class="cm">	 * Partitionable Endpoint trumps hot-reset.</span>
<span class="cm">  	 */</span>
	<span class="n">eeh_set_pe_freset</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">freset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">freset</span><span class="p">)</span>
		<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">EEH_RESET_FUNDAMENTAL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">EEH_RESET_HOT</span><span class="p">);</span>

	<span class="cm">/* The PCI bus requires that the reset be held high for at least</span>
<span class="cm">	 * a 100 milliseconds. We wait a bit longer &#39;just in case&#39;.</span>
<span class="cm">	 */</span>
<span class="cp">#define PCI_BUS_RST_HOLD_TIME_MSEC 250</span>
	<span class="n">msleep</span><span class="p">(</span><span class="n">PCI_BUS_RST_HOLD_TIME_MSEC</span><span class="p">);</span>
	
	<span class="cm">/* We might get hit with another EEH freeze as soon as the </span>
<span class="cm">	 * pci slot reset line is dropped. Make sure we don&#39;t miss</span>
<span class="cm">	 * these, and clear the flag now.</span>
<span class="cm">	 */</span>
	<span class="n">eeh_clear_slot</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">EEH_MODE_ISOLATED</span><span class="p">);</span>

	<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">EEH_RESET_DEACTIVATE</span><span class="p">);</span>

	<span class="cm">/* After a PCI slot has been reset, the PCI Express spec requires</span>
<span class="cm">	 * a 1.5 second idle time for the bus to stabilize, before starting</span>
<span class="cm">	 * up traffic.</span>
<span class="cm">	 */</span>
<span class="cp">#define PCI_BUS_SETTLE_TIME_MSEC 1800</span>
	<span class="n">msleep</span><span class="p">(</span><span class="n">PCI_BUS_SETTLE_TIME_MSEC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_reset_pe - Reset the indicated PE</span>
<span class="cm"> * @edev: PCI device associated EEH device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should be called to reset indicated device, including</span>
<span class="cm"> * PE. A PE might include multiple PCI devices and sometimes PCI bridges</span>
<span class="cm"> * might be involved as well.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">eeh_reset_pe</span><span class="p">(</span><span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span> <span class="o">=</span> <span class="n">eeh_dev_to_of_node</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span>

	<span class="cm">/* Take three shots at resetting the bus */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eeh_reset_pe_once</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">wait_state</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">PCI_BUS_RESET_WAIT_MSEC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="p">(</span><span class="n">EEH_STATE_MMIO_ACTIVE</span> <span class="o">|</span> <span class="n">EEH_STATE_DMA_ACTIVE</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;EEH: unrecoverable slot failure %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;EEH: bus reset %d failed on slot %s, rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** Save and restore of PCI BARs</span>
<span class="cm"> *</span>
<span class="cm"> * Although firmware will set up BARs during boot, it doesn&#39;t</span>
<span class="cm"> * set up device BAR&#39;s after a device reset, although it will,</span>
<span class="cm"> * if requested, set up bridge configuration. Thus, we need to</span>
<span class="cm"> * configure the PCI devices ourselves.  </span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_restore_one_device_bars - Restore the Base Address Registers for one device</span>
<span class="cm"> * @edev: PCI device associated EEH device</span>
<span class="cm"> *</span>
<span class="cm"> * Loads the PCI configuration space base address registers,</span>
<span class="cm"> * the expansion ROM base address, the latency timer, and etc.</span>
<span class="cm"> * from the saved values in the device node.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">eeh_restore_one_device_bars</span><span class="p">(</span><span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span> <span class="o">=</span> <span class="n">eeh_dev_to_of_node</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">phb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">write_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">edev</span><span class="o">-&gt;</span><span class="n">config_space</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* 12 == Expansion ROM Address */</span>
	<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">write_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="mi">12</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">edev</span><span class="o">-&gt;</span><span class="n">config_space</span><span class="p">[</span><span class="mi">12</span><span class="p">]);</span>

<span class="cp">#define BYTE_SWAP(OFF) (8*((OFF)/4)+3-(OFF))</span>
<span class="cp">#define SAVED_BYTE(OFF) (((u8 *)(edev-&gt;config_space))[BYTE_SWAP(OFF)])</span>

	<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">write_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">PCI_CACHE_LINE_SIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
	            <span class="n">SAVED_BYTE</span><span class="p">(</span><span class="n">PCI_CACHE_LINE_SIZE</span><span class="p">));</span>

	<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">write_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
	            <span class="n">SAVED_BYTE</span><span class="p">(</span><span class="n">PCI_LATENCY_TIMER</span><span class="p">));</span>

	<span class="cm">/* max latency, min grant, interrupt pin and line */</span>
	<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">write_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="mi">15</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">edev</span><span class="o">-&gt;</span><span class="n">config_space</span><span class="p">[</span><span class="mi">15</span><span class="p">]);</span>

	<span class="cm">/* Restore PERR &amp; SERR bits, some devices require it,</span>
<span class="cm">	 * don&#39;t touch the other command bits</span>
<span class="cm">	 */</span>
	<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">read_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">config_space</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_PARITY</span><span class="p">)</span>
		<span class="n">cmd</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_PARITY</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cmd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_COMMAND_PARITY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">config_space</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_SERR</span><span class="p">)</span>
		<span class="n">cmd</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_SERR</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cmd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_COMMAND_SERR</span><span class="p">;</span>
	<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">write_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_restore_bars - Restore the PCI config space info</span>
<span class="cm"> * @edev: EEH device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine performs a recursive walk to the children</span>
<span class="cm"> * of this device as well.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">eeh_restore_bars</span><span class="p">(</span><span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">edev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">((</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">EEH_MODE_SUPPORTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_BRIDGE</span><span class="p">(</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">class_code</span><span class="p">))</span>
		<span class="n">eeh_restore_one_device_bars</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span>

	<span class="n">for_each_child_of_node</span><span class="p">(</span><span class="n">eeh_dev_to_of_node</span><span class="p">(</span><span class="n">edev</span><span class="p">),</span> <span class="n">dn</span><span class="p">)</span>
		<span class="n">eeh_restore_bars</span><span class="p">(</span><span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_save_bars - Save device bars</span>
<span class="cm"> * @edev: PCI device associated EEH device</span>
<span class="cm"> *</span>
<span class="cm"> * Save the values of the device bars. Unlike the restore</span>
<span class="cm"> * routine, this routine is *not* recursive. This is because</span>
<span class="cm"> * PCI devices are added individually; but, for the restore,</span>
<span class="cm"> * an entire slot is reset at a time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">eeh_save_bars</span><span class="p">(</span><span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">edev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dn</span> <span class="o">=</span> <span class="n">eeh_dev_to_of_node</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span>
	
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">read_config</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">config_space</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_early_enable - Early enable EEH on the indicated device</span>
<span class="cm"> * @dn: device node</span>
<span class="cm"> * @data: BUID</span>
<span class="cm"> *</span>
<span class="cm"> * Enable EEH functionality on the specified PCI device. The function</span>
<span class="cm"> * is expected to be called before real PCI probing is done. However,</span>
<span class="cm"> * the PHBs have been initialized at this point.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">eeh_early_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">class_code</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="s">&quot;class-code&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">vendor_id</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="s">&quot;vendor-id&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">device_id</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="s">&quot;device-id&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">enable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span> <span class="o">=</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>

	<span class="n">edev</span><span class="o">-&gt;</span><span class="n">class_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">edev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">edev</span><span class="o">-&gt;</span><span class="n">check_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">edev</span><span class="o">-&gt;</span><span class="n">freeze_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">edev</span><span class="o">-&gt;</span><span class="n">false_positives</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_device_is_available</span><span class="p">(</span><span class="n">dn</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Ignore bad nodes. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">class_code</span> <span class="o">||</span> <span class="o">!</span><span class="n">vendor_id</span> <span class="o">||</span> <span class="o">!</span><span class="n">device_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* There is nothing to check on PCI to ISA bridges */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;isa&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">edev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">EEH_MODE_NOCHECK</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">edev</span><span class="o">-&gt;</span><span class="n">class_code</span> <span class="o">=</span> <span class="o">*</span><span class="n">class_code</span><span class="p">;</span>

	<span class="cm">/* Ok... see if this device supports EEH.  Some do, some don&#39;t,</span>
<span class="cm">	 * and the only way to find out is to check each and every one.</span>
<span class="cm">	 */</span>
	<span class="n">regs</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* First register entry is addr (00BBSS00)  */</span>
		<span class="cm">/* Try to enable eeh */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">set_option</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">EEH_OPT_ENABLE</span><span class="p">);</span>

		<span class="n">enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">edev</span><span class="o">-&gt;</span><span class="n">config_addr</span> <span class="o">=</span> <span class="n">regs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

			<span class="cm">/* If the newer, better, ibm,get-config-addr-info is supported, </span>
<span class="cm">			 * then use that instead.</span>
<span class="cm">			 */</span>
			<span class="n">edev</span><span class="o">-&gt;</span><span class="n">pe_config_addr</span> <span class="o">=</span> <span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">get_pe_addr</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>

			<span class="cm">/* Some older systems (Power4) allow the</span>
<span class="cm">			 * ibm,set-eeh-option call to succeed even on nodes</span>
<span class="cm">			 * where EEH is not supported. Verify support</span>
<span class="cm">			 * explicitly.</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">get_state</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="n">EEH_STATE_NOT_SUPPORT</span><span class="p">)</span>
				<span class="n">enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eeh_subsystem_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">edev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">EEH_MODE_SUPPORTED</span><span class="p">;</span>

			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EEH: %s: eeh enabled, config=%x pe_config=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span> <span class="n">edev</span><span class="o">-&gt;</span><span class="n">config_addr</span><span class="p">,</span>
				 <span class="n">edev</span><span class="o">-&gt;</span><span class="n">pe_config_addr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

			<span class="cm">/* This device doesn&#39;t support EEH, but it may have an</span>
<span class="cm">			 * EEH parent, in which case we mark it as supported.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">EEH_MODE_SUPPORTED</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Parent supports EEH. */</span>
				<span class="n">edev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">EEH_MODE_SUPPORTED</span><span class="p">;</span>
				<span class="n">edev</span><span class="o">-&gt;</span><span class="n">config_addr</span> <span class="o">=</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">config_addr</span><span class="p">;</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: %s: unable to get reg property.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">eeh_save_bars</span><span class="p">(</span><span class="n">edev</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_ops_register - Register platform dependent EEH operations</span>
<span class="cm"> * @ops: platform dependent EEH operations</span>
<span class="cm"> *</span>
<span class="cm"> * Register the platform dependent EEH operation callback</span>
<span class="cm"> * functions. The platform should call this function before</span>
<span class="cm"> * any other EEH operations.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">eeh_ops_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">eeh_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Invalid EEH ops name for %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eeh_ops</span> <span class="o">&amp;&amp;</span> <span class="n">eeh_ops</span> <span class="o">!=</span> <span class="n">ops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: EEH ops of platform %s already existing (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">eeh_ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_ops_unregister - Unreigster platform dependent EEH operations</span>
<span class="cm"> * @name: name of EEH platform operations</span>
<span class="cm"> *</span>
<span class="cm"> * Unregister the platform dependent EEH operation callback</span>
<span class="cm"> * functions.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__exit</span> <span class="nf">eeh_ops_unregister</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span> <span class="o">||</span> <span class="o">!</span><span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Invalid EEH ops name</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eeh_ops</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">eeh_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_init - EEH initialization</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize EEH by trying to enable it for all of the adapters in the system.</span>
<span class="cm"> * As a side effect we can determine here if eeh is supported at all.</span>
<span class="cm"> * Note that we leave EEH on so failed config cycles won&#39;t cause a machine</span>
<span class="cm"> * check.  If a user turns off EEH for a particular adapter they are really</span>
<span class="cm"> * telling Linux to ignore errors.  Some hardware (e.g. POWER5) won&#39;t</span>
<span class="cm"> * grant access to a slot if EEH isn&#39;t enabled, and so we always enable</span>
<span class="cm"> * EEH for all slots/all devices.</span>
<span class="cm"> *</span>
<span class="cm"> * The eeh-force-off option disables EEH checking globally, for all slots.</span>
<span class="cm"> * Even if force-off is set, the EEH hardware is still enabled, so that</span>
<span class="cm"> * newer systems can boot.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">eeh_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">hose</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">phb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* call platform initialization function */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eeh_ops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Platform EEH operation not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">eeh_ops</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">()))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Failed to call platform init function (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">confirm_error_lock</span><span class="p">);</span>

	<span class="cm">/* Enable EEH for all adapters */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">hose</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hose_list</span><span class="p">,</span> <span class="n">list_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phb</span> <span class="o">=</span> <span class="n">hose</span><span class="o">-&gt;</span><span class="n">dn</span><span class="p">;</span>
		<span class="n">traverse_pci_devices</span><span class="p">(</span><span class="n">phb</span><span class="p">,</span> <span class="n">eeh_early_enable</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eeh_subsystem_enabled</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;EEH: PCI Enhanced I/O Error Handling Enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;EEH: No capable adapters found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_add_device_early - Enable EEH for the indicated device_node</span>
<span class="cm"> * @dn: device node for which to set up EEH</span>
<span class="cm"> *</span>
<span class="cm"> * This routine must be used to perform EEH initialization for PCI</span>
<span class="cm"> * devices that were added after system boot (e.g. hotplug, dlpar).</span>
<span class="cm"> * This routine must be called before any i/o is performed to the</span>
<span class="cm"> * adapter (inluding any config-space i/o).</span>
<span class="cm"> * Whether this actually enables EEH or not for this device depends</span>
<span class="cm"> * on the CEC architecture, type of the device, on earlier boot</span>
<span class="cm"> * command-line arguments &amp; etc.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">eeh_add_device_early</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">phb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dn</span> <span class="o">||</span> <span class="o">!</span><span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">phb</span> <span class="o">=</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phb</span><span class="p">;</span>

	<span class="cm">/* USB Bus children of PCI devices will not have BUID&#39;s */</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">phb</span> <span class="o">||</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">phb</span><span class="o">-&gt;</span><span class="n">buid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">eeh_early_enable</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_add_device_tree_early - Enable EEH for the indicated device</span>
<span class="cm"> * @dn: device node</span>
<span class="cm"> *</span>
<span class="cm"> * This routine must be used to perform EEH initialization for the</span>
<span class="cm"> * indicated PCI device that was added after system boot (e.g.</span>
<span class="cm"> * hotplug, dlpar).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">eeh_add_device_tree_early</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">sib</span><span class="p">;</span>

	<span class="n">for_each_child_of_node</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">sib</span><span class="p">)</span>
		<span class="n">eeh_add_device_tree_early</span><span class="p">(</span><span class="n">sib</span><span class="p">);</span>
	<span class="n">eeh_add_device_early</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">eeh_add_device_tree_early</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_add_device_late - Perform EEH initialization for the indicated pci device</span>
<span class="cm"> * @dev: pci device for which to set up EEH</span>
<span class="cm"> *</span>
<span class="cm"> * This routine must be used to complete EEH initialization for PCI</span>
<span class="cm"> * devices that were added after system boot (e.g. hotplug, dlpar).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">eeh_add_device_late</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">eeh_subsystem_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EEH: Adding device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="n">dn</span> <span class="o">=</span> <span class="n">pci_device_to_OF_node</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">edev</span> <span class="o">=</span> <span class="n">of_node_to_eeh_dev</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EEH: Already referenced !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pci_dev_get</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">edev</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">archdata</span><span class="p">.</span><span class="n">edev</span> <span class="o">=</span> <span class="n">edev</span><span class="p">;</span>

	<span class="n">pci_addr_cache_insert_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">eeh_sysfs_add_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_add_device_tree_late - Perform EEH initialization for the indicated PCI bus</span>
<span class="cm"> * @bus: PCI bus</span>
<span class="cm"> *</span>
<span class="cm"> * This routine must be used to perform EEH initialization for PCI</span>
<span class="cm"> * devices which are attached to the indicated PCI bus. The PCI bus</span>
<span class="cm"> * is added after system boot through hotplug or dlpar.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">eeh_add_device_tree_late</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">bus_list</span><span class="p">)</span> <span class="p">{</span>
 		<span class="n">eeh_add_device_late</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
 		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hdr_type</span> <span class="o">==</span> <span class="n">PCI_HEADER_TYPE_BRIDGE</span><span class="p">)</span> <span class="p">{</span>
 			<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">subbus</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="p">;</span>
 			<span class="k">if</span> <span class="p">(</span><span class="n">subbus</span><span class="p">)</span>
 				<span class="n">eeh_add_device_tree_late</span><span class="p">(</span><span class="n">subbus</span><span class="p">);</span>
 		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">eeh_add_device_tree_late</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_remove_device - Undo EEH setup for the indicated pci device</span>
<span class="cm"> * @dev: pci device to be removed</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should be called when a device is removed from</span>
<span class="cm"> * a running system (e.g. by hotplug or dlpar).  It unregisters</span>
<span class="cm"> * the PCI device from the EEH subsystem.  I/O errors affecting</span>
<span class="cm"> * this device will no longer be detected after this call; thus,</span>
<span class="cm"> * i/o errors affecting this slot may leave this device unusable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">eeh_remove_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">eeh_subsystem_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">edev</span> <span class="o">=</span> <span class="n">pci_dev_to_eeh_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Unregister the device with the EEH/PCI address search system */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EEH: Removing device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">edev</span> <span class="o">||</span> <span class="o">!</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EEH: Not referenced !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">edev</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">archdata</span><span class="p">.</span><span class="n">edev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_addr_cache_remove_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">eeh_sysfs_remove_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eeh_remove_bus_device - Undo EEH setup for the indicated PCI device</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This routine must be called when a device is removed from the</span>
<span class="cm"> * running system through hotplug or dlpar. The corresponding</span>
<span class="cm"> * PCI address cache will be removed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">eeh_remove_bus_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">eeh_remove_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hdr_type</span> <span class="o">==</span> <span class="n">PCI_HEADER_TYPE_BRIDGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">bus_list</span><span class="p">)</span>
			 <span class="n">eeh_remove_bus_device</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">eeh_remove_bus_device</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_eeh_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">eeh_subsystem_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;EEH Subsystem is globally disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;eeh_total_mmio_ffs=%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">eeh_stats</span><span class="p">.</span><span class="n">total_mmio_ffs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;EEH Subsystem is enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
				<span class="s">&quot;no device=%llu</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;no device node=%llu</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;no config address=%llu</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;check not wanted=%llu</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;eeh_total_mmio_ffs=%llu</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;eeh_false_positives=%llu</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;eeh_slot_resets=%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">eeh_stats</span><span class="p">.</span><span class="n">no_device</span><span class="p">,</span>
				<span class="n">eeh_stats</span><span class="p">.</span><span class="n">no_dn</span><span class="p">,</span>
				<span class="n">eeh_stats</span><span class="p">.</span><span class="n">no_cfg_addr</span><span class="p">,</span>
				<span class="n">eeh_stats</span><span class="p">.</span><span class="n">ignored_check</span><span class="p">,</span>
				<span class="n">eeh_stats</span><span class="p">.</span><span class="n">total_mmio_ffs</span><span class="p">,</span>
				<span class="n">eeh_stats</span><span class="p">.</span><span class="n">false_positives</span><span class="p">,</span>
				<span class="n">eeh_stats</span><span class="p">.</span><span class="n">slot_resets</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_eeh_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">proc_eeh_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_eeh_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>      <span class="o">=</span> <span class="n">proc_eeh_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>      <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>    <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>   <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">eeh_init_proc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">machine_is</span><span class="p">(</span><span class="n">pseries</span><span class="p">))</span>
		<span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;powerpc/eeh&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_eeh_operations</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">eeh_init_proc</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
