<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › platforms › pseries › ras.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ras.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2001 Dave Engebretsen IBM Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>

<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/rtas.h&gt;</span>
<span class="cp">#include &lt;asm/firmware.h&gt;</span>

<span class="cp">#include &quot;pseries.h&quot;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ras_log_buf</span><span class="p">[</span><span class="n">RTAS_ERROR_LOG_MAX</span><span class="p">];</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">ras_log_buf_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">global_mce_data_buf</span><span class="p">[</span><span class="n">RTAS_ERROR_LOG_MAX</span><span class="p">];</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">__u64</span><span class="p">,</span> <span class="n">mce_data_buf</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ras_check_exception_token</span><span class="p">;</span>

<span class="cp">#define EPOW_SENSOR_TOKEN	9</span>
<span class="cp">#define EPOW_SENSOR_INDEX	0</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">ras_epow_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">ras_error_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Initialize handlers for the set of interrupts caused by hardware errors</span>
<span class="cm"> * and power system events.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_ras_IRQ</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>

	<span class="n">ras_check_exception_token</span> <span class="o">=</span> <span class="n">rtas_token</span><span class="p">(</span><span class="s">&quot;check-exception&quot;</span><span class="p">);</span>

	<span class="cm">/* Internal Errors */</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/event-sources/internal-errors&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">request_event_sources_irqs</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">ras_error_interrupt</span><span class="p">,</span>
					   <span class="s">&quot;RAS_ERROR&quot;</span><span class="p">);</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* EPOW Events */</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/event-sources/epow-events&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">request_event_sources_irqs</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">ras_epow_interrupt</span><span class="p">,</span> <span class="s">&quot;RAS_EPOW&quot;</span><span class="p">);</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">init_ras_IRQ</span><span class="p">);</span>

<span class="cp">#define EPOW_SHUTDOWN_NORMAL				1</span>
<span class="cp">#define EPOW_SHUTDOWN_ON_UPS				2</span>
<span class="cp">#define EPOW_SHUTDOWN_LOSS_OF_CRITICAL_FUNCTIONS	3</span>
<span class="cp">#define EPOW_SHUTDOWN_AMBIENT_TEMPERATURE_TOO_HIGH	4</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_system_shutdown</span><span class="p">(</span><span class="kt">char</span> <span class="n">event_modifier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">event_modifier</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EPOW_SHUTDOWN_NORMAL</span>:
		<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;Firmware initiated power off&quot;</span><span class="p">);</span>
		<span class="n">orderly_poweroff</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">EPOW_SHUTDOWN_ON_UPS</span>:
		<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;Loss of power reported by firmware, system is &quot;</span>
			<span class="s">&quot;running on UPS/battery&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">EPOW_SHUTDOWN_LOSS_OF_CRITICAL_FUNCTIONS</span>:
		<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;Loss of system critical functions reported by &quot;</span>
			<span class="s">&quot;firmware&quot;</span><span class="p">);</span>
		<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;Check RTAS error log for details&quot;</span><span class="p">);</span>
		<span class="n">orderly_poweroff</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">EPOW_SHUTDOWN_AMBIENT_TEMPERATURE_TOO_HIGH</span>:
		<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;Ambient temperature too high reported by firmware&quot;</span><span class="p">);</span>
		<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;Check RTAS error log for details&quot;</span><span class="p">);</span>
		<span class="n">orderly_poweroff</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unknown power/cooling shutdown event (modifier %d)&quot;</span><span class="p">,</span>
			<span class="n">event_modifier</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">epow_errorlog</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sensor_value</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">event_modifier</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">extended_modifier</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">platform_reason</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define EPOW_RESET			0</span>
<span class="cp">#define EPOW_WARN_COOLING		1</span>
<span class="cp">#define EPOW_WARN_POWER			2</span>
<span class="cp">#define EPOW_SYSTEM_SHUTDOWN		3</span>
<span class="cp">#define EPOW_SYSTEM_HALT		4</span>
<span class="cp">#define EPOW_MAIN_ENCLOSURE		5</span>
<span class="cp">#define EPOW_POWER_OFF			7</span>

<span class="kt">void</span> <span class="nf">rtas_parse_epow_errlog</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtas_error_log</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pseries_errorlog</span> <span class="o">*</span><span class="n">pseries_log</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epow_errorlog</span> <span class="o">*</span><span class="n">epow_log</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">action_code</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">modifier</span><span class="p">;</span>

	<span class="n">pseries_log</span> <span class="o">=</span> <span class="n">get_pseries_errorlog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">PSERIES_ELOG_SECT_ID_EPOW</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pseries_log</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">epow_log</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">epow_errorlog</span> <span class="o">*</span><span class="p">)</span><span class="n">pseries_log</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">action_code</span> <span class="o">=</span> <span class="n">epow_log</span><span class="o">-&gt;</span><span class="n">sensor_value</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>	<span class="cm">/* bottom 4 bits */</span>
	<span class="n">modifier</span> <span class="o">=</span> <span class="n">epow_log</span><span class="o">-&gt;</span><span class="n">event_modifier</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>	<span class="cm">/* bottom 4 bits */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action_code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EPOW_RESET</span>:
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Non critical power or cooling issue cleared&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">EPOW_WARN_COOLING</span>:
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Non critical cooling issue reported by firmware&quot;</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Check RTAS error log for details&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">EPOW_WARN_POWER</span>:
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Non critical power issue reported by firmware&quot;</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Check RTAS error log for details&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">EPOW_SYSTEM_SHUTDOWN</span>:
		<span class="n">handle_system_shutdown</span><span class="p">(</span><span class="n">epow_log</span><span class="o">-&gt;</span><span class="n">event_modifier</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">EPOW_SYSTEM_HALT</span>:
		<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;Firmware initiated power off&quot;</span><span class="p">);</span>
		<span class="n">orderly_poweroff</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">EPOW_MAIN_ENCLOSURE</span>:
	<span class="k">case</span> <span class="n">EPOW_POWER_OFF</span>:
		<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;Critical power/cooling issue reported by firmware&quot;</span><span class="p">);</span>
		<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;Check RTAS error log for details&quot;</span><span class="p">);</span>
		<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;Immediate power off&quot;</span><span class="p">);</span>
		<span class="n">emergency_sync</span><span class="p">();</span>
		<span class="n">kernel_power_off</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unknown power/cooling event (action code %d)&quot;</span><span class="p">,</span>
			<span class="n">action_code</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Handle environmental and power warning (EPOW) interrupts. */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ras_epow_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">critical</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">rtas_get_sensor</span><span class="p">(</span><span class="n">EPOW_SENSOR_TOKEN</span><span class="p">,</span> <span class="n">EPOW_SENSOR_INDEX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">critical</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Time Critical */</span>
	<span class="k">else</span>
		<span class="n">critical</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ras_log_buf_lock</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">ras_check_exception_token</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			   <span class="n">RTAS_VECTOR_EXTERNAL_INTERRUPT</span><span class="p">,</span>
			   <span class="n">virq_to_hw</span><span class="p">(</span><span class="n">irq</span><span class="p">),</span>
			   <span class="n">RTAS_EPOW_WARNING</span><span class="p">,</span>
			   <span class="n">critical</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ras_log_buf</span><span class="p">),</span>
				<span class="n">rtas_get_error_log_max</span><span class="p">());</span>

	<span class="n">log_error</span><span class="p">(</span><span class="n">ras_log_buf</span><span class="p">,</span> <span class="n">ERR_TYPE_RTAS_LOG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">rtas_parse_epow_errlog</span><span class="p">((</span><span class="k">struct</span> <span class="n">rtas_error_log</span> <span class="o">*</span><span class="p">)</span><span class="n">ras_log_buf</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ras_log_buf_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle hardware error interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * RTAS check-exception is called to collect data on the exception.  If</span>
<span class="cm"> * the error is deemed recoverable, we log a warning and return.</span>
<span class="cm"> * For nonrecoverable errors, an error is logged and we stop all processing</span>
<span class="cm"> * as quickly as possible in order to prevent propagation of the failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ras_error_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rtas_error_log</span> <span class="o">*</span><span class="n">rtas_elog</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fatal</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ras_log_buf_lock</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">ras_check_exception_token</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			   <span class="n">RTAS_VECTOR_EXTERNAL_INTERRUPT</span><span class="p">,</span>
			   <span class="n">virq_to_hw</span><span class="p">(</span><span class="n">irq</span><span class="p">),</span>
			   <span class="n">RTAS_INTERNAL_ERROR</span><span class="p">,</span> <span class="mi">1</span> <span class="cm">/* Time Critical */</span><span class="p">,</span>
			   <span class="n">__pa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ras_log_buf</span><span class="p">),</span>
				<span class="n">rtas_get_error_log_max</span><span class="p">());</span>

	<span class="n">rtas_elog</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rtas_error_log</span> <span class="o">*</span><span class="p">)</span><span class="n">ras_log_buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rtas_elog</span><span class="o">-&gt;</span><span class="n">severity</span> <span class="o">&gt;=</span> <span class="n">RTAS_SEVERITY_ERROR_SYNC</span><span class="p">))</span>
		<span class="n">fatal</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">fatal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* format and print the extended information */</span>
	<span class="n">log_error</span><span class="p">(</span><span class="n">ras_log_buf</span><span class="p">,</span> <span class="n">ERR_TYPE_RTAS_LOG</span><span class="p">,</span> <span class="n">fatal</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fatal</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;Fatal hardware error reported by firmware&quot;</span><span class="p">);</span>
		<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;Check RTAS error log for details&quot;</span><span class="p">);</span>
		<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;Immediate power off&quot;</span><span class="p">);</span>
		<span class="n">emergency_sync</span><span class="p">();</span>
		<span class="n">kernel_power_off</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Recoverable hardware error reported by firmware&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ras_log_buf_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Some versions of FWNMI place the buffer inside the 4kB page starting at</span>
<span class="cm"> * 0x7000. Other versions place it inside the rtas buffer. We check both.</span>
<span class="cm"> */</span>
<span class="cp">#define VALID_FWNMI_BUFFER(A) \</span>
<span class="cp">	((((A) &gt;= 0x7000) &amp;&amp; ((A) &lt; 0x7ff0)) || \</span>
<span class="cp">	(((A) &gt;= rtas.base) &amp;&amp; ((A) &lt; (rtas.base + rtas.size - 16))))</span>

<span class="cm">/*</span>
<span class="cm"> * Get the error information for errors coming through the</span>
<span class="cm"> * FWNMI vectors.  The pt_regs&#39; r3 will be updated to reflect</span>
<span class="cm"> * the actual r3 if possible, and a ptr to the error log entry</span>
<span class="cm"> * will be returned if found.</span>
<span class="cm"> *</span>
<span class="cm"> * If the RTAS error is not of the extended type, then we put it in a per</span>
<span class="cm"> * cpu 64bit buffer. If it is the extended type we use global_mce_data_buf.</span>
<span class="cm"> *</span>
<span class="cm"> * The global_mce_data_buf does not have any locks or protection around it,</span>
<span class="cm"> * if a second machine check comes in, or a system reset is done</span>
<span class="cm"> * before we have logged the error, then we will get corruption in the</span>
<span class="cm"> * error log.  This is preferable over holding off on calling</span>
<span class="cm"> * ibm,nmi-interlock which would result in us checkstopping if a</span>
<span class="cm"> * second machine check did come in.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rtas_error_log</span> <span class="o">*</span><span class="nf">fwnmi_get_errinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">savep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtas_error_log</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="o">*</span><span class="n">errhdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VALID_FWNMI_BUFFER</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;FWNMI: corrupt r3 0x%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">savep</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">savep</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* restore original r3 */</span>

	<span class="cm">/* If it isn&#39;t an extended log we can use the per cpu 64bit buffer */</span>
	<span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rtas_error_log</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">savep</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">extended</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">mce_data_buf</span><span class="p">),</span> <span class="n">h</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u64</span><span class="p">));</span>
		<span class="n">errhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rtas_error_log</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">mce_data_buf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="o">+</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">extended_log_length</span><span class="p">,</span> <span class="n">RTAS_ERROR_LOG_MAX</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">global_mce_data_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RTAS_ERROR_LOG_MAX</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">global_mce_data_buf</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">errhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rtas_error_log</span> <span class="o">*</span><span class="p">)</span><span class="n">global_mce_data_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">errhdr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Call this when done with the data returned by FWNMI_get_errinfo.</span>
<span class="cm"> * It will release the saved data area for other CPUs in the</span>
<span class="cm"> * partition to receive FWNMI errors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fwnmi_release_errinfo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">rtas_token</span><span class="p">(</span><span class="s">&quot;ibm,nmi-interlock&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;FWNMI: nmi-interlock failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pSeries_system_reset_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fwnmi_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rtas_error_log</span> <span class="o">*</span><span class="n">errhdr</span> <span class="o">=</span> <span class="n">fwnmi_get_errinfo</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">errhdr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* XXX Should look at FWNMI information */</span>
		<span class="p">}</span>
		<span class="n">fwnmi_release_errinfo</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* need to perform reset */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * See if we can recover from a machine check exception.</span>
<span class="cm"> * This is only called on power4 (or above) and only via</span>
<span class="cm"> * the Firmware Non-Maskable Interrupts (fwnmi) handler</span>
<span class="cm"> * which provides the error analysis for us.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 1 if corrected (or delivered a signal).</span>
<span class="cm"> * Return 0 if there is nothing we can do.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">recover_mce</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rtas_error_log</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">recovered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_RI</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* If MSR_RI isn&#39;t set, we cannot recover */</span>
		<span class="n">recovered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="o">-&gt;</span><span class="n">disposition</span> <span class="o">==</span> <span class="n">RTAS_DISP_FULLY_RECOVERED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Platform corrected itself */</span>
		<span class="n">recovered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="o">-&gt;</span><span class="n">disposition</span> <span class="o">==</span> <span class="n">RTAS_DISP_LIMITED_RECOVERY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Platform corrected itself but could be degraded */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;MCE: limited recovery, system may &quot;</span>
		       <span class="s">&quot;be degraded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">recovered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_global_init</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="n">err</span><span class="o">-&gt;</span><span class="n">severity</span> <span class="o">==</span> <span class="n">RTAS_SEVERITY_ERROR_SYNC</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we received a synchronous error when in userspace</span>
<span class="cm">		 * kill the task. Firmware may report details of the fail</span>
<span class="cm">		 * asynchronously, so we can&#39;t rely on the target and type</span>
<span class="cm">		 * fields being valid here.</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;MCE: uncorrectable error, killing task &quot;</span>
		       <span class="s">&quot;%s:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

		<span class="n">_exception</span><span class="p">(</span><span class="n">SIGBUS</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">BUS_MCEERR_AR</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">);</span>
		<span class="n">recovered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">log_error</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">err</span><span class="p">,</span> <span class="n">ERR_TYPE_RTAS_LOG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">recovered</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a machine check.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that on Power 4 and beyond Firmware Non-Maskable Interrupts (fwnmi)</span>
<span class="cm"> * should be present.  If so the handler which called us tells us if the</span>
<span class="cm"> * error was recovered (never true if RI=0).</span>
<span class="cm"> *</span>
<span class="cm"> * On hardware prior to Power 4 these exceptions were asynchronous which</span>
<span class="cm"> * means we can&#39;t tell exactly where it occurred and so we can&#39;t recover.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pSeries_machine_check_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rtas_error_log</span> <span class="o">*</span><span class="n">errp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fwnmi_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">errp</span> <span class="o">=</span> <span class="n">fwnmi_get_errinfo</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="n">fwnmi_release_errinfo</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">errp</span> <span class="o">&amp;&amp;</span> <span class="n">recover_mce</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">errp</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
