<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › platforms › pseries › iommu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>iommu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2001 Mike Corrigan &amp; Dave Engebretsen, IBM Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Rewrite, cleanup:</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 Olof Johansson &lt;olof@lixom.net&gt;, IBM Corporation</span>
<span class="cm"> * Copyright (C) 2006 Olof Johansson &lt;olof@lixom.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Dynamic DMA mapping support, pSeries-specific parts, both SMP and LPAR.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;	</span><span class="cm">/* for show_stack */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/crash_dump.h&gt;</span>
<span class="cp">#include &lt;linux/memory.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/rtas.h&gt;</span>
<span class="cp">#include &lt;asm/iommu.h&gt;</span>
<span class="cp">#include &lt;asm/pci-bridge.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/abs_addr.h&gt;</span>
<span class="cp">#include &lt;asm/pSeries_reconfig.h&gt;</span>
<span class="cp">#include &lt;asm/firmware.h&gt;</span>
<span class="cp">#include &lt;asm/tce.h&gt;</span>
<span class="cp">#include &lt;asm/ppc-pci.h&gt;</span>
<span class="cp">#include &lt;asm/udbg.h&gt;</span>
<span class="cp">#include &lt;asm/mmzone.h&gt;</span>

<span class="cp">#include &quot;plpar_wrappers.h&quot;</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">tce_invalidate_pSeries_sw</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span>
				      <span class="n">u64</span> <span class="o">*</span><span class="n">startp</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">endp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">invalidate</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">inc</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">startp</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">endp</span><span class="p">);</span>
	<span class="n">inc</span> <span class="o">=</span> <span class="n">L1_CACHE_BYTES</span><span class="p">;</span> <span class="cm">/* invalidate a cacheline of TCEs at a time */</span>

	<span class="cm">/* If this is non-zero, change the format.  We shift the</span>
<span class="cm">	 * address and or in the magic from the device tree. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_busno</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start</span> <span class="o">&lt;&lt;=</span> <span class="mi">12</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">&lt;&lt;=</span> <span class="mi">12</span><span class="p">;</span>
		<span class="n">inc</span> <span class="o">&lt;&lt;=</span> <span class="mi">12</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">|=</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_busno</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">|=</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_busno</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">end</span> <span class="o">|=</span> <span class="n">inc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* round up end to be different than start */</span>

	<span class="n">mb</span><span class="p">();</span> <span class="cm">/* Make sure TCEs in memory are written */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out_be64</span><span class="p">(</span><span class="n">invalidate</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tce_build_pSeries</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span>
			      <span class="kt">long</span> <span class="n">npages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uaddr</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">proto_tce</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">tcep</span><span class="p">,</span> <span class="o">*</span><span class="n">tces</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rpn</span><span class="p">;</span>

	<span class="n">proto_tce</span> <span class="o">=</span> <span class="n">TCE_PCI_READ</span><span class="p">;</span> <span class="c1">// Read allowed</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">!=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
		<span class="n">proto_tce</span> <span class="o">|=</span> <span class="n">TCE_PCI_WRITE</span><span class="p">;</span>

	<span class="n">tces</span> <span class="o">=</span> <span class="n">tcep</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_base</span><span class="p">)</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">npages</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* can&#39;t move this out since we might cross MEMBLOCK boundary */</span>
		<span class="n">rpn</span> <span class="o">=</span> <span class="p">(</span><span class="n">virt_to_abs</span><span class="p">(</span><span class="n">uaddr</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">TCE_SHIFT</span><span class="p">;</span>
		<span class="o">*</span><span class="n">tcep</span> <span class="o">=</span> <span class="n">proto_tce</span> <span class="o">|</span> <span class="p">(</span><span class="n">rpn</span> <span class="o">&amp;</span> <span class="n">TCE_RPN_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">TCE_RPN_SHIFT</span><span class="p">;</span>

		<span class="n">uaddr</span> <span class="o">+=</span> <span class="n">TCE_PAGE_SIZE</span><span class="p">;</span>
		<span class="n">tcep</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_type</span> <span class="o">&amp;</span> <span class="n">TCE_PCI_SWINV_CREATE</span><span class="p">)</span>
		<span class="n">tce_invalidate_pSeries_sw</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">tces</span><span class="p">,</span> <span class="n">tcep</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">tce_free_pSeries</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">tcep</span><span class="p">,</span> <span class="o">*</span><span class="n">tces</span><span class="p">;</span>

	<span class="n">tces</span> <span class="o">=</span> <span class="n">tcep</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_base</span><span class="p">)</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">npages</span><span class="o">--</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="n">tcep</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_type</span> <span class="o">&amp;</span> <span class="n">TCE_PCI_SWINV_FREE</span><span class="p">)</span>
		<span class="n">tce_invalidate_pSeries_sw</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">tces</span><span class="p">,</span> <span class="n">tcep</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">tce_get_pseries</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span> <span class="kt">long</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">tcep</span><span class="p">;</span>

	<span class="n">tcep</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_base</span><span class="p">)</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">*</span><span class="n">tcep</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">tce_free_pSeriesLP</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span><span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">tce_freemulti_pSeriesLP</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span><span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">long</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tce_build_pSeriesLP</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span> <span class="kt">long</span> <span class="n">tcenum</span><span class="p">,</span>
				<span class="kt">long</span> <span class="n">npages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uaddr</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">proto_tce</span><span class="p">,</span> <span class="n">tce</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rpn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">tcenum_start</span> <span class="o">=</span> <span class="n">tcenum</span><span class="p">,</span> <span class="n">npages_start</span> <span class="o">=</span> <span class="n">npages</span><span class="p">;</span>

	<span class="n">rpn</span> <span class="o">=</span> <span class="p">(</span><span class="n">virt_to_abs</span><span class="p">(</span><span class="n">uaddr</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">TCE_SHIFT</span><span class="p">;</span>
	<span class="n">proto_tce</span> <span class="o">=</span> <span class="n">TCE_PCI_READ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">!=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
		<span class="n">proto_tce</span> <span class="o">|=</span> <span class="n">TCE_PCI_WRITE</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">npages</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tce</span> <span class="o">=</span> <span class="n">proto_tce</span> <span class="o">|</span> <span class="p">(</span><span class="n">rpn</span> <span class="o">&amp;</span> <span class="n">TCE_RPN_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">TCE_RPN_SHIFT</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">plpar_tce_put</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_index</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tcenum</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">,</span> <span class="n">tce</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">H_NOT_ENOUGH_RESOURCES</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rc</span><span class="p">;</span>
			<span class="n">tce_free_pSeriesLP</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">tcenum_start</span><span class="p">,</span>
			                   <span class="p">(</span><span class="n">npages_start</span> <span class="o">-</span> <span class="p">(</span><span class="n">npages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="n">printk_ratelimit</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;tce_build_pSeriesLP: plpar_tce_put failed. rc=%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">index   = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_index</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">tcenum  = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tcenum</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">tce val = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tce</span> <span class="p">);</span>
			<span class="n">show_stack</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_SP</span><span class="p">());</span>
		<span class="p">}</span>

		<span class="n">tcenum</span><span class="o">++</span><span class="p">;</span>
		<span class="n">rpn</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">,</span> <span class="n">tce_page</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tce_buildmulti_pSeriesLP</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span> <span class="kt">long</span> <span class="n">tcenum</span><span class="p">,</span>
				     <span class="kt">long</span> <span class="n">npages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uaddr</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">proto_tce</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">tcep</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rpn</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">l</span><span class="p">,</span> <span class="n">limit</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">tcenum_start</span> <span class="o">=</span> <span class="n">tcenum</span><span class="p">,</span> <span class="n">npages_start</span> <span class="o">=</span> <span class="n">npages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">npages</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">tce_build_pSeriesLP</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">tcenum</span><span class="p">,</span> <span class="n">npages</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span>
		                           <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tcep</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tce_page</span><span class="p">);</span>

	<span class="cm">/* This is safe to do since interrupts are off when we&#39;re called</span>
<span class="cm">	 * from iommu_alloc{,_sg}()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcep</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="cm">/* If allocation fails, fall back to the loop implementation */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcep</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">tce_build_pSeriesLP</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">tcenum</span><span class="p">,</span> <span class="n">npages</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span>
					    <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tce_page</span><span class="p">)</span> <span class="o">=</span> <span class="n">tcep</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rpn</span> <span class="o">=</span> <span class="p">(</span><span class="n">virt_to_abs</span><span class="p">(</span><span class="n">uaddr</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">TCE_SHIFT</span><span class="p">;</span>
	<span class="n">proto_tce</span> <span class="o">=</span> <span class="n">TCE_PCI_READ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">!=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
		<span class="n">proto_tce</span> <span class="o">|=</span> <span class="n">TCE_PCI_WRITE</span><span class="p">;</span>

	<span class="cm">/* We can map max one pageful of TCEs at a time */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set up the page with TCE data, looping through and setting</span>
<span class="cm">		 * the values.</span>
<span class="cm">		 */</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">long</span><span class="p">,</span> <span class="n">npages</span><span class="p">,</span> <span class="mi">4096</span><span class="o">/</span><span class="n">TCE_ENTRY_SIZE</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tcep</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">proto_tce</span> <span class="o">|</span> <span class="p">(</span><span class="n">rpn</span> <span class="o">&amp;</span> <span class="n">TCE_RPN_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">TCE_RPN_SHIFT</span><span class="p">;</span>
			<span class="n">rpn</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">plpar_tce_put_indirect</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_index</span><span class="p">,</span>
					    <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tcenum</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">,</span>
					    <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">virt_to_abs</span><span class="p">(</span><span class="n">tcep</span><span class="p">),</span>
					    <span class="n">limit</span><span class="p">);</span>

		<span class="n">npages</span> <span class="o">-=</span> <span class="n">limit</span><span class="p">;</span>
		<span class="n">tcenum</span> <span class="o">+=</span> <span class="n">limit</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">npages</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">H_NOT_ENOUGH_RESOURCES</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rc</span><span class="p">;</span>
		<span class="n">tce_freemulti_pSeriesLP</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">tcenum_start</span><span class="p">,</span>
		                        <span class="p">(</span><span class="n">npages_start</span> <span class="o">-</span> <span class="p">(</span><span class="n">npages</span> <span class="o">+</span> <span class="n">limit</span><span class="p">)));</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="n">printk_ratelimit</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;tce_buildmulti_pSeriesLP: plpar_tce_put failed. rc=%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">index   = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_index</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">npages  = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">npages</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">tce[0] val = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tcep</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">show_stack</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_SP</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tce_free_pSeriesLP</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span> <span class="kt">long</span> <span class="n">tcenum</span><span class="p">,</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">npages</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">plpar_tce_put</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_index</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tcenum</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="n">printk_ratelimit</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;tce_free_pSeriesLP: plpar_tce_put failed. rc=%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">index   = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_index</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">tcenum  = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tcenum</span><span class="p">);</span>
			<span class="n">show_stack</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_SP</span><span class="p">());</span>
		<span class="p">}</span>

		<span class="n">tcenum</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">tce_freemulti_pSeriesLP</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span> <span class="kt">long</span> <span class="n">tcenum</span><span class="p">,</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">plpar_tce_stuff</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_index</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tcenum</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">npages</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="n">printk_ratelimit</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;tce_freemulti_pSeriesLP: plpar_tce_stuff failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">rc      = %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">index   = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_index</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">npages  = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">npages</span><span class="p">);</span>
		<span class="n">show_stack</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_SP</span><span class="p">());</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">tce_get_pSeriesLP</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span> <span class="kt">long</span> <span class="n">tcenum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tce_ret</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">plpar_tce_get</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_index</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tcenum</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tce_ret</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="n">printk_ratelimit</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;tce_get_pSeriesLP: plpar_tce_get failed. rc=%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">index   = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_index</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">tcenum  = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tcenum</span><span class="p">);</span>
		<span class="n">show_stack</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_SP</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">tce_ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* this is compatible with cells for the device tree property */</span>
<span class="k">struct</span> <span class="n">dynamic_dma_window_prop</span> <span class="p">{</span>
	<span class="n">__be32</span>	<span class="n">liobn</span><span class="p">;</span>		<span class="cm">/* tce table number */</span>
	<span class="n">__be64</span>	<span class="n">dma_base</span><span class="p">;</span>	<span class="cm">/* address hi,lo */</span>
	<span class="n">__be32</span>	<span class="n">tce_shift</span><span class="p">;</span>	<span class="cm">/* ilog2(tce_page_size) */</span>
	<span class="n">__be32</span>	<span class="n">window_shift</span><span class="p">;</span>	<span class="cm">/* ilog2(tce_window_size) */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">direct_window</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dynamic_dma_window_prop</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Dynamic DMA Window support */</span>
<span class="k">struct</span> <span class="n">ddw_query_response</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">windows_available</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">largest_available_block</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">page_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">migration_capable</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ddw_create_response</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">liobn</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_hi</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_lo</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">direct_window_list</span><span class="p">);</span>
<span class="cm">/* prevents races between memory on/offline and window creation */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">direct_window_list_lock</span><span class="p">);</span>
<span class="cm">/* protects initializing window twice for same device */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">direct_window_init_mutex</span><span class="p">);</span>
<span class="cp">#define DIRECT64_PROPNAME &quot;linux,direct64-ddr-window-info&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tce_clearrange_multi_pSeriesLP</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_pfn</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dynamic_dma_window_prop</span> <span class="o">*</span><span class="n">maprange</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tce_size</span><span class="p">,</span> <span class="n">num_tce</span><span class="p">,</span> <span class="n">dma_offset</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tce_shift</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">limit</span><span class="p">;</span>

	<span class="n">tce_shift</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">maprange</span><span class="o">-&gt;</span><span class="n">tce_shift</span><span class="p">);</span>
	<span class="n">tce_size</span> <span class="o">=</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">tce_shift</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">start_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">num_tce</span> <span class="o">=</span> <span class="n">num_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="cm">/* round back to the beginning of the tce page size */</span>
	<span class="n">num_tce</span> <span class="o">+=</span> <span class="n">next</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tce_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">next</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">tce_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* covert to number of tces */</span>
	<span class="n">num_tce</span> <span class="o">|=</span> <span class="n">tce_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">num_tce</span> <span class="o">&gt;&gt;=</span> <span class="n">tce_shift</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set up the page with TCE data, looping through and setting</span>
<span class="cm">		 * the values.</span>
<span class="cm">		 */</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">long</span><span class="p">,</span> <span class="n">num_tce</span><span class="p">,</span> <span class="mi">512</span><span class="p">);</span>
		<span class="n">dma_offset</span> <span class="o">=</span> <span class="n">next</span> <span class="o">+</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">maprange</span><span class="o">-&gt;</span><span class="n">dma_base</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">plpar_tce_stuff</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">maprange</span><span class="o">-&gt;</span><span class="n">liobn</span><span class="p">),</span>
					     <span class="n">dma_offset</span><span class="p">,</span>
					     <span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
		<span class="n">num_tce</span> <span class="o">-=</span> <span class="n">limit</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">num_tce</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tce_setrange_multi_pSeriesLP</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_pfn</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dynamic_dma_window_prop</span> <span class="o">*</span><span class="n">maprange</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">tcep</span><span class="p">,</span> <span class="n">tce_size</span><span class="p">,</span> <span class="n">num_tce</span><span class="p">,</span> <span class="n">dma_offset</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">proto_tce</span><span class="p">,</span> <span class="n">liobn</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tce_shift</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">l</span><span class="p">,</span> <span class="n">limit</span><span class="p">;</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>	<span class="cm">/* to protect tcep and the page behind it */</span>
	<span class="n">tcep</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tce_page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcep</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcep</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tce_page</span><span class="p">)</span> <span class="o">=</span> <span class="n">tcep</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">proto_tce</span> <span class="o">=</span> <span class="n">TCE_PCI_READ</span> <span class="o">|</span> <span class="n">TCE_PCI_WRITE</span><span class="p">;</span>

	<span class="n">liobn</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">maprange</span><span class="o">-&gt;</span><span class="n">liobn</span><span class="p">);</span>
	<span class="n">tce_shift</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">maprange</span><span class="o">-&gt;</span><span class="n">tce_shift</span><span class="p">);</span>
	<span class="n">tce_size</span> <span class="o">=</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">tce_shift</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">start_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">num_tce</span> <span class="o">=</span> <span class="n">num_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="cm">/* round back to the beginning of the tce page size */</span>
	<span class="n">num_tce</span> <span class="o">+=</span> <span class="n">next</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tce_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">next</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">tce_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* covert to number of tces */</span>
	<span class="n">num_tce</span> <span class="o">|=</span> <span class="n">tce_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">num_tce</span> <span class="o">&gt;&gt;=</span> <span class="n">tce_shift</span><span class="p">;</span>

	<span class="cm">/* We can map max one pageful of TCEs at a time */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set up the page with TCE data, looping through and setting</span>
<span class="cm">		 * the values.</span>
<span class="cm">		 */</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">long</span><span class="p">,</span> <span class="n">num_tce</span><span class="p">,</span> <span class="mi">4096</span><span class="o">/</span><span class="n">TCE_ENTRY_SIZE</span><span class="p">);</span>
		<span class="n">dma_offset</span> <span class="o">=</span> <span class="n">next</span> <span class="o">+</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">maprange</span><span class="o">-&gt;</span><span class="n">dma_base</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tcep</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">proto_tce</span> <span class="o">|</span> <span class="n">next</span><span class="p">;</span>
			<span class="n">next</span> <span class="o">+=</span> <span class="n">tce_size</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">plpar_tce_put_indirect</span><span class="p">(</span><span class="n">liobn</span><span class="p">,</span>
					    <span class="n">dma_offset</span><span class="p">,</span>
					    <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">virt_to_abs</span><span class="p">(</span><span class="n">tcep</span><span class="p">),</span>
					    <span class="n">limit</span><span class="p">);</span>

		<span class="n">num_tce</span> <span class="o">-=</span> <span class="n">limit</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">num_tce</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rc</span><span class="p">);</span>

	<span class="cm">/* error cleanup: caller will clear whole range */</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tce_setrange_multi_pSeriesLP_walk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_pfn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tce_setrange_multi_pSeriesLP</span><span class="p">(</span><span class="n">start_pfn</span><span class="p">,</span> <span class="n">num_pfn</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iommu_table_setparms</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">phb</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">basep</span><span class="p">,</span> <span class="o">*</span><span class="n">sw_inval</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">sizep</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">phb</span><span class="o">-&gt;</span><span class="n">dn</span><span class="p">;</span>

	<span class="n">basep</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;linux,tce-base&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">sizep</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;linux,tce-size&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">basep</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">sizep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PCI_DMA: iommu_table_setparms: %s has &quot;</span>
				<span class="s">&quot;missing tce entries !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="o">*</span><span class="n">basep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_kdump_kernel</span><span class="p">())</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">sizep</span><span class="p">);</span>

	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_busno</span> <span class="o">=</span> <span class="n">phb</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>

	<span class="cm">/* Units of tce entries */</span>
	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_offset</span> <span class="o">=</span> <span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_base_cur</span> <span class="o">&gt;&gt;</span> <span class="n">IOMMU_PAGE_SHIFT</span><span class="p">;</span>

	<span class="cm">/* Test if we are going over 2GB of DMA space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_base_cur</span> <span class="o">+</span> <span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_size</span> <span class="o">&gt;</span> <span class="mh">0x80000000ul</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udbg_printf</span><span class="p">(</span><span class="s">&quot;PCI_DMA: Unexpected number of IOAs under this PHB.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;PCI_DMA: Unexpected number of IOAs under this PHB.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_base_cur</span> <span class="o">+=</span> <span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_size</span><span class="p">;</span>

	<span class="cm">/* Set the tce table size - measured in entries */</span>
	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_size</span> <span class="o">=</span> <span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_size</span> <span class="o">&gt;&gt;</span> <span class="n">IOMMU_PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_blocksize</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_type</span> <span class="o">=</span> <span class="n">TCE_PCI</span><span class="p">;</span>

	<span class="n">sw_inval</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;linux,tce-sw-invalidate-info&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sw_inval</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This property contains information on how to</span>
<span class="cm">		 * invalidate the TCE entry.  The first property is</span>
<span class="cm">		 * the base MMIO address used to invalidate entries.</span>
<span class="cm">		 * The second property tells us the format of the TCE</span>
<span class="cm">		 * invalidate (whether it needs to be shifted) and</span>
<span class="cm">		 * some magic routing info to add to our invalidate</span>
<span class="cm">		 * command.</span>
<span class="cm">		 */</span>
		<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_index</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">sw_inval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_busno</span> <span class="o">=</span> <span class="n">sw_inval</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* overload this with magic */</span>
		<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_type</span> <span class="o">=</span> <span class="n">TCE_PCI_SWINV_CREATE</span> <span class="o">|</span> <span class="n">TCE_PCI_SWINV_FREE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * iommu_table_setparms_lpar</span>
<span class="cm"> *</span>
<span class="cm"> * Function: On pSeries LPAR systems, return TCE table info, given a pci bus.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iommu_table_setparms_lpar</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">phb</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dma_window</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">of_parse_dma_window</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">dma_window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>

	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_busno</span> <span class="o">=</span> <span class="n">phb</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_base</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_blocksize</span>  <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_type</span> <span class="o">=</span> <span class="n">TCE_PCI</span><span class="p">;</span>
	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">IOMMU_PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">IOMMU_PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_dma_bus_setup_pSeries</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">isa_dn</span><span class="p">,</span> <span class="o">*</span><span class="n">isa_dn_orig</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dn</span> <span class="o">*</span><span class="n">pci</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">children</span><span class="p">;</span>

	<span class="n">dn</span> <span class="o">=</span> <span class="n">pci_bus_to_OF_node</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;pci_dma_bus_setup_pSeries: setting up bus %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is not a root bus, any setup will be done for the</span>
<span class="cm">		 * device-side of the bridge in iommu_dev_setup_pSeries().</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci</span> <span class="o">=</span> <span class="n">PCI_DN</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>

	<span class="cm">/* Check if the ISA bus on the system is under</span>
<span class="cm">	 * this PHB.</span>
<span class="cm">	 */</span>
	<span class="n">isa_dn</span> <span class="o">=</span> <span class="n">isa_dn_orig</span> <span class="o">=</span> <span class="n">of_find_node_by_type</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;isa&quot;</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">isa_dn</span> <span class="o">&amp;&amp;</span> <span class="n">isa_dn</span> <span class="o">!=</span> <span class="n">dn</span><span class="p">)</span>
		<span class="n">isa_dn</span> <span class="o">=</span> <span class="n">isa_dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isa_dn_orig</span><span class="p">)</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">isa_dn_orig</span><span class="p">);</span>

	<span class="cm">/* Count number of direct PCI children of the PHB. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">children</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span> <span class="n">tmp</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">)</span>
		<span class="n">children</span><span class="o">++</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Children: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">children</span><span class="p">);</span>

	<span class="cm">/* Calculate amount of DMA window per slot. Each window must be</span>
<span class="cm">	 * a power of two (due to pci_alloc_consistent requirements).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Keep 256MB aside for PHBs with ISA.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isa_dn</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No ISA/IDE - just set window size and return */</span>
		<span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_size</span> <span class="o">=</span> <span class="mh">0x80000000ul</span><span class="p">;</span> <span class="cm">/* To be divided */</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_size</span> <span class="o">*</span> <span class="n">children</span> <span class="o">&gt;</span> <span class="mh">0x80000000ul</span><span class="p">)</span>
			<span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_size</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;No ISA/IDE, window size is 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_size</span><span class="p">);</span>
		<span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_base_cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we have ISA, then we probably have an IDE</span>
<span class="cm">	 * controller too. Allocate a 128MB table but</span>
<span class="cm">	 * skip the first 128MB to avoid stepping on ISA</span>
<span class="cm">	 * space.</span>
<span class="cm">	 */</span>
	<span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_size</span> <span class="o">=</span> <span class="mh">0x8000000ul</span><span class="p">;</span>
	<span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_base_cur</span> <span class="o">=</span> <span class="mh">0x8000000ul</span><span class="p">;</span>

	<span class="n">tbl</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
			   <span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

	<span class="n">iommu_table_setparms</span><span class="p">(</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="p">,</span> <span class="n">dn</span><span class="p">,</span> <span class="n">tbl</span><span class="p">);</span>
	<span class="n">pci</span><span class="o">-&gt;</span><span class="n">iommu_table</span> <span class="o">=</span> <span class="n">iommu_init_table</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

	<span class="cm">/* Divide the rest (1.75GB) among the children */</span>
	<span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_size</span> <span class="o">=</span> <span class="mh">0x80000000ul</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_size</span> <span class="o">*</span> <span class="n">children</span> <span class="o">&gt;</span> <span class="mh">0x70000000ul</span><span class="p">)</span>
		<span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_size</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ISA/IDE, window size is 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">dma_window_size</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_dma_bus_setup_pSeriesLP</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">,</span> <span class="o">*</span><span class="n">pdn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dn</span> <span class="o">*</span><span class="n">ppci</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dma_window</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dn</span> <span class="o">=</span> <span class="n">pci_bus_to_OF_node</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;pci_dma_bus_setup_pSeriesLP: setting up bus %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>

	<span class="cm">/* Find nearest ibm,dma-window, walking up the device tree */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pdn</span> <span class="o">=</span> <span class="n">dn</span><span class="p">;</span> <span class="n">pdn</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">pdn</span> <span class="o">=</span> <span class="n">pdn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_window</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">pdn</span><span class="p">,</span> <span class="s">&quot;ibm,dma-window&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_window</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_window</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;  no ibm,dma-window property !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ppci</span> <span class="o">=</span> <span class="n">PCI_DN</span><span class="p">(</span><span class="n">pdn</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;  parent is %s, iommu_table: 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">pdn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span> <span class="n">ppci</span><span class="o">-&gt;</span><span class="n">iommu_table</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ppci</span><span class="o">-&gt;</span><span class="n">iommu_table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tbl</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
				   <span class="n">ppci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">iommu_table_setparms_lpar</span><span class="p">(</span><span class="n">ppci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="p">,</span> <span class="n">pdn</span><span class="p">,</span> <span class="n">tbl</span><span class="p">,</span> <span class="n">dma_window</span><span class="p">);</span>
		<span class="n">ppci</span><span class="o">-&gt;</span><span class="n">iommu_table</span> <span class="o">=</span> <span class="n">iommu_init_table</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">ppci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;  created table: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ppci</span><span class="o">-&gt;</span><span class="n">iommu_table</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_dma_dev_setup_pSeries</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;pci_dma_dev_setup_pSeries: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="n">dn</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>

	<span class="cm">/* If we&#39;re the direct child of a root bus, then we need to allocate</span>
<span class="cm">	 * an iommu table ourselves. The bus setup code should have setup</span>
<span class="cm">	 * the window sizes already.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">phb</span> <span class="o">=</span> <span class="n">PCI_DN</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phb</span><span class="p">;</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; --&gt; first child, no bridge. Allocating iommu table.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">tbl</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
				   <span class="n">phb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">iommu_table_setparms</span><span class="p">(</span><span class="n">phb</span><span class="p">,</span> <span class="n">dn</span><span class="p">,</span> <span class="n">tbl</span><span class="p">);</span>
		<span class="n">PCI_DN</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iommu_table</span> <span class="o">=</span> <span class="n">iommu_init_table</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">phb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">set_iommu_table_base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_DN</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iommu_table</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If this device is further down the bus tree, search upwards until</span>
<span class="cm">	 * an already allocated iommu table is found and use that.</span>
<span class="cm">	 */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">dn</span> <span class="o">&amp;&amp;</span> <span class="n">PCI_DN</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">PCI_DN</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iommu_table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">dn</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dn</span> <span class="o">&amp;&amp;</span> <span class="n">PCI_DN</span><span class="p">(</span><span class="n">dn</span><span class="p">))</span>
		<span class="n">set_iommu_table_base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_DN</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iommu_table</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;iommu: Device %s has no iommu table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__read_mostly</span> <span class="n">disable_ddw</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">disable_ddw_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_ddw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;ppc iommu: disabling ddw.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;disable_ddw&quot;</span><span class="p">,</span> <span class="n">disable_ddw_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_ddw</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dynamic_dma_window_prop</span> <span class="o">*</span><span class="n">dwp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">win64</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ddw_avail</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">liobn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ddw_avail</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;ibm,ddw-applicable&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">win64</span> <span class="o">=</span> <span class="n">of_find_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">DIRECT64_PROPNAME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">win64</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ddw_avail</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">||</span> <span class="n">win64</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dwp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">delprop</span><span class="p">;</span>

	<span class="n">dwp</span> <span class="o">=</span> <span class="n">win64</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
	<span class="n">liobn</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">dwp</span><span class="o">-&gt;</span><span class="n">liobn</span><span class="p">);</span>

	<span class="cm">/* clear the whole window, note the arg is in kernel pages */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">tce_clearrange_multi_pSeriesLP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
		<span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">dwp</span><span class="o">-&gt;</span><span class="n">window_shift</span><span class="p">)</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span> <span class="n">dwp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s failed to clear tces in window.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s successfully cleared tces in window.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">ddw_avail</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">liobn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: failed to remove direct window: rtas returned &quot;</span>
			<span class="s">&quot;%d to ibm,remove-pe-dma-window(%x) %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">ddw_avail</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">liobn</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: successfully removed direct window: rtas returned &quot;</span>
			<span class="s">&quot;%d to ibm,remove-pe-dma-window(%x) %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">ddw_avail</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">liobn</span><span class="p">);</span>

<span class="nl">delprop:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">prom_remove_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">win64</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: failed to remove direct window property: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">find_existing_ddw</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">pdn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">direct_window</span> <span class="o">*</span><span class="n">window</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dynamic_dma_window_prop</span> <span class="o">*</span><span class="n">direct64</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dma_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direct_window_list_lock</span><span class="p">);</span>
	<span class="cm">/* check if we already created a window and dupe that config if so */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">direct_window_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">pdn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">direct64</span> <span class="o">=</span> <span class="n">window</span><span class="o">-&gt;</span><span class="n">prop</span><span class="p">;</span>
			<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">direct64</span><span class="o">-&gt;</span><span class="n">dma_base</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direct_window_list_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dma_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_existing_ddw_windows</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">pdn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">direct_window</span> <span class="o">*</span><span class="n">window</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dynamic_dma_window_prop</span> <span class="o">*</span><span class="n">direct64</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_LPAR</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_node_with_property</span><span class="p">(</span><span class="n">pdn</span><span class="p">,</span> <span class="n">DIRECT64_PROPNAME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">direct64</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">pdn</span><span class="p">,</span> <span class="n">DIRECT64_PROPNAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">direct64</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">window</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">window</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">window</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dynamic_dma_window_prop</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
			<span class="n">remove_ddw</span><span class="p">(</span><span class="n">pdn</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">window</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">pdn</span><span class="p">;</span>
		<span class="n">window</span><span class="o">-&gt;</span><span class="n">prop</span> <span class="o">=</span> <span class="n">direct64</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direct_window_list_lock</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">direct_window_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direct_window_list_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">machine_arch_initcall</span><span class="p">(</span><span class="n">pseries</span><span class="p">,</span> <span class="n">find_existing_ddw_windows</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">query_ddw</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ddw_avail</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ddw_query_response</span> <span class="o">*</span><span class="n">query</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cfg_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">buid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the config address and phb buid of the PE window.</span>
<span class="cm">	 * Rely on eeh to retrieve this for us.</span>
<span class="cm">	 * Retrieve them from the pci device, not the node with the</span>
<span class="cm">	 * dma-window property</span>
<span class="cm">	 */</span>
	<span class="n">edev</span> <span class="o">=</span> <span class="n">pci_dev_to_eeh_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">cfg_addr</span> <span class="o">=</span> <span class="n">edev</span><span class="o">-&gt;</span><span class="n">config_addr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">pe_config_addr</span><span class="p">)</span>
		<span class="n">cfg_addr</span> <span class="o">=</span> <span class="n">edev</span><span class="o">-&gt;</span><span class="n">pe_config_addr</span><span class="p">;</span>
	<span class="n">buid</span> <span class="o">=</span> <span class="n">edev</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">buid</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">ddw_avail</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">query</span><span class="p">,</span>
		  <span class="n">cfg_addr</span><span class="p">,</span> <span class="n">BUID_HI</span><span class="p">(</span><span class="n">buid</span><span class="p">),</span> <span class="n">BUID_LO</span><span class="p">(</span><span class="n">buid</span><span class="p">));</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ibm,query-pe-dma-windows(%x) %x %x %x&quot;</span>
		<span class="s">&quot; returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ddw_avail</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cfg_addr</span><span class="p">,</span> <span class="n">BUID_HI</span><span class="p">(</span><span class="n">buid</span><span class="p">),</span>
		<span class="n">BUID_LO</span><span class="p">(</span><span class="n">buid</span><span class="p">),</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_ddw</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ddw_avail</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ddw_create_response</span> <span class="o">*</span><span class="n">create</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page_shift</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">window_shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="n">edev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cfg_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">buid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the config address and phb buid of the PE window.</span>
<span class="cm">	 * Rely on eeh to retrieve this for us.</span>
<span class="cm">	 * Retrieve them from the pci device, not the node with the</span>
<span class="cm">	 * dma-window property</span>
<span class="cm">	 */</span>
	<span class="n">edev</span> <span class="o">=</span> <span class="n">pci_dev_to_eeh_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">cfg_addr</span> <span class="o">=</span> <span class="n">edev</span><span class="o">-&gt;</span><span class="n">config_addr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edev</span><span class="o">-&gt;</span><span class="n">pe_config_addr</span><span class="p">)</span>
		<span class="n">cfg_addr</span> <span class="o">=</span> <span class="n">edev</span><span class="o">-&gt;</span><span class="n">pe_config_addr</span><span class="p">;</span>
	<span class="n">buid</span> <span class="o">=</span> <span class="n">edev</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">buid</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* extra outputs are LIOBN and dma-addr (hi, lo) */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">ddw_avail</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">create</span><span class="p">,</span> <span class="n">cfg_addr</span><span class="p">,</span>
				<span class="n">BUID_HI</span><span class="p">(</span><span class="n">buid</span><span class="p">),</span> <span class="n">BUID_LO</span><span class="p">(</span><span class="n">buid</span><span class="p">),</span> <span class="n">page_shift</span><span class="p">,</span> <span class="n">window_shift</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">rtas_busy_delay</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;ibm,create-pe-dma-window(%x) %x %x %x %x %x returned %d &quot;</span>
		<span class="s">&quot;(liobn = 0x%x starting addr = %x %x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ddw_avail</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		 <span class="n">cfg_addr</span><span class="p">,</span> <span class="n">BUID_HI</span><span class="p">(</span><span class="n">buid</span><span class="p">),</span> <span class="n">BUID_LO</span><span class="p">(</span><span class="n">buid</span><span class="p">),</span> <span class="n">page_shift</span><span class="p">,</span>
		 <span class="n">window_shift</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">create</span><span class="o">-&gt;</span><span class="n">liobn</span><span class="p">,</span> <span class="n">create</span><span class="o">-&gt;</span><span class="n">addr_hi</span><span class="p">,</span> <span class="n">create</span><span class="o">-&gt;</span><span class="n">addr_lo</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If the PE supports dynamic dma windows, and there is space for a table</span>
<span class="cm"> * that can map all pages in a linear offset, then setup such a table,</span>
<span class="cm"> * and record the dma-offset in the struct device.</span>
<span class="cm"> *</span>
<span class="cm"> * dev: the pci device we are checking</span>
<span class="cm"> * pdn: the parent pe node with the ibm,dma_window property</span>
<span class="cm"> * Future: also check if we can remap the base window for our base page size</span>
<span class="cm"> *</span>
<span class="cm"> * returns the dma offset for use by dma_set_mask</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">enable_ddw</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">pdn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ddw_query_response</span> <span class="n">query</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ddw_create_response</span> <span class="n">create</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_shift</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">ddw_avail</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">direct_window</span> <span class="o">*</span><span class="n">window</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">win64</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dynamic_dma_window_prop</span> <span class="o">*</span><span class="n">ddwprop</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direct_window_init_mutex</span><span class="p">);</span>

	<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">find_existing_ddw</span><span class="p">(</span><span class="n">pdn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * the ibm,ddw-applicable property holds the tokens for:</span>
<span class="cm">	 * ibm,query-pe-dma-window</span>
<span class="cm">	 * ibm,create-pe-dma-window</span>
<span class="cm">	 * ibm,remove-pe-dma-window</span>
<span class="cm">	 * for the given node in that order.</span>
<span class="cm">	 * the property is actually in the parent, not the PE</span>
<span class="cm">	 */</span>
	<span class="n">ddw_avail</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">pdn</span><span class="p">,</span> <span class="s">&quot;ibm,ddw-applicable&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ddw_avail</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

       <span class="cm">/*</span>
<span class="cm">	 * Query if there is a second window of size to map the</span>
<span class="cm">	 * whole partition.  Query returns number of windows, largest</span>
<span class="cm">	 * block assigned to PE (partition endpoint), and two bitmasks</span>
<span class="cm">	 * of page sizes: supported and supported for migrate-dma.</span>
<span class="cm">	 */</span>
	<span class="n">dn</span> <span class="o">=</span> <span class="n">pci_device_to_OF_node</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">query_ddw</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ddw_avail</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">query</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="p">.</span><span class="n">windows_available</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * no additional windows are available for this device.</span>
<span class="cm">		 * We might be able to reallocate the existing window,</span>
<span class="cm">		 * trading in for a larger page size.</span>
<span class="cm">		 */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no free dynamic windows&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="p">.</span><span class="n">page_size</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page_shift</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span> <span class="cm">/* 16MB */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="p">.</span><span class="n">page_size</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page_shift</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="cm">/* 64kB */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="p">.</span><span class="n">page_size</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page_shift</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="cm">/* 4kB */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no supported direct page size in mask %x&quot;</span><span class="p">,</span>
			  <span class="n">query</span><span class="p">.</span><span class="n">page_size</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* verify the window * number of ptes will map the partition */</span>
	<span class="cm">/* check largest block * page size &gt; max memory hotplug addr */</span>
	<span class="n">max_addr</span> <span class="o">=</span> <span class="n">memory_hotplug_max</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="p">.</span><span class="n">largest_available_block</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">max_addr</span> <span class="o">&gt;&gt;</span> <span class="n">page_shift</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t map partiton max 0x%llx with %u &quot;</span>
			  <span class="s">&quot;%llu-sized pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">,</span>  <span class="n">query</span><span class="p">.</span><span class="n">largest_available_block</span><span class="p">,</span>
			  <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">page_shift</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">order_base_2</span><span class="p">(</span><span class="n">max_addr</span><span class="p">);</span>
	<span class="n">win64</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">property</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">win64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;couldn&#39;t allocate property for 64bit dma window</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">win64</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">DIRECT64_PROPNAME</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">win64</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">ddwprop</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ddwprop</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">win64</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ddwprop</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">win64</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">||</span> <span class="o">!</span><span class="n">win64</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;couldn&#39;t allocate property name and value</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_prop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">create_ddw</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ddw_avail</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">create</span><span class="p">,</span> <span class="n">page_shift</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_prop</span><span class="p">;</span>

	<span class="n">ddwprop</span><span class="o">-&gt;</span><span class="n">liobn</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">create</span><span class="p">.</span><span class="n">liobn</span><span class="p">);</span>
	<span class="n">ddwprop</span><span class="o">-&gt;</span><span class="n">dma_base</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">of_read_number</span><span class="p">(</span><span class="o">&amp;</span><span class="n">create</span><span class="p">.</span><span class="n">addr_hi</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">ddwprop</span><span class="o">-&gt;</span><span class="n">tce_shift</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">page_shift</span><span class="p">);</span>
	<span class="n">ddwprop</span><span class="o">-&gt;</span><span class="n">window_shift</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;created tce table LIOBN 0x%x for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">create</span><span class="p">.</span><span class="n">liobn</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>

	<span class="n">window</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">window</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">window</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_clear_window</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_system_ram_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">memblock_end_of_DRAM</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
			<span class="n">win64</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">tce_setrange_multi_pSeriesLP_walk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to map direct window for %s: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_window</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">prom_add_property</span><span class="p">(</span><span class="n">pdn</span><span class="p">,</span> <span class="n">win64</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to add dma window property for %s: %d&quot;</span><span class="p">,</span>
			 <span class="n">pdn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_window</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">window</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">pdn</span><span class="p">;</span>
	<span class="n">window</span><span class="o">-&gt;</span><span class="n">prop</span> <span class="o">=</span> <span class="n">ddwprop</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direct_window_list_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">direct_window_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direct_window_list_lock</span><span class="p">);</span>

	<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">of_read_number</span><span class="p">(</span><span class="o">&amp;</span><span class="n">create</span><span class="p">.</span><span class="n">addr_hi</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

<span class="nl">out_free_window:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>

<span class="nl">out_clear_window:</span>
	<span class="n">remove_ddw</span><span class="p">(</span><span class="n">pdn</span><span class="p">);</span>

<span class="nl">out_free_prop:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">win64</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">win64</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">win64</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direct_window_init_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dma_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_dma_dev_setup_pSeriesLP</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">pdn</span><span class="p">,</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dma_window</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dn</span> <span class="o">*</span><span class="n">pci</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;pci_dma_dev_setup_pSeriesLP: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="cm">/* dev setup for LPAR is a little tricky, since the device tree might</span>
<span class="cm">	 * contain the dma-window properties per-device and not necessarily</span>
<span class="cm">	 * for the bus. So we need to search upwards in the tree until we</span>
<span class="cm">	 * either hit a dma-window property, OR find a parent with a table</span>
<span class="cm">	 * already allocated.</span>
<span class="cm">	 */</span>
	<span class="n">dn</span> <span class="o">=</span> <span class="n">pci_device_to_OF_node</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;  node is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pdn</span> <span class="o">=</span> <span class="n">dn</span><span class="p">;</span> <span class="n">pdn</span> <span class="o">&amp;&amp;</span> <span class="n">PCI_DN</span><span class="p">(</span><span class="n">pdn</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PCI_DN</span><span class="p">(</span><span class="n">pdn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iommu_table</span><span class="p">;</span>
	     <span class="n">pdn</span> <span class="o">=</span> <span class="n">pdn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_window</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">pdn</span><span class="p">,</span> <span class="s">&quot;ibm,dma-window&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_window</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdn</span> <span class="o">||</span> <span class="o">!</span><span class="n">PCI_DN</span><span class="p">(</span><span class="n">pdn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;pci_dma_dev_setup_pSeriesLP: &quot;</span>
		       <span class="s">&quot;no DMA window found for pci dev=%s dn=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">dn</span><span class="o">?</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span> <span class="o">:</span> <span class="s">&quot;&lt;null&gt;&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;  parent is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>

	<span class="n">pci</span> <span class="o">=</span> <span class="n">PCI_DN</span><span class="p">(</span><span class="n">pdn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">iommu_table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tbl</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iommu_table</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
				   <span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">iommu_table_setparms_lpar</span><span class="p">(</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="p">,</span> <span class="n">pdn</span><span class="p">,</span> <span class="n">tbl</span><span class="p">,</span> <span class="n">dma_window</span><span class="p">);</span>
		<span class="n">pci</span><span class="o">-&gt;</span><span class="n">iommu_table</span> <span class="o">=</span> <span class="n">iommu_init_table</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">pci</span><span class="o">-&gt;</span><span class="n">phb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;  created table: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci</span><span class="o">-&gt;</span><span class="n">iommu_table</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;  found DMA window, table: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci</span><span class="o">-&gt;</span><span class="n">iommu_table</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">set_iommu_table_base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci</span><span class="o">-&gt;</span><span class="n">iommu_table</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dma_set_mask_pSeriesLP</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">dma_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ddw_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">pdn</span><span class="p">,</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dma_window</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dma_offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_is_pci</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">check_mask</span><span class="p">;</span>

	<span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* only attempt to use a new window if 64-bit DMA is requested */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disable_ddw</span> <span class="o">&amp;&amp;</span> <span class="n">dma_mask</span> <span class="o">==</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dn</span> <span class="o">=</span> <span class="n">pci_device_to_OF_node</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;node is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * the device tree might contain the dma-window properties</span>
<span class="cm">		 * per-device and not necessarily for the bus. So we need to</span>
<span class="cm">		 * search upwards in the tree until we either hit a dma-window</span>
<span class="cm">		 * property, OR find a parent with a table already allocated.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">pdn</span> <span class="o">=</span> <span class="n">dn</span><span class="p">;</span> <span class="n">pdn</span> <span class="o">&amp;&amp;</span> <span class="n">PCI_DN</span><span class="p">(</span><span class="n">pdn</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PCI_DN</span><span class="p">(</span><span class="n">pdn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iommu_table</span><span class="p">;</span>
				<span class="n">pdn</span> <span class="o">=</span> <span class="n">pdn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_window</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">pdn</span><span class="p">,</span> <span class="s">&quot;ibm,dma-window&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dma_window</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdn</span> <span class="o">&amp;&amp;</span> <span class="n">PCI_DN</span><span class="p">(</span><span class="n">pdn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dma_offset</span> <span class="o">=</span> <span class="n">enable_ddw</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pdn</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dma_offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Using 64-bit direct DMA at offset %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dma_offset</span><span class="p">);</span>
				<span class="n">set_dma_offset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_offset</span><span class="p">);</span>
				<span class="n">set_dma_ops</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_direct_ops</span><span class="p">);</span>
				<span class="n">ddw_enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* fall back on iommu ops, restore table pointer with ops */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ddw_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">get_dma_ops</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">dma_iommu_ops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Restoring 32-bit DMA via iommu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">set_dma_ops</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_iommu_ops</span><span class="p">);</span>
		<span class="n">pci_dma_dev_setup_pSeriesLP</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">check_mask:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_supported</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="o">*</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="n">dma_mask</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">dma_get_required_mask_pSeriesLP</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disable_ddw</span> <span class="o">&amp;&amp;</span> <span class="n">dev_is_pci</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>

		<span class="n">dn</span> <span class="o">=</span> <span class="n">pci_device_to_OF_node</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

		<span class="cm">/* search upwards for ibm,dma-window */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">dn</span> <span class="o">&amp;&amp;</span> <span class="n">PCI_DN</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PCI_DN</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iommu_table</span><span class="p">;</span>
				<span class="n">dn</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">of_get_property</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="s">&quot;ibm,dma-window&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* if there is a ibm,ddw-applicable property require 64 bits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dn</span> <span class="o">&amp;&amp;</span> <span class="n">PCI_DN</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">of_get_property</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="s">&quot;ibm,ddw-applicable&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dma_iommu_ops</span><span class="p">.</span><span class="n">get_required_mask</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else  </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>
<span class="cp">#define pci_dma_bus_setup_pSeries	NULL</span>
<span class="cp">#define pci_dma_dev_setup_pSeries	NULL</span>
<span class="cp">#define pci_dma_bus_setup_pSeriesLP	NULL</span>
<span class="cp">#define pci_dma_dev_setup_pSeriesLP	NULL</span>
<span class="cp">#define dma_set_mask_pSeriesLP		NULL</span>
<span class="cp">#define dma_get_required_mask_pSeriesLP	NULL</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_PCI */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iommu_mem_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">direct_window</span> <span class="o">*</span><span class="n">window</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memory_notify</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MEM_GOING_ONLINE</span>:
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direct_window_list_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">direct_window_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">|=</span> <span class="n">tce_setrange_multi_pSeriesLP</span><span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">start_pfn</span><span class="p">,</span>
					<span class="n">arg</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">,</span> <span class="n">window</span><span class="o">-&gt;</span><span class="n">prop</span><span class="p">);</span>
			<span class="cm">/* XXX log error */</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direct_window_list_lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MEM_CANCEL_ONLINE</span>:
	<span class="k">case</span> <span class="n">MEM_OFFLINE</span>:
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direct_window_list_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">direct_window_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">|=</span> <span class="n">tce_clearrange_multi_pSeriesLP</span><span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">start_pfn</span><span class="p">,</span>
					<span class="n">arg</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">,</span> <span class="n">window</span><span class="o">-&gt;</span><span class="n">prop</span><span class="p">);</span>
			<span class="cm">/* XXX log error */</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direct_window_list_lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">!=</span> <span class="n">MEM_CANCEL_ONLINE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_BAD</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">iommu_mem_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">iommu_mem_notifier</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iommu_reconfig_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dn</span> <span class="o">*</span><span class="n">pci</span> <span class="o">=</span> <span class="n">PCI_DN</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">direct_window</span> <span class="o">*</span><span class="n">window</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PSERIES_RECONFIG_REMOVE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">pci</span> <span class="o">&amp;&amp;</span> <span class="n">pci</span><span class="o">-&gt;</span><span class="n">iommu_table</span><span class="p">)</span>
			<span class="n">iommu_free_table</span><span class="p">(</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">iommu_table</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direct_window_list_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">direct_window_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">np</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">window</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direct_window_list_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Because the notifier runs after isolation of the</span>
<span class="cm">		 * slot, we are guaranteed any DMA window has already</span>
<span class="cm">		 * been revoked and the TCEs have been marked invalid,</span>
<span class="cm">		 * so we don&#39;t need a call to remove_ddw(np). However,</span>
<span class="cm">		 * if an additional notifier action is added before the</span>
<span class="cm">		 * isolate call, we should update this code for</span>
<span class="cm">		 * completeness with such a call.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">iommu_reconfig_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">iommu_reconfig_notifier</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* These are called very early. */</span>
<span class="kt">void</span> <span class="nf">iommu_init_early_pSeries</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_chosen</span> <span class="o">&amp;&amp;</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">of_chosen</span><span class="p">,</span> <span class="s">&quot;linux,iommu-off&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_LPAR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_MULTITCE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ppc_md</span><span class="p">.</span><span class="n">tce_build</span> <span class="o">=</span> <span class="n">tce_buildmulti_pSeriesLP</span><span class="p">;</span>
			<span class="n">ppc_md</span><span class="p">.</span><span class="n">tce_free</span>	 <span class="o">=</span> <span class="n">tce_freemulti_pSeriesLP</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ppc_md</span><span class="p">.</span><span class="n">tce_build</span> <span class="o">=</span> <span class="n">tce_build_pSeriesLP</span><span class="p">;</span>
			<span class="n">ppc_md</span><span class="p">.</span><span class="n">tce_free</span>	 <span class="o">=</span> <span class="n">tce_free_pSeriesLP</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">tce_get</span>   <span class="o">=</span> <span class="n">tce_get_pSeriesLP</span><span class="p">;</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">pci_dma_bus_setup</span> <span class="o">=</span> <span class="n">pci_dma_bus_setup_pSeriesLP</span><span class="p">;</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">pci_dma_dev_setup</span> <span class="o">=</span> <span class="n">pci_dma_dev_setup_pSeriesLP</span><span class="p">;</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">dma_set_mask</span> <span class="o">=</span> <span class="n">dma_set_mask_pSeriesLP</span><span class="p">;</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">dma_get_required_mask</span> <span class="o">=</span> <span class="n">dma_get_required_mask_pSeriesLP</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">tce_build</span> <span class="o">=</span> <span class="n">tce_build_pSeries</span><span class="p">;</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">tce_free</span>  <span class="o">=</span> <span class="n">tce_free_pSeries</span><span class="p">;</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">tce_get</span>   <span class="o">=</span> <span class="n">tce_get_pseries</span><span class="p">;</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">pci_dma_bus_setup</span> <span class="o">=</span> <span class="n">pci_dma_bus_setup_pSeries</span><span class="p">;</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">pci_dma_dev_setup</span> <span class="o">=</span> <span class="n">pci_dma_dev_setup_pSeries</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="n">pSeries_reconfig_notifier_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu_reconfig_nb</span><span class="p">);</span>
	<span class="n">register_memory_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iommu_mem_nb</span><span class="p">);</span>

	<span class="n">set_pci_dma_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_iommu_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">disable_multitce</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_LPAR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_MULTITCE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Disabling MULTITCE firmware feature</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">tce_build</span> <span class="o">=</span> <span class="n">tce_build_pSeriesLP</span><span class="p">;</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">tce_free</span>	 <span class="o">=</span> <span class="n">tce_free_pSeriesLP</span><span class="p">;</span>
		<span class="n">powerpc_firmware_features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FW_FEATURE_MULTITCE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;multitce=&quot;</span><span class="p">,</span> <span class="n">disable_multitce</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
