<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › kernel › head_booke.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>head_booke.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __HEAD_BOOKE_H__</span>
<span class="cp">#define __HEAD_BOOKE_H__</span>

<span class="cp">#include &lt;asm/ptrace.h&gt;	</span><span class="cm">/* for STACK_FRAME_REGS_MARKER */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/kvm_asm.h&gt;</span>
<span class="cp">#include &lt;asm/kvm_booke_hv_asm.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Macros used for common Book-e exception handling</span>
<span class="cm"> */</span>

<span class="cp">#define SET_IVOR(vector_number, vector_label)		\</span>
<span class="cp">		li	r26,vector_label@l; 		\</span>
<span class="cp">		mtspr	SPRN_IVOR##vector_number,r26;	\</span>
<span class="cp">		sync</span>

<span class="cp">#if (THREAD_SHIFT &lt; 15)</span>
<span class="cp">#define ALLOC_STACK_FRAME(reg, val)			\</span>
<span class="cp">	addi reg,reg,val</span>
<span class="cp">#else</span>
<span class="cp">#define ALLOC_STACK_FRAME(reg, val)			\</span>
<span class="cp">	addis	reg,reg,val@ha;				\</span>
<span class="cp">	addi	reg,reg,val@l</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Macro used to get to thread save registers.</span>
<span class="cm"> * Note that entries 0-3 are used for the prolog code, and the remaining</span>
<span class="cm"> * entries are available for specific exception use in the event a handler</span>
<span class="cm"> * requires more than 4 scratch registers.</span>
<span class="cm"> */</span>
<span class="cp">#define THREAD_NORMSAVE(offset)	(THREAD_NORMSAVES + (offset * 4))</span>

<span class="cp">#define NORMAL_EXCEPTION_PROLOG(intno)						     \</span>
<span class="cp">	mtspr	SPRN_SPRG_WSCRATCH0, r10;	</span><span class="cm">/* save one register */</span><span class="cp">	     \</span>
<span class="cp">	mfspr	r10, SPRN_SPRG_THREAD;					     \</span>
<span class="cp">	stw	r11, THREAD_NORMSAVE(0)(r10);				     \</span>
<span class="cp">	stw	r13, THREAD_NORMSAVE(2)(r10);				     \</span>
<span class="cp">	mfcr	r13;			</span><span class="cm">/* save CR in r13 for now	   */</span><span class="cp">\</span>
<span class="cp">	mfspr	r11, SPRN_SRR1;		                                     \</span>
<span class="cp">	DO_KVM	BOOKE_INTERRUPT_##intno SPRN_SRR1;			     \</span>
<span class="cp">	andi.	r11, r11, MSR_PR;	</span><span class="cm">/* check whether user or kernel    */</span><span class="cp">\</span>
<span class="cp">	mr	r11, r1;						     \</span>
<span class="cp">	beq	1f;							     \</span>
<span class="cp">	</span><span class="cm">/* if from user, start at top of this thread&#39;s kernel stack */</span><span class="cp">       \</span>
<span class="cp">	lwz	r11, THREAD_INFO-THREAD(r10);				     \</span>
<span class="cp">	ALLOC_STACK_FRAME(r11, THREAD_SIZE);				     \</span>
<span class="cp">1 :	subi	r11, r11, INT_FRAME_SIZE; </span><span class="cm">/* Allocate exception frame */</span><span class="cp">     \</span>
<span class="cp">	stw	r13, _CCR(r11);		</span><span class="cm">/* save various registers */</span><span class="cp">	     \</span>
<span class="cp">	stw	r12,GPR12(r11);						     \</span>
<span class="cp">	stw	r9,GPR9(r11);						     \</span>
<span class="cp">	mfspr	r13, SPRN_SPRG_RSCRATCH0;				     \</span>
<span class="cp">	stw	r13, GPR10(r11);					     \</span>
<span class="cp">	lwz	r12, THREAD_NORMSAVE(0)(r10);				     \</span>
<span class="cp">	stw	r12,GPR11(r11);						     \</span>
<span class="cp">	lwz	r13, THREAD_NORMSAVE(2)(r10); </span><span class="cm">/* restore r13 */</span><span class="cp">		     \</span>
<span class="cp">	mflr	r10;							     \</span>
<span class="cp">	stw	r10,_LINK(r11);						     \</span>
<span class="cp">	mfspr	r12,SPRN_SRR0;						     \</span>
<span class="cp">	stw	r1, GPR1(r11);						     \</span>
<span class="cp">	mfspr	r9,SPRN_SRR1;						     \</span>
<span class="cp">	stw	r1, 0(r11);						     \</span>
<span class="cp">	mr	r1, r11;						     \</span>
<span class="cp">	rlwinm	r9,r9,0,14,12;		</span><span class="cm">/* clear MSR_WE (necessary?)	   */</span><span class="cp">\</span>
<span class="cp">	stw	r0,GPR0(r11);						     \</span>
<span class="cp">	lis	r10, STACK_FRAME_REGS_MARKER@ha;</span><span class="cm">/* exception frame marker */</span><span class="cp"> \</span>
<span class="cp">	addi	r10, r10, STACK_FRAME_REGS_MARKER@l;			     \</span>
<span class="cp">	stw	r10, 8(r11);						     \</span>
<span class="cp">	SAVE_4GPRS(3, r11);						     \</span>
<span class="cp">	SAVE_2GPRS(7, r11)</span>

<span class="cm">/* To handle the additional exception priority levels on 40x and Book-E</span>
<span class="cm"> * processors we allocate a stack per additional priority level.</span>
<span class="cm"> *</span>
<span class="cm"> * On 40x critical is the only additional level</span>
<span class="cm"> * On 44x/e500 we have critical and machine check</span>
<span class="cm"> * On e200 we have critical and debug (machine check occurs via critical)</span>
<span class="cm"> *</span>
<span class="cm"> * Additionally we reserve a SPRG for each priority level so we can free up a</span>
<span class="cm"> * GPR to use as the base for indirect access to the exception stacks.  This</span>
<span class="cm"> * is necessary since the MMU is always on, for Book-E parts, and the stacks</span>
<span class="cm"> * are offset from KERNELBASE.</span>
<span class="cm"> *</span>
<span class="cm"> * There is some space optimization to be had here if desired.  However</span>
<span class="cm"> * to allow for a common kernel with support for debug exceptions either</span>
<span class="cm"> * going to critical or their own debug level we aren&#39;t currently</span>
<span class="cm"> * providing configurations that micro-optimize space usage.</span>
<span class="cm"> */</span>

<span class="cp">#define MC_STACK_BASE		mcheckirq_ctx</span>
<span class="cp">#define CRIT_STACK_BASE		critirq_ctx</span>

<span class="cm">/* only on e500mc/e200 */</span>
<span class="cp">#define DBG_STACK_BASE		dbgirq_ctx</span>

<span class="cp">#define EXC_LVL_FRAME_OVERHEAD	(THREAD_SIZE - INT_FRAME_SIZE - EXC_LVL_SIZE)</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp">#define BOOKE_LOAD_EXC_LEVEL_STACK(level)		\</span>
<span class="cp">	mfspr	r8,SPRN_PIR;				\</span>
<span class="cp">	slwi	r8,r8,2;				\</span>
<span class="cp">	addis	r8,r8,level##_STACK_BASE@ha;		\</span>
<span class="cp">	lwz	r8,level##_STACK_BASE@l(r8);		\</span>
<span class="cp">	addi	r8,r8,EXC_LVL_FRAME_OVERHEAD;</span>
<span class="cp">#else</span>
<span class="cp">#define BOOKE_LOAD_EXC_LEVEL_STACK(level)		\</span>
<span class="cp">	lis	r8,level##_STACK_BASE@ha;		\</span>
<span class="cp">	lwz	r8,level##_STACK_BASE@l(r8);		\</span>
<span class="cp">	addi	r8,r8,EXC_LVL_FRAME_OVERHEAD;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Exception prolog for critical/machine check exceptions.  This is a</span>
<span class="cm"> * little different from the normal exception prolog above since a</span>
<span class="cm"> * critical/machine check exception can potentially occur at any point</span>
<span class="cm"> * during normal exception processing. Thus we cannot use the same SPRG</span>
<span class="cm"> * registers as the normal prolog above. Instead we use a portion of the</span>
<span class="cm"> * critical/machine check exception stack at low physical addresses.</span>
<span class="cm"> */</span>
<span class="cp">#define EXC_LEVEL_EXCEPTION_PROLOG(exc_level, intno, exc_level_srr0, exc_level_srr1) \</span>
<span class="cp">	mtspr	SPRN_SPRG_WSCRATCH_##exc_level,r8;			     \</span>
<span class="cp">	BOOKE_LOAD_EXC_LEVEL_STACK(exc_level);</span><span class="cm">/* r8 points to the exc_level stack*/</span><span class="cp"> \</span>
<span class="cp">	stw	r9,GPR9(r8);		</span><span class="cm">/* save various registers	   */</span><span class="cp">\</span>
<span class="cp">	mfcr	r9;			</span><span class="cm">/* save CR in r9 for now	   */</span><span class="cp">\</span>
<span class="cp">	stw	r10,GPR10(r8);						     \</span>
<span class="cp">	stw	r11,GPR11(r8);						     \</span>
<span class="cp">	stw	r9,_CCR(r8);		</span><span class="cm">/* save CR on stack		   */</span><span class="cp">\</span>
<span class="cp">	mfspr	r11,exc_level_srr1;	</span><span class="cm">/* check whether user or kernel    */</span><span class="cp">\</span>
<span class="cp">	DO_KVM	BOOKE_INTERRUPT_##intno exc_level_srr1;		             \</span>
<span class="cp">	andi.	r11,r11,MSR_PR;						     \</span>
<span class="cp">	mfspr	r11,SPRN_SPRG_THREAD;	</span><span class="cm">/* if from user, start at top of   */</span><span class="cp">\</span>
<span class="cp">	lwz	r11,THREAD_INFO-THREAD(r11); </span><span class="cm">/* this thread&#39;s kernel stack */</span><span class="cp">\</span>
<span class="cp">	addi	r11,r11,EXC_LVL_FRAME_OVERHEAD;	</span><span class="cm">/* allocate stack frame    */</span><span class="cp">\</span>
<span class="cp">	beq	1f;							     \</span>
<span class="cp">	</span><span class="cm">/* COMING FROM USER MODE */</span><span class="cp">					     \</span>
<span class="cp">	stw	r9,_CCR(r11);		</span><span class="cm">/* save CR			   */</span><span class="cp">\</span>
<span class="cp">	lwz	r10,GPR10(r8);		</span><span class="cm">/* copy regs from exception stack  */</span><span class="cp">\</span>
<span class="cp">	lwz	r9,GPR9(r8);						     \</span>
<span class="cp">	stw	r10,GPR10(r11);						     \</span>
<span class="cp">	lwz	r10,GPR11(r8);						     \</span>
<span class="cp">	stw	r9,GPR9(r11);						     \</span>
<span class="cp">	stw	r10,GPR11(r11);						     \</span>
<span class="cp">	b	2f;							     \</span>
<span class="cp">	</span><span class="cm">/* COMING FROM PRIV MODE */</span><span class="cp">					     \</span>
<span class="cp">1:	lwz	r9,TI_FLAGS-EXC_LVL_FRAME_OVERHEAD(r11);		     \</span>
<span class="cp">	lwz	r10,TI_PREEMPT-EXC_LVL_FRAME_OVERHEAD(r11);		     \</span>
<span class="cp">	stw	r9,TI_FLAGS-EXC_LVL_FRAME_OVERHEAD(r8);			     \</span>
<span class="cp">	stw	r10,TI_PREEMPT-EXC_LVL_FRAME_OVERHEAD(r8);		     \</span>
<span class="cp">	lwz	r9,TI_TASK-EXC_LVL_FRAME_OVERHEAD(r11);			     \</span>
<span class="cp">	stw	r9,TI_TASK-EXC_LVL_FRAME_OVERHEAD(r8);			     \</span>
<span class="cp">	mr	r11,r8;							     \</span>
<span class="cp">2:	mfspr	r8,SPRN_SPRG_RSCRATCH_##exc_level;			     \</span>
<span class="cp">	stw	r12,GPR12(r11);		</span><span class="cm">/* save various registers	   */</span><span class="cp">\</span>
<span class="cp">	mflr	r10;							     \</span>
<span class="cp">	stw	r10,_LINK(r11);						     \</span>
<span class="cp">	mfspr	r12,SPRN_DEAR;		</span><span class="cm">/* save DEAR and ESR in the frame  */</span><span class="cp">\</span>
<span class="cp">	stw	r12,_DEAR(r11);		</span><span class="cm">/* since they may have had stuff   */</span><span class="cp">\</span>
<span class="cp">	mfspr	r9,SPRN_ESR;		</span><span class="cm">/* in them at the point where the  */</span><span class="cp">\</span>
<span class="cp">	stw	r9,_ESR(r11);		</span><span class="cm">/* exception was taken		   */</span><span class="cp">\</span>
<span class="cp">	mfspr	r12,exc_level_srr0;					     \</span>
<span class="cp">	stw	r1,GPR1(r11);						     \</span>
<span class="cp">	mfspr	r9,exc_level_srr1;					     \</span>
<span class="cp">	stw	r1,0(r11);						     \</span>
<span class="cp">	mr	r1,r11;							     \</span>
<span class="cp">	rlwinm	r9,r9,0,14,12;		</span><span class="cm">/* clear MSR_WE (necessary?)	   */</span><span class="cp">\</span>
<span class="cp">	stw	r0,GPR0(r11);						     \</span>
<span class="cp">	SAVE_4GPRS(3, r11);						     \</span>
<span class="cp">	SAVE_2GPRS(7, r11)</span>

<span class="cp">#define CRITICAL_EXCEPTION_PROLOG(intno) \</span>
<span class="cp">		EXC_LEVEL_EXCEPTION_PROLOG(CRIT, intno, SPRN_CSRR0, SPRN_CSRR1)</span>
<span class="cp">#define DEBUG_EXCEPTION_PROLOG \</span>
<span class="cp">		EXC_LEVEL_EXCEPTION_PROLOG(DBG, DEBUG, SPRN_DSRR0, SPRN_DSRR1)</span>
<span class="cp">#define MCHECK_EXCEPTION_PROLOG \</span>
<span class="cp">		EXC_LEVEL_EXCEPTION_PROLOG(MC, MACHINE_CHECK, \</span>
<span class="cp">			SPRN_MCSRR0, SPRN_MCSRR1)</span>

<span class="cm">/*</span>
<span class="cm"> * Guest Doorbell -- this is a bit odd in that uses GSRR0/1 despite</span>
<span class="cm"> * being delivered to the host.  This exception can only happen</span>
<span class="cm"> * inside a KVM guest -- so we just handle up to the DO_KVM rather</span>
<span class="cm"> * than try to fit this into one of the existing prolog macros.</span>
<span class="cm"> */</span>
<span class="cp">#define GUEST_DOORBELL_EXCEPTION \</span>
<span class="cp">	START_EXCEPTION(GuestDoorbell);					     \</span>
<span class="cp">	mtspr	SPRN_SPRG_WSCRATCH0, r10;	</span><span class="cm">/* save one register */</span><span class="cp">	     \</span>
<span class="cp">	mfspr	r10, SPRN_SPRG_THREAD;					     \</span>
<span class="cp">	stw	r11, THREAD_NORMSAVE(0)(r10);				     \</span>
<span class="cp">	mfspr	r11, SPRN_SRR1;		                                     \</span>
<span class="cp">	stw	r13, THREAD_NORMSAVE(2)(r10);				     \</span>
<span class="cp">	mfcr	r13;			</span><span class="cm">/* save CR in r13 for now	   */</span><span class="cp">\</span>
<span class="cp">	DO_KVM	BOOKE_INTERRUPT_GUEST_DBELL SPRN_GSRR1;			     \</span>
<span class="cp">	trap</span>

<span class="cm">/*</span>
<span class="cm"> * Exception vectors.</span>
<span class="cm"> */</span>
<span class="cp">#define	START_EXCEPTION(label)						     \</span>
<span class="cp">        .align 5;              						     \</span>
<span class="cp">label:</span>

<span class="cp">#define FINISH_EXCEPTION(func)					\</span>
<span class="cp">	bl	transfer_to_handler_full;			\</span>
<span class="cp">	.long	func;						\</span>
<span class="cp">	.long	ret_from_except_full</span>

<span class="cp">#define EXCEPTION(n, intno, label, hdlr, xfer)			\</span>
<span class="cp">	START_EXCEPTION(label);					\</span>
<span class="cp">	NORMAL_EXCEPTION_PROLOG(intno);				\</span>
<span class="cp">	addi	r3,r1,STACK_FRAME_OVERHEAD;			\</span>
<span class="cp">	xfer(n, hdlr)</span>

<span class="cp">#define CRITICAL_EXCEPTION(n, intno, label, hdlr)			\</span>
<span class="cp">	START_EXCEPTION(label);						\</span>
<span class="cp">	CRITICAL_EXCEPTION_PROLOG(intno);				\</span>
<span class="cp">	addi	r3,r1,STACK_FRAME_OVERHEAD;				\</span>
<span class="cp">	EXC_XFER_TEMPLATE(hdlr, n+2, (MSR_KERNEL &amp; ~(MSR_ME|MSR_DE|MSR_CE)), \</span>
<span class="cp">			  NOCOPY, crit_transfer_to_handler, \</span>
<span class="cp">			  ret_from_crit_exc)</span>

<span class="cp">#define MCHECK_EXCEPTION(n, label, hdlr)			\</span>
<span class="cp">	START_EXCEPTION(label);					\</span>
<span class="cp">	MCHECK_EXCEPTION_PROLOG;				\</span>
<span class="cp">	mfspr	r5,SPRN_ESR;					\</span>
<span class="cp">	stw	r5,_ESR(r11);					\</span>
<span class="cp">	addi	r3,r1,STACK_FRAME_OVERHEAD;			\</span>
<span class="cp">	EXC_XFER_TEMPLATE(hdlr, n+4, (MSR_KERNEL &amp; ~(MSR_ME|MSR_DE|MSR_CE)), \</span>
<span class="cp">			  NOCOPY, mcheck_transfer_to_handler,   \</span>
<span class="cp">			  ret_from_mcheck_exc)</span>

<span class="cp">#define EXC_XFER_TEMPLATE(hdlr, trap, msr, copyee, tfer, ret)	\</span>
<span class="cp">	li	r10,trap;					\</span>
<span class="cp">	stw	r10,_TRAP(r11);					\</span>
<span class="cp">	lis	r10,msr@h;					\</span>
<span class="cp">	ori	r10,r10,msr@l;					\</span>
<span class="cp">	copyee(r10, r9);					\</span>
<span class="cp">	bl	tfer;		 				\</span>
<span class="cp">	.long	hdlr;						\</span>
<span class="cp">	.long	ret</span>

<span class="cp">#define COPY_EE(d, s)		rlwimi d,s,0,16,16</span>
<span class="cp">#define NOCOPY(d, s)</span>

<span class="cp">#define EXC_XFER_STD(n, hdlr)		\</span>
<span class="cp">	EXC_XFER_TEMPLATE(hdlr, n, MSR_KERNEL, NOCOPY, transfer_to_handler_full, \</span>
<span class="cp">			  ret_from_except_full)</span>

<span class="cp">#define EXC_XFER_LITE(n, hdlr)		\</span>
<span class="cp">	EXC_XFER_TEMPLATE(hdlr, n+1, MSR_KERNEL, NOCOPY, transfer_to_handler, \</span>
<span class="cp">			  ret_from_except)</span>

<span class="cp">#define EXC_XFER_EE(n, hdlr)		\</span>
<span class="cp">	EXC_XFER_TEMPLATE(hdlr, n, MSR_KERNEL, COPY_EE, transfer_to_handler_full, \</span>
<span class="cp">			  ret_from_except_full)</span>

<span class="cp">#define EXC_XFER_EE_LITE(n, hdlr)	\</span>
<span class="cp">	EXC_XFER_TEMPLATE(hdlr, n+1, MSR_KERNEL, COPY_EE, transfer_to_handler, \</span>
<span class="cp">			  ret_from_except)</span>

<span class="cm">/* Check for a single step debug exception while in an exception</span>
<span class="cm"> * handler before state has been saved.  This is to catch the case</span>
<span class="cm"> * where an instruction that we are trying to single step causes</span>
<span class="cm"> * an exception (eg ITLB/DTLB miss) and thus the first instruction of</span>
<span class="cm"> * the exception handler generates a single step debug exception.</span>
<span class="cm"> *</span>
<span class="cm"> * If we get a debug trap on the first instruction of an exception handler,</span>
<span class="cm"> * we reset the MSR_DE in the _exception handler&#39;s_ MSR (the debug trap is</span>
<span class="cm"> * a critical exception, so we are using SPRN_CSRR1 to manipulate the MSR).</span>
<span class="cm"> * The exception handler was handling a non-critical interrupt, so it will</span>
<span class="cm"> * save (and later restore) the MSR via SPRN_CSRR1, which will still have</span>
<span class="cm"> * the MSR_DE bit set.</span>
<span class="cm"> */</span>
<span class="cp">#define DEBUG_DEBUG_EXCEPTION						      \</span>
<span class="cp">	START_EXCEPTION(DebugDebug);					      \</span>
<span class="cp">	DEBUG_EXCEPTION_PROLOG;						      \</span>
<span class="cp">									      \</span>
<span class="cp">	</span><span class="cm">/*								      \</span>
<span class="cm">	 * If there is a single step or branch-taken exception in an	      \</span>
<span class="cm">	 * exception entry sequence, it was probably meant to apply to	      \</span>
<span class="cm">	 * the code where the exception occurred (since exception entry	      \</span>
<span class="cm">	 * doesn&#39;t turn off DE automatically).  We simulate the effect	      \</span>
<span class="cm">	 * of turning off DE on entry to an exception handler by turning      \</span>
<span class="cm">	 * off DE in the DSRR1 value and clearing the debug status.	      \</span>
<span class="cm">	 */</span><span class="cp">								      \</span>
<span class="cp">	mfspr	r10,SPRN_DBSR;		</span><span class="cm">/* check single-step/branch taken */</span><span class="cp">  \</span>
<span class="cp">	andis.	r10,r10,(DBSR_IC|DBSR_BT)@h;				      \</span>
<span class="cp">	beq+	2f;							      \</span>
<span class="cp">									      \</span>
<span class="cp">	lis	r10,KERNELBASE@h;	</span><span class="cm">/* check if exception in vectors */</span><span class="cp">   \</span>
<span class="cp">	ori	r10,r10,KERNELBASE@l;					      \</span>
<span class="cp">	cmplw	r12,r10;						      \</span>
<span class="cp">	blt+	2f;			</span><span class="cm">/* addr below exception vectors */</span><span class="cp">    \</span>
<span class="cp">									      \</span>
<span class="cp">	lis	r10,DebugDebug@h;					      \</span>
<span class="cp">	ori	r10,r10,DebugDebug@l;					      \</span>
<span class="cp">	cmplw	r12,r10;						      \</span>
<span class="cp">	bgt+	2f;			</span><span class="cm">/* addr above exception vectors */</span><span class="cp">    \</span>
<span class="cp">									      \</span>
<span class="cp">	</span><span class="cm">/* here it looks like we got an inappropriate debug exception. */</span><span class="cp">     \</span>
<span class="cp">1:	rlwinm	r9,r9,0,~MSR_DE;	</span><span class="cm">/* clear DE in the CDRR1 value */</span><span class="cp">     \</span>
<span class="cp">	lis	r10,(DBSR_IC|DBSR_BT)@h;	</span><span class="cm">/* clear the IC event */</span><span class="cp">      \</span>
<span class="cp">	mtspr	SPRN_DBSR,r10;						      \</span>
<span class="cp">	</span><span class="cm">/* restore state and get out */</span><span class="cp">					      \</span>
<span class="cp">	lwz	r10,_CCR(r11);						      \</span>
<span class="cp">	lwz	r0,GPR0(r11);						      \</span>
<span class="cp">	lwz	r1,GPR1(r11);						      \</span>
<span class="cp">	mtcrf	0x80,r10;						      \</span>
<span class="cp">	mtspr	SPRN_DSRR0,r12;						      \</span>
<span class="cp">	mtspr	SPRN_DSRR1,r9;						      \</span>
<span class="cp">	lwz	r9,GPR9(r11);						      \</span>
<span class="cp">	lwz	r12,GPR12(r11);						      \</span>
<span class="cp">	mtspr	SPRN_SPRG_WSCRATCH_DBG,r8;				      \</span>
<span class="cp">	BOOKE_LOAD_EXC_LEVEL_STACK(DBG); </span><span class="cm">/* r8 points to the debug stack */</span><span class="cp"> \</span>
<span class="cp">	lwz	r10,GPR10(r8);						      \</span>
<span class="cp">	lwz	r11,GPR11(r8);						      \</span>
<span class="cp">	mfspr	r8,SPRN_SPRG_RSCRATCH_DBG;				      \</span>
<span class="cp">									      \</span>
<span class="cp">	PPC_RFDI;							      \</span>
<span class="cp">	b	.;							      \</span>
<span class="cp">									      \</span>
<span class="cp">	</span><span class="cm">/* continue normal handling for a debug exception... */</span><span class="cp">		      \</span>
<span class="cp">2:	mfspr	r4,SPRN_DBSR;						      \</span>
<span class="cp">	addi	r3,r1,STACK_FRAME_OVERHEAD;				      \</span>
<span class="cp">	EXC_XFER_TEMPLATE(DebugException, 0x2008, (MSR_KERNEL &amp; ~(MSR_ME|MSR_DE|MSR_CE)), NOCOPY, debug_transfer_to_handler, ret_from_debug_exc)</span>

<span class="cp">#define DEBUG_CRIT_EXCEPTION						      \</span>
<span class="cp">	START_EXCEPTION(DebugCrit);					      \</span>
<span class="cp">	CRITICAL_EXCEPTION_PROLOG(DEBUG);				      \</span>
<span class="cp">									      \</span>
<span class="cp">	</span><span class="cm">/*								      \</span>
<span class="cm">	 * If there is a single step or branch-taken exception in an	      \</span>
<span class="cm">	 * exception entry sequence, it was probably meant to apply to	      \</span>
<span class="cm">	 * the code where the exception occurred (since exception entry	      \</span>
<span class="cm">	 * doesn&#39;t turn off DE automatically).  We simulate the effect	      \</span>
<span class="cm">	 * of turning off DE on entry to an exception handler by turning      \</span>
<span class="cm">	 * off DE in the CSRR1 value and clearing the debug status.	      \</span>
<span class="cm">	 */</span><span class="cp">								      \</span>
<span class="cp">	mfspr	r10,SPRN_DBSR;		</span><span class="cm">/* check single-step/branch taken */</span><span class="cp">  \</span>
<span class="cp">	andis.	r10,r10,(DBSR_IC|DBSR_BT)@h;				      \</span>
<span class="cp">	beq+	2f;							      \</span>
<span class="cp">									      \</span>
<span class="cp">	lis	r10,KERNELBASE@h;	</span><span class="cm">/* check if exception in vectors */</span><span class="cp">   \</span>
<span class="cp">	ori	r10,r10,KERNELBASE@l;					      \</span>
<span class="cp">	cmplw	r12,r10;						      \</span>
<span class="cp">	blt+	2f;			</span><span class="cm">/* addr below exception vectors */</span><span class="cp">    \</span>
<span class="cp">									      \</span>
<span class="cp">	lis	r10,DebugCrit@h;					      \</span>
<span class="cp">	ori	r10,r10,DebugCrit@l;					      \</span>
<span class="cp">	cmplw	r12,r10;						      \</span>
<span class="cp">	bgt+	2f;			</span><span class="cm">/* addr above exception vectors */</span><span class="cp">    \</span>
<span class="cp">									      \</span>
<span class="cp">	</span><span class="cm">/* here it looks like we got an inappropriate debug exception. */</span><span class="cp">     \</span>
<span class="cp">1:	rlwinm	r9,r9,0,~MSR_DE;	</span><span class="cm">/* clear DE in the CSRR1 value */</span><span class="cp">     \</span>
<span class="cp">	lis	r10,(DBSR_IC|DBSR_BT)@h;	</span><span class="cm">/* clear the IC event */</span><span class="cp">      \</span>
<span class="cp">	mtspr	SPRN_DBSR,r10;						      \</span>
<span class="cp">	</span><span class="cm">/* restore state and get out */</span><span class="cp">					      \</span>
<span class="cp">	lwz	r10,_CCR(r11);						      \</span>
<span class="cp">	lwz	r0,GPR0(r11);						      \</span>
<span class="cp">	lwz	r1,GPR1(r11);						      \</span>
<span class="cp">	mtcrf	0x80,r10;						      \</span>
<span class="cp">	mtspr	SPRN_CSRR0,r12;						      \</span>
<span class="cp">	mtspr	SPRN_CSRR1,r9;						      \</span>
<span class="cp">	lwz	r9,GPR9(r11);						      \</span>
<span class="cp">	lwz	r12,GPR12(r11);						      \</span>
<span class="cp">	mtspr	SPRN_SPRG_WSCRATCH_CRIT,r8;				      \</span>
<span class="cp">	BOOKE_LOAD_EXC_LEVEL_STACK(CRIT); </span><span class="cm">/* r8 points to the debug stack */</span><span class="cp">  \</span>
<span class="cp">	lwz	r10,GPR10(r8);						      \</span>
<span class="cp">	lwz	r11,GPR11(r8);						      \</span>
<span class="cp">	mfspr	r8,SPRN_SPRG_RSCRATCH_CRIT;				      \</span>
<span class="cp">									      \</span>
<span class="cp">	rfci;								      \</span>
<span class="cp">	b	.;							      \</span>
<span class="cp">									      \</span>
<span class="cp">	</span><span class="cm">/* continue normal handling for a critical exception... */</span><span class="cp">	      \</span>
<span class="cp">2:	mfspr	r4,SPRN_DBSR;						      \</span>
<span class="cp">	addi	r3,r1,STACK_FRAME_OVERHEAD;				      \</span>
<span class="cp">	EXC_XFER_TEMPLATE(DebugException, 0x2002, (MSR_KERNEL &amp; ~(MSR_ME|MSR_DE|MSR_CE)), NOCOPY, crit_transfer_to_handler, ret_from_crit_exc)</span>

<span class="cp">#define DATA_STORAGE_EXCEPTION						      \</span>
<span class="cp">	START_EXCEPTION(DataStorage)					      \</span>
<span class="cp">	NORMAL_EXCEPTION_PROLOG(DATA_STORAGE);		      \</span>
<span class="cp">	mfspr	r5,SPRN_ESR;		</span><span class="cm">/* Grab the ESR and save it */</span><span class="cp">	      \</span>
<span class="cp">	stw	r5,_ESR(r11);						      \</span>
<span class="cp">	mfspr	r4,SPRN_DEAR;		</span><span class="cm">/* Grab the DEAR */</span><span class="cp">		      \</span>
<span class="cp">	EXC_XFER_LITE(0x0300, handle_page_fault)</span>

<span class="cp">#define INSTRUCTION_STORAGE_EXCEPTION					      \</span>
<span class="cp">	START_EXCEPTION(InstructionStorage)				      \</span>
<span class="cp">	NORMAL_EXCEPTION_PROLOG(INST_STORAGE);		      \</span>
<span class="cp">	mfspr	r5,SPRN_ESR;		</span><span class="cm">/* Grab the ESR and save it */</span><span class="cp">	      \</span>
<span class="cp">	stw	r5,_ESR(r11);						      \</span>
<span class="cp">	mr      r4,r12;                 </span><span class="cm">/* Pass SRR0 as arg2 */</span><span class="cp">		      \</span>
<span class="cp">	li      r5,0;                   </span><span class="cm">/* Pass zero as arg3 */</span><span class="cp">		      \</span>
<span class="cp">	EXC_XFER_LITE(0x0400, handle_page_fault)</span>

<span class="cp">#define ALIGNMENT_EXCEPTION						      \</span>
<span class="cp">	START_EXCEPTION(Alignment)					      \</span>
<span class="cp">	NORMAL_EXCEPTION_PROLOG(ALIGNMENT);		      \</span>
<span class="cp">	mfspr   r4,SPRN_DEAR;           </span><span class="cm">/* Grab the DEAR and save it */</span><span class="cp">	      \</span>
<span class="cp">	stw     r4,_DEAR(r11);						      \</span>
<span class="cp">	addi    r3,r1,STACK_FRAME_OVERHEAD;				      \</span>
<span class="cp">	EXC_XFER_EE(0x0600, alignment_exception)</span>

<span class="cp">#define PROGRAM_EXCEPTION						      \</span>
<span class="cp">	START_EXCEPTION(Program)					      \</span>
<span class="cp">	NORMAL_EXCEPTION_PROLOG(PROGRAM);		      \</span>
<span class="cp">	mfspr	r4,SPRN_ESR;		</span><span class="cm">/* Grab the ESR and save it */</span><span class="cp">	      \</span>
<span class="cp">	stw	r4,_ESR(r11);						      \</span>
<span class="cp">	addi	r3,r1,STACK_FRAME_OVERHEAD;				      \</span>
<span class="cp">	EXC_XFER_STD(0x0700, program_check_exception)</span>

<span class="cp">#define DECREMENTER_EXCEPTION						      \</span>
<span class="cp">	START_EXCEPTION(Decrementer)					      \</span>
<span class="cp">	NORMAL_EXCEPTION_PROLOG(DECREMENTER);		      \</span>
<span class="cp">	lis     r0,TSR_DIS@h;           </span><span class="cm">/* Setup the DEC interrupt mask */</span><span class="cp">    \</span>
<span class="cp">	mtspr   SPRN_TSR,r0;		</span><span class="cm">/* Clear the DEC interrupt */</span><span class="cp">	      \</span>
<span class="cp">	addi    r3,r1,STACK_FRAME_OVERHEAD;				      \</span>
<span class="cp">	EXC_XFER_LITE(0x0900, timer_interrupt)</span>

<span class="cp">#define FP_UNAVAILABLE_EXCEPTION					      \</span>
<span class="cp">	START_EXCEPTION(FloatingPointUnavailable)			      \</span>
<span class="cp">	NORMAL_EXCEPTION_PROLOG(FP_UNAVAIL);		      \</span>
<span class="cp">	beq	1f;							      \</span>
<span class="cp">	bl	load_up_fpu;		</span><span class="cm">/* if from user, just load it up */</span><span class="cp">   \</span>
<span class="cp">	b	fast_exception_return;					      \</span>
<span class="cp">1:	addi	r3,r1,STACK_FRAME_OVERHEAD;				      \</span>
<span class="cp">	EXC_XFER_EE_LITE(0x800, kernel_fp_unavailable_exception)</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="k">struct</span> <span class="n">exception_regs</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mas0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mas1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mas2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mas3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mas6</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mas7</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">srr0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">srr1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">csrr0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">csrr1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dsrr0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dsrr1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">saved_ksp_limit</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* ensure this structure is always sized to a multiple of the stack alignment */</span>
<span class="cp">#define STACK_EXC_LVL_FRAME_SIZE	_ALIGN_UP(sizeof (struct exception_regs), 16)</span>

<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* __HEAD_BOOKE_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
