<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › kernel › smp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>smp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SMP support for ppc.</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Cort Dougan (cort@cs.nmt.edu) borrowing a great</span>
<span class="cm"> * deal of code from the sparc and intel versions.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1999 Cort Dougan &lt;cort@cs.nmt.edu&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * PowerPC-64 Support added by Dave Engebretsen, Peter Bergner, and</span>
<span class="cm"> * Mike Corrigan {engebret|bergner|mikec}@us.ibm.com</span>
<span class="cm"> *</span>
<span class="cm"> *      This program is free software; you can redistribute it and/or</span>
<span class="cm"> *      modify it under the terms of the GNU General Public License</span>
<span class="cm"> *      as published by the Free Software Foundation; either version</span>
<span class="cm"> *      2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#undef DEBUG</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/topology.h&gt;</span>

<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#include &lt;asm/time.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/cputhreads.h&gt;</span>
<span class="cp">#include &lt;asm/cputable.h&gt;</span>
<span class="cp">#include &lt;asm/mpic.h&gt;</span>
<span class="cp">#include &lt;asm/vdso_datapage.h&gt;</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cp">#include &lt;asm/paca.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;asm/debug.h&gt;</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp">#include &lt;asm/udbg.h&gt;</span>
<span class="cp">#define DBG(fmt...) udbg_printf(fmt)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG(fmt...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="cm">/* State of each CPU during hotplug phases */</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">cpu_state</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">secondary_ti</span><span class="p">;</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">cpumask_var_t</span><span class="p">,</span> <span class="n">cpu_sibling_map</span><span class="p">);</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">cpumask_var_t</span><span class="p">,</span> <span class="n">cpu_core_map</span><span class="p">);</span>

<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">);</span>
<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">cpu_core_map</span><span class="p">);</span>

<span class="cm">/* SMP operations for this machine */</span>
<span class="k">struct</span> <span class="n">smp_ops_t</span> <span class="o">*</span><span class="n">smp_ops</span><span class="p">;</span>

<span class="cm">/* Can&#39;t be static due to PowerMac hackery */</span>
<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_callin_map</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">smt_enabled_at_boot</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">crash_ipi_function_ptr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">smp_generic_kick_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nr</span> <span class="o">&gt;=</span> <span class="n">NR_CPUS</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The processor is currently spinning, waiting for the</span>
<span class="cm">	 * cpu_start field to become non-zero After we set cpu_start,</span>
<span class="cm">	 * the processor will continue on to secondary_start</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">paca</span><span class="p">[</span><span class="n">nr</span><span class="p">].</span><span class="n">cpu_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">paca</span><span class="p">[</span><span class="n">nr</span><span class="p">].</span><span class="n">cpu_start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ok it&#39;s not there, so it might be soft-unplugged, let&#39;s</span>
<span class="cm">	 * try to bring it back</span>
<span class="cm">	 */</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">,</span> <span class="n">nr</span><span class="p">)</span> <span class="o">=</span> <span class="n">CPU_UP_PREPARE</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">smp_send_reschedule</span><span class="p">(</span><span class="n">nr</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">call_function_action</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">generic_smp_call_function_interrupt</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">reschedule_action</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scheduler_ipi</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">call_function_single_action</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">generic_smp_call_function_single_interrupt</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">debug_ipi_action</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crash_ipi_function_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">crash_ipi_function_ptr</span><span class="p">(</span><span class="n">get_irq_regs</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUGGER</span>
	<span class="n">debugger_ipi</span><span class="p">(</span><span class="n">get_irq_regs</span><span class="p">());</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUGGER */</span><span class="cp"></span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irq_handler_t</span> <span class="n">smp_ipi_action</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">PPC_MSG_CALL_FUNCTION</span><span class="p">]</span> <span class="o">=</span>  <span class="n">call_function_action</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PPC_MSG_RESCHEDULE</span><span class="p">]</span> <span class="o">=</span> <span class="n">reschedule_action</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PPC_MSG_CALL_FUNC_SINGLE</span><span class="p">]</span> <span class="o">=</span> <span class="n">call_function_single_action</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PPC_MSG_DEBUGGER_BREAK</span><span class="p">]</span> <span class="o">=</span> <span class="n">debug_ipi_action</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">smp_ipi_name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">PPC_MSG_CALL_FUNCTION</span><span class="p">]</span> <span class="o">=</span>  <span class="s">&quot;ipi call function&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PPC_MSG_RESCHEDULE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ipi reschedule&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PPC_MSG_CALL_FUNC_SINGLE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ipi call function single&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PPC_MSG_DEBUGGER_BREAK</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ipi debugger&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* optional function to request ipi, for controllers with &gt;= 4 ipis */</span>
<span class="kt">int</span> <span class="nf">smp_request_message_ipi</span><span class="p">(</span><span class="kt">int</span> <span class="n">virq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">msg</span> <span class="o">&gt;</span> <span class="n">PPC_MSG_DEBUGGER_BREAK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if !defined(CONFIG_DEBUGGER) &amp;&amp; !defined(CONFIG_KEXEC)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">==</span> <span class="n">PPC_MSG_DEBUGGER_BREAK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">virq</span><span class="p">,</span> <span class="n">smp_ipi_action</span><span class="p">[</span><span class="n">msg</span><span class="p">],</span>
			  <span class="n">IRQF_PERCPU</span> <span class="o">|</span> <span class="n">IRQF_NO_THREAD</span><span class="p">,</span>
			  <span class="n">smp_ipi_name</span><span class="p">[</span><span class="n">msg</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;unable to request_irq %d for %s (rc %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">virq</span><span class="p">,</span> <span class="n">smp_ipi_name</span><span class="p">[</span><span class="n">msg</span><span class="p">],</span> <span class="n">err</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC_SMP_MUXED_IPI</span>
<span class="k">struct</span> <span class="n">cpu_messages</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">messages</span><span class="p">;</span>			<span class="cm">/* current messages */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">;</span>		<span class="cm">/* data for cause ipi */</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU_SHARED_ALIGNED</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_messages</span><span class="p">,</span> <span class="n">ipi_message</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">smp_muxed_ipi_set_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_messages</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ipi_message</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smp_muxed_ipi_message_pass</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_messages</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ipi_message</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">messages</span><span class="p">;</span>

	<span class="n">message</span><span class="p">[</span><span class="n">msg</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">cause_ipi</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">irqreturn_t</span> <span class="nf">smp_ipi_demux</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_messages</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ipi_message</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">all</span><span class="p">;</span>

	<span class="n">mb</span><span class="p">();</span>	<span class="cm">/* order any irq clear */</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">all</span> <span class="o">=</span> <span class="n">xchg_local</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">messages</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifdef __BIG_ENDIAN</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">all</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">24</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">PPC_MSG_CALL_FUNCTION</span><span class="p">)))</span>
			<span class="n">generic_smp_call_function_interrupt</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">all</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">24</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">PPC_MSG_RESCHEDULE</span><span class="p">)))</span>
			<span class="n">scheduler_ipi</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">all</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">24</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">PPC_MSG_CALL_FUNC_SINGLE</span><span class="p">)))</span>
			<span class="n">generic_smp_call_function_single_interrupt</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">all</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">24</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">PPC_MSG_DEBUGGER_BREAK</span><span class="p">)))</span>
			<span class="n">debug_ipi_action</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#error Unsupported ENDIAN</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">messages</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_SMP_MUXED_IPI */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">do_message_pass</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">message_pass</span><span class="p">)</span>
		<span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">message_pass</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PPC_SMP_MUXED_IPI</span>
	<span class="k">else</span>
		<span class="n">smp_muxed_ipi_message_pass</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smp_send_reschedule</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">smp_ops</span><span class="p">))</span>
		<span class="n">do_message_pass</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">PPC_MSG_RESCHEDULE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">smp_send_reschedule</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">arch_send_call_function_single_ipi</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">do_message_pass</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">PPC_MSG_CALL_FUNC_SINGLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arch_send_call_function_ipi_mask</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
		<span class="n">do_message_pass</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">PPC_MSG_CALL_FUNCTION</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_DEBUGGER) || defined(CONFIG_KEXEC)</span>
<span class="kt">void</span> <span class="nf">smp_send_debugger_break</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">me</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">smp_ops</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">me</span><span class="p">)</span>
			<span class="n">do_message_pass</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">PPC_MSG_DEBUGGER_BREAK</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_KEXEC</span>
<span class="kt">void</span> <span class="nf">crash_send_ipi</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">crash_ipi_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">crash_ipi_function_ptr</span> <span class="o">=</span> <span class="n">crash_ipi_callback</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crash_ipi_callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mb</span><span class="p">();</span>
		<span class="n">smp_send_debugger_break</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">stop_this_cpu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Remove this CPU */</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smp_send_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_call_function</span><span class="p">(</span><span class="n">stop_this_cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">current_set</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">smp_store_cpu_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_pvr</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_PVR</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PPC_FSL_BOOK3E</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">next_tlbcam_idx</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span>
		<span class="o">=</span> <span class="p">(</span><span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_TLB1CFG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TLBnCFG_N_ENTRY</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_prepare_cpus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;smp_prepare_cpus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * setup_cpu may need to be called on the boot cpu. We havent</span>
<span class="cm">	 * spun any cpus up but lets be paranoid.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">boot_cpuid</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="cm">/* Fixup boot cpu */</span>
	<span class="n">smp_store_cpu_info</span><span class="p">(</span><span class="n">boot_cpuid</span><span class="p">);</span>
	<span class="n">cpu_callin_map</span><span class="p">[</span><span class="n">boot_cpuid</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">zalloc_cpumask_var_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="n">zalloc_cpumask_var_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_core_map</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">boot_cpuid</span><span class="p">,</span> <span class="n">cpu_sibling_mask</span><span class="p">(</span><span class="n">boot_cpuid</span><span class="p">));</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">boot_cpuid</span><span class="p">,</span> <span class="n">cpu_core_mask</span><span class="p">(</span><span class="n">boot_cpuid</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smp_ops</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">)</span>
			<span class="n">max_cpus</span> <span class="o">=</span> <span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">();</span>
		<span class="k">else</span>
			<span class="n">max_cpus</span> <span class="o">=</span> <span class="n">NR_CPUS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">max_cpus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">smp_prepare_boot_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()</span> <span class="o">!=</span> <span class="n">boot_cpuid</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="n">paca</span><span class="p">[</span><span class="n">boot_cpuid</span><span class="p">].</span><span class="n">__current</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">current_set</span><span class="p">[</span><span class="n">boot_cpuid</span><span class="p">]</span> <span class="o">=</span> <span class="n">task_thread_info</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>

<span class="kt">int</span> <span class="nf">generic_cpu_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">boot_cpuid</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">processorCount</span><span class="o">--</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">migrate_irqs</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">generic_cpu_die</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smp_rmb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPU_DEAD</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;CPU%d didn&#39;t die...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">generic_mach_cpu_die</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">idle_task_exit</span><span class="p">();</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;CPU%d offline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">)</span> <span class="o">=</span> <span class="n">CPU_DEAD</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CPU_UP_PREPARE</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">generic_set_cpu_dead</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">CPU_DEAD</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">generic_check_cpu_restart</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPU_UP_PREPARE</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_idle_thread_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">task_thread_info</span><span class="p">(</span><span class="n">idle</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="n">paca</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">__current</span> <span class="o">=</span> <span class="n">idle</span><span class="p">;</span>
	<span class="n">paca</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">kstack</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ti</span> <span class="o">+</span> <span class="n">THREAD_SIZE</span> <span class="o">-</span> <span class="n">STACK_FRAME_OVERHEAD</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">secondary_ti</span> <span class="o">=</span> <span class="n">current_set</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">__cpu_up</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tidle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smp_ops</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">cpu_bootable</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">cpu_bootable</span><span class="p">(</span><span class="n">cpu</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">cpu_idle_thread_init</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tidle</span><span class="p">);</span>

	<span class="cm">/* Make sure callin-map entry is 0 (can be leftover a CPU</span>
<span class="cm">	 * hotplug</span>
<span class="cm">	 */</span>
	<span class="n">cpu_callin_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The information for processor bringup must</span>
<span class="cm">	 * be written out to main store before we release</span>
<span class="cm">	 * the processor.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="cm">/* wake up cpus */</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;smp: kicking cpu %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">kick_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;smp: failed starting cpu %d (rc %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * wait to see if the cpu made a callin (is actually up).</span>
<span class="cm">	 * use this value that I found through experimentation.</span>
<span class="cm">	 * -- Cort</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">system_state</span> <span class="o">&lt;</span> <span class="n">SYSTEM_RUNNING</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">;</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_callin_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span> <span class="n">c</span><span class="o">--</span><span class="p">)</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="k">else</span>
		<span class="cm">/*</span>
<span class="cm">		 * CPUs can take much longer to come up in the</span>
<span class="cm">		 * hotplug case.  Wait five seconds.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_callin_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span> <span class="n">c</span><span class="o">--</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_callin_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Processor %u is stuck.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;Processor %u found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">give_timebase</span><span class="p">)</span>
		<span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">give_timebase</span><span class="p">();</span>

	<span class="cm">/* Wait until cpu puts itself in the online map */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return the value of the reg property corresponding to the given</span>
<span class="cm"> * logical cpu.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cpu_to_core_id</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">np</span> <span class="o">=</span> <span class="n">of_get_cpu_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reg</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">id</span> <span class="o">=</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Helper routines for cpu to core mapping */</span>
<span class="kt">int</span> <span class="nf">cpu_core_index_of_thread</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu</span> <span class="o">&gt;&gt;</span> <span class="n">threads_shift</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cpu_core_index_of_thread</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">cpu_first_thread_of_core</span><span class="p">(</span><span class="kt">int</span> <span class="n">core</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">core</span> <span class="o">&lt;&lt;</span> <span class="n">threads_shift</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cpu_first_thread_of_core</span><span class="p">);</span>

<span class="cm">/* Must be called when no change can occur to cpu_present_mask,</span>
<span class="cm"> * i.e. during cpu online or offline.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">cpu_to_l2cache</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_present</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">np</span> <span class="o">=</span> <span class="n">of_get_cpu_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">of_find_next_cache_node</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Activate a secondary processor. */</span>
<span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">start_secondary</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">l2_cache</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">base</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">mm_count</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">;</span>

	<span class="n">smp_store_cpu_info</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">set_dec</span><span class="p">(</span><span class="n">tb_ticks_per_jiffy</span><span class="p">);</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">cpu_callin_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">setup_cpu</span><span class="p">)</span>
		<span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">setup_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">take_timebase</span><span class="p">)</span>
		<span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">take_timebase</span><span class="p">();</span>

	<span class="n">secondary_cpu_time_init</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">system_state</span> <span class="o">==</span> <span class="n">SYSTEM_RUNNING</span><span class="p">)</span>
		<span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">processorCount</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">ipi_call_lock</span><span class="p">();</span>
	<span class="n">notify_cpu_starting</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="cm">/* Update sibling maps */</span>
	<span class="n">base</span> <span class="o">=</span> <span class="n">cpu_first_thread_sibling</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads_per_core</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_offline</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_sibling_mask</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">cpu_sibling_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>

		<span class="cm">/* cpu_core_map should be a superset of</span>
<span class="cm">		 * cpu_sibling_map even if we don&#39;t have cache</span>
<span class="cm">		 * information, so update the former here, too.</span>
<span class="cm">		 */</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_core_mask</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">cpu_core_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">l2_cache</span> <span class="o">=</span> <span class="n">cpu_to_l2cache</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">cpu_to_l2cache</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span> <span class="o">==</span> <span class="n">l2_cache</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_core_mask</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cpu_core_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">l2_cache</span><span class="p">);</span>
	<span class="n">ipi_call_unlock</span><span class="p">();</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">cpu_idle</span><span class="p">();</span>

	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">setup_profiling_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">multiplier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_cpus_done</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_var_t</span> <span class="n">old_mask</span><span class="p">;</span>

	<span class="cm">/* We want the setup_cpu() here to be called from CPU 0, but our</span>
<span class="cm">	 * init thread may have been &quot;borrowed&quot; by another CPU in the meantime</span>
<span class="cm">	 * se we pin us down to CPU 0 for a short while</span>
<span class="cm">	 */</span>
	<span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_mask</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">);</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">old_mask</span><span class="p">,</span> <span class="n">tsk_cpus_allowed</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
	<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">boot_cpuid</span><span class="p">));</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">smp_ops</span> <span class="o">&amp;&amp;</span> <span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">setup_cpu</span><span class="p">)</span>
		<span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">setup_cpu</span><span class="p">(</span><span class="n">boot_cpuid</span><span class="p">);</span>

	<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">old_mask</span><span class="p">);</span>

	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">old_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smp_ops</span> <span class="o">&amp;&amp;</span> <span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">bringup_done</span><span class="p">)</span>
		<span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">bringup_done</span><span class="p">();</span>

	<span class="n">dump_numa_cpu_topology</span><span class="p">();</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">arch_sd_sibling_asym_packing</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_ASYM_SMT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Enabling Asymmetric SMT scheduling</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SD_ASYM_PACKING</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="kt">int</span> <span class="nf">__cpu_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">l2_cache</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">cpu_disable</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">cpu_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Update sibling maps */</span>
	<span class="n">base</span> <span class="o">=</span> <span class="n">cpu_first_thread_sibling</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads_per_core</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_sibling_mask</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">cpu_sibling_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_core_mask</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">cpu_core_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">l2_cache</span> <span class="o">=</span> <span class="n">cpu_to_l2cache</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">cpu_to_l2cache</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span> <span class="o">==</span> <span class="n">l2_cache</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_core_mask</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
			<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cpu_core_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">l2_cache</span><span class="p">);</span>


	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__cpu_die</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">cpu_die</span><span class="p">)</span>
		<span class="n">smp_ops</span><span class="o">-&gt;</span><span class="n">cpu_die</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">powerpc_cpu_hotplug_driver_mutex</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">cpu_hotplug_driver_lock</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">powerpc_cpu_hotplug_driver_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cpu_hotplug_driver_unlock</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">powerpc_cpu_hotplug_driver_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cpu_die</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">cpu_die</span><span class="p">)</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">cpu_die</span><span class="p">();</span>

	<span class="cm">/* If we return, we re-enter start_secondary */</span>
	<span class="n">start_secondary_resume</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
