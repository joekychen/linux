<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › kernel › fadump.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fadump.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Firmware Assisted dump: A robust mechanism to get reliable kernel crash</span>
<span class="cm"> * dump with assistance from firmware. This approach does not use kexec,</span>
<span class="cm"> * instead firmware assists in booting the kdump kernel while preserving</span>
<span class="cm"> * memory contents. The most of the code implementation has been adapted</span>
<span class="cm"> * from phyp assisted dump implementation written by Linas Vepstas and</span>
<span class="cm"> * Manish Ahuja</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2011 IBM Corporation</span>
<span class="cm"> * Author: Mahesh Salgaonkar &lt;mahesh@linux.vnet.ibm.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#undef DEBUG</span>
<span class="cp">#define pr_fmt(fmt) &quot;fadump: &quot; fmt</span>

<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/crash_dump.h&gt;</span>
<span class="cp">#include &lt;linux/kobject.h&gt;</span>
<span class="cp">#include &lt;linux/sysfs.h&gt;</span>

<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/rtas.h&gt;</span>
<span class="cp">#include &lt;asm/fadump.h&gt;</span>
<span class="cp">#include &lt;asm/debug.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fw_dump</span> <span class="n">fw_dump</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fadump_mem_struct</span> <span class="n">fdm</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">fadump_mem_struct</span> <span class="o">*</span><span class="n">fdm_active</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">fadump_mutex</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">fad_crash_memory_ranges</span> <span class="n">crash_memory_ranges</span><span class="p">[</span><span class="n">INIT_CRASHMEM_RANGES</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">crash_mem_ranges</span><span class="p">;</span>

<span class="cm">/* Scan the Firmware Assisted dump configuration details. */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_init_dt_scan_fw_dump</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">sections</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_sections</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">token</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">uname</span><span class="p">,</span> <span class="s">&quot;rtas&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if Firmware Assisted dump is supported. if yes, check</span>
<span class="cm">	 * if dump has been initiated on last reboot.</span>
<span class="cm">	 */</span>
	<span class="n">token</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ibm,configure-kernel-dump&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">token</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fw_dump</span><span class="p">.</span><span class="n">fadump_supported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">fw_dump</span><span class="p">.</span><span class="n">ibm_configure_kernel_dump</span> <span class="o">=</span> <span class="o">*</span><span class="n">token</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The &#39;ibm,kernel-dump&#39; rtas node is present only if there is</span>
<span class="cm">	 * dump data waiting for us.</span>
<span class="cm">	 */</span>
	<span class="n">fdm_active</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ibm,kernel-dump&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fdm_active</span><span class="p">)</span>
		<span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Get the sizes required to store dump data for the firmware provided</span>
<span class="cm">	 * dump sections.</span>
<span class="cm">	 * For each dump section type supported, a 32bit cell which defines</span>
<span class="cm">	 * the ID of a supported section followed by two 32 bit cells which</span>
<span class="cm">	 * gives teh size of the section in bytes.</span>
<span class="cm">	 */</span>
	<span class="n">sections</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ibm,configure-kernel-dump-sizes&quot;</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sections</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">num_sections</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_sections</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">sections</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">type</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">of_read_number</span><span class="p">(</span><span class="n">sections</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FADUMP_CPU_STATE_DATA</span>:
			<span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_state_data_size</span> <span class="o">=</span>
					<span class="n">of_read_ulong</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sections</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FADUMP_HPTE_REGION</span>:
			<span class="n">fw_dump</span><span class="p">.</span><span class="n">hpte_region_size</span> <span class="o">=</span>
					<span class="n">of_read_ulong</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sections</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_fadump_active</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_active</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Print firmware assisted dump configurations for debugging purpose. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fadump_show_config</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Support for firmware-assisted dump (fadump): %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">fadump_supported</span> <span class="o">?</span> <span class="s">&quot;present&quot;</span> <span class="o">:</span> <span class="s">&quot;no support&quot;</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">fadump_supported</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Fadump enabled    : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">fadump_enabled</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">));</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Dump Active       : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_active</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">));</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Dump section sizes:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;    CPU state data size: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_state_data_size</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;    HPTE region size   : %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">hpte_region_size</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Boot memory size  : %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">boot_memory_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">init_fadump_mem_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">fadump_mem_struct</span> <span class="o">*</span><span class="n">fdm</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fdm</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">fdm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fadump_mem_struct</span><span class="p">));</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dump_format_version</span> <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dump_num_sections</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dump_status_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">offset_first_dump_section</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fadump_mem_struct</span><span class="p">,</span> <span class="n">cpu_state_data</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fields for disk dump option.</span>
<span class="cm">	 * We are not using disk dump option, hence set these fields to 0.</span>
<span class="cm">	 */</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dd_block_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dd_block_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dd_num_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dd_offset_disk_path</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* set 0 to disable an automatic dump-reboot. */</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">max_time_auto</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Kernel dump sections */</span>
	<span class="cm">/* cpu state data section. */</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">request_flag</span> <span class="o">=</span> <span class="n">FADUMP_REQUEST_FLAG</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">source_data_type</span> <span class="o">=</span> <span class="n">FADUMP_CPU_STATE_DATA</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">source_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">source_len</span> <span class="o">=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_state_data_size</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">destination_address</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_state_data_size</span><span class="p">;</span>

	<span class="cm">/* hpte region section */</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">hpte_region</span><span class="p">.</span><span class="n">request_flag</span> <span class="o">=</span> <span class="n">FADUMP_REQUEST_FLAG</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">hpte_region</span><span class="p">.</span><span class="n">source_data_type</span> <span class="o">=</span> <span class="n">FADUMP_HPTE_REGION</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">hpte_region</span><span class="p">.</span><span class="n">source_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">hpte_region</span><span class="p">.</span><span class="n">source_len</span> <span class="o">=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">hpte_region_size</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">hpte_region</span><span class="p">.</span><span class="n">destination_address</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">hpte_region_size</span><span class="p">;</span>

	<span class="cm">/* RMA region section */</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">request_flag</span> <span class="o">=</span> <span class="n">FADUMP_REQUEST_FLAG</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">source_data_type</span> <span class="o">=</span> <span class="n">FADUMP_REAL_MODE_REGION</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">source_address</span> <span class="o">=</span> <span class="n">RMA_START</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">source_len</span> <span class="o">=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">boot_memory_size</span><span class="p">;</span>
	<span class="n">fdm</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">destination_address</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">boot_memory_size</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fadump_calculate_reserve_size(): reserve variable boot area 5% of System RAM</span>
<span class="cm"> *</span>
<span class="cm"> * Function to find the largest memory size we need to reserve during early</span>
<span class="cm"> * boot process. This will be the size of the memory that is required for a</span>
<span class="cm"> * kernel to boot successfully.</span>
<span class="cm"> *</span>
<span class="cm"> * This function has been taken from phyp-assisted dump feature implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * returns larger of 256MB or 5% rounded down to multiples of 256MB.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: Come up with better approach to find out more accurate memory size</span>
<span class="cm"> * that is required for a kernel to boot successfully.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">fadump_calculate_reserve_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the size is specified through fadump_reserve_mem= cmdline</span>
<span class="cm">	 * option. If yes, then use that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_bootvar</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_bootvar</span><span class="p">;</span>

	<span class="cm">/* divide by 20 to get 5% of value */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">memblock_end_of_DRAM</span><span class="p">()</span> <span class="o">/</span> <span class="mi">20</span><span class="p">;</span>

	<span class="cm">/* round it down in multiples of 256 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x0FFFFFFFUL</span><span class="p">;</span>

	<span class="cm">/* Truncate to memory_limit. We don&#39;t want to over reserve the memory.*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memory_limit</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">memory_limit</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">memory_limit</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">MIN_BOOT_MEM</span> <span class="o">?</span> <span class="n">size</span> <span class="o">:</span> <span class="n">MIN_BOOT_MEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the total memory size required to be reserved for</span>
<span class="cm"> * firmware-assisted dump registration.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_fadump_area_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">+=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_state_data_size</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">hpte_region_size</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">boot_memory_size</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fadump_crash_info_header</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span><span class="p">);</span> <span class="cm">/* ELF core header.*/</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">);</span> <span class="cm">/* place holder for cpu notes */</span>
	<span class="cm">/* Program headers for crash memory regions. */</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">memblock_num_regions</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">fadump_reserve_mem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">memory_boundary</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">fadump_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">fadump_supported</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Firmware-assisted dump is not supported on&quot;</span>
				<span class="s">&quot; this hardware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">fw_dump</span><span class="p">.</span><span class="n">fadump_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initialize boot memory size</span>
<span class="cm">	 * If dump is active then we have already calculated the size during</span>
<span class="cm">	 * first kernel.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fdm_active</span><span class="p">)</span>
		<span class="n">fw_dump</span><span class="p">.</span><span class="n">boot_memory_size</span> <span class="o">=</span> <span class="n">fdm_active</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">source_len</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">fw_dump</span><span class="p">.</span><span class="n">boot_memory_size</span> <span class="o">=</span> <span class="n">fadump_calculate_reserve_size</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the memory boundary.</span>
<span class="cm">	 * If memory_limit is less than actual memory boundary then reserve</span>
<span class="cm">	 * the memory for fadump beyond the memory_limit and adjust the</span>
<span class="cm">	 * memory_limit accordingly, so that the running kernel can run with</span>
<span class="cm">	 * specified memory_limit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memory_limit</span> <span class="o">&amp;&amp;</span> <span class="n">memory_limit</span> <span class="o">&lt;</span> <span class="n">memblock_end_of_DRAM</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">get_fadump_area_size</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">memory_limit</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">memblock_end_of_DRAM</span><span class="p">())</span>
			<span class="n">memory_limit</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">memory_limit</span> <span class="o">=</span> <span class="n">memblock_end_of_DRAM</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Adjusted memory_limit for firmware-assisted&quot;</span>
				<span class="s">&quot; dump, now %#016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">memory_limit</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memory_limit</span><span class="p">)</span>
		<span class="n">memory_boundary</span> <span class="o">=</span> <span class="n">memory_limit</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">memory_boundary</span> <span class="o">=</span> <span class="n">memblock_end_of_DRAM</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Firmware-assisted dump is active.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If last boot has crashed then reserve all the memory</span>
<span class="cm">		 * above boot_memory_size so that we don&#39;t touch it until</span>
<span class="cm">		 * dump is written to disk by userspace tool. This memory</span>
<span class="cm">		 * will be released for general use once the dump is saved.</span>
<span class="cm">		 */</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">boot_memory_size</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">memory_boundary</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>
		<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Reserved %ldMB of memory at %ldMB &quot;</span>
				<span class="s">&quot;for saving crash dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">base</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">));</span>

		<span class="n">fw_dump</span><span class="p">.</span><span class="n">fadumphdr_addr</span> <span class="o">=</span>
				<span class="n">fdm_active</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">destination_address</span> <span class="o">+</span>
				<span class="n">fdm_active</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">source_len</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;fadumphdr_addr = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">fadumphdr_addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Reserve the memory at the top of memory. */</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">get_fadump_area_size</span><span class="p">();</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">memory_boundary</span> <span class="o">-</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Reserved %ldMB of memory at %ldMB &quot;</span>
				<span class="s">&quot;for firmware-assisted dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">base</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_start</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Look for fadump= cmdline option. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_fadump_param</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fw_dump</span><span class="p">.</span><span class="n">fadump_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fw_dump</span><span class="p">.</span><span class="n">fadump_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;fadump&quot;</span><span class="p">,</span> <span class="n">early_fadump_param</span><span class="p">);</span>

<span class="cm">/* Look for fadump_reserve_mem= cmdline option */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_fadump_reserve_mem</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_bootvar</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;fadump_reserve_mem&quot;</span><span class="p">,</span> <span class="n">early_fadump_reserve_mem</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">register_fw_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">fadump_mem_struct</span> <span class="o">*</span><span class="n">fdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wait_time</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Registering for firmware-assisted kernel dump...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* TODO: Add upper time limit for the delay */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">ibm_configure_kernel_dump</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="n">FADUMP_REGISTER</span><span class="p">,</span> <span class="n">fdm</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fadump_mem_struct</span><span class="p">));</span>

		<span class="n">wait_time</span> <span class="o">=</span> <span class="n">rtas_busy_delay_time</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_time</span><span class="p">)</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="n">wait_time</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">wait_time</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="mi">1</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to register firmware-assisted kernel&quot;</span>
			<span class="s">&quot; dump. Hardware Error(%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="mi">3</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to register firmware-assisted kernel&quot;</span>
			<span class="s">&quot; dump. Parameter Error(%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="mi">9</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;firmware-assisted kernel dump is already &quot;</span>
			<span class="s">&quot; registered.&quot;</span><span class="p">);</span>
		<span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;firmware-assisted kernel dump registration&quot;</span>
			<span class="s">&quot; is successful</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">crash_fadump</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fadump_crash_info_header</span> <span class="o">*</span><span class="n">fdh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_registered</span> <span class="o">||</span> <span class="o">!</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">fadumphdr_addr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">fdh</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">fadumphdr_addr</span><span class="p">);</span>
	<span class="n">crashing_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">fdh</span><span class="o">-&gt;</span><span class="n">crashing_cpu</span> <span class="o">=</span> <span class="n">crashing_cpu</span><span class="p">;</span>
	<span class="n">crash_save_vmcoreinfo</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="p">)</span>
		<span class="n">fdh</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ppc_save_regs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdh</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>

	<span class="n">fdh</span><span class="o">-&gt;</span><span class="n">cpu_online_mask</span> <span class="o">=</span> <span class="o">*</span><span class="n">cpu_online_mask</span><span class="p">;</span>

	<span class="cm">/* Call ibm,os-term rtas call to trigger firmware assisted dump */</span>
	<span class="n">rtas_os_term</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define GPR_MASK	0xffffff0000000000</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fadump_gpr_index</span><span class="p">(</span><span class="n">u64</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">GPR_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">REG_ID</span><span class="p">(</span><span class="s">&quot;GPR&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* get the digits at the end */</span>
		<span class="n">id</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GPR_MASK</span><span class="p">;</span>
		<span class="n">id</span> <span class="o">&gt;&gt;=</span> <span class="mi">24</span><span class="p">;</span>
		<span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">id</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">sscanf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">31</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fadump_set_regval</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="n">u64</span> <span class="n">reg_id</span><span class="p">,</span>
								<span class="n">u64</span> <span class="n">reg_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">fadump_gpr_index</span><span class="p">(</span><span class="n">reg_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">reg_val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reg_id</span> <span class="o">==</span> <span class="n">REG_ID</span><span class="p">(</span><span class="s">&quot;NIA&quot;</span><span class="p">))</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">reg_val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reg_id</span> <span class="o">==</span> <span class="n">REG_ID</span><span class="p">(</span><span class="s">&quot;MSR&quot;</span><span class="p">))</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">reg_val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reg_id</span> <span class="o">==</span> <span class="n">REG_ID</span><span class="p">(</span><span class="s">&quot;CTR&quot;</span><span class="p">))</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ctr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">reg_val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reg_id</span> <span class="o">==</span> <span class="n">REG_ID</span><span class="p">(</span><span class="s">&quot;LR&quot;</span><span class="p">))</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">reg_val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reg_id</span> <span class="o">==</span> <span class="n">REG_ID</span><span class="p">(</span><span class="s">&quot;XER&quot;</span><span class="p">))</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">reg_val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reg_id</span> <span class="o">==</span> <span class="n">REG_ID</span><span class="p">(</span><span class="s">&quot;CR&quot;</span><span class="p">))</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ccr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">reg_val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reg_id</span> <span class="o">==</span> <span class="n">REG_ID</span><span class="p">(</span><span class="s">&quot;DAR&quot;</span><span class="p">))</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">dar</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">reg_val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reg_id</span> <span class="o">==</span> <span class="n">REG_ID</span><span class="p">(</span><span class="s">&quot;DSISR&quot;</span><span class="p">))</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">dsisr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">reg_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fadump_reg_entry</span><span class="o">*</span>
<span class="nf">fadump_read_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">fadump_reg_entry</span> <span class="o">*</span><span class="n">reg_entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span><span class="p">));</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">reg_entry</span><span class="o">-&gt;</span><span class="n">reg_id</span> <span class="o">!=</span> <span class="n">REG_ID</span><span class="p">(</span><span class="s">&quot;CPUEND&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fadump_set_regval</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">reg_entry</span><span class="o">-&gt;</span><span class="n">reg_id</span><span class="p">,</span>
					<span class="n">reg_entry</span><span class="o">-&gt;</span><span class="n">reg_value</span><span class="p">);</span>
		<span class="n">reg_entry</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">reg_entry</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">reg_entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="o">*</span><span class="nf">fadump_append_elf_note</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">type</span><span class="p">,</span>
						<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">data_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elf_note</span> <span class="n">note</span><span class="p">;</span>

	<span class="n">note</span><span class="p">.</span><span class="n">n_namesz</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">note</span><span class="p">.</span><span class="n">n_descsz</span> <span class="o">=</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="n">note</span><span class="p">.</span><span class="n">n_type</span>   <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">note</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">note</span><span class="p">));</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">note</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">note</span><span class="p">.</span><span class="n">n_namesz</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="p">(</span><span class="n">note</span><span class="p">.</span><span class="n">n_namesz</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">note</span><span class="p">.</span><span class="n">n_descsz</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="p">(</span><span class="n">note</span><span class="p">.</span><span class="n">n_descsz</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fadump_final_note</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elf_note</span> <span class="n">note</span><span class="p">;</span>

	<span class="n">note</span><span class="p">.</span><span class="n">n_namesz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">note</span><span class="p">.</span><span class="n">n_descsz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">note</span><span class="p">.</span><span class="n">n_type</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">note</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">note</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="o">*</span><span class="nf">fadump_regs_to_elf_notes</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elf_prstatus</span> <span class="n">prstatus</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prstatus</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">prstatus</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * FIXME: How do i get PID? Do I really need it?</span>
<span class="cm">	 * prstatus.pr_pid = ????</span>
<span class="cm">	 */</span>
	<span class="n">elf_core_copy_kernel_regs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prstatus</span><span class="p">.</span><span class="n">pr_reg</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">fadump_append_elf_note</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">KEXEC_CORE_NOTE_NAME</span><span class="p">,</span> <span class="n">NT_PRSTATUS</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">prstatus</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">prstatus</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fadump_update_elfcore_header</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">bufp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">elf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="n">phdr</span><span class="p">;</span>

	<span class="n">elf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">bufp</span><span class="p">;</span>
	<span class="n">bufp</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span><span class="p">);</span>

	<span class="cm">/* First note is a place holder for cpu notes info. */</span>
	<span class="n">phdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="p">)</span><span class="n">bufp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_type</span> <span class="o">==</span> <span class="n">PT_NOTE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_paddr</span> <span class="o">=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf</span><span class="p">;</span>
		<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_offset</span>	<span class="o">=</span> <span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_paddr</span><span class="p">;</span>
		<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_filesz</span>	<span class="o">=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf_size</span><span class="p">;</span>
		<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_memsz</span> <span class="o">=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">fadump_cpu_notes_buf_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">order</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">__GFP_ZERO</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vaddr</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">SetPageReserved</span><span class="p">(</span><span class="n">page</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vaddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fadump_cpu_notes_buf_free</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">order</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">page</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">__free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read CPU state dump data and convert it into ELF notes.</span>
<span class="cm"> * The CPU dump starts with magic number &quot;REGSAVE&quot;. NumCpusOffset should be</span>
<span class="cm"> * used to access the data to allow for additional fields to be added without</span>
<span class="cm"> * affecting compatibility. Each list of registers for a CPU starts with</span>
<span class="cm"> * &quot;CPUSTRT&quot; and ends with &quot;CPUEND&quot;. Each register entry is of 16 bytes,</span>
<span class="cm"> * 8 Byte ASCII identifier and 8 Byte register value. The register entry</span>
<span class="cm"> * with identifier &quot;CPUSTRT&quot; and &quot;CPUEND&quot; contains 4 byte cpu id as part</span>
<span class="cm"> * of register value. For more details refer to PAPR document.</span>
<span class="cm"> *</span>
<span class="cm"> * Only for the crashing cpu we ignore the CPU dump data and get exact</span>
<span class="cm"> * state from fadump crash info structure populated by first kernel at the</span>
<span class="cm"> * time of crash.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">fadump_build_cpu_notes</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">fadump_mem_struct</span> <span class="o">*</span><span class="n">fdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fadump_reg_save_area_header</span> <span class="o">*</span><span class="n">reg_header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fadump_reg_entry</span> <span class="o">*</span><span class="n">reg_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fadump_crash_info_header</span> <span class="o">*</span><span class="n">fdh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_cpus</span><span class="p">,</span> <span class="o">*</span><span class="n">note_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="n">regs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fdm</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">bytes_dumped</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">fdm</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">destination_address</span><span class="p">;</span>
	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="n">reg_header</span> <span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg_header</span><span class="o">-&gt;</span><span class="n">magic_number</span> <span class="o">!=</span> <span class="n">REGSAVE_AREA_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unable to read register save area.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;--------CPU State Data------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Magic Number: %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_header</span><span class="o">-&gt;</span><span class="n">magic_number</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;NumCpuOffset: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_header</span><span class="o">-&gt;</span><span class="n">num_cpu_offset</span><span class="p">);</span>

	<span class="n">vaddr</span> <span class="o">+=</span> <span class="n">reg_header</span><span class="o">-&gt;</span><span class="n">num_cpu_offset</span><span class="p">;</span>
	<span class="n">num_cpus</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">vaddr</span><span class="p">));</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;NumCpus     : %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num_cpus</span><span class="p">);</span>
	<span class="n">vaddr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
	<span class="n">reg_entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fadump_reg_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">vaddr</span><span class="p">;</span>

	<span class="cm">/* Allocate buffer to hold cpu crash notes. */</span>
	<span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf_size</span> <span class="o">=</span> <span class="n">num_cpus</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">note_buf_t</span><span class="p">);</span>
	<span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf_size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf_size</span><span class="p">);</span>
	<span class="n">note_buf</span> <span class="o">=</span> <span class="n">fadump_cpu_notes_buf_alloc</span><span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">note_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to allocate 0x%lx bytes for &quot;</span>
			<span class="s">&quot;cpu notes buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">note_buf</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Allocated buffer for cpu notes of size %ld at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">num_cpus</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">note_buf_t</span><span class="p">)),</span> <span class="n">note_buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">fadumphdr_addr</span><span class="p">)</span>
		<span class="n">fdh</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">fadumphdr_addr</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_cpus</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg_entry</span><span class="o">-&gt;</span><span class="n">reg_id</span> <span class="o">!=</span> <span class="n">REG_ID</span><span class="p">(</span><span class="s">&quot;CPUSTRT&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unable to read CPU state data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Lower 4 bytes of reg_value contains logical cpu id */</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">reg_entry</span><span class="o">-&gt;</span><span class="n">reg_value</span> <span class="o">&amp;</span> <span class="n">FADUMP_CPU_ID_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdh</span><span class="o">-&gt;</span><span class="n">cpu_online_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SKIP_TO_NEXT_CPU</span><span class="p">(</span><span class="n">reg_entry</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Reading register data for cpu %d...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fdh</span> <span class="o">&amp;&amp;</span> <span class="n">fdh</span><span class="o">-&gt;</span><span class="n">crashing_cpu</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">regs</span> <span class="o">=</span> <span class="n">fdh</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">;</span>
			<span class="n">note_buf</span> <span class="o">=</span> <span class="n">fadump_regs_to_elf_notes</span><span class="p">(</span><span class="n">note_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
			<span class="n">SKIP_TO_NEXT_CPU</span><span class="p">(</span><span class="n">reg_entry</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">reg_entry</span><span class="o">++</span><span class="p">;</span>
			<span class="n">reg_entry</span> <span class="o">=</span> <span class="n">fadump_read_registers</span><span class="p">(</span><span class="n">reg_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
			<span class="n">note_buf</span> <span class="o">=</span> <span class="n">fadump_regs_to_elf_notes</span><span class="p">(</span><span class="n">note_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">fadump_final_note</span><span class="p">(</span><span class="n">note_buf</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Updating elfcore header (%llx) with cpu notes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">fdh</span><span class="o">-&gt;</span><span class="n">elfcorehdr_addr</span><span class="p">);</span>
	<span class="n">fadump_update_elfcore_header</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">fdh</span><span class="o">-&gt;</span><span class="n">elfcorehdr_addr</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_out:</span>
	<span class="n">fadump_cpu_notes_buf_free</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf</span><span class="p">),</span>
					<span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf_size</span><span class="p">);</span>
	<span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Validate and process the dump data stored by firmware before exporting</span>
<span class="cm"> * it through &#39;/proc/vmcore&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">process_fadump</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">fadump_mem_struct</span> <span class="o">*</span><span class="n">fdm_active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fadump_crash_info_header</span> <span class="o">*</span><span class="n">fdh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fdm_active</span> <span class="o">||</span> <span class="o">!</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">fadumphdr_addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Check if the dump data is valid. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fdm_active</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dump_status_flag</span> <span class="o">==</span> <span class="n">FADUMP_ERROR_FLAG</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">fdm_active</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">error_flags</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">fdm_active</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">error_flags</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Dump taken by platform is not valid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fdm_active</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">bytes_dumped</span> <span class="o">!=</span>
			<span class="n">fdm_active</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">source_len</span><span class="p">)</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">fdm_active</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">bytes_dumped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Dump taken by platform is incomplete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Validate the fadump crash info header */</span>
	<span class="n">fdh</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">fadumphdr_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fdh</span><span class="o">-&gt;</span><span class="n">magic_number</span> <span class="o">!=</span> <span class="n">FADUMP_CRASH_INFO_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Crash info header is not valid.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fadump_build_cpu_notes</span><span class="p">(</span><span class="n">fdm_active</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are done validating dump info and elfcore header is now ready</span>
<span class="cm">	 * to be exported. set elfcorehdr_addr so that vmcore module will</span>
<span class="cm">	 * export the elfcore header through &#39;/proc/vmcore&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">elfcorehdr_addr</span> <span class="o">=</span> <span class="n">fdh</span><span class="o">-&gt;</span><span class="n">elfcorehdr_addr</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fadump_add_crash_memory</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;crash_memory_range[%d] [%#016llx-%#016llx], %#llx bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">crash_mem_ranges</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">base</span><span class="p">));</span>
	<span class="n">crash_memory_ranges</span><span class="p">[</span><span class="n">crash_mem_ranges</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">crash_memory_ranges</span><span class="p">[</span><span class="n">crash_mem_ranges</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">crash_mem_ranges</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fadump_exclude_reserved_area</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ra_start</span><span class="p">,</span> <span class="n">ra_end</span><span class="p">;</span>

	<span class="n">ra_start</span> <span class="o">=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_start</span><span class="p">;</span>
	<span class="n">ra_end</span> <span class="o">=</span> <span class="n">ra_start</span> <span class="o">+</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ra_start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ra_end</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">ra_start</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">ra_end</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fadump_add_crash_memory</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">ra_start</span><span class="p">);</span>
			<span class="n">fadump_add_crash_memory</span><span class="p">(</span><span class="n">ra_end</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">ra_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fadump_add_crash_memory</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">ra_start</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ra_end</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fadump_add_crash_memory</span><span class="p">(</span><span class="n">ra_end</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">fadump_add_crash_memory</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fadump_init_elfcore_header</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">bufp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">elf</span><span class="p">;</span>

	<span class="n">elf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">bufp</span><span class="p">;</span>
	<span class="n">bufp</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">,</span> <span class="n">ELFMAG</span><span class="p">,</span> <span class="n">SELFMAG</span><span class="p">);</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_CLASS</span><span class="p">]</span> <span class="o">=</span> <span class="n">ELF_CLASS</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">ELF_DATA</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_VERSION</span><span class="p">]</span> <span class="o">=</span> <span class="n">EV_CURRENT</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_OSABI</span><span class="p">]</span> <span class="o">=</span> <span class="n">ELF_OSABI</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="o">+</span><span class="n">EI_PAD</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">EI_NIDENT</span><span class="o">-</span><span class="n">EI_PAD</span><span class="p">);</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">=</span> <span class="n">ET_CORE</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_machine</span> <span class="o">=</span> <span class="n">ELF_ARCH</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_version</span> <span class="o">=</span> <span class="n">EV_CURRENT</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_phoff</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span><span class="p">);</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_shoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_flags</span> <span class="o">=</span> <span class="n">ELF_CORE_EFLAGS</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_ehsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span><span class="p">);</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_phentsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">);</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_phnum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_shentsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_shnum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_shstrndx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Traverse through memblock structure and setup crash memory ranges. These</span>
<span class="cm"> * ranges will be used create PT_LOAD program headers in elfcore header.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fadump_setup_crash_memory_ranges</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memblock_region</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Setup crash memory ranges.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">crash_mem_ranges</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * add the first memory chunk (RMA_START through boot_memory_size) as</span>
<span class="cm">	 * a separate memory chunk. The reason is, at the time crash firmware</span>
<span class="cm">	 * will move the content of this memory chunk to different location</span>
<span class="cm">	 * specified during fadump registration. We need to create a separate</span>
<span class="cm">	 * program header for this chunk with the correct offset.</span>
<span class="cm">	 */</span>
	<span class="n">fadump_add_crash_memory</span><span class="p">(</span><span class="n">RMA_START</span><span class="p">,</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">boot_memory_size</span><span class="p">);</span>

	<span class="n">for_each_memblock</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">RMA_START</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&gt;=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">boot_memory_size</span><span class="p">)</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">boot_memory_size</span><span class="p">;</span>

		<span class="cm">/* add this range excluding the reserved dump area. */</span>
		<span class="n">fadump_exclude_reserved_area</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If the given physical address falls within the boot memory region then</span>
<span class="cm"> * return the relocated address that points to the dump region reserved</span>
<span class="cm"> * for saving initial boot memory contents.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">fadump_relocate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">paddr</span> <span class="o">&gt;</span> <span class="n">RMA_START</span> <span class="o">&amp;&amp;</span> <span class="n">paddr</span> <span class="o">&lt;</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">boot_memory_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fdm</span><span class="p">.</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">destination_address</span> <span class="o">+</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">paddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fadump_create_elfcore_headers</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">bufp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">elf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="n">phdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">fadump_init_elfcore_header</span><span class="p">(</span><span class="n">bufp</span><span class="p">);</span>
	<span class="n">elf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">bufp</span><span class="p">;</span>
	<span class="n">bufp</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * setup ELF PT_NOTE, place holder for cpu notes info. The notes info</span>
<span class="cm">	 * will be populated during second kernel boot after crash. Hence</span>
<span class="cm">	 * this PT_NOTE will always be the first elf note.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: Any new ELF note addition should be placed after this note.</span>
<span class="cm">	 */</span>
	<span class="n">phdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="p">)</span><span class="n">bufp</span><span class="p">;</span>
	<span class="n">bufp</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">);</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_type</span> <span class="o">=</span> <span class="n">PT_NOTE</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_vaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_align</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_paddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_filesz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_memsz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* setup ELF PT_NOTE for vmcoreinfo */</span>
	<span class="n">phdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="p">)</span><span class="n">bufp</span><span class="p">;</span>
	<span class="n">bufp</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">);</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_type</span>	<span class="o">=</span> <span class="n">PT_NOTE</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_flags</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_vaddr</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_align</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_paddr</span>	<span class="o">=</span> <span class="n">fadump_relocate</span><span class="p">(</span><span class="n">paddr_vmcoreinfo_note</span><span class="p">());</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_offset</span>	<span class="o">=</span> <span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_paddr</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_memsz</span>	<span class="o">=</span> <span class="n">vmcoreinfo_max_size</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_filesz</span>	<span class="o">=</span> <span class="n">vmcoreinfo_max_size</span><span class="p">;</span>

	<span class="cm">/* Increment number of program headers. */</span>
	<span class="p">(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* setup PT_LOAD sections. */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">crash_mem_ranges</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">mbase</span><span class="p">,</span> <span class="n">msize</span><span class="p">;</span>
		<span class="n">mbase</span> <span class="o">=</span> <span class="n">crash_memory_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span><span class="p">;</span>
		<span class="n">msize</span> <span class="o">=</span> <span class="n">crash_memory_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msize</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">phdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="p">)</span><span class="n">bufp</span><span class="p">;</span>
		<span class="n">bufp</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">);</span>
		<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_type</span>	<span class="o">=</span> <span class="n">PT_LOAD</span><span class="p">;</span>
		<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_flags</span>	<span class="o">=</span> <span class="n">PF_R</span><span class="o">|</span><span class="n">PF_W</span><span class="o">|</span><span class="n">PF_X</span><span class="p">;</span>
		<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_offset</span>	<span class="o">=</span> <span class="n">mbase</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mbase</span> <span class="o">==</span> <span class="n">RMA_START</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The entire RMA region will be moved by firmware</span>
<span class="cm">			 * to the specified destination_address. Hence set</span>
<span class="cm">			 * the correct offset.</span>
<span class="cm">			 */</span>
			<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_offset</span> <span class="o">=</span> <span class="n">fdm</span><span class="p">.</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">destination_address</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_paddr</span> <span class="o">=</span> <span class="n">mbase</span><span class="p">;</span>
		<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">mbase</span><span class="p">);</span>
		<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_filesz</span> <span class="o">=</span> <span class="n">msize</span><span class="p">;</span>
		<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_memsz</span> <span class="o">=</span> <span class="n">msize</span><span class="p">;</span>
		<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_align</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Increment number of program headers. */</span>
		<span class="p">(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">init_fadump_header</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fadump_crash_info_header</span> <span class="o">*</span><span class="n">fdh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fw_dump</span><span class="p">.</span><span class="n">fadumphdr_addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">fdh</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fadump_crash_info_header</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">fdh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fadump_crash_info_header</span><span class="p">));</span>
	<span class="n">fdh</span><span class="o">-&gt;</span><span class="n">magic_number</span> <span class="o">=</span> <span class="n">FADUMP_CRASH_INFO_MAGIC</span><span class="p">;</span>
	<span class="n">fdh</span><span class="o">-&gt;</span><span class="n">elfcorehdr_addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="cm">/* We will set the crashing cpu id in crash_fadump() during crash. */</span>
	<span class="n">fdh</span><span class="o">-&gt;</span><span class="n">crashing_cpu</span> <span class="o">=</span> <span class="n">CPU_UNKNOWN</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">register_fadump</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If no memory is reserved then we can not register for firmware-</span>
<span class="cm">	 * assisted dump.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_size</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">fadump_setup_crash_memory_ranges</span><span class="p">();</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">fdm</span><span class="p">.</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">destination_address</span> <span class="o">+</span> <span class="n">fdm</span><span class="p">.</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">source_len</span><span class="p">;</span>
	<span class="cm">/* Initialize fadump crash info header. */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">init_fadump_header</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Creating ELF core headers at %#016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">fadump_create_elfcore_headers</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>

	<span class="cm">/* register the future kernel dump with firmware. */</span>
	<span class="n">register_fw_dump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fadump_unregister_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">fadump_mem_struct</span> <span class="o">*</span><span class="n">fdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wait_time</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Un-register firmware-assisted dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* TODO: Add upper time limit for the delay */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">ibm_configure_kernel_dump</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="n">FADUMP_UNREGISTER</span><span class="p">,</span> <span class="n">fdm</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fadump_mem_struct</span><span class="p">));</span>

		<span class="n">wait_time</span> <span class="o">=</span> <span class="n">rtas_busy_delay_time</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_time</span><span class="p">)</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="n">wait_time</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">wait_time</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to un-register firmware-assisted dump.&quot;</span>
			<span class="s">&quot; unexpected error(%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_registered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fadump_invalidate_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">fadump_mem_struct</span> <span class="o">*</span><span class="n">fdm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wait_time</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Invalidating firmware-assisted dump registration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* TODO: Add upper time limit for the delay */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">ibm_configure_kernel_dump</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="n">FADUMP_INVALIDATE</span><span class="p">,</span> <span class="n">fdm</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fadump_mem_struct</span><span class="p">));</span>

		<span class="n">wait_time</span> <span class="o">=</span> <span class="n">rtas_busy_delay_time</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_time</span><span class="p">)</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="n">wait_time</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">wait_time</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to invalidate firmware-assisted dump &quot;</span>
			<span class="s">&quot;rgistration. unexpected error(%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fdm_active</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">fadump_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Invalidate the registration only if dump is active. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">init_fadump_mem_struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdm</span><span class="p">,</span>
			<span class="n">fdm_active</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">destination_address</span><span class="p">);</span>
		<span class="n">fadump_invalidate_dump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdm</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release the memory that was reserved in early boot to preserve the memory</span>
<span class="cm"> * contents. The released memory will be available for general use.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fadump_release_memory</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">begin</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ra_start</span><span class="p">,</span> <span class="n">ra_end</span><span class="p">;</span>

	<span class="n">ra_start</span> <span class="o">=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_start</span><span class="p">;</span>
	<span class="n">ra_end</span> <span class="o">=</span> <span class="n">ra_start</span> <span class="o">+</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_size</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * exclude the dump reserve area. Will reuse it for next</span>
<span class="cm">		 * fadump registration.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;=</span> <span class="n">ra_end</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">addr</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ra_start</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
		<span class="n">init_page_count</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
		<span class="n">totalram_pages</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fadump_invalidate_release_mem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reserved_area_start</span><span class="p">,</span> <span class="n">reserved_area_end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">destination_address</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fadump_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fadump_mutex</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">destination_address</span> <span class="o">=</span> <span class="n">fdm_active</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">destination_address</span><span class="p">;</span>
	<span class="n">fadump_cleanup</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fadump_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save the current reserved memory bounds we will require them</span>
<span class="cm">	 * later for releasing the memory for general use.</span>
<span class="cm">	 */</span>
	<span class="n">reserved_area_start</span> <span class="o">=</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_start</span><span class="p">;</span>
	<span class="n">reserved_area_end</span> <span class="o">=</span> <span class="n">reserved_area_start</span> <span class="o">+</span>
			<span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_size</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Setup reserve_dump_area_start and its size so that we can</span>
<span class="cm">	 * reuse this reserved memory for Re-registration.</span>
<span class="cm">	 */</span>
	<span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_start</span> <span class="o">=</span> <span class="n">destination_address</span><span class="p">;</span>
	<span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_size</span> <span class="o">=</span> <span class="n">get_fadump_area_size</span><span class="p">();</span>

	<span class="n">fadump_release_memory</span><span class="p">(</span><span class="n">reserved_area_start</span><span class="p">,</span> <span class="n">reserved_area_end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fadump_cpu_notes_buf_free</span><span class="p">(</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf</span><span class="p">),</span>
				<span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf_size</span><span class="p">);</span>
		<span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">fw_dump</span><span class="p">.</span><span class="n">cpu_notes_buf_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Initialize the kernel dump memory structure for FAD registration. */</span>
	<span class="n">init_fadump_mem_struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdm</span><span class="p">,</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_start</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">fadump_release_memory_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_active</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Take away the &#39;/proc/vmcore&#39;. We are releasing the dump</span>
<span class="cm">		 * memory, hence it will not be valid anymore.</span>
<span class="cm">		 */</span>
		<span class="n">vmcore_cleanup</span><span class="p">();</span>
		<span class="n">fadump_invalidate_release_mem</span><span class="p">();</span>

	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">fadump_enabled_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">fadump_enabled</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">fadump_register_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_registered</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">fadump_register_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">fadump_enabled</span> <span class="o">||</span> <span class="n">fdm_active</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fadump_mutex</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;0&#39;</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_registered</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Un-register Firmware-assisted dump */</span>
		<span class="n">fadump_unregister_dump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdm</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="sc">&#39;1&#39;</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_registered</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Register Firmware-assisted dump */</span>
		<span class="n">register_fadump</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">unlock_out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fadump_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fadump_region_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">fadump_mem_struct</span> <span class="o">*</span><span class="n">fdm_ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">fadump_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fadump_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fdm_active</span><span class="p">)</span>
		<span class="n">fdm_ptr</span> <span class="o">=</span> <span class="n">fdm_active</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fadump_mutex</span><span class="p">);</span>
		<span class="n">fdm_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fdm</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
			<span class="s">&quot;CPU : [%#016llx-%#016llx] %#llx bytes, &quot;</span>
			<span class="s">&quot;Dumped: %#llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">destination_address</span><span class="p">,</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">destination_address</span> <span class="o">+</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">source_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">source_len</span><span class="p">,</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">bytes_dumped</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
			<span class="s">&quot;HPTE: [%#016llx-%#016llx] %#llx bytes, &quot;</span>
			<span class="s">&quot;Dumped: %#llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">hpte_region</span><span class="p">.</span><span class="n">destination_address</span><span class="p">,</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">hpte_region</span><span class="p">.</span><span class="n">destination_address</span> <span class="o">+</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">hpte_region</span><span class="p">.</span><span class="n">source_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">hpte_region</span><span class="p">.</span><span class="n">source_len</span><span class="p">,</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">hpte_region</span><span class="p">.</span><span class="n">bytes_dumped</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
			<span class="s">&quot;DUMP: [%#016llx-%#016llx] %#llx bytes, &quot;</span>
			<span class="s">&quot;Dumped: %#llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">destination_address</span><span class="p">,</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">destination_address</span> <span class="o">+</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">source_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">source_len</span><span class="p">,</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">rmr_region</span><span class="p">.</span><span class="n">bytes_dumped</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fdm_active</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_start</span> <span class="o">==</span>
		<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">destination_address</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Dump is active. Show reserved memory region. */</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
			<span class="s">&quot;    : [%#016llx-%#016llx] %#llx bytes, &quot;</span>
			<span class="s">&quot;Dumped: %#llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_start</span><span class="p">,</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">destination_address</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">destination_address</span> <span class="o">-</span>
			<span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_start</span><span class="p">,</span>
			<span class="n">fdm_ptr</span><span class="o">-&gt;</span><span class="n">cpu_state_data</span><span class="p">.</span><span class="n">destination_address</span> <span class="o">-</span>
			<span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_start</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fdm_active</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fadump_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">fadump_release_attr</span> <span class="o">=</span> <span class="n">__ATTR</span><span class="p">(</span><span class="n">fadump_release_mem</span><span class="p">,</span>
						<span class="mo">0200</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						<span class="n">fadump_release_memory_store</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">fadump_attr</span> <span class="o">=</span> <span class="n">__ATTR</span><span class="p">(</span><span class="n">fadump_enabled</span><span class="p">,</span>
						<span class="mo">0444</span><span class="p">,</span> <span class="n">fadump_enabled_show</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">fadump_register_attr</span> <span class="o">=</span> <span class="n">__ATTR</span><span class="p">(</span><span class="n">fadump_registered</span><span class="p">,</span>
						<span class="mo">0644</span><span class="p">,</span> <span class="n">fadump_register_show</span><span class="p">,</span>
						<span class="n">fadump_register_store</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fadump_region_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">fadump_region_show</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">fadump_region_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>    <span class="o">=</span> <span class="n">fadump_region_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>    <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fadump_init_files</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">sysfs_create_file</span><span class="p">(</span><span class="n">kernel_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fadump_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fadump: unable to create sysfs file&quot;</span>
			<span class="s">&quot; fadump_enabled (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">sysfs_create_file</span><span class="p">(</span><span class="n">kernel_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fadump_register_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fadump: unable to create sysfs file&quot;</span>
			<span class="s">&quot; fadump_registered (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="n">debugfs_file</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;fadump_region&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span>
					<span class="n">powerpc_debugfs_root</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">fadump_region_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debugfs_file</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fadump: unable to create debugfs file&quot;</span>
				<span class="s">&quot; fadump_region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sysfs_create_file</span><span class="p">(</span><span class="n">kernel_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fadump_release_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fadump: unable to create sysfs file&quot;</span>
				<span class="s">&quot; fadump_release_mem (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Prepare for firmware-assisted dump.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_fadump</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">fadump_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">fadump_supported</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Firmware-assisted dump is not supported on&quot;</span>
			<span class="s">&quot; this hardware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fadump_show_config</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * If dump data is available then see if it is valid and prepare for</span>
<span class="cm">	 * saving it to the disk.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">dump_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if dump process fails then invalidate the registration</span>
<span class="cm">		 * and release memory before proceeding for re-registration.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">process_fadump</span><span class="p">(</span><span class="n">fdm_active</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">fadump_invalidate_release_mem</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="cm">/* Initialize the kernel dump memory structure for FAD registration. */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_size</span><span class="p">)</span>
		<span class="n">init_fadump_mem_struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdm</span><span class="p">,</span> <span class="n">fw_dump</span><span class="p">.</span><span class="n">reserve_dump_area_start</span><span class="p">);</span>
	<span class="n">fadump_init_files</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">setup_fadump</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
