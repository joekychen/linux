<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › kernel › signal_64.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>signal_64.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  PowerPC version </span>
<span class="cm"> *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)</span>
<span class="cm"> *</span>
<span class="cm"> *  Derived from &quot;arch/i386/kernel/signal.c&quot;</span>
<span class="cm"> *    Copyright (C) 1991, 1992 Linus Torvalds</span>
<span class="cm"> *    1997-11-28  Modified for POSIX.1b signals by Richard Henderson</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or</span>
<span class="cm"> *  modify it under the terms of the GNU General Public License</span>
<span class="cm"> *  as published by the Free Software Foundation; either version</span>
<span class="cm"> *  2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>

<span class="cp">#include &lt;asm/sigcontext.h&gt;</span>
<span class="cp">#include &lt;asm/ucontext.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/unistd.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/syscalls.h&gt;</span>
<span class="cp">#include &lt;asm/vdso.h&gt;</span>
<span class="cp">#include &lt;asm/switch_to.h&gt;</span>

<span class="cp">#include &quot;signal.h&quot;</span>

<span class="cp">#define DEBUG_SIG 0</span>

<span class="cp">#define GP_REGS_SIZE	min(sizeof(elf_gregset_t), sizeof(struct pt_regs))</span>
<span class="cp">#define FP_REGS_SIZE	sizeof(elf_fpregset_t)</span>

<span class="cp">#define TRAMP_TRACEBACK	3</span>
<span class="cp">#define TRAMP_SIZE	6</span>

<span class="cm">/*</span>
<span class="cm"> * When we have signals to deliver, we set up on the user stack,</span>
<span class="cm"> * going down from the original stack pointer:</span>
<span class="cm"> *	1) a rt_sigframe struct which contains the ucontext	</span>
<span class="cm"> *	2) a gap of __SIGNAL_FRAMESIZE bytes which acts as a dummy caller</span>
<span class="cm"> *	   frame for the signal handler.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">rt_sigframe</span> <span class="p">{</span>
	<span class="cm">/* sys_rt_sigreturn requires the ucontext be the first field */</span>
	<span class="k">struct</span> <span class="n">ucontext</span> <span class="n">uc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_unused</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tramp</span><span class="p">[</span><span class="n">TRAMP_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">__user</span> <span class="o">*</span><span class="n">pinfo</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">puc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">info</span><span class="p">;</span>
	<span class="cm">/* 64 bit ABI allows for 288 bytes below sp before decrementing it. */</span>
	<span class="kt">char</span> <span class="n">abigap</span><span class="p">[</span><span class="mi">288</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">16</span><span class="p">)));</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">fmt32</span><span class="p">[]</span> <span class="o">=</span> <span class="n">KERN_INFO</span> \
	<span class="s">&quot;%s[%d]: bad frame in %s: %08lx nip %08lx lr %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">fmt64</span><span class="p">[]</span> <span class="o">=</span> <span class="n">KERN_INFO</span> \
	<span class="s">&quot;%s[%d]: bad frame in %s: %016lx nip %016lx lr %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Set up the sigcontext for the signal frame.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">setup_sigcontext</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">signr</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">handler</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">ctx_has_vsx_region</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the</span>
<span class="cm">	 * process never used altivec yet (MSR_VEC is zero in pt_regs of</span>
<span class="cm">	 * the context). This is very important because we must ensure we</span>
<span class="cm">	 * don&#39;t lose the VRSAVE content that may have been set prior to</span>
<span class="cm">	 * the process doing its first vector operation</span>
<span class="cm">	 * Userland shall check AT_HWCAP to know wether it can rely on the</span>
<span class="cm">	 * v_regs pointer or not</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_ALTIVEC</span>
	<span class="n">elf_vrreg_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">v_regs</span> <span class="o">=</span> <span class="p">(</span><span class="n">elf_vrreg_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">vmx_reserve</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xful</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msr</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">flush_fp_to_thread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ALTIVEC</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">v_regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">v_regs</span><span class="p">);</span>

	<span class="cm">/* save altivec registers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">used_vr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush_altivec_to_thread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="cm">/* Copy 33 vec registers (vr0..31 and vscr) to the stack */</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__copy_to_user</span><span class="p">(</span><span class="n">v_regs</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vr</span><span class="p">,</span> <span class="mi">33</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vector128</span><span class="p">));</span>
		<span class="cm">/* set MSR_VEC in the MSR value in the frame to indicate that sc-&gt;v_reg)</span>
<span class="cm">		 * contains valid data.</span>
<span class="cm">		 */</span>
		<span class="n">msr</span> <span class="o">|=</span> <span class="n">MSR_VEC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* We always copy to/from vrsave, it&#39;s 0 if we don&#39;t have or don&#39;t</span>
<span class="cm">	 * use altivec.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vrsave</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">v_regs</span><span class="p">[</span><span class="mi">33</span><span class="p">]);</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_ALTIVEC */</span><span class="cp"></span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">v_regs</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ALTIVEC */</span><span class="cp"></span>
	<span class="n">flush_fp_to_thread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="cm">/* copy fpr regs and fpscr */</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_fpr_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">fp_regs</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_VSX</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy VSX low doubleword to local buffer for formatting,</span>
<span class="cm">	 * then out to userspace.  Update v_regs to point after the</span>
<span class="cm">	 * VMX data.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">used_vsr</span> <span class="o">&amp;&amp;</span> <span class="n">ctx_has_vsx_region</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__giveup_vsx</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="n">v_regs</span> <span class="o">+=</span> <span class="n">ELF_NVRREG</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_vsx_to_user</span><span class="p">(</span><span class="n">v_regs</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="cm">/* set MSR_VSX in the MSR value in the frame to</span>
<span class="cm">		 * indicate that sc-&gt;vs_reg) contains valid data.</span>
<span class="cm">		 */</span>
		<span class="n">msr</span> <span class="o">|=</span> <span class="n">MSR_VSX</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_VSX */</span><span class="cp"></span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gp_regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">FULL_REGS</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gp_regs</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">GP_REGS_SIZE</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">msr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gp_regs</span><span class="p">[</span><span class="n">PT_MSR</span><span class="p">]);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">signr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">|=</span>  <span class="n">__put_user</span><span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">oldmask</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Restore the sigcontext from the signal frame.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">restore_sigcontext</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sigcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_ALTIVEC</span>
	<span class="n">elf_vrreg_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">v_regs</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">save_r13</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msr</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_VSX</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* If this is not a signal return, we preserve the TLS in r13 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig</span><span class="p">)</span>
		<span class="n">save_r13</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>

	<span class="cm">/* copy the GPRs */</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__copy_from_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">gp_regs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gp_regs</span><span class="p">[</span><span class="n">PT_NIP</span><span class="p">]);</span>
	<span class="cm">/* get MSR separately, transfer the LE bit if doing signal return */</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">msr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gp_regs</span><span class="p">[</span><span class="n">PT_MSR</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span><span class="p">)</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">=</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MSR_LE</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_LE</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">orig_gpr3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gp_regs</span><span class="p">[</span><span class="n">PT_ORIG_R3</span><span class="p">]);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ctr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gp_regs</span><span class="p">[</span><span class="n">PT_CTR</span><span class="p">]);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gp_regs</span><span class="p">[</span><span class="n">PT_LNK</span><span class="p">]);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">xer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gp_regs</span><span class="p">[</span><span class="n">PT_XER</span><span class="p">]);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ccr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gp_regs</span><span class="p">[</span><span class="n">PT_CCR</span><span class="p">]);</span>
	<span class="cm">/* skip SOFTE */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">trap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">dar</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gp_regs</span><span class="p">[</span><span class="n">PT_DAR</span><span class="p">]);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">dsisr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gp_regs</span><span class="p">[</span><span class="n">PT_DSISR</span><span class="p">]);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gp_regs</span><span class="p">[</span><span class="n">PT_RESULT</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig</span><span class="p">)</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">save_r13</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">|=</span>  <span class="n">__get_user</span><span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">oldmask</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do this before updating the thread state in</span>
<span class="cm">	 * current-&gt;thread.fpr/vr.  That way, if we get preempted</span>
<span class="cm">	 * and another task grabs the FPU/Altivec, it won&#39;t be</span>
<span class="cm">	 * tempted to save the current CPU state into the thread_struct</span>
<span class="cm">	 * and corrupt what we are writing there.</span>
<span class="cm">	 */</span>
	<span class="n">discard_lazy_cpu_state</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Force reload of FP/VEC.</span>
<span class="cm">	 * This has to be done before copying stuff into current-&gt;thread.fpr/vr</span>
<span class="cm">	 * for the reasons explained in the previous comment.</span>
<span class="cm">	 */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MSR_FP</span> <span class="o">|</span> <span class="n">MSR_FE0</span> <span class="o">|</span> <span class="n">MSR_FE1</span> <span class="o">|</span> <span class="n">MSR_VEC</span> <span class="o">|</span> <span class="n">MSR_VSX</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ALTIVEC</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">v_regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">v_regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v_regs</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">v_regs</span><span class="p">,</span> <span class="mi">34</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vector128</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="cm">/* Copy 33 vec registers (vr0..31 and vscr) from the stack */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v_regs</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_VEC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__copy_from_user</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vr</span><span class="p">,</span> <span class="n">v_regs</span><span class="p">,</span>
					<span class="mi">33</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vector128</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">used_vr</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">33</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vector128</span><span class="p">));</span>
	<span class="cm">/* Always get VRSAVE back */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v_regs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vrsave</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">v_regs</span><span class="p">[</span><span class="mi">33</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vrsave</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ALTIVEC */</span><span class="cp"></span>
	<span class="cm">/* restore floating point */</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_fpr_from_user</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">fp_regs</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_VSX</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get additional VSX data. Update v_regs to point after the</span>
<span class="cm">	 * VMX data.  Copy VSX low doubleword from userspace to local</span>
<span class="cm">	 * buffer for formatting, then into the taskstruct.</span>
<span class="cm">	 */</span>
	<span class="n">v_regs</span> <span class="o">+=</span> <span class="n">ELF_NVRREG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_VSX</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_vsx_from_user</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">v_regs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">TS_VSRLOWOFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Setup the trampoline code on the stack</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">setup_trampoline</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">syscall</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">tramp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* addi r1, r1, __SIGNAL_FRAMESIZE  # Pop the dummy stackframe */</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="mh">0x38210000UL</span> <span class="o">|</span> <span class="p">(</span><span class="n">__SIGNAL_FRAMESIZE</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">tramp</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="cm">/* li r0, __NR_[rt_]sigreturn| */</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="mh">0x38000000UL</span> <span class="o">|</span> <span class="p">(</span><span class="n">syscall</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">tramp</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="cm">/* sc */</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="mh">0x44000002UL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tramp</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="cm">/* Minimal traceback info */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">TRAMP_TRACEBACK</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TRAMP_SIZE</span> <span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tramp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">tramp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">tramp</span><span class="p">[</span><span class="n">TRAMP_SIZE</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Userspace code may pass a ucontext which doesn&#39;t include VSX added</span>
<span class="cm"> * at the end.  We need to check for this case.</span>
<span class="cm"> */</span>
<span class="cp">#define UCONTEXTSIZEWITHOUTVSX \</span>
<span class="cp">		(sizeof(struct ucontext) - 32*sizeof(long))</span>

<span class="cm">/*</span>
<span class="cm"> * Handle {get,set,swap}_context operations</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sys_swapcontext</span><span class="p">(</span><span class="k">struct</span> <span class="n">ucontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">old_ctx</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">ucontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">new_ctx</span><span class="p">,</span>
		    <span class="kt">long</span> <span class="n">ctx_size</span><span class="p">,</span> <span class="kt">long</span> <span class="n">r6</span><span class="p">,</span> <span class="kt">long</span> <span class="n">r7</span><span class="p">,</span> <span class="kt">long</span> <span class="n">r8</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">set</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_msr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctx_has_vsx_region</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_ctx</span> <span class="o">&amp;&amp;</span>
	    <span class="n">get_user</span><span class="p">(</span><span class="n">new_msr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_ctx</span><span class="o">-&gt;</span><span class="n">uc_mcontext</span><span class="p">.</span><span class="n">gp_regs</span><span class="p">[</span><span class="n">PT_MSR</span><span class="p">]))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check that the context is not smaller than the original</span>
<span class="cm">	 * size (with VMX but without VSX)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx_size</span> <span class="o">&lt;</span> <span class="n">UCONTEXTSIZEWITHOUTVSX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the new context state sets the MSR VSX bits but</span>
<span class="cm">	 * it doesn&#39;t provide VSX state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ctx_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ucontext</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">new_msr</span> <span class="o">&amp;</span> <span class="n">MSR_VSX</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/* Does the context have enough room to store VSX data? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx_size</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ucontext</span><span class="p">))</span>
		<span class="n">ctx_has_vsx_region</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_ctx</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">old_ctx</span><span class="p">,</span> <span class="n">ctx_size</span><span class="p">)</span>
		    <span class="o">||</span> <span class="n">setup_sigcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_ctx</span><span class="o">-&gt;</span><span class="n">uc_mcontext</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">ctx_has_vsx_region</span><span class="p">)</span>
		    <span class="o">||</span> <span class="n">__copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_ctx</span><span class="o">-&gt;</span><span class="n">uc_sigmask</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sigset_t</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">new_ctx</span><span class="p">,</span> <span class="n">ctx_size</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">new_ctx</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">new_ctx</span> <span class="o">+</span> <span class="n">ctx_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we get a fault copying the context into the kernel&#39;s</span>
<span class="cm">	 * image of the user&#39;s registers, we can&#39;t just return -EFAULT</span>
<span class="cm">	 * because the user&#39;s registers will be corrupted.  For instance</span>
<span class="cm">	 * the NIP value may have been updated but not some of the</span>
<span class="cm">	 * other registers.  Given that we have done the access_ok</span>
<span class="cm">	 * and successfully read the first and last bytes of the region</span>
<span class="cm">	 * above, this should only happen in an out-of-memory situation</span>
<span class="cm">	 * or if another thread unmaps the region containing the context.</span>
<span class="cm">	 * We kill the task with a SIGSEGV in this situation.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_ctx</span><span class="o">-&gt;</span><span class="n">uc_sigmask</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">set</span><span class="p">)))</span>
		<span class="n">do_exit</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">);</span>
	<span class="n">set_current_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">restore_sigcontext</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_ctx</span><span class="o">-&gt;</span><span class="n">uc_mcontext</span><span class="p">))</span>
		<span class="n">do_exit</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">);</span>

	<span class="cm">/* This returns like rt_sigreturn */</span>
	<span class="n">set_thread_flag</span><span class="p">(</span><span class="n">TIF_RESTOREALL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Do a signal return; undo the signal stack.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">sys_rt_sigreturn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r3</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r4</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r5</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r6</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r7</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r8</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ucontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ucontext</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">sigset_t</span> <span class="n">set</span><span class="p">;</span>

	<span class="cm">/* Always make any pending restarted system calls return -EINTR */</span>
	<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">restart_block</span><span class="p">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">do_no_restart_syscall</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">uc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uc</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">uc_sigmask</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">set</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>
	<span class="n">set_current_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">restore_sigcontext</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">uc_mcontext</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>

	<span class="cm">/* do_sigaltstack expects a __user pointer and won&#39;t modify</span>
<span class="cm">	 * what&#39;s in there anyway</span>
<span class="cm">	 */</span>
	<span class="n">do_sigaltstack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">uc_stack</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="n">set_thread_flag</span><span class="p">(</span><span class="n">TIF_RESTOREALL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">badframe:</span>
<span class="cp">#if DEBUG_SIG</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;badframe in sys_rt_sigreturn, regs=%p uc=%p &amp;uc-&gt;uc_mcontext=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="p">,</span> <span class="n">uc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">uc_mcontext</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">show_unhandled_signals</span><span class="p">)</span>
		<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_64BIT</span> <span class="o">?</span> <span class="n">fmt64</span> <span class="o">:</span> <span class="n">fmt32</span><span class="p">,</span>
				   <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="s">&quot;rt_sigreturn&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">uc</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">handle_rt_signal64</span><span class="p">(</span><span class="kt">int</span> <span class="n">signr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">ka</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
		<span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Handler is *really* a pointer to the function descriptor for</span>
<span class="cm">	 * the signal routine.  The first entry in the function</span>
<span class="cm">	 * descriptor is the entry address of signal and the second</span>
<span class="cm">	 * entry is the TOC value we need to use.</span>
<span class="cm">	 */</span>
	<span class="n">func_descr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">funct_desc_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_sigframe</span> <span class="n">__user</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newsp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">frame</span> <span class="o">=</span> <span class="n">get_sigframe</span><span class="p">(</span><span class="n">ka</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">frame</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">frame</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">pinfo</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">puc</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_siginfo_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>

	<span class="cm">/* Create the ucontext.  */</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_flags</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_link</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_sp</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">sas_ss_flags</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
			  <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_flags</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_size</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">setup_sigcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_mcontext</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">signr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_sigmask</span><span class="p">,</span> <span class="n">set</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>

	<span class="cm">/* Make sure signal handler doesn&#39;t get spurious FP exceptions */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpscr</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set up to return from userspace. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vdso64_rt_sigtramp</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">vdso_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">vdso_base</span> <span class="o">+</span> <span class="n">vdso64_rt_sigtramp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">setup_trampoline</span><span class="p">(</span><span class="n">__NR_rt_sigreturn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">funct_desc_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">func_descr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span><span class="p">;</span>

	<span class="cm">/* Allocate a dummy caller frame for the signal handler. */</span>
	<span class="n">newsp</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">frame</span><span class="p">)</span> <span class="o">-</span> <span class="n">__SIGNAL_FRAMESIZE</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">newsp</span><span class="p">);</span>

	<span class="cm">/* Set up &quot;regs&quot; so we &quot;return&quot; to the signal handler. */</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">funct_desc_ptr</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
	<span class="cm">/* enter the signal handler in big-endian mode */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSR_LE</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">newsp</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">funct_desc_ptr</span><span class="o">-&gt;</span><span class="n">toc</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">signr</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">&amp;</span> <span class="n">SA_SIGINFO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">pinfo</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">puc</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">frame</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_mcontext</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">badframe:</span>
<span class="cp">#if DEBUG_SIG</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;badframe in setup_rt_frame, regs=%p frame=%p newsp=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">newsp</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">show_unhandled_signals</span><span class="p">)</span>
		<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_64BIT</span> <span class="o">?</span> <span class="n">fmt64</span> <span class="o">:</span> <span class="n">fmt32</span><span class="p">,</span>
				   <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="s">&quot;setup_rt_frame&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">frame</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

	<span class="n">force_sigsegv</span><span class="p">(</span><span class="n">signr</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
