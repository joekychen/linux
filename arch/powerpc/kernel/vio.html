<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › kernel › vio.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>vio.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * IBM PowerPC Virtual I/O Infrastructure Support.</span>
<span class="cm"> *</span>
<span class="cm"> *    Copyright (c) 2003,2008 IBM Corp.</span>
<span class="cm"> *     Dave Engebretsen engebret@us.ibm.com</span>
<span class="cm"> *     Santiago Leon santil@us.ibm.com</span>
<span class="cm"> *     Hollis Blanchard &lt;hollisb@us.ibm.com&gt;</span>
<span class="cm"> *     Stephen Rothwell</span>
<span class="cm"> *     Robert Jennings &lt;rcjenn@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *      This program is free software; you can redistribute it and/or</span>
<span class="cm"> *      modify it under the terms of the GNU General Public License</span>
<span class="cm"> *      as published by the Free Software Foundation; either version</span>
<span class="cm"> *      2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/kobject.h&gt;</span>

<span class="cp">#include &lt;asm/iommu.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/vio.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/firmware.h&gt;</span>
<span class="cp">#include &lt;asm/tce.h&gt;</span>
<span class="cp">#include &lt;asm/abs_addr.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/hvcall.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">vio_bus_type</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vio_dev</span> <span class="n">vio_bus_device</span>  <span class="o">=</span> <span class="p">{</span> <span class="cm">/* fake &quot;parent&quot; device */</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;vio&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">init_name</span> <span class="o">=</span> <span class="s">&quot;vio&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vio_bus_type</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_PPC_SMLPAR</span>
<span class="cm">/**</span>
<span class="cm"> * vio_cmo_pool - A pool of IO memory for CMO use</span>
<span class="cm"> *</span>
<span class="cm"> * @size: The size of the pool in bytes</span>
<span class="cm"> * @free: The amount of free memory in the pool</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vio_cmo_pool</span> <span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">free</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* How many ms to delay queued balance work */</span>
<span class="cp">#define VIO_CMO_BALANCE_DELAY 100</span>

<span class="cm">/* Portion out IO memory to CMO devices by this chunk size */</span>
<span class="cp">#define VIO_CMO_BALANCE_CHUNK 131072</span>

<span class="cm">/**</span>
<span class="cm"> * vio_cmo_dev_entry - A device that is CMO-enabled and requires entitlement</span>
<span class="cm"> *</span>
<span class="cm"> * @vio_dev: struct vio_dev pointer</span>
<span class="cm"> * @list: pointer to other devices on bus that are being tracked</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vio_cmo_dev_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * vio_cmo - VIO bus accounting structure for CMO entitlement</span>
<span class="cm"> *</span>
<span class="cm"> * @lock: spinlock for entire structure</span>
<span class="cm"> * @balance_q: work queue for balancing system entitlement</span>
<span class="cm"> * @device_list: list of CMO-enabled devices requiring entitlement</span>
<span class="cm"> * @entitled: total system entitlement in bytes</span>
<span class="cm"> * @reserve: pool of memory from which devices reserve entitlement, incl. spare</span>
<span class="cm"> * @excess: pool of excess entitlement not needed for device reserves or spare</span>
<span class="cm"> * @spare: IO memory for device hotplug functionality</span>
<span class="cm"> * @min: minimum necessary for system operation</span>
<span class="cm"> * @desired: desired memory for system operation</span>
<span class="cm"> * @curr: bytes currently allocated</span>
<span class="cm"> * @high: high water mark for IO data usage</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vio_cmo</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">balance_q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">device_list</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">entitled</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vio_cmo_pool</span> <span class="n">reserve</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vio_cmo_pool</span> <span class="n">excess</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">spare</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">min</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">desired</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">curr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">high</span><span class="p">;</span>
<span class="p">}</span> <span class="n">vio_cmo</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * vio_cmo_OF_devices - Count the number of OF devices that have DMA windows</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vio_cmo_num_OF_devs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node_vroot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Count the number of vdevice entries with an</span>
<span class="cm">	 * ibm,my-dma-window OF property</span>
<span class="cm">	 */</span>
	<span class="n">node_vroot</span> <span class="o">=</span> <span class="n">of_find_node_by_name</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;vdevice&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_vroot</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">of_node</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>

		<span class="n">for_each_child_of_node</span><span class="p">(</span><span class="n">node_vroot</span><span class="p">,</span> <span class="n">of_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prop</span> <span class="o">=</span> <span class="n">of_find_property</span><span class="p">(</span><span class="n">of_node</span><span class="p">,</span> <span class="s">&quot;ibm,my-dma-window&quot;</span><span class="p">,</span>
			                       <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prop</span><span class="p">)</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">node_vroot</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vio_cmo_alloc - allocate IO memory for CMO-enable devices</span>
<span class="cm"> *</span>
<span class="cm"> * @viodev: VIO device requesting IO memory</span>
<span class="cm"> * @size: size of allocation requested</span>
<span class="cm"> *</span>
<span class="cm"> * Allocations come from memory reserved for the devices and any excess</span>
<span class="cm"> * IO memory available to all devices.  The spare pool used to service</span>
<span class="cm"> * hotplug must be equal to %VIO_CMO_MIN_ENT for the excess pool to be</span>
<span class="cm"> * made available.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *  0 for successful allocation and -ENOMEM for a failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vio_cmo_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">reserve_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">excess_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Determine the amount of free entitlement available in reserve */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">&gt;</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span><span class="p">)</span>
		<span class="n">reserve_free</span> <span class="o">=</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">-</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span><span class="p">;</span>

	<span class="cm">/* If spare is not fulfilled, the excess pool can not be used. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">spare</span> <span class="o">&gt;=</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">)</span>
		<span class="n">excess_free</span> <span class="o">=</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">free</span><span class="p">;</span>

	<span class="cm">/* The request can be satisfied */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">reserve_free</span> <span class="o">+</span> <span class="n">excess_free</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">curr</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">curr</span> <span class="o">&gt;</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">high</span><span class="p">)</span>
			<span class="n">vio_cmo</span><span class="p">.</span><span class="n">high</span> <span class="o">=</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">curr</span><span class="p">;</span>
		<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">min</span><span class="p">(</span><span class="n">reserve_free</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">free</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vio_cmo_dealloc - deallocate IO memory from CMO-enable devices</span>
<span class="cm"> * @viodev: VIO device freeing IO memory</span>
<span class="cm"> * @size: size of deallocation</span>
<span class="cm"> *</span>
<span class="cm"> * IO memory is freed by the device back to the correct memory pools.</span>
<span class="cm"> * The spare pool is replenished first from either memory pool, then</span>
<span class="cm"> * the reserve pool is used to reduce device entitlement, the excess</span>
<span class="cm"> * pool is used to increase the reserve pool toward the desired entitlement</span>
<span class="cm"> * target, and then the remaining memory is returned to the pools.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vio_cmo_dealloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">spare_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">excess_freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">reserve_freed</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">vio_cmo</span><span class="p">.</span><span class="n">curr</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* Amount of memory freed from the excess pool */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span> <span class="o">&gt;</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">excess_freed</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">reserve_freed</span><span class="p">,</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span> <span class="o">-</span>
		                                   <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">));</span>
		<span class="n">reserve_freed</span> <span class="o">-=</span> <span class="n">excess_freed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Remove allocation from device */</span>
	<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span> <span class="o">-=</span> <span class="p">(</span><span class="n">reserve_freed</span> <span class="o">+</span> <span class="n">excess_freed</span><span class="p">);</span>

	<span class="cm">/* Spare is a subset of the reserve pool, replenish it first. */</span>
	<span class="n">spare_needed</span> <span class="o">=</span> <span class="n">VIO_CMO_MIN_ENT</span> <span class="o">-</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">spare</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Replenish the spare in the reserve pool from the excess pool.</span>
<span class="cm">	 * This moves entitlement into the reserve pool.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spare_needed</span> <span class="o">&amp;&amp;</span> <span class="n">excess_freed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">excess_freed</span><span class="p">,</span> <span class="n">spare_needed</span><span class="p">);</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">spare</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">excess_freed</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">spare_needed</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">balance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Replenish the spare in the reserve pool from the reserve pool.</span>
<span class="cm">	 * This removes entitlement from the device down to VIO_CMO_MIN_ENT,</span>
<span class="cm">	 * if needed, and gives it to the spare pool. The amount of used</span>
<span class="cm">	 * memory in this pool does not change.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spare_needed</span> <span class="o">&amp;&amp;</span> <span class="n">reserve_freed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">min3</span><span class="p">(</span><span class="n">spare_needed</span><span class="p">,</span> <span class="n">reserve_freed</span><span class="p">,</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">-</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">));</span>

		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">spare</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">reserve_freed</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">spare_needed</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">balance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Increase the reserve pool until the desired allocation is met.</span>
<span class="cm">	 * Move an allocation freed from the excess pool into the reserve</span>
<span class="cm">	 * pool and schedule a balance operation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">excess_freed</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">&gt;</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">excess_freed</span><span class="p">,</span> <span class="p">(</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">-</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span><span class="p">));</span>

		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">excess_freed</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">balance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Return memory from the excess pool to that pool */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">excess_freed</span><span class="p">)</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">free</span> <span class="o">+=</span> <span class="n">excess_freed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">balance</span><span class="p">)</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">balance_q</span><span class="p">,</span> <span class="n">VIO_CMO_BALANCE_DELAY</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vio_cmo_entitlement_update - Manage system entitlement changes</span>
<span class="cm"> *</span>
<span class="cm"> * @new_entitlement: new system entitlement to attempt to accommodate</span>
<span class="cm"> *</span>
<span class="cm"> * Increases in entitlement will be used to fulfill the spare entitlement</span>
<span class="cm"> * and the rest is given to the excess pool.  Decreases, if they are</span>
<span class="cm"> * possible, come from the excess pool and from unused device entitlement</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 on success, -ENOMEM when change can not be made</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vio_cmo_entitlement_update</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">new_entitlement</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vio_cmo_dev_entry</span> <span class="o">*</span><span class="n">dev_ent</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">avail</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Entitlement increases */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_entitlement</span> <span class="o">&gt;</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">new_entitlement</span> <span class="o">-</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">;</span>

		<span class="cm">/* Fulfill spare allocation */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">spare</span> <span class="o">&lt;</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="p">(</span><span class="n">VIO_CMO_MIN_ENT</span> <span class="o">-</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">spare</span><span class="p">));</span>
			<span class="n">vio_cmo</span><span class="p">.</span><span class="n">spare</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">vio_cmo</span><span class="p">.</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">delta</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Remaining new allocation goes to the excess pool */</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">free</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Entitlement decreases */</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">-</span> <span class="n">new_entitlement</span><span class="p">;</span>
	<span class="n">avail</span> <span class="o">=</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">free</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to check how much unused entitlement each device can</span>
<span class="cm">	 * sacrifice to fulfill entitlement change.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev_ent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">device_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&gt;=</span> <span class="n">delta</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">viodev</span> <span class="o">=</span> <span class="n">dev_ent</span><span class="o">-&gt;</span><span class="n">viodev</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">&gt;</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">&gt;</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">))</span>
				<span class="n">avail</span> <span class="o">+=</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">-</span>
				         <span class="n">max_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span><span class="p">,</span>
				               <span class="n">VIO_CMO_MIN_ENT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;=</span> <span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">-=</span> <span class="n">delta</span><span class="p">;</span>

		<span class="cm">/* Take entitlement from the excess pool first */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">free</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">free</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Remove all but VIO_CMO_MIN_ENT bytes from devices</span>
<span class="cm">		 * until entitlement change is served</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev_ent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">device_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">delta</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">viodev</span> <span class="o">=</span> <span class="n">dev_ent</span><span class="o">-&gt;</span><span class="n">viodev</span><span class="p">;</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">&gt;</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">&gt;</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">))</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">-</span>
				      <span class="n">max_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span><span class="p">,</span>
				            <span class="n">VIO_CMO_MIN_ENT</span><span class="p">);</span>
			<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">-=</span> <span class="n">min</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
			<span class="n">delta</span> <span class="o">-=</span> <span class="n">min</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">balance_q</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vio_cmo_balance - Balance entitlement among devices</span>
<span class="cm"> *</span>
<span class="cm"> * @work: work queue structure for this operation</span>
<span class="cm"> *</span>
<span class="cm"> * Any system entitlement above the minimum needed for devices, or</span>
<span class="cm"> * already allocated to devices, can be distributed to the devices.</span>
<span class="cm"> * The list of devices is iterated through to recalculate the desired</span>
<span class="cm"> * entitlement level and to determine how much entitlement above the</span>
<span class="cm"> * minimum entitlement is allocated to devices.</span>
<span class="cm"> *</span>
<span class="cm"> * Small chunks of the available entitlement are given to devices until</span>
<span class="cm"> * their requirements are fulfilled or there is no entitlement left to give.</span>
<span class="cm"> * Upon completion sizes of the reserve and excess pools are calculated.</span>
<span class="cm"> *</span>
<span class="cm"> * The system minimum entitlement level is also recalculated here.</span>
<span class="cm"> * Entitlement will be reserved for devices even after vio_bus_remove to</span>
<span class="cm"> * accommodate reloading the driver.  The OF tree is walked to count the</span>
<span class="cm"> * number of devices present and this will remove entitlement for devices</span>
<span class="cm"> * that have actually left the system after having vio_bus_remove called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vio_cmo_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_cmo</span> <span class="o">*</span><span class="n">cmo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vio_cmo_dev_entry</span> <span class="o">*</span><span class="n">dev_ent</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">avail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">need</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">devcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fulfilled</span><span class="p">;</span>

	<span class="n">cmo</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vio_cmo</span><span class="p">,</span> <span class="n">balance_q</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Calculate minimum entitlement and fulfill spare */</span>
	<span class="n">cmo</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">=</span> <span class="n">vio_cmo_num_OF_devs</span><span class="p">()</span> <span class="o">*</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cmo</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">&gt;</span> <span class="n">cmo</span><span class="o">-&gt;</span><span class="n">entitled</span><span class="p">);</span>
	<span class="n">cmo</span><span class="o">-&gt;</span><span class="n">spare</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">,</span> <span class="p">(</span><span class="n">cmo</span><span class="o">-&gt;</span><span class="n">entitled</span> <span class="o">-</span> <span class="n">cmo</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">));</span>
	<span class="n">cmo</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">+=</span> <span class="n">cmo</span><span class="o">-&gt;</span><span class="n">spare</span><span class="p">;</span>
	<span class="n">cmo</span><span class="o">-&gt;</span><span class="n">desired</span> <span class="o">=</span> <span class="n">cmo</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine how much entitlement is available and reset device</span>
<span class="cm">	 * entitlements</span>
<span class="cm">	 */</span>
	<span class="n">avail</span> <span class="o">=</span> <span class="n">cmo</span><span class="o">-&gt;</span><span class="n">entitled</span> <span class="o">-</span> <span class="n">cmo</span><span class="o">-&gt;</span><span class="n">spare</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev_ent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">device_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">viodev</span> <span class="o">=</span> <span class="n">dev_ent</span><span class="o">-&gt;</span><span class="n">viodev</span><span class="p">;</span>
		<span class="n">devcount</span><span class="o">++</span><span class="p">;</span>
		<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">=</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">;</span>
		<span class="n">cmo</span><span class="o">-&gt;</span><span class="n">desired</span> <span class="o">+=</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">-</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">);</span>
		<span class="n">avail</span> <span class="o">-=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span><span class="p">,</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Having provided each device with the minimum entitlement, loop</span>
<span class="cm">	 * over the devices portioning out the remaining entitlement</span>
<span class="cm">	 * until there is nothing left.</span>
<span class="cm">	 */</span>
	<span class="n">level</span> <span class="o">=</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fulfilled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev_ent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">device_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">viodev</span> <span class="o">=</span> <span class="n">dev_ent</span><span class="o">-&gt;</span><span class="n">viodev</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">&lt;=</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">fulfilled</span><span class="o">++</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Give the device up to VIO_CMO_BALANCE_CHUNK</span>
<span class="cm">			 * bytes of entitlement, but do not exceed the</span>
<span class="cm">			 * desired level of entitlement for the device.</span>
<span class="cm">			 */</span>
			<span class="n">chunk</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">avail</span><span class="p">,</span> <span class="n">VIO_CMO_BALANCE_CHUNK</span><span class="p">);</span>
			<span class="n">chunk</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">-</span>
			                    <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">));</span>
			<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">+=</span> <span class="n">chunk</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the memory for this entitlement increase was</span>
<span class="cm">			 * already allocated to the device it does not come</span>
<span class="cm">			 * from the available pool being portioned out.</span>
<span class="cm">			 */</span>
			<span class="n">need</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span><span class="p">,</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">)</span><span class="o">-</span>
			       <span class="n">max</span><span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
			<span class="n">avail</span> <span class="o">-=</span> <span class="n">need</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fulfilled</span> <span class="o">==</span> <span class="n">devcount</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">level</span> <span class="o">+=</span> <span class="n">VIO_CMO_BALANCE_CHUNK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate new reserve and excess pool sizes */</span>
	<span class="n">cmo</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">cmo</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">;</span>
	<span class="n">cmo</span><span class="o">-&gt;</span><span class="n">excess</span><span class="p">.</span><span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmo</span><span class="o">-&gt;</span><span class="n">excess</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">need</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev_ent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">device_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">viodev</span> <span class="o">=</span> <span class="n">dev_ent</span><span class="o">-&gt;</span><span class="n">viodev</span><span class="p">;</span>
		<span class="cm">/* Calculated reserve size above the minimum entitlement */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">)</span>
			<span class="n">cmo</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">-</span>
			                      <span class="n">VIO_CMO_MIN_ENT</span><span class="p">);</span>
		<span class="cm">/* Calculated used excess entitlement */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span> <span class="o">&gt;</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">)</span>
			<span class="n">need</span> <span class="o">+=</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span> <span class="o">-</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cmo</span><span class="o">-&gt;</span><span class="n">excess</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">cmo</span><span class="o">-&gt;</span><span class="n">entitled</span> <span class="o">-</span> <span class="n">cmo</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="n">cmo</span><span class="o">-&gt;</span><span class="n">excess</span><span class="p">.</span><span class="n">free</span> <span class="o">=</span> <span class="n">cmo</span><span class="o">-&gt;</span><span class="n">excess</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">need</span><span class="p">;</span>

	<span class="n">cancel_delayed_work</span><span class="p">(</span><span class="n">to_delayed_work</span><span class="p">(</span><span class="n">work</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">vio_dma_iommu_alloc_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					  <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flag</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vio_cmo_alloc</span><span class="p">(</span><span class="n">viodev</span><span class="p">,</span> <span class="n">roundup</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocs_failed</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dma_iommu_ops</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vio_cmo_dealloc</span><span class="p">(</span><span class="n">viodev</span><span class="p">,</span> <span class="n">roundup</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocs_failed</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vio_dma_iommu_free_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dma_iommu_ops</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>

	<span class="n">vio_cmo_dealloc</span><span class="p">(</span><span class="n">viodev</span><span class="p">,</span> <span class="n">roundup</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="nf">vio_dma_iommu_map_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
                                         <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
                                         <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
                                         <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dma_addr_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">DMA_ERROR_CODE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vio_cmo_alloc</span><span class="p">(</span><span class="n">viodev</span><span class="p">,</span> <span class="n">roundup</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">IOMMU_PAGE_SIZE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocs_failed</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dma_iommu_ops</span><span class="p">.</span><span class="n">map_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ret</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">vio_cmo_dealloc</span><span class="p">(</span><span class="n">viodev</span><span class="p">,</span> <span class="n">roundup</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">IOMMU_PAGE_SIZE</span><span class="p">));</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocs_failed</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vio_dma_iommu_unmap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span>
				     <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dma_iommu_ops</span><span class="p">.</span><span class="n">unmap_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>

	<span class="n">vio_cmo_dealloc</span><span class="p">(</span><span class="n">viodev</span><span class="p">,</span> <span class="n">roundup</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">IOMMU_PAGE_SIZE</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vio_dma_iommu_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span>
                                <span class="kt">int</span> <span class="n">nelems</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
                                <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">alloc_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">sgl</span> <span class="o">=</span> <span class="n">sglist</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">nelems</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">,</span> <span class="n">sgl</span><span class="o">++</span><span class="p">)</span>
		<span class="n">alloc_size</span> <span class="o">+=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">IOMMU_PAGE_SIZE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vio_cmo_alloc</span><span class="p">(</span><span class="n">viodev</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocs_failed</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dma_iommu_ops</span><span class="p">.</span><span class="n">map_sg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">nelems</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vio_cmo_dealloc</span><span class="p">(</span><span class="n">viodev</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocs_failed</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">sgl</span> <span class="o">=</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">ret</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">,</span> <span class="n">sgl</span><span class="o">++</span><span class="p">)</span>
		<span class="n">alloc_size</span> <span class="o">-=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">dma_length</span><span class="p">,</span> <span class="n">IOMMU_PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_size</span><span class="p">)</span>
		<span class="n">vio_cmo_dealloc</span><span class="p">(</span><span class="n">viodev</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vio_dma_iommu_unmap_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nelems</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">alloc_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">sgl</span> <span class="o">=</span> <span class="n">sglist</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">nelems</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">,</span> <span class="n">sgl</span><span class="o">++</span><span class="p">)</span>
		<span class="n">alloc_size</span> <span class="o">+=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">dma_length</span><span class="p">,</span> <span class="n">IOMMU_PAGE_SIZE</span><span class="p">);</span>

	<span class="n">dma_iommu_ops</span><span class="p">.</span><span class="n">unmap_sg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">nelems</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>

	<span class="n">vio_cmo_dealloc</span><span class="p">(</span><span class="n">viodev</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vio_dma_iommu_dma_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">dma_iommu_ops</span><span class="p">.</span><span class="n">dma_supported</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">vio_dma_get_required_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">dma_iommu_ops</span><span class="p">.</span><span class="n">get_required_mask</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="n">vio_dma_mapping_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc</span>             <span class="o">=</span> <span class="n">vio_dma_iommu_alloc_coherent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free</span>              <span class="o">=</span> <span class="n">vio_dma_iommu_free_coherent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_sg</span>            <span class="o">=</span> <span class="n">vio_dma_iommu_map_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_sg</span>          <span class="o">=</span> <span class="n">vio_dma_iommu_unmap_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_page</span>          <span class="o">=</span> <span class="n">vio_dma_iommu_map_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_page</span>        <span class="o">=</span> <span class="n">vio_dma_iommu_unmap_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_supported</span>     <span class="o">=</span> <span class="n">vio_dma_iommu_dma_supported</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_required_mask</span> <span class="o">=</span> <span class="n">vio_dma_get_required_mask</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * vio_cmo_set_dev_desired - Set desired entitlement for a device</span>
<span class="cm"> *</span>
<span class="cm"> * @viodev: struct vio_dev for device to alter</span>
<span class="cm"> * @new_desired: new desired entitlement level in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * For use by devices to request a change to their entitlement at runtime or</span>
<span class="cm"> * through sysfs.  The desired entitlement level is changed and a balancing</span>
<span class="cm"> * of system resources is scheduled to run in the future.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">vio_cmo_set_dev_desired</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">desired</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vio_cmo_dev_entry</span> <span class="o">*</span><span class="n">dev_ent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_CMO</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">desired</span> <span class="o">&lt;</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">)</span>
		<span class="n">desired</span> <span class="o">=</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Changes will not be made for devices not in the device list.</span>
<span class="cm">	 * If it is not in the device list, then no driver is loaded</span>
<span class="cm">	 * for the device and it can not receive entitlement.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev_ent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">device_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">viodev</span> <span class="o">==</span> <span class="n">dev_ent</span><span class="o">-&gt;</span><span class="n">viodev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Increase/decrease in desired device entitlement */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">desired</span> <span class="o">&gt;=</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Just bump the bus and device values prior to a balance*/</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">+=</span> <span class="n">desired</span> <span class="o">-</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span><span class="p">;</span>
		<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">=</span> <span class="n">desired</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Decrease bus and device values for desired entitlement */</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">-=</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">-</span> <span class="n">desired</span><span class="p">;</span>
		<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">=</span> <span class="n">desired</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If less entitlement is desired than current entitlement, move</span>
<span class="cm">		 * any reserve memory in the change region to the excess pool.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">&gt;</span> <span class="n">desired</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vio_cmo</span><span class="p">.</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">-</span> <span class="n">desired</span><span class="p">;</span>
			<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">-</span> <span class="n">desired</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * If entitlement moving from the reserve pool to the</span>
<span class="cm">			 * excess pool is currently unused, add to the excess</span>
<span class="cm">			 * free counter.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span> <span class="o">&lt;</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">)</span>
				<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">free</span> <span class="o">+=</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">-</span>
				                       <span class="n">max</span><span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span><span class="p">,</span> <span class="n">desired</span><span class="p">);</span>
			<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">=</span> <span class="n">desired</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">balance_q</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vio_cmo_bus_probe - Handle CMO specific bus probe activities</span>
<span class="cm"> *</span>
<span class="cm"> * @viodev - Pointer to struct vio_dev for device</span>
<span class="cm"> *</span>
<span class="cm"> * Determine the devices IO memory entitlement needs, attempting</span>
<span class="cm"> * to satisfy the system minimum entitlement at first and scheduling</span>
<span class="cm"> * a balance operation to take care of the rest at a later time.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 on success, -EINVAL when device doesn&#39;t support CMO, and</span>
<span class="cm"> *          -ENOMEM when entitlement is not available for device or</span>
<span class="cm"> *          device entry.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vio_cmo_bus_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_cmo_dev_entry</span> <span class="o">*</span><span class="n">dev_ent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vio_driver</span> <span class="o">*</span><span class="n">viodrv</span> <span class="o">=</span> <span class="n">to_vio_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">dma_capable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* A device requires entitlement if it has a DMA window property */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VDEVICE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">of_get_property</span><span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span>
					<span class="s">&quot;ibm,my-dma-window&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="n">dma_capable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PFO</span>:
		<span class="n">dma_capable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unknown device family: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Configure entitlement for the device. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_capable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check that the driver is CMO enabled and get desired DMA */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">get_desired_dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: device driver does not support CMO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			        <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">=</span> <span class="n">IOMMU_PAGE_ALIGN</span><span class="p">(</span><span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">get_desired_dma</span><span class="p">(</span><span class="n">viodev</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">&lt;</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">)</span>
			<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">=</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">;</span>

		<span class="n">dev_ent</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_cmo_dev_entry</span><span class="p">),</span>
		                  <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_ent</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">dev_ent</span><span class="o">-&gt;</span><span class="n">viodev</span> <span class="o">=</span> <span class="n">viodev</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_ent</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">device_list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the needs for vio_cmo.min have not changed since they</span>
<span class="cm">	 * were last set, the number of devices in the OF tree has</span>
<span class="cm">	 * been constant and the IO memory for this is already in</span>
<span class="cm">	 * the reserve pool.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">min</span> <span class="o">==</span> <span class="p">((</span><span class="n">vio_cmo_num_OF_devs</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
	                    <span class="n">VIO_CMO_MIN_ENT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Updated desired entitlement if device requires it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
			<span class="n">vio_cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">+=</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">-</span>
		                        <span class="n">VIO_CMO_MIN_ENT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">spare</span> <span class="o">+</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">free</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: insufficient free &quot;</span>
			        <span class="s">&quot;entitlement to add device. &quot;</span>
			        <span class="s">&quot;Need %lu, have %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">spare</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">));</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Use excess pool first to fulfill request */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">free</span><span class="p">);</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">free</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="cm">/* Use spare if excess pool was insufficient */</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">spare</span> <span class="o">-=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="cm">/* Update bus accounting */</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">min</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">+=</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vio_cmo_bus_remove - Handle CMO specific bus removal activities</span>
<span class="cm"> *</span>
<span class="cm"> * @viodev - Pointer to struct vio_dev for device</span>
<span class="cm"> *</span>
<span class="cm"> * Remove the device from the cmo device list.  The minimum entitlement</span>
<span class="cm"> * will be reserved for the device as long as it is in the system.  The</span>
<span class="cm"> * rest of the entitlement the device had been allocated will be returned</span>
<span class="cm"> * to the system.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vio_cmo_bus_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_cmo_dev_entry</span> <span class="o">*</span><span class="n">dev_ent</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: device had %lu bytes of IO &quot;</span>
		        <span class="s">&quot;allocated after remove operation.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		        <span class="n">__func__</span><span class="p">,</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocated</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove the device from the device list being maintained for</span>
<span class="cm">	 * CMO enabled devices.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev_ent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">device_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">viodev</span> <span class="o">==</span> <span class="n">dev_ent</span><span class="o">-&gt;</span><span class="n">viodev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_ent</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dev_ent</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Devices may not require any entitlement and they do not need</span>
<span class="cm">	 * to be processed.  Otherwise, return the device&#39;s entitlement</span>
<span class="cm">	 * back to the pools.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This device has not yet left the OF tree, it&#39;s</span>
<span class="cm">		 * minimum entitlement remains in vio_cmo.min and</span>
<span class="cm">		 * vio_cmo.desired</span>
<span class="cm">		 */</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">-=</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">-</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Save min allocation for device in reserve as long</span>
<span class="cm">		 * as it exists in OF tree as determined by later</span>
<span class="cm">		 * balance operation</span>
<span class="cm">		 */</span>
		<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">-=</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">;</span>

		<span class="cm">/* Replenish spare from freed reserve pool */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">spare</span> <span class="o">&lt;</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">,</span> <span class="p">(</span><span class="n">VIO_CMO_MIN_ENT</span> <span class="o">-</span>
			                                 <span class="n">vio_cmo</span><span class="p">.</span><span class="n">spare</span><span class="p">));</span>
			<span class="n">vio_cmo</span><span class="p">.</span><span class="n">spare</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Remaining reserve goes to excess pool */</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">;</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">free</span> <span class="o">+=</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">;</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Until the device is removed it will keep a</span>
<span class="cm">		 * minimum entitlement; this will guarantee that</span>
<span class="cm">		 * a module unload/load will result in a success.</span>
<span class="cm">		 */</span>
		<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">=</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">;</span>
		<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">=</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">;</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocs_failed</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vio_cmo_set_dma_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_dma_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vio_dma_mapping_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vio_cmo_bus_init - CMO entitlement initialization at bus init time</span>
<span class="cm"> *</span>
<span class="cm"> * Set up the reserve and excess entitlement pools based on available</span>
<span class="cm"> * system entitlement and the number of devices in the OF tree that</span>
<span class="cm"> * require entitlement in the reserve pool.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vio_cmo_bus_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcall_mpp_data</span> <span class="n">mpp_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_cmo</span><span class="p">));</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">device_list</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">balance_q</span><span class="p">,</span> <span class="n">vio_cmo_balance</span><span class="p">);</span>

	<span class="cm">/* Get current system entitlement */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">h_get_mpp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpp_data</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * On failure, continue with entitlement set to 0, will panic()</span>
<span class="cm">	 * later when spare is reserved.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: unable to determine system IO &quot;</span>\
		       <span class="s">&quot;entitlement. (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vio_cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">=</span> <span class="n">mpp_data</span><span class="p">.</span><span class="n">entitled_mem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set reservation and check against entitlement */</span>
	<span class="n">vio_cmo</span><span class="p">.</span><span class="n">spare</span> <span class="o">=</span> <span class="n">VIO_CMO_MIN_ENT</span><span class="p">;</span>
	<span class="n">vio_cmo</span><span class="p">.</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">spare</span><span class="p">;</span>
	<span class="n">vio_cmo</span><span class="p">.</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vio_cmo_num_OF_devs</span><span class="p">()</span> <span class="o">*</span>
	                         <span class="n">VIO_CMO_MIN_ENT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">entitled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: insufficient system entitlement</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: Insufficient system entitlement&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set the remaining accounting variables */</span>
	<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">entitled</span> <span class="o">-</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">free</span> <span class="o">=</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">excess</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="n">vio_cmo</span><span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="n">vio_cmo</span><span class="p">.</span><span class="n">desired</span> <span class="o">=</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">reserve</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* sysfs device functions and data structures for CMO */</span>

<span class="cp">#define viodev_cmo_rd_attr(name)                                        \</span>
<span class="cp">static ssize_t viodev_cmo_##name##_show(struct device *dev,             \</span>
<span class="cp">                                        struct device_attribute *attr,  \</span>
<span class="cp">                                         char *buf)                     \</span>
<span class="cp">{                                                                       \</span>
<span class="cp">	return sprintf(buf, &quot;%lu\n&quot;, to_vio_dev(dev)-&gt;cmo.name);        \</span>
<span class="cp">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">viodev_cmo_allocs_failed_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocs_failed</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">viodev_cmo_allocs_failed_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">.</span><span class="n">allocs_failed</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">viodev_cmo_desired_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">new_desired</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_desired</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">vio_cmo_set_dev_desired</span><span class="p">(</span><span class="n">viodev</span><span class="p">,</span> <span class="n">new_desired</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">viodev_cmo_rd_attr</span><span class="p">(</span><span class="n">desired</span><span class="p">);</span>
<span class="n">viodev_cmo_rd_attr</span><span class="p">(</span><span class="n">entitled</span><span class="p">);</span>
<span class="n">viodev_cmo_rd_attr</span><span class="p">(</span><span class="n">allocated</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">name_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">devspec_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">modalias_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">vio_cmo_dev_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">devspec</span><span class="p">),</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">modalias</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">cmo_desired</span><span class="p">,</span>       <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IWGRP</span><span class="o">|</span><span class="n">S_IRGRP</span><span class="o">|</span><span class="n">S_IROTH</span><span class="p">,</span>
	       <span class="n">viodev_cmo_desired_show</span><span class="p">,</span> <span class="n">viodev_cmo_desired_set</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">cmo_entitled</span><span class="p">,</span>      <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">viodev_cmo_entitled_show</span><span class="p">,</span>      <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">cmo_allocated</span><span class="p">,</span>     <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">viodev_cmo_allocated_show</span><span class="p">,</span>     <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">cmo_allocs_failed</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IWGRP</span><span class="o">|</span><span class="n">S_IRGRP</span><span class="o">|</span><span class="n">S_IROTH</span><span class="p">,</span>
	       <span class="n">viodev_cmo_allocs_failed_show</span><span class="p">,</span> <span class="n">viodev_cmo_allocs_failed_reset</span><span class="p">),</span>
	<span class="n">__ATTR_NULL</span>
<span class="p">};</span>

<span class="cm">/* sysfs bus functions and data structures for CMO */</span>

<span class="cp">#define viobus_cmo_rd_attr(name)                                        \</span>
<span class="cp">static ssize_t                                                          \</span>
<span class="cp">viobus_cmo_##name##_show(struct bus_type *bt, char *buf)                \</span>
<span class="cp">{                                                                       \</span>
<span class="cp">	return sprintf(buf, &quot;%lu\n&quot;, vio_cmo.name);                     \</span>
<span class="cp">}</span>

<span class="cp">#define viobus_cmo_pool_rd_attr(name, var)                              \</span>
<span class="cp">static ssize_t                                                          \</span>
<span class="cp">viobus_cmo_##name##_pool_show_##var(struct bus_type *bt, char *buf)     \</span>
<span class="cp">{                                                                       \</span>
<span class="cp">	return sprintf(buf, &quot;%lu\n&quot;, vio_cmo.name.var);                 \</span>
<span class="cp">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">viobus_cmo_high_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
                                     <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">vio_cmo</span><span class="p">.</span><span class="n">high</span> <span class="o">=</span> <span class="n">vio_cmo</span><span class="p">.</span><span class="n">curr</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_cmo</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">viobus_cmo_rd_attr</span><span class="p">(</span><span class="n">entitled</span><span class="p">);</span>
<span class="n">viobus_cmo_pool_rd_attr</span><span class="p">(</span><span class="n">reserve</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="n">viobus_cmo_pool_rd_attr</span><span class="p">(</span><span class="n">excess</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="n">viobus_cmo_pool_rd_attr</span><span class="p">(</span><span class="n">excess</span><span class="p">,</span> <span class="n">free</span><span class="p">);</span>
<span class="n">viobus_cmo_rd_attr</span><span class="p">(</span><span class="n">spare</span><span class="p">);</span>
<span class="n">viobus_cmo_rd_attr</span><span class="p">(</span><span class="n">min</span><span class="p">);</span>
<span class="n">viobus_cmo_rd_attr</span><span class="p">(</span><span class="n">desired</span><span class="p">);</span>
<span class="n">viobus_cmo_rd_attr</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
<span class="n">viobus_cmo_rd_attr</span><span class="p">(</span><span class="n">high</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bus_attribute</span> <span class="n">vio_cmo_bus_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">cmo_entitled</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">viobus_cmo_entitled_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">cmo_reserve_size</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">viobus_cmo_reserve_pool_show_size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">cmo_excess_size</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">viobus_cmo_excess_pool_show_size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">cmo_excess_free</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">viobus_cmo_excess_pool_show_free</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">cmo_spare</span><span class="p">,</span>   <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">viobus_cmo_spare_show</span><span class="p">,</span>   <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">cmo_min</span><span class="p">,</span>     <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">viobus_cmo_min_show</span><span class="p">,</span>     <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">cmo_desired</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">viobus_cmo_desired_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">cmo_curr</span><span class="p">,</span>    <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">viobus_cmo_curr_show</span><span class="p">,</span>    <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">cmo_high</span><span class="p">,</span>    <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IWGRP</span><span class="o">|</span><span class="n">S_IRGRP</span><span class="o">|</span><span class="n">S_IROTH</span><span class="p">,</span>
	       <span class="n">viobus_cmo_high_show</span><span class="p">,</span> <span class="n">viobus_cmo_high_reset</span><span class="p">),</span>
	<span class="n">__ATTR_NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vio_cmo_sysfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vio_bus_type</span><span class="p">.</span><span class="n">dev_attrs</span> <span class="o">=</span> <span class="n">vio_cmo_dev_attrs</span><span class="p">;</span>
	<span class="n">vio_bus_type</span><span class="p">.</span><span class="n">bus_attrs</span> <span class="o">=</span> <span class="n">vio_cmo_bus_attrs</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_PPC_SMLPAR */</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">vio_cmo_entitlement_update</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">new_entitlement</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">vio_cmo_set_dev_desired</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">desired</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vio_cmo_bus_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vio_cmo_bus_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vio_cmo_set_dma_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vio_cmo_bus_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vio_cmo_sysfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_SMLPAR */</span><span class="cp"></span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vio_cmo_entitlement_update</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vio_cmo_set_dev_desired</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Platform Facilities Option (PFO) support</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * vio_h_cop_sync - Perform a synchronous PFO co-processor operation</span>
<span class="cm"> *</span>
<span class="cm"> * @vdev - Pointer to a struct vio_dev for device</span>
<span class="cm"> * @op - Pointer to a struct vio_pfo_op for the operation parameters</span>
<span class="cm"> *</span>
<span class="cm"> * Calls the hypervisor to synchronously perform the PFO operation</span>
<span class="cm"> * described in @op.  In the case of a busy response from the hypervisor,</span>
<span class="cm"> * the operation will be re-submitted indefinitely unless a non-zero timeout</span>
<span class="cm"> * is specified or an error occurs. The timeout places a limit on when to</span>
<span class="cm"> * stop re-submitting a operation, the total time can be exceeded if an</span>
<span class="cm"> * operation is in progress.</span>
<span class="cm"> *</span>
<span class="cm"> * If op-&gt;hcall_ret is not NULL, this will be set to the return from the</span>
<span class="cm"> * last h_cop_op call or it will be 0 if an error not involving the h_call</span>
<span class="cm"> * was encountered.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	0 on success,</span>
<span class="cm"> *	-EINVAL if the h_call fails due to an invalid parameter,</span>
<span class="cm"> *	-E2BIG if the h_call can not be performed synchronously,</span>
<span class="cm"> *	-EBUSY if a timeout is specified and has elapsed,</span>
<span class="cm"> *	-EACCES if the memory area for data/status has been rescinded, or</span>
<span class="cm"> *	-EPERM if a hardware fault has been indicated</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vio_h_cop_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vio_pfo_op</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">hret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">)</span>
		<span class="n">deadline</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hret</span> <span class="o">=</span> <span class="n">plpar_hcall_norets</span><span class="p">(</span><span class="n">H_COP</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
				<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">resource_id</span><span class="p">,</span>
				<span class="n">op</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">inlen</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">out</span><span class="p">,</span>
				<span class="n">op</span><span class="o">-&gt;</span><span class="n">outlen</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">csbcpb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hret</span> <span class="o">==</span> <span class="n">H_SUCCESS</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">hret</span> <span class="o">!=</span> <span class="n">H_NOT_ENOUGH_RESOURCES</span> <span class="o">&amp;&amp;</span>
		     <span class="n">hret</span> <span class="o">!=</span> <span class="n">H_BUSY</span> <span class="o">&amp;&amp;</span> <span class="n">hret</span> <span class="o">!=</span> <span class="n">H_RESOURCE</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">&amp;&amp;</span> <span class="n">time_after</span><span class="p">(</span><span class="n">deadline</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: hcall ret(%ld), retrying.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">hret</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">H_SUCCESS</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">H_OP_MODE</span>:
	<span class="k">case</span> <span class="n">H_TOO_BIG</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">H_RESCINDED</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">H_HARDWARE</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">H_NOT_ENOUGH_RESOURCES</span>:
	<span class="k">case</span> <span class="n">H_RESOURCE</span>:
	<span class="k">case</span> <span class="n">H_BUSY</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Sync h_cop_op failure (ret:%d) (hret:%ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">hret</span><span class="p">);</span>

	<span class="n">op</span><span class="o">-&gt;</span><span class="n">hcall_err</span> <span class="o">=</span> <span class="n">hret</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vio_h_cop_sync</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="nf">vio_build_iommu_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dma_window</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">dma_window</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span>
				  <span class="s">&quot;ibm,my-dma-window&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_window</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">tbl</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tbl</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tbl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">of_parse_dma_window</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="n">dma_window</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>

	<span class="cm">/* TCE table size - measured in tce entries */</span>
	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">IOMMU_PAGE_SHIFT</span><span class="p">;</span>
	<span class="cm">/* offset for VIO should always be 0 */</span>
	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">IOMMU_PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_busno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_type</span> <span class="o">=</span> <span class="n">TCE_VB</span><span class="p">;</span>
	<span class="n">tbl</span><span class="o">-&gt;</span><span class="n">it_blocksize</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">iommu_init_table</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vio_match_device: - Tell if a VIO device has a matching</span>
<span class="cm"> *			VIO device id structure.</span>
<span class="cm"> * @ids:	array of VIO device id structures to search in</span>
<span class="cm"> * @dev:	the VIO device structure to match against</span>
<span class="cm"> *</span>
<span class="cm"> * Used by a driver to check whether a VIO device present in the</span>
<span class="cm"> * system is in its list of supported devices. Returns the matching</span>
<span class="cm"> * vio_device_id structure or NULL if there is no match.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vio_device_id</span> <span class="o">*</span><span class="nf">vio_match_device</span><span class="p">(</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">vio_device_id</span> <span class="o">*</span><span class="n">ids</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">strncmp</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span>
					 <span class="n">ids</span><span class="o">-&gt;</span><span class="n">compat</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ids</span><span class="p">;</span>
		<span class="n">ids</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert from struct device to struct vio_dev and pass to driver.</span>
<span class="cm"> * dev-&gt;driver has already been set by generic code because vio_bus_match</span>
<span class="cm"> * succeeded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vio_bus_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vio_driver</span> <span class="o">*</span><span class="n">viodrv</span> <span class="o">=</span> <span class="n">to_vio_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">vio_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">id</span> <span class="o">=</span> <span class="n">vio_match_device</span><span class="p">(</span><span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">,</span> <span class="n">viodev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">cmo</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_CMO</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">vio_cmo_bus_probe</span><span class="p">(</span><span class="n">viodev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">viodev</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_CMO</span><span class="p">))</span>
			<span class="n">vio_cmo_bus_remove</span><span class="p">(</span><span class="n">viodev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* convert from struct device to struct vio_dev and pass to driver. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vio_bus_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vio_driver</span> <span class="o">*</span><span class="n">viodrv</span> <span class="o">=</span> <span class="n">to_vio_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">devptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hold a reference to the device after the remove function is called</span>
<span class="cm">	 * to allow for CMO accounting cleanup for the device.</span>
<span class="cm">	 */</span>
	<span class="n">devptr</span> <span class="o">=</span> <span class="n">get_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">viodev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_CMO</span><span class="p">))</span>
		<span class="n">vio_cmo_bus_remove</span><span class="p">(</span><span class="n">viodev</span><span class="p">);</span>

	<span class="n">put_device</span><span class="p">(</span><span class="n">devptr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vio_register_driver: - Register a new vio driver</span>
<span class="cm"> * @drv:	The vio_driver structure to be registered.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__vio_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_driver</span> <span class="o">*</span><span class="n">viodrv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: driver %s registering</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* fill in &#39;struct driver&#39; fields */</span>
	<span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">pm</span> <span class="o">=</span> <span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="p">;</span>
	<span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vio_bus_type</span><span class="p">;</span>
	<span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span><span class="p">;</span>
	<span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">mod_name</span> <span class="o">=</span> <span class="n">mod_name</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__vio_register_driver</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vio_unregister_driver - Remove registration of vio driver.</span>
<span class="cm"> * @driver:	The vio_driver struct to be removed form registration</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">vio_unregister_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_driver</span> <span class="o">*</span><span class="n">viodrv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodrv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vio_unregister_driver</span><span class="p">);</span>

<span class="cm">/* vio_dev refcount hit 0 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">vio_dev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iommu_table</span> <span class="o">*</span><span class="n">tbl</span> <span class="o">=</span> <span class="n">get_iommu_table_base</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tbl</span><span class="p">)</span>
		<span class="n">iommu_free_table</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">of_node</span> <span class="o">?</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="o">-&gt;</span><span class="n">full_name</span> <span class="o">:</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vio_register_device_node: - Register a new vio device.</span>
<span class="cm"> * @of_node:	The OF node for this device.</span>
<span class="cm"> *</span>
<span class="cm"> * Creates and initializes a vio_dev structure from the data in</span>
<span class="cm"> * of_node and adds it to the list of virtual devices.</span>
<span class="cm"> * Returns a pointer to the created vio_dev or NULL if node has</span>
<span class="cm"> * NULL device_type or compatible fields.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="nf">vio_register_device_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">of_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">parent_node</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">unit_address</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pfo_resid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">vio_dev_family</span> <span class="n">family</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">of_node_name</span> <span class="o">=</span> <span class="n">of_node</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">?</span> <span class="n">of_node</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;&lt;unknown&gt;&quot;</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine if this node is a under the /vdevice node or under the</span>
<span class="cm">	 * /ibm,platform-facilities node.  This decides the device&#39;s family.</span>
<span class="cm">	 */</span>
	<span class="n">parent_node</span> <span class="o">=</span> <span class="n">of_get_parent</span><span class="p">(</span><span class="n">of_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span> <span class="s">&quot;/ibm,platform-facilities&quot;</span><span class="p">))</span>
			<span class="n">family</span> <span class="o">=</span> <span class="n">PFO</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span> <span class="s">&quot;/vdevice&quot;</span><span class="p">))</span>
			<span class="n">family</span> <span class="o">=</span> <span class="n">VDEVICE</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: parent(%s) of %s not recognized.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span>
					<span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span>
					<span class="n">of_node_name</span><span class="p">);</span>
			<span class="n">of_node_put</span><span class="p">(</span><span class="n">parent_node</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">parent_node</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: could not determine the parent of node %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">of_node_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">PFO</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_get_property</span><span class="p">(</span><span class="n">of_node</span><span class="p">,</span> <span class="s">&quot;interrupt-controller&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Skipping the interrupt controller %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">of_node_name</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* allocate a vio_dev for this node */</span>
	<span class="n">viodev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">viodev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: allocation failure for VIO device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we need the &#39;device_type&#39; property, in order to match with drivers */</span>
	<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">=</span> <span class="n">family</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">==</span> <span class="n">VDEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_node</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">of_node</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: node %s is missing the &#39;device_type&#39; &quot;</span>
					<span class="s">&quot;property.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">of_node_name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">unit_address</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">of_node</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unit_address</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: node %s missing &#39;reg&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">of_node_name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%x&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">unit_address</span><span class="p">);</span>
		<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">of_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">unit_address</span> <span class="o">=</span> <span class="o">*</span><span class="n">unit_address</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* PFO devices need their resource_id for submitting COP_OPs</span>
<span class="cm">		 * This is an optional field for devices, but is required when</span>
<span class="cm">		 * performing synchronous ops */</span>
		<span class="n">pfo_resid</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">of_node</span><span class="p">,</span> <span class="s">&quot;ibm,resource-id&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pfo_resid</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">resource_id</span> <span class="o">=</span> <span class="o">*</span><span class="n">pfo_resid</span><span class="p">;</span>

		<span class="n">unit_address</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">of_node_name</span><span class="p">);</span>
		<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">of_node_name</span><span class="p">;</span>
		<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">of_node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span> <span class="o">=</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">of_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_CMO</span><span class="p">))</span>
		<span class="n">vio_cmo_set_dma_ops</span><span class="p">(</span><span class="n">viodev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">set_dma_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_iommu_ops</span><span class="p">);</span>
	<span class="n">set_iommu_table_base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">vio_build_iommu_table</span><span class="p">(</span><span class="n">viodev</span><span class="p">));</span>
	<span class="n">set_dev_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">of_node_to_nid</span><span class="p">(</span><span class="n">of_node</span><span class="p">));</span>

	<span class="cm">/* init generic &#39;struct device&#39; fields: */</span>
	<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vio_bus_device</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vio_bus_type</span><span class="p">;</span>
	<span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">vio_dev_release</span><span class="p">;</span>
        <span class="cm">/* needed to ensure proper operation of coherent allocations</span>
<span class="cm">         * later, in case driver doesn&#39;t set it explicitly */</span>
        <span class="n">dma_set_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
        <span class="n">dma_set_coherent_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>

	<span class="cm">/* register with generic device framework */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: failed to register device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">viodev</span><span class="p">;</span>

<span class="nl">out:</span>	<span class="cm">/* Use this exit point for any return prior to device_register */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">viodev</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vio_register_device_node</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * vio_bus_scan_for_devices - Scan OF and register each child device</span>
<span class="cm"> * @root_name - OF node name for the root of the subtree to search.</span>
<span class="cm"> *		This must be non-NULL</span>
<span class="cm"> *</span>
<span class="cm"> * Starting from the root node provide, register the device node for</span>
<span class="cm"> * each child beneath the root.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vio_bus_scan_register_devices</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">root_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node_root</span><span class="p">,</span> <span class="o">*</span><span class="n">node_child</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root_name</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">node_root</span> <span class="o">=</span> <span class="n">of_find_node_by_name</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_root</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * Create struct vio_devices for each virtual device in</span>
<span class="cm">		 * the device tree. Drivers will associate with them later.</span>
<span class="cm">		 */</span>
		<span class="n">node_child</span> <span class="o">=</span> <span class="n">of_get_next_child</span><span class="p">(</span><span class="n">node_root</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">node_child</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vio_register_device_node</span><span class="p">(</span><span class="n">node_child</span><span class="p">);</span>
			<span class="n">node_child</span> <span class="o">=</span> <span class="n">of_get_next_child</span><span class="p">(</span><span class="n">node_root</span><span class="p">,</span> <span class="n">node_child</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">node_root</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vio_bus_init: - Initialize the virtual IO bus</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">vio_bus_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_CMO</span><span class="p">))</span>
		<span class="n">vio_cmo_sysfs_init</span><span class="p">();</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">bus_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_bus_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;failed to register VIO bus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The fake parent of all vio devices, just to give us</span>
<span class="cm">	 * a nice directory</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_bus_device</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: device_register returned %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_CMO</span><span class="p">))</span>
		<span class="n">vio_cmo_bus_init</span><span class="p">();</span>

	<span class="n">vio_bus_scan_register_devices</span><span class="p">(</span><span class="s">&quot;vdevice&quot;</span><span class="p">);</span>
	<span class="n">vio_bus_scan_register_devices</span><span class="p">(</span><span class="s">&quot;ibm,platform-facilities&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">vio_bus_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">name_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">devspec_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">of_node</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">of_node</span> <span class="o">?</span> <span class="n">of_node</span><span class="o">-&gt;</span><span class="n">full_name</span> <span class="o">:</span> <span class="s">&quot;none&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">modalias_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">vio_dev</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="n">dn</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dn</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="s">&quot;compatible&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;vio:T%sS%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vio_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">vio_dev_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">devspec</span><span class="p">),</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">modalias</span><span class="p">),</span>
	<span class="n">__ATTR_NULL</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">vio_unregister_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viodev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vio_unregister_device</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vio_bus_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">vio_dev</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vio_driver</span> <span class="o">*</span><span class="n">vio_drv</span> <span class="o">=</span> <span class="n">to_vio_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">vio_device_id</span> <span class="o">*</span><span class="n">ids</span> <span class="o">=</span> <span class="n">vio_drv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">ids</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vio_match_device</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">vio_dev</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vio_hotplug</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">vio_dev</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="n">dn</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dn</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="s">&quot;compatible&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;MODALIAS=vio:T%sS%s&quot;</span><span class="p">,</span> <span class="n">vio_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">vio_bus_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;vio&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_attrs</span> <span class="o">=</span> <span class="n">vio_dev_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">uevent</span> <span class="o">=</span> <span class="n">vio_hotplug</span><span class="p">,</span>
	<span class="p">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">vio_bus_match</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">vio_bus_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">vio_bus_remove</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * vio_get_attribute: - get attribute for virtual device</span>
<span class="cm"> * @vdev:	The vio device to get property.</span>
<span class="cm"> * @which:	The property/attribute to be extracted.</span>
<span class="cm"> * @length:	Pointer to length of returned data size (unused if NULL).</span>
<span class="cm"> *</span>
<span class="cm"> * Calls prom.c&#39;s of_get_property() to return the value of the</span>
<span class="cm"> * attribute specified by @which</span>
<span class="cm">*/</span>
<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">vio_get_attribute</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">which</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vio_get_attribute</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC_PSERIES</span>
<span class="cm">/* vio_find_name() - internal because only vio.c knows how we formatted the</span>
<span class="cm"> * kobject name</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="nf">vio_find_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">found</span><span class="p">;</span>

	<span class="n">found</span> <span class="o">=</span> <span class="n">bus_find_device_by_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vio_bus_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">found</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vio_find_node - find an already-registered vio_dev</span>
<span class="cm"> * @vnode: device_node of the virtual device we&#39;re looking for</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="nf">vio_find_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">vnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">unit_address</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">kobj_name</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">vnode_parent</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_type</span><span class="p">;</span>

	<span class="n">vnode_parent</span> <span class="o">=</span> <span class="n">of_get_parent</span><span class="p">(</span><span class="n">vnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vnode_parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev_type</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">vnode_parent</span><span class="p">,</span> <span class="s">&quot;device_type&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">vnode_parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_type</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* construct the kobject name from the device node */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dev_type</span><span class="p">,</span> <span class="s">&quot;vdevice&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unit_address</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">vnode</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unit_address</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">kobj_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kobj_name</span><span class="p">),</span> <span class="s">&quot;%x&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">unit_address</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dev_type</span><span class="p">,</span> <span class="s">&quot;ibm,platform-facilities&quot;</span><span class="p">))</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">kobj_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kobj_name</span><span class="p">),</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">vio_find_name</span><span class="p">(</span><span class="n">kobj_name</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vio_find_node</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">vio_enable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">h_vio_signal</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">,</span> <span class="n">VIO_IRQ_ENABLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vio: Error 0x%x enabling interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vio_enable_interrupts</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">vio_disable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">h_vio_signal</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">,</span> <span class="n">VIO_IRQ_DISABLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vio: Error 0x%x disabling interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vio_disable_interrupts</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_PSERIES */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
