<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › kernel › process.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>process.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Derived from &quot;arch/i386/kernel/process.c&quot;</span>
<span class="cm"> *    Copyright (C) 1995  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  Updated and modified by Cort Dougan (cort@cs.nmt.edu) and</span>
<span class="cm"> *  Paul Mackerras (paulus@cs.anu.edu.au)</span>
<span class="cm"> *</span>
<span class="cm"> *  PowerPC version</span>
<span class="cm"> *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or</span>
<span class="cm"> *  modify it under the terms of the GNU General Public License</span>
<span class="cm"> *  as published by the Free Software Foundation; either version</span>
<span class="cm"> *  2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/user.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/prctl.h&gt;</span>
<span class="cp">#include &lt;linux/init_task.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/mqueue.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/utsname.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/personality.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/hw_breakpoint.h&gt;</span>

<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/mmu.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/time.h&gt;</span>
<span class="cp">#include &lt;asm/runlatch.h&gt;</span>
<span class="cp">#include &lt;asm/syscalls.h&gt;</span>
<span class="cp">#include &lt;asm/switch_to.h&gt;</span>
<span class="cp">#include &lt;asm/debug.h&gt;</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cp">#include &lt;asm/firmware.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_get_SP</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_SMP</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">last_task_used_math</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">last_task_used_altivec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">last_task_used_vsx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">last_task_used_spe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Make sure the floating-point register state in the</span>
<span class="cm"> * the thread_struct is up to date for task tsk.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">flush_fp_to_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We need to disable preemption here because if we didn&#39;t,</span>
<span class="cm">		 * another process could get scheduled after the regs-&gt;msr</span>
<span class="cm">		 * test but before we have finished saving the FP registers</span>
<span class="cm">		 * to the thread_struct.  That process could take over the</span>
<span class="cm">		 * FPU, and then when we get scheduled again we would store</span>
<span class="cm">		 * bogus values for the remaining FP registers.</span>
<span class="cm">		 */</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_FP</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
			<span class="cm">/*</span>
<span class="cm">			 * This should only ever be called for current or</span>
<span class="cm">			 * for a stopped child process.  Since we save away</span>
<span class="cm">			 * the FP register state on context switch on SMP,</span>
<span class="cm">			 * there is something wrong if a stopped child appears</span>
<span class="cm">			 * to still have its FP state in the CPU registers.</span>
<span class="cm">			 */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tsk</span> <span class="o">!=</span> <span class="n">current</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">giveup_fpu</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">flush_fp_to_thread</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">enable_kernel_fp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">preemptible</span><span class="p">());</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_FP</span><span class="p">))</span>
		<span class="n">giveup_fpu</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">giveup_fpu</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>	<span class="cm">/* just enables FP for kernel */</span>
<span class="cp">#else</span>
	<span class="n">giveup_fpu</span><span class="p">(</span><span class="n">last_task_used_math</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">enable_kernel_fp</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ALTIVEC</span>
<span class="kt">void</span> <span class="nf">enable_kernel_altivec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">preemptible</span><span class="p">());</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_VEC</span><span class="p">))</span>
		<span class="n">giveup_altivec</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">giveup_altivec_notask</span><span class="p">();</span>
<span class="cp">#else</span>
	<span class="n">giveup_altivec</span><span class="p">(</span><span class="n">last_task_used_altivec</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">enable_kernel_altivec</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Make sure the VMX/Altivec register state in the</span>
<span class="cm"> * the thread_struct is up to date for task tsk.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">flush_altivec_to_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_VEC</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tsk</span> <span class="o">!=</span> <span class="n">current</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">giveup_altivec</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">flush_altivec_to_thread</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ALTIVEC */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_VSX</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/* not currently used, but some crazy RAID module might want to later */</span>
<span class="c">void enable_kernel_vsx(void)</span>
<span class="c">{</span>
<span class="c">	WARN_ON(preemptible());</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="c">	if (current-&gt;thread.regs &amp;&amp; (current-&gt;thread.regs-&gt;msr &amp; MSR_VSX))</span>
<span class="c">		giveup_vsx(current);</span>
<span class="c">	else</span>
<span class="c">		giveup_vsx(NULL);	/* just enable vsx for kernel - force */</span>
<span class="cp">#else</span>
<span class="c">	giveup_vsx(last_task_used_vsx);</span>
<span class="cp">#endif /* CONFIG_SMP */</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">enable_kernel_vsx</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">giveup_vsx</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">giveup_fpu</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">giveup_altivec</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">__giveup_vsx</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">flush_vsx_to_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_VSX</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tsk</span> <span class="o">!=</span> <span class="n">current</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">giveup_vsx</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">flush_vsx_to_thread</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_VSX */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SPE</span>

<span class="kt">void</span> <span class="nf">enable_kernel_spe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">preemptible</span><span class="p">());</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_SPE</span><span class="p">))</span>
		<span class="n">giveup_spe</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">giveup_spe</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>	<span class="cm">/* just enable SPE for kernel - force */</span>
<span class="cp">#else</span>
	<span class="n">giveup_spe</span><span class="p">(</span><span class="n">last_task_used_spe</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* __SMP __ */</span><span class="cp"></span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">enable_kernel_spe</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">flush_spe_to_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_SPE</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tsk</span> <span class="o">!=</span> <span class="n">current</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">spefscr</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_SPEFSCR</span><span class="p">);</span>
			<span class="n">giveup_spe</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SPE */</span><span class="cp"></span>

<span class="cp">#ifndef CONFIG_SMP</span>
<span class="cm">/*</span>
<span class="cm"> * If we are doing lazy switching of CPU state (FP, altivec or SPE),</span>
<span class="cm"> * and the current task has some state, discard it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">discard_lazy_cpu_state</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_task_used_math</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span>
		<span class="n">last_task_used_math</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ALTIVEC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_task_used_altivec</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span>
		<span class="n">last_task_used_altivec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ALTIVEC */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_VSX</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_task_used_vsx</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span>
		<span class="n">last_task_used_vsx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_VSX */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_SPE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_task_used_spe</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span>
		<span class="n">last_task_used_spe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PPC_ADV_DEBUG_REGS</span>
<span class="kt">void</span> <span class="nf">do_send_trap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signal_code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">breakpt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">siginfo_t</span> <span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_DABR_MATCH</span><span class="p">,</span> <span class="s">&quot;dabr_match&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span>
			<span class="mi">11</span><span class="p">,</span> <span class="n">SIGSEGV</span><span class="p">)</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Deliver the signal to userspace */</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGTRAP</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="n">breakpt</span><span class="p">;</span>	<span class="cm">/* breakpoint or watchpoint id */</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">signal_code</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">;</span>
	<span class="n">force_sig_info</span><span class="p">(</span><span class="n">SIGTRAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else	</span><span class="cm">/* !CONFIG_PPC_ADV_DEBUG_REGS */</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">do_dabr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">siginfo_t</span> <span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_DABR_MATCH</span><span class="p">,</span> <span class="s">&quot;dabr_match&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span>
			<span class="mi">11</span><span class="p">,</span> <span class="n">SIGSEGV</span><span class="p">)</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debugger_dabr_match</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Clear the DABR */</span>
	<span class="n">set_dabr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Deliver the signal to userspace */</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGTRAP</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">TRAP_HWBKPT</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">;</span>
	<span class="n">force_sig_info</span><span class="p">(</span><span class="n">SIGTRAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_PPC_ADV_DEBUG_REGS */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">current_dabr</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC_ADV_DEBUG_REGS</span>
<span class="cm">/*</span>
<span class="cm"> * Set the debug registers back to their default &quot;safe&quot; values.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_debug_reg_defaults</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kr">thread</span><span class="o">-&gt;</span><span class="n">iac1</span> <span class="o">=</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">iac2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#if CONFIG_PPC_ADV_DEBUG_IACS &gt; 2</span>
	<span class="kr">thread</span><span class="o">-&gt;</span><span class="n">iac3</span> <span class="o">=</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">iac4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dac1</span> <span class="o">=</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dac2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#if CONFIG_PPC_ADV_DEBUG_DVCS &gt; 0</span>
	<span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dvc1</span> <span class="o">=</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dvc2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dbcr0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BOOKE</span>
	<span class="cm">/*</span>
<span class="cm">	 * Force User/Supervisor bits to b11 (user-only MSR[PR]=1)</span>
<span class="cm">	 */</span>
	<span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dbcr1</span> <span class="o">=</span> <span class="n">DBCR1_IAC1US</span> <span class="o">|</span> <span class="n">DBCR1_IAC2US</span> <span class="o">|</span>	\
			<span class="n">DBCR1_IAC3US</span> <span class="o">|</span> <span class="n">DBCR1_IAC4US</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Force Data Address Compare User/Supervisor bits to be User-only</span>
<span class="cm">	 * (0b11 MSR[PR]=1) and set all other bits in DBCR2 register to be 0.</span>
<span class="cm">	 */</span>
	<span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dbcr2</span> <span class="o">=</span> <span class="n">DBCR2_DAC1US</span> <span class="o">|</span> <span class="n">DBCR2_DAC2US</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dbcr1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">prime_debug_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_IAC1</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">iac1</span><span class="p">);</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_IAC2</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">iac2</span><span class="p">);</span>
<span class="cp">#if CONFIG_PPC_ADV_DEBUG_IACS &gt; 2</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_IAC3</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">iac3</span><span class="p">);</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_IAC4</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">iac4</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_DAC1</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dac1</span><span class="p">);</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_DAC2</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dac2</span><span class="p">);</span>
<span class="cp">#if CONFIG_PPC_ADV_DEBUG_DVCS &gt; 0</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_DVC1</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dvc1</span><span class="p">);</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_DVC2</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dvc2</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_DBCR0</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dbcr0</span><span class="p">);</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_DBCR1</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dbcr1</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_BOOKE</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_DBCR2</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dbcr2</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Unless neither the old or new thread are making use of the</span>
<span class="cm"> * debug registers, set the debug registers from the values</span>
<span class="cm"> * stored in the new thread.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">switch_booke_debug_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="n">new_thread</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dbcr0</span> <span class="o">&amp;</span> <span class="n">DBCR0_IDM</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">new_thread</span><span class="o">-&gt;</span><span class="n">dbcr0</span> <span class="o">&amp;</span> <span class="n">DBCR0_IDM</span><span class="p">))</span>
			<span class="n">prime_debug_regs</span><span class="p">(</span><span class="n">new_thread</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else	</span><span class="cm">/* !CONFIG_PPC_ADV_DEBUG_REGS */</span><span class="cp"></span>
<span class="cp">#ifndef CONFIG_HAVE_HW_BREAKPOINT</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_debug_reg_defaults</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dabr</span><span class="p">)</span> <span class="p">{</span>
		<span class="kr">thread</span><span class="o">-&gt;</span><span class="n">dabr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">set_dabr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_HAVE_HW_BREAKPOINT */</span><span class="cp"></span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_PPC_ADV_DEBUG_REGS */</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">set_dabr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dabr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">current_dabr</span><span class="p">)</span> <span class="o">=</span> <span class="n">dabr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">set_dabr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ppc_md</span><span class="p">.</span><span class="n">set_dabr</span><span class="p">(</span><span class="n">dabr</span><span class="p">);</span>

	<span class="cm">/* XXX should we have a CPU_FTR_HAS_DABR ? */</span>
<span class="cp">#ifdef CONFIG_PPC_ADV_DEBUG_REGS</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_DAC1</span><span class="p">,</span> <span class="n">dabr</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PPC_47x</span>
	<span class="n">isync</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="cp">#elif defined(CONFIG_PPC_BOOK3S)</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_DABR</span><span class="p">,</span> <span class="n">dabr</span><span class="p">);</span>
<span class="cp">#endif</span>


	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_usage</span><span class="p">,</span> <span class="n">cpu_usage_array</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">__switch_to</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="n">new_thread</span><span class="p">,</span> <span class="o">*</span><span class="n">old_thread</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PPC_BOOK3S_64</span>
	<span class="k">struct</span> <span class="n">ppc64_tlb_batch</span> <span class="o">*</span><span class="n">batch</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/* avoid complexity of lazy save/restore of fpu</span>
<span class="cm">	 * by just saving it every time we switch out if</span>
<span class="cm">	 * this task used the fpu during the last quantum.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If it tries to use the fpu again, it&#39;ll trap and</span>
<span class="cm">	 * reload its fp regs.  So we don&#39;t have to do a restore</span>
<span class="cm">	 * every switch, just a save.</span>
<span class="cm">	 *  -- Cort</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_FP</span><span class="p">))</span>
		<span class="n">giveup_fpu</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_ALTIVEC</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the previous thread used altivec in the last quantum</span>
<span class="cm">	 * (thus changing altivec regs) then save them.</span>
<span class="cm">	 * We used to check the VRSAVE register but not all apps</span>
<span class="cm">	 * set it, so we don&#39;t rely on it now (and in fact we need</span>
<span class="cm">	 * to save &amp; restore VSCR even if VRSAVE == 0).  -- paulus</span>
<span class="cm">	 *</span>
<span class="cm">	 * On SMP we always save/restore altivec regs just to avoid the</span>
<span class="cm">	 * complexity of changing processors.</span>
<span class="cm">	 *  -- Cort</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_VEC</span><span class="p">))</span>
		<span class="n">giveup_altivec</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ALTIVEC */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_VSX</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_VSX</span><span class="p">))</span>
		<span class="cm">/* VMX and FPU registers are already save here */</span>
		<span class="n">__giveup_vsx</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_VSX */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_SPE</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the previous thread used spe in the last quantum</span>
<span class="cm">	 * (thus changing spe regs) then save them.</span>
<span class="cm">	 *</span>
<span class="cm">	 * On SMP we always save/restore spe regs just to avoid the</span>
<span class="cm">	 * complexity of changing processors.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">prev</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_SPE</span><span class="p">)))</span>
		<span class="n">giveup_spe</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SPE */</span><span class="cp"></span>

<span class="cp">#else  </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_ALTIVEC</span>
	<span class="cm">/* Avoid the trap.  On smp this this never happens since</span>
<span class="cm">	 * we don&#39;t set last_task_used_altivec -- Cort</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span> <span class="o">&amp;&amp;</span> <span class="n">last_task_used_altivec</span> <span class="o">==</span> <span class="n">new</span><span class="p">)</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">|=</span> <span class="n">MSR_VEC</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ALTIVEC */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_VSX</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span> <span class="o">&amp;&amp;</span> <span class="n">last_task_used_vsx</span> <span class="o">==</span> <span class="n">new</span><span class="p">)</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">|=</span> <span class="n">MSR_VSX</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_VSX */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_SPE</span>
	<span class="cm">/* Avoid the trap.  On smp this this never happens since</span>
<span class="cm">	 * we don&#39;t set last_task_used_spe</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span> <span class="o">&amp;&amp;</span> <span class="n">last_task_used_spe</span> <span class="o">==</span> <span class="n">new</span><span class="p">)</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">|=</span> <span class="n">MSR_SPE</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SPE */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PPC_ADV_DEBUG_REGS</span>
	<span class="n">switch_booke_debug_regs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cm">/*</span>
<span class="cm"> * For PPC_BOOK3S_64, we use the hw-breakpoint interfaces that would</span>
<span class="cm"> * schedule DABR</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_HAVE_HW_BREAKPOINT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">current_dabr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dabr</span><span class="p">))</span>
		<span class="n">set_dabr</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dabr</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HAVE_HW_BREAKPOINT */</span><span class="cp"></span>
<span class="cp">#endif</span>


	<span class="n">new_thread</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>
	<span class="n">old_thread</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="cm">/*</span>
<span class="cm">	 * Collect processor utilization data per process</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_SPLPAR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_usage</span> <span class="o">*</span><span class="n">cu</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_usage_array</span><span class="p">);</span>
		<span class="kt">long</span> <span class="kt">unsigned</span> <span class="n">start_tb</span><span class="p">,</span> <span class="n">current_tb</span><span class="p">;</span>
		<span class="n">start_tb</span> <span class="o">=</span> <span class="n">old_thread</span><span class="o">-&gt;</span><span class="n">start_tb</span><span class="p">;</span>
		<span class="n">cu</span><span class="o">-&gt;</span><span class="n">current_tb</span> <span class="o">=</span> <span class="n">current_tb</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_PURR</span><span class="p">);</span>
		<span class="n">old_thread</span><span class="o">-&gt;</span><span class="n">accum_tb</span> <span class="o">+=</span> <span class="p">(</span><span class="n">current_tb</span> <span class="o">-</span> <span class="n">start_tb</span><span class="p">);</span>
		<span class="n">new_thread</span><span class="o">-&gt;</span><span class="n">start_tb</span> <span class="o">=</span> <span class="n">current_tb</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PPC_BOOK3S_64</span>
	<span class="n">batch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ppc64_tlb_batch</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">local_flags</span> <span class="o">|=</span> <span class="n">_TLF_LAZY_MMU</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span>
			<span class="n">__flush_tlb_pending</span><span class="p">(</span><span class="n">batch</span><span class="p">);</span>
		<span class="n">batch</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_BOOK3S_64 */</span><span class="cp"></span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">account_system_vtime</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">account_process_vtime</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t take a PMU exception inside _switch() since there is a</span>
<span class="cm">	 * window where the kernel stack SLB and the kernel stack are out</span>
<span class="cm">	 * of sync. Hard disable here.</span>
<span class="cm">	 */</span>
	<span class="n">hard_irq_disable</span><span class="p">();</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">_switch</span><span class="p">(</span><span class="n">old_thread</span><span class="p">,</span> <span class="n">new_thread</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC_BOOK3S_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">local_flags</span> <span class="o">&amp;</span> <span class="n">_TLF_LAZY_MMU</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">local_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_TLF_LAZY_MMU</span><span class="p">;</span>
		<span class="n">batch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ppc64_tlb_batch</span><span class="p">);</span>
		<span class="n">batch</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_BOOK3S_64 */</span><span class="cp"></span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">last</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">instructions_to_print</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">show_instructions</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span> <span class="o">-</span> <span class="p">(</span><span class="n">instructions_to_print</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Instruction dump:&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instructions_to_print</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">instr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cp">#if !defined(CONFIG_BOOKE)</span>
		<span class="cm">/* If executing with the IMMU off, adjust pc rather</span>
<span class="cm">		 * than print XXXXXXXX.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_IR</span><span class="p">))</span>
			<span class="n">pc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">phys_to_virt</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="cm">/* We use __get_user here *only* to avoid an OOPS on a</span>
<span class="cm">		 * bad address because the pc *should* only be a</span>
<span class="cm">		 * kernel address.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__kernel_text_address</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span> <span class="o">||</span>
		     <span class="n">__get_user</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">pc</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;XXXXXXXX &quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span> <span class="o">==</span> <span class="n">pc</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;&lt;%08x&gt; &quot;</span><span class="p">,</span> <span class="n">instr</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%08x &quot;</span><span class="p">,</span> <span class="n">instr</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">pc</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">regbit</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bit</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">msr_bits</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#if defined(CONFIG_PPC64) &amp;&amp; !defined(CONFIG_BOOKE)</span>
	<span class="p">{</span><span class="n">MSR_SF</span><span class="p">,</span>	<span class="s">&quot;SF&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">MSR_HV</span><span class="p">,</span>	<span class="s">&quot;HV&quot;</span><span class="p">},</span>
<span class="cp">#endif</span>
	<span class="p">{</span><span class="n">MSR_VEC</span><span class="p">,</span>	<span class="s">&quot;VEC&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">MSR_VSX</span><span class="p">,</span>	<span class="s">&quot;VSX&quot;</span><span class="p">},</span>
<span class="cp">#ifdef CONFIG_BOOKE</span>
	<span class="p">{</span><span class="n">MSR_CE</span><span class="p">,</span>	<span class="s">&quot;CE&quot;</span><span class="p">},</span>
<span class="cp">#endif</span>
	<span class="p">{</span><span class="n">MSR_EE</span><span class="p">,</span>	<span class="s">&quot;EE&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">MSR_PR</span><span class="p">,</span>	<span class="s">&quot;PR&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">MSR_FP</span><span class="p">,</span>	<span class="s">&quot;FP&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">MSR_ME</span><span class="p">,</span>	<span class="s">&quot;ME&quot;</span><span class="p">},</span>
<span class="cp">#ifdef CONFIG_BOOKE</span>
	<span class="p">{</span><span class="n">MSR_DE</span><span class="p">,</span>	<span class="s">&quot;DE&quot;</span><span class="p">},</span>
<span class="cp">#else</span>
	<span class="p">{</span><span class="n">MSR_SE</span><span class="p">,</span>	<span class="s">&quot;SE&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">MSR_BE</span><span class="p">,</span>	<span class="s">&quot;BE&quot;</span><span class="p">},</span>
<span class="cp">#endif</span>
	<span class="p">{</span><span class="n">MSR_IR</span><span class="p">,</span>	<span class="s">&quot;IR&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">MSR_DR</span><span class="p">,</span>	<span class="s">&quot;DR&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">MSR_PMM</span><span class="p">,</span>	<span class="s">&quot;PMM&quot;</span><span class="p">},</span>
<span class="cp">#ifndef CONFIG_BOOKE</span>
	<span class="p">{</span><span class="n">MSR_RI</span><span class="p">,</span>	<span class="s">&quot;RI&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">MSR_LE</span><span class="p">,</span>	<span class="s">&quot;LE&quot;</span><span class="p">},</span>
<span class="cp">#endif</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span>		<span class="nb">NULL</span><span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">printbits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="k">struct</span> <span class="n">regbit</span> <span class="o">*</span><span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;&lt;&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">bits</span><span class="o">-&gt;</span><span class="n">bit</span><span class="p">;</span> <span class="o">++</span><span class="n">bits</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">bits</span><span class="o">-&gt;</span><span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s%s&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">bits</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">sep</span> <span class="o">=</span> <span class="s">&quot;,&quot;</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;&gt;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cp">#define REG		&quot;%016lx&quot;</span>
<span class="cp">#define REGS_PER_LINE	4</span>
<span class="cp">#define LAST_VOLATILE	13</span>
<span class="cp">#else</span>
<span class="cp">#define REG		&quot;%08lx&quot;</span>
<span class="cp">#define REGS_PER_LINE	8</span>
<span class="cp">#define LAST_VOLATILE	12</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">show_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">trap</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;NIP: &quot;</span><span class="n">REG</span><span class="s">&quot; LR: &quot;</span><span class="n">REG</span><span class="s">&quot; CTR: &quot;</span><span class="n">REG</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ctr</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;REGS: %p TRAP: %04lx   %s  (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">trap</span><span class="p">,</span> <span class="n">print_tainted</span><span class="p">(),</span> <span class="n">init_utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;MSR: &quot;</span><span class="n">REG</span><span class="s">&quot; &quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span><span class="p">);</span>
	<span class="n">printbits</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span><span class="p">,</span> <span class="n">msr_bits</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  CR: %08lx  XER: %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ccr</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">xer</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SOFTE: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">softe</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">trap</span> <span class="o">=</span> <span class="n">TRAP</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">trap</span> <span class="o">!=</span> <span class="mh">0xc00</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_CFAR</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CFAR: &quot;</span><span class="n">REG</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">orig_gpr3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trap</span> <span class="o">==</span> <span class="mh">0x300</span> <span class="o">||</span> <span class="n">trap</span> <span class="o">==</span> <span class="mh">0x600</span><span class="p">)</span>
<span class="cp">#if defined(CONFIG_4xx) || defined(CONFIG_BOOKE)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DEAR: &quot;</span><span class="n">REG</span><span class="s">&quot;, ESR: &quot;</span><span class="n">REG</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">dar</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">dsisr</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DAR: &quot;</span><span class="n">REG</span><span class="s">&quot;, DSISR: %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">dar</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">dsisr</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;TASK = %p[%d] &#39;%s&#39; THREAD: %p&quot;</span><span class="p">,</span>
	       <span class="n">current</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_thread_info</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; CPU: %d&quot;</span><span class="p">,</span> <span class="n">raw_smp_processor_id</span><span class="p">());</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span>  <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">%</span> <span class="n">REGS_PER_LINE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">GPR%02d: &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">REG</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">LAST_VOLATILE</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">FULL_REGS</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_KALLSYMS</span>
	<span class="cm">/*</span>
<span class="cm">	 * Lookup NIP late so we have the best change of getting the</span>
<span class="cm">	 * above info out without failing</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;NIP [&quot;</span><span class="n">REG</span><span class="s">&quot;] %pS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;LR [&quot;</span><span class="n">REG</span><span class="s">&quot;] %pS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">show_stack</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="n">show_instructions</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">exit_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">discard_lazy_cpu_state</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">flush_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">discard_lazy_cpu_state</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_HAVE_HW_BREAKPOINT</span>
	<span class="n">flush_ptrace_hw_breakpoint</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_HAVE_HW_BREAKPOINT */</span><span class="cp"></span>
	<span class="n">set_debug_reg_defaults</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HAVE_HW_BREAKPOINT */</span><span class="cp"></span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">release_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this gets called so that we can store coprocessor state into memory and</span>
<span class="cm"> * copy the current task into the new thread.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">arch_dup_task_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">flush_fp_to_thread</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
	<span class="n">flush_altivec_to_thread</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
	<span class="n">flush_vsx_to_thread</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
	<span class="n">flush_spe_to_thread</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_HAVE_HW_BREAKPOINT</span>
	<span class="n">flush_ptrace_hw_breakpoint</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HAVE_HW_BREAKPOINT */</span><span class="cp"></span>

	<span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy a thread..</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dscr_default</span><span class="p">;</span> <span class="cm">/* defined in arch/powerpc/kernel/sysfs.c */</span>

<span class="kt">int</span> <span class="nf">copy_thread</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">usp</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unused</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">childregs</span><span class="p">,</span> <span class="o">*</span><span class="n">kregs</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">ret_from_fork</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">task_stack_page</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">THREAD_SIZE</span><span class="p">;</span>

	<span class="n">CHECK_FULL_REGS</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="cm">/* Copy registers */</span>
	<span class="n">sp</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span><span class="p">);</span>
	<span class="n">childregs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span> <span class="n">sp</span><span class="p">;</span>
	<span class="o">*</span><span class="n">childregs</span> <span class="o">=</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">childregs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_PR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* for kernel thread, set `current&#39; and stackptr in new task */</span>
		<span class="n">childregs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PPC32</span>
		<span class="n">childregs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="n">clear_tsk_thread_flag</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">TIF_32BIT</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* no user register state */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">childregs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">usp</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span> <span class="o">=</span> <span class="n">childregs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_SETTLS</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_32bit_task</span><span class="p">())</span>
				<span class="n">childregs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">childregs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
			<span class="k">else</span>
<span class="cp">#endif</span>
				<span class="n">childregs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">childregs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">childregs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* Result from fork() */</span>
	<span class="n">sp</span> <span class="o">-=</span> <span class="n">STACK_FRAME_OVERHEAD</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The way this works is that at some point in the future</span>
<span class="cm">	 * some task will call _switch to switch to the new task.</span>
<span class="cm">	 * That will pop off the stack frame created below and start</span>
<span class="cm">	 * the new task running at ret_from_fork.  The new task will</span>
<span class="cm">	 * do some house keeping and then return from the fork or clone</span>
<span class="cm">	 * system call, using the stack frame created above.</span>
<span class="cm">	 */</span>
	<span class="n">sp</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span><span class="p">);</span>
	<span class="n">kregs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span> <span class="n">sp</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">-=</span> <span class="n">STACK_FRAME_OVERHEAD</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">ksp</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">ksp_limit</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">task_stack_page</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">_ALIGN_UP</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_info</span><span class="p">),</span> <span class="mi">16</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC_STD_MMU_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_has_feature</span><span class="p">(</span><span class="n">MMU_FTR_SLB</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp_vsid</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">llp</span> <span class="o">=</span> <span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">mmu_linear_psize</span><span class="p">].</span><span class="n">sllp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mmu_has_feature</span><span class="p">(</span><span class="n">MMU_FTR_1T_SEGMENT</span><span class="p">))</span>
			<span class="n">sp_vsid</span> <span class="o">=</span> <span class="n">get_kernel_vsid</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">MMU_SEGSIZE_1T</span><span class="p">)</span>
				<span class="o">&lt;&lt;</span> <span class="n">SLB_VSID_SHIFT_1T</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">sp_vsid</span> <span class="o">=</span> <span class="n">get_kernel_vsid</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">MMU_SEGSIZE_256M</span><span class="p">)</span>
				<span class="o">&lt;&lt;</span> <span class="n">SLB_VSID_SHIFT</span><span class="p">;</span>
		<span class="n">sp_vsid</span> <span class="o">|=</span> <span class="n">SLB_VSID_KERNEL</span> <span class="o">|</span> <span class="n">llp</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">ksp_vsid</span> <span class="o">=</span> <span class="n">sp_vsid</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_STD_MMU_64 */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_PPC64 </span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_DSCR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dscr_inherit</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dscr_inherit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dscr</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dscr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">dscr_default</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dscr_inherit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dscr</span> <span class="o">=</span> <span class="n">dscr_default</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dscr_inherit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dscr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * The PPC64 ABI makes use of a TOC to contain function </span>
<span class="cm">	 * pointers.  The function (ret_from_except) is actually a pointer</span>
<span class="cm">	 * to the TOC entry.  The first entry is a pointer to the actual</span>
<span class="cm">	 * function.</span>
<span class="cm"> 	 */</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="n">kregs</span><span class="o">-&gt;</span><span class="n">nip</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">ret_from_fork</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">kregs</span><span class="o">-&gt;</span><span class="n">nip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ret_from_fork</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up a thread for executing a new program</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">start_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load_addr</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* saved by ELF_PLAT_INIT */</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we exec out of a kernel thread then thread.regs will not be</span>
<span class="cm">	 * set.  Do it now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">task_stack_page</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">+</span> <span class="n">THREAD_SIZE</span><span class="p">;</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span> <span class="o">=</span> <span class="n">regs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">));</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ccr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have just cleared all the nonvolatile GPRs, so make</span>
<span class="cm">	 * FULL_REGS(regs) return true.  This is necessary to allow</span>
<span class="cm">	 * ptrace to examine the thread immediately after exec.</span>
<span class="cm">	 */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">trap</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">1UL</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC32</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">mq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">=</span> <span class="n">MSR_USER</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_32bit_task</span><span class="p">())</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entry</span><span class="p">,</span> <span class="n">toc</span><span class="p">;</span>

		<span class="cm">/* start is a relocated pointer to the function descriptor for</span>
<span class="cm">		 * the elf _start routine.  The first entry in the function</span>
<span class="cm">		 * descriptor is the entry address of _start and the second</span>
<span class="cm">		 * entry is the TOC value we need to use.</span>
<span class="cm">		 */</span>
		<span class="n">__get_user</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">start</span><span class="p">);</span>
		<span class="n">__get_user</span><span class="p">(</span><span class="n">toc</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Check whether the e_entry function descriptor entries</span>
<span class="cm">		 * need to be relocated before we can use them.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">load_addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">entry</span> <span class="o">+=</span> <span class="n">load_addr</span><span class="p">;</span>
			<span class="n">toc</span>   <span class="o">+=</span> <span class="n">load_addr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">toc</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">=</span> <span class="n">MSR_USER64</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">=</span> <span class="n">MSR_USER32</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">discard_lazy_cpu_state</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_VSX</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">used_vsr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpr</span><span class="p">));</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpscr</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ALTIVEC</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vr</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vscr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vscr</span><span class="p">));</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vscr</span><span class="p">.</span><span class="n">u</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00010000</span><span class="p">;</span> <span class="cm">/* Java mode disabled */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vrsave</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">used_vr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ALTIVEC */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_SPE</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">evr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">evr</span><span class="p">));</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">spefscr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">used_spe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SPE */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cp">#define PR_FP_ALL_EXCEPT (PR_FP_EXC_DIV | PR_FP_EXC_OVF | PR_FP_EXC_UND \</span>
<span class="cp">		| PR_FP_EXC_RES | PR_FP_EXC_INV)</span>

<span class="kt">int</span> <span class="nf">set_fpexc_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="p">;</span>

	<span class="cm">/* This is a bit hairy.  If we are an SPE enabled  processor</span>
<span class="cm">	 * (have embedded fp) we store the IEEE exception enable flags in</span>
<span class="cm">	 * fpexc_mode.  fpexc_mode is also used for setting FP exception</span>
<span class="cm">	 * mode (asyn, precise, disabled) for &#39;Classic&#39; FP. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">PR_FP_EXC_SW_ENABLE</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SPE</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_SPE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpexc_mode</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span>
				<span class="p">(</span><span class="n">PR_FP_EXC_SW_ENABLE</span> <span class="o">|</span> <span class="n">PR_FP_ALL_EXCEPT</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/* on a CONFIG_SPE this does not hurt us.  The bits that</span>
<span class="cm">	 * __pack_fe01 use do not overlap with bits used for</span>
<span class="cm">	 * PR_FP_EXC_SW_ENABLE.  Additionally, the MSR[FE0,FE1] bits</span>
<span class="cm">	 * on CONFIG_SPE implementations are reserved so writing to</span>
<span class="cm">	 * them does not change anything */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">PR_FP_EXC_PRECISE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpexc_mode</span> <span class="o">=</span> <span class="n">__pack_fe01</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_FP</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">=</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MSR_FE0</span><span class="o">|</span><span class="n">MSR_FE1</span><span class="p">))</span>
			<span class="o">|</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpexc_mode</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_fpexc_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpexc_mode</span> <span class="o">&amp;</span> <span class="n">PR_FP_EXC_SW_ENABLE</span><span class="p">)</span>
<span class="cp">#ifdef CONFIG_SPE</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_SPE</span><span class="p">))</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpexc_mode</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">else</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">__unpack_fe01</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpexc_mode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">adr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">set_endian</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">==</span> <span class="n">PR_ENDIAN_LITTLE</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_REAL_LE</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">PR_ENDIAN_PPC_LITTLE</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_PPC_LE</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">PR_ENDIAN_BIG</span><span class="p">)</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSR_LE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">PR_ENDIAN_LITTLE</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="n">PR_ENDIAN_PPC_LITTLE</span><span class="p">)</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">|=</span> <span class="n">MSR_LE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_endian</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_PPC_LE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_REAL_LE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_LE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_REAL_LE</span><span class="p">))</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">PR_ENDIAN_LITTLE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">PR_ENDIAN_PPC_LITTLE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">PR_ENDIAN_BIG</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">adr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">set_unalign_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">align_ctl</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_unalign_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">align_ctl</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">adr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define TRUNC_PTR(x)	((typeof(x))(((unsigned long)(x)) &amp; 0xffffffff))</span>

<span class="kt">int</span> <span class="nf">sys_clone</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">usp</span><span class="p">,</span>
	      <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">parent_tidp</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">child_threadptr</span><span class="p">,</span>
	      <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">child_tidp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p6</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">CHECK_FULL_REGS</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">usp</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* stack pointer for child */</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_32bit_task</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">parent_tidp</span> <span class="o">=</span> <span class="n">TRUNC_PTR</span><span class="p">(</span><span class="n">parent_tidp</span><span class="p">);</span>
		<span class="n">child_tidp</span> <span class="o">=</span> <span class="n">TRUNC_PTR</span><span class="p">(</span><span class="n">child_tidp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
 	<span class="k">return</span> <span class="n">do_fork</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">usp</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">parent_tidp</span><span class="p">,</span> <span class="n">child_tidp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sys_fork</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p3</span><span class="p">,</span>
	     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p4</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p5</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p6</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">CHECK_FULL_REGS</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">do_fork</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sys_vfork</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p3</span><span class="p">,</span>
	      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p4</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p5</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p6</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">CHECK_FULL_REGS</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">do_fork</span><span class="p">(</span><span class="n">CLONE_VFORK</span> <span class="o">|</span> <span class="n">CLONE_VM</span> <span class="o">|</span> <span class="n">SIGCHLD</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			<span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sys_execve</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a2</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a3</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a4</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a5</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>

	<span class="n">filename</span> <span class="o">=</span> <span class="n">getname</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">a0</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">flush_fp_to_thread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">flush_altivec_to_thread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">flush_spe_to_thread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">do_execve</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span>
			  <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="k">const</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">a1</span><span class="p">,</span>
			  <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="k">const</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">a2</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">valid_irq_stack</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nbytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Avoid crashing if the stack has overflowed and corrupted</span>
<span class="cm">	 * task_cpu(p), which is in the thread_info struct.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_possible</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">stack_page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">hardirq_ctx</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">&gt;=</span> <span class="n">stack_page</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_struct</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">sp</span> <span class="o">&lt;=</span> <span class="n">stack_page</span> <span class="o">+</span> <span class="n">THREAD_SIZE</span> <span class="o">-</span> <span class="n">nbytes</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">stack_page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">softirq_ctx</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">&gt;=</span> <span class="n">stack_page</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_struct</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">sp</span> <span class="o">&lt;=</span> <span class="n">stack_page</span> <span class="o">+</span> <span class="n">THREAD_SIZE</span> <span class="o">-</span> <span class="n">nbytes</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">validate_sp</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nbytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">task_stack_page</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">&gt;=</span> <span class="n">stack_page</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_struct</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="n">sp</span> <span class="o">&lt;=</span> <span class="n">stack_page</span> <span class="o">+</span> <span class="n">THREAD_SIZE</span> <span class="o">-</span> <span class="n">nbytes</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">valid_irq_stack</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">validate_sp</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_wchan</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="n">sp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="n">p</span> <span class="o">==</span> <span class="n">current</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_RUNNING</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">ksp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">validate_sp</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">STACK_FRAME_OVERHEAD</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">sp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">validate_sp</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">STACK_FRAME_OVERHEAD</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ip</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">sp</span><span class="p">)[</span><span class="n">STACK_FRAME_LR_SAVE</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_sched_functions</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">ip</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">kstack_depth_to_print</span> <span class="o">=</span> <span class="n">CONFIG_PRINT_STACK_DEPTH</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">show_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">stack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">lr</span><span class="p">,</span> <span class="n">newsp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">firstframe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
	<span class="kt">int</span> <span class="n">curr_frame</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">curr_ret_stack</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">return_to_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rth</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">return_to_handler</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mrth</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">mod_return_to_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="n">rth</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">rth</span><span class="p">;</span>
	<span class="n">mrth</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mod_return_to_handler</span><span class="p">;</span>
	<span class="n">mrth</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">mrth</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">stack</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span>
			<span class="n">asm</span><span class="p">(</span><span class="s">&quot;mr %0,1&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">sp</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">sp</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">ksp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Call Trace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">validate_sp</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="n">STACK_FRAME_OVERHEAD</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">stack</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">sp</span><span class="p">;</span>
		<span class="n">newsp</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">ip</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="n">STACK_FRAME_LR_SAVE</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firstframe</span> <span class="o">||</span> <span class="n">ip</span> <span class="o">!=</span> <span class="n">lr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;[&quot;</span><span class="n">REG</span><span class="s">&quot;] [&quot;</span><span class="n">REG</span><span class="s">&quot;] %pS&quot;</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ip</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ip</span> <span class="o">==</span> <span class="n">rth</span> <span class="o">||</span> <span class="n">ip</span> <span class="o">==</span> <span class="n">mrth</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">curr_frame</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot; (%pS)&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ret_stack</span><span class="p">[</span><span class="n">curr_frame</span><span class="p">].</span><span class="n">ret</span><span class="p">);</span>
				<span class="n">curr_frame</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">firstframe</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot; (unreliable)&quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">firstframe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * See if this is an exception frame.</span>
<span class="cm">		 * We look for the &quot;regshere&quot; marker in the current frame.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">validate_sp</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="n">STACK_INT_FRAME_SIZE</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">stack</span><span class="p">[</span><span class="n">STACK_FRAME_MARKER</span><span class="p">]</span> <span class="o">==</span> <span class="n">STACK_FRAME_REGS_MARKER</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span>
				<span class="p">(</span><span class="n">sp</span> <span class="o">+</span> <span class="n">STACK_FRAME_OVERHEAD</span><span class="p">);</span>
			<span class="n">lr</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;--- Exception: %lx at %pS</span><span class="se">\n</span><span class="s">    LR = %pS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">trap</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">lr</span><span class="p">);</span>
			<span class="n">firstframe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sp</span> <span class="o">=</span> <span class="n">newsp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">kstack_depth_to_print</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dump_stack</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">show_stack</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dump_stack</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cm">/* Called with hard IRQs off */</span>
<span class="kt">void</span> <span class="nf">__ppc64_runlatch_on</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">current_thread_info</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_CTRLF</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">CTRL_RUNLATCH</span><span class="p">;</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_CTRLT</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">local_flags</span> <span class="o">|=</span> <span class="n">_TLF_RUNLATCH</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Called with hard IRQs off */</span>
<span class="kt">void</span> <span class="nf">__ppc64_runlatch_off</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">current_thread_info</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">local_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_TLF_RUNLATCH</span><span class="p">;</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_CTRLF</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CTRL_RUNLATCH</span><span class="p">;</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_CTRLT</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">arch_align_stack</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">&amp;</span> <span class="n">ADDR_NO_RANDOMIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">randomize_va_space</span><span class="p">)</span>
		<span class="n">sp</span> <span class="o">-=</span> <span class="n">get_random_int</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">brk_rnd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* 8MB for 32bit, 1GB for 64bit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_32bit_task</span><span class="p">())</span>
		<span class="n">rnd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="n">get_random_int</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">23</span><span class="o">-</span><span class="n">PAGE_SHIFT</span><span class="p">)));</span>
	<span class="k">else</span>
		<span class="n">rnd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="n">get_random_int</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">30</span><span class="o">-</span><span class="n">PAGE_SHIFT</span><span class="p">)));</span>

	<span class="k">return</span> <span class="n">rnd</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">arch_randomize_brk</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC_STD_MMU_64</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we are using 1TB segments and we are allowed to randomise</span>
<span class="cm">	 * the heap, we can put it above 1TB so it is backed by a 1TB</span>
<span class="cm">	 * segment. Otherwise the heap will be in the bottom 1TB</span>
<span class="cm">	 * which always uses 256MB segments and this may result in a</span>
<span class="cm">	 * performance penalty.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_32bit_task</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mmu_highuser_ssize</span> <span class="o">==</span> <span class="n">MMU_SEGSIZE_1T</span><span class="p">))</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">,</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">SID_SHIFT_1T</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">brk_rnd</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">randomize_et_dyn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">brk_rnd</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">base</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">base</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
