<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › kernel › prom.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>prom.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Procedures for creating, accessing and interpreting the device tree.</span>
<span class="cm"> *</span>
<span class="cm"> * Paul Mackerras	August 1996.</span>
<span class="cm"> * Copyright (C) 1996-2005 Paul Mackerras.</span>
<span class="cm"> * </span>
<span class="cm"> *  Adapted for 64bit PowerPC by Dave Engebretsen and Peter Bergner.</span>
<span class="cm"> *    {engebret|bergner}@us.ibm.com </span>
<span class="cm"> *</span>
<span class="cm"> *      This program is free software; you can redistribute it and/or</span>
<span class="cm"> *      modify it under the terms of the GNU General Public License</span>
<span class="cm"> *      as published by the Free Software Foundation; either version</span>
<span class="cm"> *      2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#undef DEBUG</span>

<span class="cp">#include &lt;stdarg.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/stringify.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/initrd.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/kexec.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>

<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/rtas.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/kdump.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#include &lt;asm/mmu.h&gt;</span>
<span class="cp">#include &lt;asm/paca.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/pci.h&gt;</span>
<span class="cp">#include &lt;asm/iommu.h&gt;</span>
<span class="cp">#include &lt;asm/btext.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/pSeries_reconfig.h&gt;</span>
<span class="cp">#include &lt;asm/pci-bridge.h&gt;</span>
<span class="cp">#include &lt;asm/kexec.h&gt;</span>
<span class="cp">#include &lt;asm/opal.h&gt;</span>
<span class="cp">#include &lt;asm/fadump.h&gt;</span>

<span class="cp">#include &lt;mm/mmu_decl.h&gt;</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define DBG(fmt...) printk(KERN_ERR fmt)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG(fmt...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="kt">int</span> <span class="n">__initdata</span> <span class="n">iommu_is_off</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">__initdata</span> <span class="n">iommu_force_on</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tce_alloc_start</span><span class="p">,</span> <span class="n">tce_alloc_end</span><span class="p">;</span>
<span class="n">u64</span> <span class="n">ppc64_rma_size</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="n">phys_addr_t</span> <span class="n">first_memblock_size</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">boot_cpu_count</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_parse_mem</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">memory_limit</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">memparse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">));</span>
	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;memory limit = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">memory_limit</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;mem&quot;</span><span class="p">,</span> <span class="n">early_parse_mem</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * overlaps_initrd - check for overlap with page aligned extension of</span>
<span class="cm"> * initrd.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">overlaps_initrd</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">initrd_start</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span>	<span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_ALIGN_DOWN</span><span class="p">(</span><span class="n">initrd_start</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">start</span> <span class="o">&lt;=</span> <span class="n">_ALIGN_UP</span><span class="p">(</span><span class="n">initrd_end</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * move_device_tree - move tree to an unused area, if needed.</span>
<span class="cm"> *</span>
<span class="cm"> * The device tree may be allocated beyond our memory limit, or inside the</span>
<span class="cm"> * crash kernel region for kdump, or within the page aligned range of initrd.</span>
<span class="cm"> * If so, move it out of the way.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">move_device_tree</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;-&gt; move_device_tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">initial_boot_params</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">initial_boot_params</span><span class="o">-&gt;</span><span class="n">totalsize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">memory_limit</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">PHYSICAL_START</span> <span class="o">+</span> <span class="n">memory_limit</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">overlaps_crashkernel</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">overlaps_initrd</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">memblock_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">initial_boot_params</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">initial_boot_params</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">boot_param_header</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;Moved device tree to 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;&lt;- move_device_tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ibm,pa-features is a per-cpu property that contains a string of</span>
<span class="cm"> * attribute descriptors, each of which has a 2 byte header plus up</span>
<span class="cm"> * to 254 bytes worth of processor attribute bits.  First header</span>
<span class="cm"> * byte specifies the number of bytes following the header.</span>
<span class="cm"> * Second header byte is an &quot;attribute-specifier&quot; type, of which</span>
<span class="cm"> * zero is the only currently-defined value.</span>
<span class="cm"> * Implementation:  Pass in the byte and bit offset for the feature</span>
<span class="cm"> * that we are interested in.  The function will return -1 if the</span>
<span class="cm"> * pa-features property is missing, or a 1/0 to indicate if the feature</span>
<span class="cm"> * is supported/not supported.  Note that the bit numbers are</span>
<span class="cm"> * big-endian to match the definition in PAPR.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ibm_pa_feature</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">cpu_features</span><span class="p">;</span>	<span class="cm">/* CPU_FTR_xxx bit */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">mmu_features</span><span class="p">;</span>	<span class="cm">/* MMU_FTR_xxx bit */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">cpu_user_ftrs</span><span class="p">;</span>	<span class="cm">/* PPC_FEATURE_xxx bit */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">pabyte</span><span class="p">;</span>		<span class="cm">/* byte number in ibm,pa-features */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">pabit</span><span class="p">;</span>		<span class="cm">/* bit number (big-endian) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">invert</span><span class="p">;</span>		<span class="cm">/* if 1, pa bit set =&gt; clear feature */</span>
<span class="p">}</span> <span class="n">ibm_pa_features</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PPC_FEATURE_HAS_MMU</span><span class="p">,</span>	<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PPC_FEATURE_HAS_FPU</span><span class="p">,</span>	<span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="n">MMU_FTR_SLB</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>		<span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="n">CPU_FTR_CTRL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>		<span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="n">CPU_FTR_NOEXECUTE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>	<span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="n">CPU_FTR_NODSISRALIGN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>	<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="n">MMU_FTR_CI_LARGE_PAGE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>	<span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="n">CPU_FTR_REAL_LE</span><span class="p">,</span> <span class="n">PPC_FEATURE_TRUE_LE</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">scan_features</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ftrs</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tablelen</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ibm_pa_feature</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ft_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">bit</span><span class="p">;</span>

	<span class="cm">/* find descriptor with type == 0 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tablelen</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ftrs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tablelen</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>		<span class="cm">/* descriptor 0 not found */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ftrs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">tablelen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">ftrs</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* loop over bits we know about */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ft_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">pabyte</span> <span class="o">&gt;=</span> <span class="n">ftrs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">ftrs</span><span class="p">[</span><span class="mi">2</span> <span class="o">+</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">pabyte</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">7</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">pabit</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">^</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">invert</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cur_cpu_spec</span><span class="o">-&gt;</span><span class="n">cpu_features</span> <span class="o">|=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">cpu_features</span><span class="p">;</span>
			<span class="n">cur_cpu_spec</span><span class="o">-&gt;</span><span class="n">cpu_user_features</span> <span class="o">|=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">cpu_user_ftrs</span><span class="p">;</span>
			<span class="n">cur_cpu_spec</span><span class="o">-&gt;</span><span class="n">mmu_features</span> <span class="o">|=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">mmu_features</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cur_cpu_spec</span><span class="o">-&gt;</span><span class="n">cpu_features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">cpu_features</span><span class="p">;</span>
			<span class="n">cur_cpu_spec</span><span class="o">-&gt;</span><span class="n">cpu_user_features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">cpu_user_ftrs</span><span class="p">;</span>
			<span class="n">cur_cpu_spec</span><span class="o">-&gt;</span><span class="n">mmu_features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">mmu_features</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">check_cpu_pa_features</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pa_ftrs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tablelen</span><span class="p">;</span>

	<span class="n">pa_ftrs</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ibm,pa-features&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tablelen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pa_ftrs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">scan_features</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">pa_ftrs</span><span class="p">,</span> <span class="n">tablelen</span><span class="p">,</span>
		      <span class="n">ibm_pa_features</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ibm_pa_features</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC_STD_MMU_64</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">check_cpu_slb_size</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">slb_size_ptr</span><span class="p">;</span>

	<span class="n">slb_size_ptr</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;slb-size&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slb_size_ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mmu_slb_size</span> <span class="o">=</span> <span class="o">*</span><span class="n">slb_size_ptr</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">slb_size_ptr</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ibm,slb-size&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slb_size_ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mmu_slb_size</span> <span class="o">=</span> <span class="o">*</span><span class="n">slb_size_ptr</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define check_cpu_slb_size(node) do { } while(0)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">feature_property</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">min_value</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu_feature</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu_user_ftr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">feature_properties</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_ALTIVEC</span>
	<span class="p">{</span><span class="s">&quot;altivec&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CPU_FTR_ALTIVEC</span><span class="p">,</span> <span class="n">PPC_FEATURE_HAS_ALTIVEC</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;ibm,vmx&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">CPU_FTR_ALTIVEC</span><span class="p">,</span> <span class="n">PPC_FEATURE_HAS_ALTIVEC</span><span class="p">},</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ALTIVEC */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_VSX</span>
	<span class="cm">/* Yes, this _really_ is ibm,vmx == 2 to enable VSX */</span>
	<span class="p">{</span><span class="s">&quot;ibm,vmx&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">CPU_FTR_VSX</span><span class="p">,</span> <span class="n">PPC_FEATURE_HAS_VSX</span><span class="p">},</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_VSX */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="p">{</span><span class="s">&quot;ibm,dfp&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PPC_FEATURE_HAS_DFP</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;ibm,purr&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">CPU_FTR_PURR</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;ibm,spurr&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">CPU_FTR_SPURR</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>
<span class="p">};</span>

<span class="cp">#if defined(CONFIG_44x) &amp;&amp; defined(CONFIG_PPC_FPU)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">identical_pvr_fixup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pvr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">model</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;model&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since 440GR(x)/440EP(x) processors have the same pvr,</span>
<span class="cm">	 * we check the node path and set bit 28 in the cur_cpu_spec</span>
<span class="cm">	 * pvr for EP(x) processor version. This bit is always 0 in</span>
<span class="cm">	 * the &quot;real&quot; pvr. Then we call identify_cpu again with</span>
<span class="cm">	 * the new logical pvr to enable FPU support.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">model</span> <span class="o">&amp;&amp;</span> <span class="n">strstr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s">&quot;440EP&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pvr</span> <span class="o">=</span> <span class="n">cur_cpu_spec</span><span class="o">-&gt;</span><span class="n">pvr_value</span> <span class="o">|</span> <span class="mh">0x8</span><span class="p">;</span>
		<span class="n">identify_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pvr</span><span class="p">);</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;Using logical pvr %x for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvr</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define identical_pvr_fixup(node) do { } while(0)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">check_cpu_feature_properties</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">feature_property</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">feature_properties</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">feature_properties</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prop</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prop</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">prop</span> <span class="o">&gt;=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">min_value</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cur_cpu_spec</span><span class="o">-&gt;</span><span class="n">cpu_features</span> <span class="o">|=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">cpu_feature</span><span class="p">;</span>
			<span class="n">cur_cpu_spec</span><span class="o">-&gt;</span><span class="n">cpu_user_features</span> <span class="o">|=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">cpu_user_ftr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_init_dt_scan_cpus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;device_type&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">intserv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nthreads</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found_thread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* We are scanning &quot;cpu&quot; nodes only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Get physical cpuid */</span>
	<span class="n">intserv</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ibm,ppc-interrupt-server#s&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intserv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nthreads</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">intserv</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">nthreads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now see if any of these threads match our boot cpu.</span>
<span class="cm">	 * NOTE: This must match the parsing done in smp_setup_cpu_maps.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * version 2 of the kexec param format adds the phys cpuid of</span>
<span class="cm">		 * booted proc.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">initial_boot_params</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">intserv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">initial_boot_params</span><span class="o">-&gt;</span><span class="n">boot_cpuid_phys</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="n">boot_cpu_count</span><span class="p">;</span>
				<span class="n">found_thread</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Check if it&#39;s the boot-cpu, set it&#39;s hw index now,</span>
<span class="cm">			 * unfortunately this format did not support booting</span>
<span class="cm">			 * off secondary threads.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
					<span class="s">&quot;linux,boot-cpu&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">found</span> <span class="o">=</span> <span class="n">boot_cpu_count</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#ifdef CONFIG_SMP</span>
		<span class="cm">/* logical cpu id is always 0 on UP kernels */</span>
		<span class="n">boot_cpu_count</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;boot cpu: logical %d physical %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span>
			<span class="n">intserv</span><span class="p">[</span><span class="n">found_thread</span><span class="p">]);</span>
		<span class="n">boot_cpuid</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
		<span class="n">set_hard_smp_processor_id</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">intserv</span><span class="p">[</span><span class="n">found_thread</span><span class="p">]);</span>

		<span class="cm">/*</span>
<span class="cm">		 * PAPR defines &quot;logical&quot; PVR values for cpus that</span>
<span class="cm">		 * meet various levels of the architecture:</span>
<span class="cm">		 * 0x0f000001	Architecture version 2.04</span>
<span class="cm">		 * 0x0f000002	Architecture version 2.05</span>
<span class="cm">		 * If the cpu-version property in the cpu node contains</span>
<span class="cm">		 * such a value, we call identify_cpu again with the</span>
<span class="cm">		 * logical PVR value in order to use the cpu feature</span>
<span class="cm">		 * bits appropriate for the architecture level.</span>
<span class="cm">		 *</span>
<span class="cm">		 * A POWER6 partition in &quot;POWER6 architected&quot; mode</span>
<span class="cm">		 * uses the 0x0f000002 PVR value; in POWER5+ mode</span>
<span class="cm">		 * it uses 0x0f000001.</span>
<span class="cm">		 */</span>
		<span class="n">prop</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;cpu-version&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prop</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">prop</span> <span class="o">&amp;</span> <span class="mh">0xff000000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0f000000</span><span class="p">)</span>
			<span class="n">identify_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">prop</span><span class="p">);</span>

		<span class="n">identical_pvr_fixup</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">check_cpu_feature_properties</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="n">check_cpu_pa_features</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="n">check_cpu_slb_size</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC_PSERIES</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nthreads</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">cur_cpu_spec</span><span class="o">-&gt;</span><span class="n">cpu_features</span> <span class="o">|=</span> <span class="n">CPU_FTR_SMT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cur_cpu_spec</span><span class="o">-&gt;</span><span class="n">cpu_features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CPU_FTR_SMT</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_init_dt_scan_chosen_ppc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uname</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">lprop</span><span class="p">;</span>

	<span class="cm">/* Use common scan routine to determine if this is the chosen node */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">early_init_dt_scan_chosen</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">uname</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="cm">/* check if iommu is forced on or off */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;linux,iommu-off&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">iommu_is_off</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;linux,iommu-force-on&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">iommu_force_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* mem=x on the command line is the preferred mechanism */</span>
	<span class="n">lprop</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;linux,memory-limit&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprop</span><span class="p">)</span>
		<span class="n">memory_limit</span> <span class="o">=</span> <span class="o">*</span><span class="n">lprop</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="n">lprop</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;linux,tce-alloc-start&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprop</span><span class="p">)</span>
		<span class="n">tce_alloc_start</span> <span class="o">=</span> <span class="o">*</span><span class="n">lprop</span><span class="p">;</span>
	<span class="n">lprop</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;linux,tce-alloc-end&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprop</span><span class="p">)</span>
		<span class="n">tce_alloc_end</span> <span class="o">=</span> <span class="o">*</span><span class="n">lprop</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_KEXEC</span>
	<span class="n">lprop</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;linux,crashkernel-base&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprop</span><span class="p">)</span>
		<span class="n">crashk_res</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="o">*</span><span class="n">lprop</span><span class="p">;</span>

	<span class="n">lprop</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;linux,crashkernel-size&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprop</span><span class="p">)</span>
		<span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="o">*</span><span class="n">lprop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* break now */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC_PSERIES</span>
<span class="cm">/*</span>
<span class="cm"> * Interpret the ibm,dynamic-memory property in the</span>
<span class="cm"> * /ibm,dynamic-reconfiguration-memory node.</span>
<span class="cm"> * This contains a list of memory blocks along with NUMA affinity</span>
<span class="cm"> * information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_init_dt_scan_drconf_memory</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">dm</span><span class="p">,</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="o">*</span><span class="n">usm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">memblock_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_kexec_kdump</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rngs</span><span class="p">;</span>

	<span class="n">ls</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ibm,lmb-size&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ls</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">dt_root_size_cells</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be32</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memblock_size</span> <span class="o">=</span> <span class="n">dt_mem_next_cell</span><span class="p">(</span><span class="n">dt_root_size_cells</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="p">);</span>

	<span class="n">dm</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ibm,dynamic-memory&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dm</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be32</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">dm</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* number of entries */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">dt_root_addr_cells</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be32</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* check if this is a kexec/kdump kernel. */</span>
	<span class="n">usm</span> <span class="o">=</span> <span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;linux,drconf-usable-memory&quot;</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usm</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">is_kexec_kdump</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">dt_mem_next_cell</span><span class="p">(</span><span class="n">dt_root_addr_cells</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dm</span><span class="p">);</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">dm</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="cm">/* skip DRC index, pad, assoc. list index, flags */</span>
		<span class="n">dm</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="cm">/* skip this block if the reserved bit is set in flags (0x80)</span>
<span class="cm">		   or if the block is not assigned to this partition (0x8) */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">memblock_size</span><span class="p">;</span>
		<span class="n">rngs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_kexec_kdump</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * For each memblock in ibm,dynamic-memory, a corresponding</span>
<span class="cm">			 * entry in linux,drconf-usable-memory property contains</span>
<span class="cm">			 * a counter &#39;p&#39; followed by &#39;p&#39; (base, size) duple.</span>
<span class="cm">			 * Now read the counter from</span>
<span class="cm">			 * linux,drconf-usable-memory property</span>
<span class="cm">			 */</span>
			<span class="n">rngs</span> <span class="o">=</span> <span class="n">dt_mem_next_cell</span><span class="p">(</span><span class="n">dt_root_size_cells</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rngs</span><span class="p">)</span> <span class="cm">/* there are no (base, size) duple */</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_kexec_kdump</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">base</span> <span class="o">=</span> <span class="n">dt_mem_next_cell</span><span class="p">(</span><span class="n">dt_root_addr_cells</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">usm</span><span class="p">);</span>
				<span class="n">size</span> <span class="o">=</span> <span class="n">dt_mem_next_cell</span><span class="p">(</span><span class="n">dt_root_size_cells</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">usm</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iommu_is_off</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&gt;=</span> <span class="mh">0x80000000ul</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">base</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mh">0x80000000ul</span><span class="p">)</span>
					<span class="n">size</span> <span class="o">=</span> <span class="mh">0x80000000ul</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">memblock_add</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">rngs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memblock_dump_all</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define early_init_dt_scan_drconf_memory(node)	0</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC_PSERIES */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_init_dt_scan_memory_ppc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">,</span>
						<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uname</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">strcmp</span><span class="p">(</span><span class="n">uname</span><span class="p">,</span> <span class="s">&quot;ibm,dynamic-reconfiguration-memory&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">early_init_dt_scan_drconf_memory</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">early_init_dt_scan_memory</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">uname</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">early_init_dt_add_memory_arch</span><span class="p">(</span><span class="n">u64</span> <span class="n">base</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iommu_is_off</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&gt;=</span> <span class="mh">0x80000000ul</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">base</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mh">0x80000000ul</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="mh">0x80000000ul</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/* Keep track of the beginning of memory -and- the size of</span>
<span class="cm">	 * the very first block in the device-tree as it represents</span>
<span class="cm">	 * the RMA on ppc64 server</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&lt;</span> <span class="n">memstart_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memstart_addr</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
		<span class="n">first_memblock_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Add the chunk to the MEMBLOCK list */</span>
	<span class="n">memblock_add</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">early_init_dt_alloc_memory_arch</span><span class="p">(</span><span class="n">u64</span> <span class="n">size</span><span class="p">,</span> <span class="n">u64</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__va</span><span class="p">(</span><span class="n">memblock_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">early_init_dt_setup_initrd_arch</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">initrd_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="n">initrd_end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>
	<span class="n">initrd_below_start_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">early_reserve_mem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">reserve_map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">self_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">self_size</span><span class="p">;</span>

	<span class="n">reserve_map</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">initial_boot_params</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">initial_boot_params</span><span class="o">-&gt;</span><span class="n">off_mem_rsvmap</span><span class="p">);</span>

	<span class="cm">/* before we do anything, lets reserve the dt blob */</span>
	<span class="n">self_base</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">initial_boot_params</span><span class="p">);</span>
	<span class="n">self_size</span> <span class="o">=</span> <span class="n">initial_boot_params</span><span class="o">-&gt;</span><span class="n">totalsize</span><span class="p">;</span>
	<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">self_base</span><span class="p">,</span> <span class="n">self_size</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
	<span class="cm">/* then reserve the initrd, if any */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">initrd_start</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">initrd_end</span> <span class="o">&gt;</span> <span class="n">initrd_start</span><span class="p">))</span>
		<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">_ALIGN_DOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">initrd_start</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">),</span>
			<span class="n">_ALIGN_UP</span><span class="p">(</span><span class="n">initrd_end</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">_ALIGN_DOWN</span><span class="p">(</span><span class="n">initrd_start</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_BLK_DEV_INITRD */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PPC32</span>
	<span class="cm">/* </span>
<span class="cm">	 * Handle the case where we might be booting from an old kexec</span>
<span class="cm">	 * image that setup the mem_rsvmap as pairs of 32-bit values</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">reserve_map</span> <span class="o">&gt;</span> <span class="mh">0xffffffffull</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">base_32</span><span class="p">,</span> <span class="n">size_32</span><span class="p">;</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">reserve_map_32</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">reserve_map</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">base_32</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">reserve_map_32</span><span class="o">++</span><span class="p">);</span>
			<span class="n">size_32</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">reserve_map_32</span><span class="o">++</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size_32</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* skip if the reservation is for the blob */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">base_32</span> <span class="o">==</span> <span class="n">self_base</span> <span class="o">&amp;&amp;</span> <span class="n">size_32</span> <span class="o">==</span> <span class="n">self_size</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;reserving: %x -&gt; %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">base_32</span><span class="p">,</span> <span class="n">size_32</span><span class="p">);</span>
			<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">base_32</span><span class="p">,</span> <span class="n">size_32</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">base</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">reserve_map</span><span class="o">++</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">reserve_map</span><span class="o">++</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;reserving: %llx -&gt; %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">early_init_devtree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phys_addr_t</span> <span class="n">limit</span><span class="p">;</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot; -&gt; early_init_devtree(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">);</span>

	<span class="cm">/* Setup flat device-tree pointer */</span>
	<span class="n">initial_boot_params</span> <span class="o">=</span> <span class="n">params</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC_RTAS</span>
	<span class="cm">/* Some machines might need RTAS info for debugging, grab it now. */</span>
	<span class="n">of_scan_flat_dt</span><span class="p">(</span><span class="n">early_init_dt_scan_rtas</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PPC_POWERNV</span>
	<span class="cm">/* Some machines might need OPAL info for debugging, grab it now. */</span>
	<span class="n">of_scan_flat_dt</span><span class="p">(</span><span class="n">early_init_dt_scan_opal</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_FA_DUMP</span>
	<span class="cm">/* scan tree to see if dump is active during last boot */</span>
	<span class="n">of_scan_flat_dt</span><span class="p">(</span><span class="n">early_init_dt_scan_fw_dump</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Pre-initialize the cmd_line with the content of boot_commmand_line,</span>
<span class="cm">	 * which will be empty except when the content of the variable has</span>
<span class="cm">	 * been overriden by a bootloading mechanism. This happens typically</span>
<span class="cm">	 * with HAL takeover</span>
<span class="cm">	 */</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">cmd_line</span><span class="p">,</span> <span class="n">boot_command_line</span><span class="p">,</span> <span class="n">COMMAND_LINE_SIZE</span><span class="p">);</span>

	<span class="cm">/* Retrieve various informations from the /chosen node of the</span>
<span class="cm">	 * device-tree, including the platform type, initrd location and</span>
<span class="cm">	 * size, TCE reserve, and more ...</span>
<span class="cm">	 */</span>
	<span class="n">of_scan_flat_dt</span><span class="p">(</span><span class="n">early_init_dt_scan_chosen_ppc</span><span class="p">,</span> <span class="n">cmd_line</span><span class="p">);</span>

	<span class="cm">/* Scan memory nodes and rebuild MEMBLOCKs */</span>
	<span class="n">of_scan_flat_dt</span><span class="p">(</span><span class="n">early_init_dt_scan_root</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">of_scan_flat_dt</span><span class="p">(</span><span class="n">early_init_dt_scan_memory_ppc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Save command line for /proc/cmdline and then parse parameters */</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">boot_command_line</span><span class="p">,</span> <span class="n">cmd_line</span><span class="p">,</span> <span class="n">COMMAND_LINE_SIZE</span><span class="p">);</span>
	<span class="n">parse_early_param</span><span class="p">();</span>

	<span class="cm">/* make sure we&#39;ve parsed cmdline for mem= before this */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memory_limit</span><span class="p">)</span>
		<span class="n">first_memblock_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">first_memblock_size</span><span class="p">,</span> <span class="n">memory_limit</span><span class="p">);</span>
	<span class="n">setup_initial_memory_limit</span><span class="p">(</span><span class="n">memstart_addr</span><span class="p">,</span> <span class="n">first_memblock_size</span><span class="p">);</span>
	<span class="cm">/* Reserve MEMBLOCK regions used by kernel, initrd, dt, etc... */</span>
	<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">PHYSICAL_START</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">klimit</span><span class="p">)</span> <span class="o">-</span> <span class="n">PHYSICAL_START</span><span class="p">);</span>
	<span class="cm">/* If relocatable, reserve first 32k for interrupt vectors etc. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PHYSICAL_START</span> <span class="o">&gt;</span> <span class="n">MEMORY_START</span><span class="p">)</span>
		<span class="n">memblock_reserve</span><span class="p">(</span><span class="n">MEMORY_START</span><span class="p">,</span> <span class="mh">0x8000</span><span class="p">);</span>
	<span class="n">reserve_kdump_trampoline</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_FA_DUMP</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we fail to reserve memory for firmware-assisted dump then</span>
<span class="cm">	 * fallback to kexec based kdump.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fadump_reserve_mem</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="cp">#endif</span>
		<span class="n">reserve_crashkernel</span><span class="p">();</span>
	<span class="n">early_reserve_mem</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that total memory size is page-aligned, because otherwise</span>
<span class="cm">	 * mark_bootmem() gets upset.</span>
<span class="cm">	 */</span>
	<span class="n">limit</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">memory_limit</span> <span class="o">?:</span> <span class="n">memblock_phys_mem_size</span><span class="p">(),</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">memblock_enforce_memory_limit</span><span class="p">(</span><span class="n">limit</span><span class="p">);</span>

	<span class="n">memblock_allow_resize</span><span class="p">();</span>
	<span class="n">memblock_dump_all</span><span class="p">();</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;Phys. mem: %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">memblock_phys_mem_size</span><span class="p">());</span>

	<span class="cm">/* We may need to relocate the flat tree, do it now.</span>
<span class="cm">	 * FIXME .. and the initrd too? */</span>
	<span class="n">move_device_tree</span><span class="p">();</span>

	<span class="n">allocate_pacas</span><span class="p">();</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;Scanning CPUs ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Retrieve CPU related informations from the flat tree</span>
<span class="cm">	 * (altivec support, boot CPU ID, ...)</span>
<span class="cm">	 */</span>
	<span class="n">of_scan_flat_dt</span><span class="p">(</span><span class="n">early_init_dt_scan_cpus</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_SMP) &amp;&amp; defined(CONFIG_PPC64)</span>
	<span class="cm">/* We&#39;ll later wait for secondaries to check in; there are</span>
<span class="cm">	 * NCPUS-1 non-boot CPUs  :-)</span>
<span class="cm">	 */</span>
	<span class="n">spinning_secondaries</span> <span class="o">=</span> <span class="n">boot_cpu_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot; &lt;- early_init_devtree()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******</span>
<span class="cm"> *</span>
<span class="cm"> * New implementation of the OF &quot;find&quot; APIs, return a refcounted</span>
<span class="cm"> * object, call of_node_put() when done.  The device tree and list</span>
<span class="cm"> * are protected by a rw_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that property management will need some locking as well,</span>
<span class="cm"> * this isn&#39;t dealt with yet.</span>
<span class="cm"> *</span>
<span class="cm"> *******/</span>

<span class="cm">/**</span>
<span class="cm"> *	of_find_next_cache_node - Find a node&#39;s subsidiary cache</span>
<span class="cm"> *	@np:	node of type &quot;cpu&quot; or &quot;cache&quot;</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a node pointer with refcount incremented, use</span>
<span class="cm"> *	of_node_put() on it when done.  Caller should hold a reference</span>
<span class="cm"> *	to np.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_find_next_cache_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">phandle</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;l2-cache&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span>
		<span class="n">handle</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;next-level-cache&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">of_find_node_by_phandle</span><span class="p">(</span><span class="o">*</span><span class="n">handle</span><span class="p">);</span>

	<span class="cm">/* OF on pmac has nodes instead of properties named &quot;l2-cache&quot;</span>
<span class="cm">	 * beneath CPU nodes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">))</span>
		<span class="n">for_each_child_of_node</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;cache&quot;</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">child</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC_PSERIES</span>
<span class="cm">/*</span>
<span class="cm"> * Fix up the uninitialized fields in a new device node:</span>
<span class="cm"> * name, type and pci-specific fields</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">of_finish_dynamic_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">of_get_parent</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">phandle</span> <span class="o">*</span><span class="n">ibm_phandle</span><span class="p">;</span>

	<span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;device_type&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&lt;NULL&gt;&quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="s">&quot;&lt;NULL&gt;&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We don&#39;t support that function on PowerMac, at least</span>
<span class="cm">	 * not yet</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">machine_is</span><span class="p">(</span><span class="n">powermac</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* fix up new node&#39;s phandle field */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ibm_phandle</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ibm,phandle&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)))</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">phandle</span> <span class="o">=</span> <span class="o">*</span><span class="n">ibm_phandle</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">prom_reconfig_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PSERIES_RECONFIG_ADD</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">of_finish_dynamic_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;finish_node returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">prom_reconfig_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">prom_reconfig_notifier</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="cm">/* This one needs to run first */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">prom_reconfig_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pSeries_reconfig_notifier_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prom_reconfig_nb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">prom_reconfig_setup</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Find the device node for a given logical cpu number, also returns the cpu</span>
<span class="cm"> * local thread number (index in ibm,interrupt-server#s) if relevant and</span>
<span class="cm"> * asked for (non NULL)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_get_cpu_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="kr">thread</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">hardid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>

	<span class="n">hardid</span> <span class="o">=</span> <span class="n">get_hard_smp_processor_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">for_each_node_by_type</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">intserv</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plen</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>

		<span class="cm">/* Check for ibm,ppc-interrupt-server#s. If it doesn&#39;t exist</span>
<span class="cm">		 * fallback to &quot;reg&quot; property and assume no threads</span>
<span class="cm">		 */</span>
		<span class="n">intserv</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;ibm,ppc-interrupt-server#s&quot;</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">plen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intserv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">reg</span> <span class="o">==</span> <span class="n">hardid</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="kr">thread</span><span class="p">)</span>
					<span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">np</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">plen</span> <span class="o">/=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">plen</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">hardid</span> <span class="o">==</span> <span class="n">intserv</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="kr">thread</span><span class="p">)</span>
						<span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
					<span class="k">return</span> <span class="n">np</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_get_cpu_node</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_DEBUG_FS) &amp;&amp; defined(DEBUG)</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">debugfs_blob_wrapper</span> <span class="n">flat_dt_blob</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">export_flat_device_tree</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>

	<span class="n">flat_dt_blob</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">initial_boot_params</span><span class="p">;</span>
	<span class="n">flat_dt_blob</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">initial_boot_params</span><span class="o">-&gt;</span><span class="n">totalsize</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">debugfs_create_blob</span><span class="p">(</span><span class="s">&quot;flat-device-tree&quot;</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="n">S_IRUSR</span><span class="p">,</span>
				<span class="n">powerpc_debugfs_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flat_dt_blob</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">export_flat_device_tree</span><span class="p">);</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
