<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › kernel › lparcfg.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>lparcfg.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * PowerPC64 LPAR Configuration Information Driver</span>
<span class="cm"> *</span>
<span class="cm"> * Dave Engebretsen engebret@us.ibm.com</span>
<span class="cm"> *    Copyright (c) 2003 Dave Engebretsen</span>
<span class="cm"> * Will Schmidt willschm@us.ibm.com</span>
<span class="cm"> *    SPLPAR updates, Copyright (c) 2003 Will Schmidt IBM Corporation.</span>
<span class="cm"> *    seq_file updates, Copyright (c) 2004 Will Schmidt IBM Corporation.</span>
<span class="cm"> * Nathan Lynch nathanl@austin.ibm.com</span>
<span class="cm"> *    Added lparcfg_write, Copyright (C) 2004 Nathan Lynch IBM Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> *      This program is free software; you can redistribute it and/or</span>
<span class="cm"> *      modify it under the terms of the GNU General Public License</span>
<span class="cm"> *      as published by the Free Software Foundation; either version</span>
<span class="cm"> *      2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver creates a proc file at /proc/ppc64/lparcfg which contains</span>
<span class="cm"> * keyword - value pairs that specify the configuration of the partition.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/lppaca.h&gt;</span>
<span class="cp">#include &lt;asm/hvcall.h&gt;</span>
<span class="cp">#include &lt;asm/firmware.h&gt;</span>
<span class="cp">#include &lt;asm/rtas.h&gt;</span>
<span class="cp">#include &lt;asm/time.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/vdso_datapage.h&gt;</span>
<span class="cp">#include &lt;asm/vio.h&gt;</span>
<span class="cp">#include &lt;asm/mmu.h&gt;</span>

<span class="cp">#define MODULE_VERS &quot;1.9&quot;</span>
<span class="cp">#define MODULE_NAME &quot;lparcfg&quot;</span>

<span class="cm">/* #define LPARCFG_DEBUG */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc_ppc64_lparcfg</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Track sum of all purrs across all processors. This is used to further</span>
<span class="cm"> * calculate usage values by different applications</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_purr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sum_purr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_usage</span> <span class="o">*</span><span class="n">cu</span><span class="p">;</span>

		<span class="n">cu</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_usage_array</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">sum_purr</span> <span class="o">+=</span> <span class="n">cu</span><span class="o">-&gt;</span><span class="n">current_tb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sum_purr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Methods used to fetch LPAR data when running on a pSeries platform.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">hvcall_ppp_data</span> <span class="p">{</span>
	<span class="n">u64</span>	<span class="n">entitlement</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">unallocated_entitlement</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">group_num</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">pool_num</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">capped</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">weight</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">unallocated_weight</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">active_procs_in_pool</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">active_system_procs</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">phys_platform_procs</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">max_proc_cap_avail</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">entitled_proc_cap_avail</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * H_GET_PPP hcall returns info in 4 parms.</span>
<span class="cm"> *  entitled_capacity,unallocated_capacity,</span>
<span class="cm"> *  aggregation, resource_capability).</span>
<span class="cm"> *</span>
<span class="cm"> *  R4 = Entitled Processor Capacity Percentage.</span>
<span class="cm"> *  R5 = Unallocated Processor Capacity Percentage.</span>
<span class="cm"> *  R6 (AABBCCDDEEFFGGHH).</span>
<span class="cm"> *      XXXX - reserved (0)</span>
<span class="cm"> *          XXXX - reserved (0)</span>
<span class="cm"> *              XXXX - Group Number</span>
<span class="cm"> *                  XXXX - Pool Number.</span>
<span class="cm"> *  R7 (IIJJKKLLMMNNOOPP).</span>
<span class="cm"> *      XX - reserved. (0)</span>
<span class="cm"> *        XX - bit 0-6 reserved (0).   bit 7 is Capped indicator.</span>
<span class="cm"> *          XX - variable processor Capacity Weight</span>
<span class="cm"> *            XX - Unallocated Variable Processor Capacity Weight.</span>
<span class="cm"> *              XXXX - Active processors in Physical Processor Pool.</span>
<span class="cm"> *                  XXXX  - Processors active on platform.</span>
<span class="cm"> *  R8 (QQQQRRRRRRSSSSSS). if ibm,partition-performance-parameters-level &gt;= 1</span>
<span class="cm"> *	XXXX - Physical platform procs allocated to virtualization.</span>
<span class="cm"> *	    XXXXXX - Max procs capacity % available to the partitions pool.</span>
<span class="cm"> *	          XXXXXX - Entitled procs capacity % available to the</span>
<span class="cm"> *			   partitions pool.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">h_get_ppp</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvcall_ppp_data</span> <span class="o">*</span><span class="n">ppp_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">retbuf</span><span class="p">[</span><span class="n">PLPAR_HCALL9_BUFSIZE</span><span class="p">];</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">plpar_hcall9</span><span class="p">(</span><span class="n">H_GET_PPP</span><span class="p">,</span> <span class="n">retbuf</span><span class="p">);</span>

	<span class="n">ppp_data</span><span class="o">-&gt;</span><span class="n">entitlement</span> <span class="o">=</span> <span class="n">retbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ppp_data</span><span class="o">-&gt;</span><span class="n">unallocated_entitlement</span> <span class="o">=</span> <span class="n">retbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">ppp_data</span><span class="o">-&gt;</span><span class="n">group_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">retbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">ppp_data</span><span class="o">-&gt;</span><span class="n">pool_num</span> <span class="o">=</span> <span class="n">retbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>

	<span class="n">ppp_data</span><span class="o">-&gt;</span><span class="n">capped</span> <span class="o">=</span> <span class="p">(</span><span class="n">retbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="n">ppp_data</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="p">(</span><span class="n">retbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">ppp_data</span><span class="o">-&gt;</span><span class="n">unallocated_weight</span> <span class="o">=</span> <span class="p">(</span><span class="n">retbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">ppp_data</span><span class="o">-&gt;</span><span class="n">active_procs_in_pool</span> <span class="o">=</span> <span class="p">(</span><span class="n">retbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">ppp_data</span><span class="o">-&gt;</span><span class="n">active_system_procs</span> <span class="o">=</span> <span class="n">retbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>

	<span class="n">ppp_data</span><span class="o">-&gt;</span><span class="n">phys_platform_procs</span> <span class="o">=</span> <span class="n">retbuf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">ppp_data</span><span class="o">-&gt;</span><span class="n">max_proc_cap_avail</span> <span class="o">=</span> <span class="p">(</span><span class="n">retbuf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">;</span>
	<span class="n">ppp_data</span><span class="o">-&gt;</span><span class="n">entitled_proc_cap_avail</span> <span class="o">=</span> <span class="n">retbuf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">h_pic</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pool_idle_time</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">num_procs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">retbuf</span><span class="p">[</span><span class="n">PLPAR_HCALL_BUFSIZE</span><span class="p">];</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">plpar_hcall</span><span class="p">(</span><span class="n">H_PIC</span><span class="p">,</span> <span class="n">retbuf</span><span class="p">);</span>

	<span class="o">*</span><span class="n">pool_idle_time</span> <span class="o">=</span> <span class="n">retbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="o">*</span><span class="n">num_procs</span> <span class="o">=</span> <span class="n">retbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * parse_ppp_data</span>
<span class="cm"> * Parse out the data returned from h_get_ppp and h_pic</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parse_ppp_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcall_ppp_data</span> <span class="n">ppp_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">perf_level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">h_get_ppp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppp_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;partition_entitled_capacity=%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	           <span class="n">ppp_data</span><span class="p">.</span><span class="n">entitlement</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;group=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ppp_data</span><span class="p">.</span><span class="n">group_num</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;system_active_processors=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	           <span class="n">ppp_data</span><span class="p">.</span><span class="n">active_system_procs</span><span class="p">);</span>

	<span class="cm">/* pool related entries are appropriate for shared configs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lppaca_of</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">shared_proc</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pool_idle_time</span><span class="p">,</span> <span class="n">pool_procs</span><span class="p">;</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pool=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ppp_data</span><span class="p">.</span><span class="n">pool_num</span><span class="p">);</span>

		<span class="cm">/* report pool_capacity in percentage */</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pool_capacity=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">ppp_data</span><span class="p">.</span><span class="n">active_procs_in_pool</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>

		<span class="n">h_pic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool_idle_time</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool_procs</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pool_idle_time=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pool_idle_time</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pool_num_procs=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pool_procs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;unallocated_capacity_weight=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">ppp_data</span><span class="p">.</span><span class="n">unallocated_weight</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;capacity_weight=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ppp_data</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;capped=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ppp_data</span><span class="p">.</span><span class="n">capped</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;unallocated_capacity=%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">ppp_data</span><span class="p">.</span><span class="n">unallocated_entitlement</span><span class="p">);</span>

	<span class="cm">/* The last bits of information returned from h_get_ppp are only</span>
<span class="cm">	 * valid if the ibm,partition-performance-parameters-level</span>
<span class="cm">	 * property is &gt;= 1.</span>
<span class="cm">	 */</span>
	<span class="n">root</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perf_level</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">root</span><span class="p">,</span>
				<span class="s">&quot;ibm,partition-performance-parameters-level&quot;</span><span class="p">,</span>
					     <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">perf_level</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">perf_level</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
			    <span class="s">&quot;physical_procs_allocated_to_virtualization=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">ppp_data</span><span class="p">.</span><span class="n">phys_platform_procs</span><span class="p">);</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;max_proc_capacity_available=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">ppp_data</span><span class="p">.</span><span class="n">max_proc_cap_avail</span><span class="p">);</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;entitled_proc_capacity_available=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">ppp_data</span><span class="p">.</span><span class="n">entitled_proc_cap_avail</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">of_node_put</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parse_mpp_data</span>
<span class="cm"> * Parse out data returned from h_get_mpp</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parse_mpp_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcall_mpp_data</span> <span class="n">mpp_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">h_get_mpp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpp_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;entitled_memory=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mpp_data</span><span class="p">.</span><span class="n">entitled_mem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mpp_data</span><span class="p">.</span><span class="n">mapped_mem</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;mapped_entitled_memory=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		           <span class="n">mpp_data</span><span class="p">.</span><span class="n">mapped_mem</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;entitled_memory_group_number=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mpp_data</span><span class="p">.</span><span class="n">group_num</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;entitled_memory_pool_number=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mpp_data</span><span class="p">.</span><span class="n">pool_num</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;entitled_memory_weight=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mpp_data</span><span class="p">.</span><span class="n">mem_weight</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;unallocated_entitled_memory_weight=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	           <span class="n">mpp_data</span><span class="p">.</span><span class="n">unallocated_mem_weight</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;unallocated_io_mapping_entitlement=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	           <span class="n">mpp_data</span><span class="p">.</span><span class="n">unallocated_entitlement</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mpp_data</span><span class="p">.</span><span class="n">pool_size</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;entitled_memory_pool_size=%ld bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		           <span class="n">mpp_data</span><span class="p">.</span><span class="n">pool_size</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;entitled_memory_loan_request=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	           <span class="n">mpp_data</span><span class="p">.</span><span class="n">loan_request</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;backing_memory=%ld bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mpp_data</span><span class="p">.</span><span class="n">backing_mem</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parse_mpp_x_data</span>
<span class="cm"> * Parse out data returned from h_get_mpp_x</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parse_mpp_x_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcall_mpp_x_data</span> <span class="n">mpp_x_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_XCMO</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h_get_mpp_x</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpp_x_data</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;coalesced_bytes=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mpp_x_data</span><span class="p">.</span><span class="n">coalesced_bytes</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mpp_x_data</span><span class="p">.</span><span class="n">pool_coalesced_bytes</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pool_coalesced_bytes=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">mpp_x_data</span><span class="p">.</span><span class="n">pool_coalesced_bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mpp_x_data</span><span class="p">.</span><span class="n">pool_purr_cycles</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;coalesce_pool_purr=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mpp_x_data</span><span class="p">.</span><span class="n">pool_purr_cycles</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mpp_x_data</span><span class="p">.</span><span class="n">pool_spurr_cycles</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;coalesce_pool_spurr=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mpp_x_data</span><span class="p">.</span><span class="n">pool_spurr_cycles</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define SPLPAR_CHARACTERISTICS_TOKEN 20</span>
<span class="cp">#define SPLPAR_MAXLENGTH 1026*(sizeof(char))</span>

<span class="cm">/*</span>
<span class="cm"> * parse_system_parameter_string()</span>
<span class="cm"> * Retrieve the potential_processors, max_entitled_capacity and friends</span>
<span class="cm"> * through the get-system-parameter rtas call.  Replace keyword strings as</span>
<span class="cm"> * necessary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parse_system_parameter_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">call_status</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">local_buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">SPLPAR_MAXLENGTH</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">local_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s %s kmalloc failure at line %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtas_data_buf_lock</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rtas_data_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SPLPAR_MAXLENGTH</span><span class="p">);</span>
	<span class="n">call_status</span> <span class="o">=</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">rtas_token</span><span class="p">(</span><span class="s">&quot;ibm,get-system-parameter&quot;</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
				<span class="nb">NULL</span><span class="p">,</span>
				<span class="n">SPLPAR_CHARACTERISTICS_TOKEN</span><span class="p">,</span>
				<span class="n">__pa</span><span class="p">(</span><span class="n">rtas_data_buf</span><span class="p">),</span>
				<span class="n">RTAS_DATA_BUF_SIZE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">local_buffer</span><span class="p">,</span> <span class="n">rtas_data_buf</span><span class="p">,</span> <span class="n">SPLPAR_MAXLENGTH</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtas_data_buf_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">call_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;%s %s Error calling get-system-parameter (0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">call_status</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">splpar_strlen</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">w_idx</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">workbuffer</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">SPLPAR_MAXLENGTH</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">workbuffer</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s %s kmalloc failure at line %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">local_buffer</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#ifdef LPARCFG_DEBUG</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;success calling get-system-parameter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">splpar_strlen</span> <span class="o">=</span> <span class="n">local_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">256</span> <span class="o">+</span> <span class="n">local_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">local_buffer</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* step over strlen value */</span>

		<span class="n">w_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="n">local_buffer</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">splpar_strlen</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">workbuffer</span><span class="p">[</span><span class="n">w_idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_buffer</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">local_buffer</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">local_buffer</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">workbuffer</span><span class="p">[</span><span class="n">w_idx</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">w_idx</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* avoid the empty string */</span>
					<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">workbuffer</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">workbuffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SPLPAR_MAXLENGTH</span><span class="p">);</span>
				<span class="n">idx</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* skip the comma */</span>
				<span class="n">w_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">local_buffer</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;=&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* code here to replace workbuffer contents</span>
<span class="cm">				   with different keyword strings */</span>
				<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">workbuffer</span><span class="p">,</span> <span class="s">&quot;MaxEntCap&quot;</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">strcpy</span><span class="p">(</span><span class="n">workbuffer</span><span class="p">,</span>
					       <span class="s">&quot;partition_max_entitled_capacity&quot;</span><span class="p">);</span>
					<span class="n">w_idx</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">workbuffer</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">workbuffer</span><span class="p">,</span> <span class="s">&quot;MaxPlatProcs&quot;</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">strcpy</span><span class="p">(</span><span class="n">workbuffer</span><span class="p">,</span>
					       <span class="s">&quot;system_potential_processors&quot;</span><span class="p">);</span>
					<span class="n">w_idx</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">workbuffer</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">workbuffer</span><span class="p">);</span>
		<span class="n">local_buffer</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* back up over strlen value */</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">local_buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Return the number of processors in the system.</span>
<span class="cm"> * This function reads through the device tree and counts</span>
<span class="cm"> * the virtual processors, this does not include threads.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lparcfg_count_active_processors</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">cpus_dn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">cpus_dn</span> <span class="o">=</span> <span class="n">of_find_node_by_type</span><span class="p">(</span><span class="n">cpus_dn</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">)))</span> <span class="p">{</span>
<span class="cp">#ifdef LPARCFG_DEBUG</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;cpus_dn %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpus_dn</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pseries_cmo_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cmo_faults</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cmo_fault_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;cmo_enabled=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_CMO</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_CMO</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmo_faults</span> <span class="o">+=</span> <span class="n">lppaca_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">).</span><span class="n">cmo_faults</span><span class="p">;</span>
		<span class="n">cmo_fault_time</span> <span class="o">+=</span> <span class="n">lppaca_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">).</span><span class="n">cmo_fault_time</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;cmo_faults=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmo_faults</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;cmo_fault_time_usec=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">cmo_fault_time</span> <span class="o">/</span> <span class="n">tb_ticks_per_usec</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;cmo_primary_psp=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmo_get_primary_psp</span><span class="p">());</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;cmo_secondary_psp=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmo_get_secondary_psp</span><span class="p">());</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;cmo_page_size=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmo_get_page_size</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">splpar_dispatch_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dispatches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dispatch_dispersions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dispatches</span> <span class="o">+=</span> <span class="n">lppaca_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">).</span><span class="n">yield_count</span><span class="p">;</span>
		<span class="n">dispatch_dispersions</span> <span class="o">+=</span> <span class="n">lppaca_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">).</span><span class="n">dispersion_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;dispatches=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dispatches</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;dispatch_dispersions=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dispatch_dispersions</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">parse_em_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">retbuf</span><span class="p">[</span><span class="n">PLPAR_HCALL_BUFSIZE</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">plpar_hcall</span><span class="p">(</span><span class="n">H_GET_EM_PARMS</span><span class="p">,</span> <span class="n">retbuf</span><span class="p">)</span> <span class="o">==</span> <span class="n">H_SUCCESS</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;power_mode_data=%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pseries_lparcfg_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">partition_potential_processors</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">partition_active_processors</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">rtas_node</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lrdrp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rtas_node</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/rtas&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtas_node</span><span class="p">)</span>
		<span class="n">lrdrp</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">rtas_node</span><span class="p">,</span> <span class="s">&quot;ibm,lrdr-capacity&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lrdrp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">partition_potential_processors</span> <span class="o">=</span> <span class="n">vdso_data</span><span class="o">-&gt;</span><span class="n">processorCount</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">partition_potential_processors</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">lrdrp</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">rtas_node</span><span class="p">);</span>

	<span class="n">partition_active_processors</span> <span class="o">=</span> <span class="n">lparcfg_count_active_processors</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_SPLPAR</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* this call handles the ibm,get-system-parameter contents */</span>
		<span class="n">parse_system_parameter_string</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="n">parse_ppp_data</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="n">parse_mpp_data</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="n">parse_mpp_x_data</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="n">pseries_cmo_data</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="n">splpar_dispatch_data</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;purr=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">get_purr</span><span class="p">());</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* non SPLPAR case */</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;system_active_processors=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">partition_potential_processors</span><span class="p">);</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;system_potential_processors=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">partition_potential_processors</span><span class="p">);</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;partition_max_entitled_capacity=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">partition_potential_processors</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;partition_entitled_capacity=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">partition_active_processors</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;partition_active_processors=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">partition_active_processors</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;partition_potential_processors=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">partition_potential_processors</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;shared_processor_mode=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lppaca_of</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">shared_proc</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;slb_size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mmu_slb_size</span><span class="p">);</span>

	<span class="n">parse_em_data</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">update_ppp</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">entitlement</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">weight</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcall_ppp_data</span> <span class="n">ppp_data</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">new_weight</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">new_entitled</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* Get our current parameters */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">h_get_ppp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppp_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entitlement</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_weight</span> <span class="o">=</span> <span class="n">ppp_data</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
		<span class="n">new_entitled</span> <span class="o">=</span> <span class="o">*</span><span class="n">entitlement</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_weight</span> <span class="o">=</span> <span class="o">*</span><span class="n">weight</span><span class="p">;</span>
		<span class="n">new_entitled</span> <span class="o">=</span> <span class="n">ppp_data</span><span class="p">.</span><span class="n">entitlement</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: current_entitled = %llu, current_weight = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">__func__</span><span class="p">,</span> <span class="n">ppp_data</span><span class="p">.</span><span class="n">entitlement</span><span class="p">,</span> <span class="n">ppp_data</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: new_entitled = %llu, new_weight = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">__func__</span><span class="p">,</span> <span class="n">new_entitled</span><span class="p">,</span> <span class="n">new_weight</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">plpar_hcall_norets</span><span class="p">(</span><span class="n">H_SET_PPP</span><span class="p">,</span> <span class="n">new_entitled</span><span class="p">,</span> <span class="n">new_weight</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * update_mpp</span>
<span class="cm"> *</span>
<span class="cm"> * Update the memory entitlement and weight for the partition.  Caller must</span>
<span class="cm"> * specify either a new entitlement or weight, not both, to be updated</span>
<span class="cm"> * since the h_set_mpp call takes both entitlement and weight as parameters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">update_mpp</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">entitlement</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">weight</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcall_mpp_data</span> <span class="n">mpp_data</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">new_entitled</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">new_weight</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entitlement</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check with vio to ensure the new memory entitlement</span>
<span class="cm">		 * can be handled.</span>
<span class="cm">		 */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">vio_cmo_entitlement_update</span><span class="p">(</span><span class="o">*</span><span class="n">entitlement</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">h_get_mpp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpp_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entitlement</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_weight</span> <span class="o">=</span> <span class="n">mpp_data</span><span class="p">.</span><span class="n">mem_weight</span><span class="p">;</span>
		<span class="n">new_entitled</span> <span class="o">=</span> <span class="o">*</span><span class="n">entitlement</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_weight</span> <span class="o">=</span> <span class="o">*</span><span class="n">weight</span><span class="p">;</span>
		<span class="n">new_entitled</span> <span class="o">=</span> <span class="n">mpp_data</span><span class="p">.</span><span class="n">entitled_mem</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: current_entitled = %lu, current_weight = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	         <span class="n">__func__</span><span class="p">,</span> <span class="n">mpp_data</span><span class="p">.</span><span class="n">entitled_mem</span><span class="p">,</span> <span class="n">mpp_data</span><span class="p">.</span><span class="n">mem_weight</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: new_entitled = %llu, new_weight = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">__func__</span><span class="p">,</span> <span class="n">new_entitled</span><span class="p">,</span> <span class="n">new_weight</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">plpar_hcall_norets</span><span class="p">(</span><span class="n">H_SET_MPP</span><span class="p">,</span> <span class="n">new_entitled</span><span class="p">,</span> <span class="n">new_weight</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interface for changing system parameters (variable capacity weight</span>
<span class="cm"> * and entitled capacity).  Format of input is &quot;param_name=value&quot;;</span>
<span class="cm"> * anything after value is ignored.  Valid parameters at this time are</span>
<span class="cm"> * &quot;partition_entitled_capacity&quot; and &quot;capacity_weight&quot;.  We use</span>
<span class="cm"> * H_SET_PPP to alter parameters.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be invoked only on systems with</span>
<span class="cm"> * FW_FEATURE_SPLPAR.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">lparcfg_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">kbuf_sz</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">kbuf</span><span class="p">[</span><span class="n">kbuf_sz</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">new_entitled</span><span class="p">,</span> <span class="o">*</span><span class="n">new_entitled_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">new_entitled</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">new_weight</span><span class="p">,</span> <span class="o">*</span><span class="n">new_weight_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">new_weight</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_SPLPAR</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">kbuf_sz</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">kbuf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">kbuf</span><span class="p">[</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">kbuf</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="o">*</span><span class="n">tmp</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">kbuf</span><span class="p">,</span> <span class="s">&quot;partition_entitled_capacity&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>
		<span class="o">*</span><span class="n">new_entitled_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">endp</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">update_ppp</span><span class="p">(</span><span class="n">new_entitled_ptr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">kbuf</span><span class="p">,</span> <span class="s">&quot;capacity_weight&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>
		<span class="o">*</span><span class="n">new_weight_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">endp</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">update_ppp</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">new_weight_ptr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">kbuf</span><span class="p">,</span> <span class="s">&quot;entitled_memory&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>
		<span class="o">*</span><span class="n">new_entitled_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">endp</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">update_mpp</span><span class="p">(</span><span class="n">new_entitled_ptr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">kbuf</span><span class="p">,</span> <span class="s">&quot;entitled_memory_weight&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>
		<span class="o">*</span><span class="n">new_weight_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">endp</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">update_mpp</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">new_weight_ptr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">H_SUCCESS</span> <span class="o">||</span> <span class="n">retval</span> <span class="o">==</span> <span class="n">H_CONSTRAINED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">H_BUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">H_HARDWARE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">H_PARAMETER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lparcfg_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">rootdn</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">model</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">system_id</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lp_index_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lp_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MODULE_NAME</span><span class="p">,</span> <span class="n">MODULE_VERS</span><span class="p">);</span>

	<span class="n">rootdn</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rootdn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">rootdn</span><span class="p">,</span> <span class="s">&quot;model&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
			<span class="n">model</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">rootdn</span><span class="p">,</span> <span class="s">&quot;system-id&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
			<span class="n">system_id</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">lp_index_ptr</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">rootdn</span><span class="p">,</span> <span class="s">&quot;ibm,partition-no&quot;</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp_index_ptr</span><span class="p">)</span>
			<span class="n">lp_index</span> <span class="o">=</span> <span class="o">*</span><span class="n">lp_index_ptr</span><span class="p">;</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">rootdn</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;serial_number=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">system_id</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;system_type=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;partition_id=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">lp_index</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pseries_lparcfg_data</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lparcfg_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">lparcfg_data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">lparcfg_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">lparcfg_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">lparcfg_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">lparcfg_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">ent</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IRGRP</span> <span class="o">|</span> <span class="n">S_IROTH</span><span class="p">;</span>

	<span class="cm">/* Allow writing if we have FW_FEATURE_SPLPAR */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_SPLPAR</span><span class="p">))</span>
		<span class="n">mode</span> <span class="o">|=</span> <span class="n">S_IWUSR</span><span class="p">;</span>

	<span class="n">ent</span> <span class="o">=</span> <span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;powerpc/lparcfg&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lparcfg_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to create powerpc/lparcfg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">proc_ppc64_lparcfg</span> <span class="o">=</span> <span class="n">ent</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">lparcfg_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proc_ppc64_lparcfg</span><span class="p">)</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;lparcfg&quot;</span><span class="p">,</span> <span class="n">proc_ppc64_lparcfg</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">lparcfg_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">lparcfg_cleanup</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Interface for LPAR configuration data&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Dave Engebretsen&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
