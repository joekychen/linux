<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › kernel › cacheinfo.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>cacheinfo.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Processor cache information made available to userspace via sysfs;</span>
<span class="cm"> * intended to be compatible with x86 intel_cacheinfo implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2008 IBM Corporation</span>
<span class="cm"> * Author: Nathan Lynch</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/kobject.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>

<span class="cp">#include &quot;cacheinfo.h&quot;</span>

<span class="cm">/* per-cpu object for tracking:</span>
<span class="cm"> * - a &quot;cache&quot; kobject for the top-level directory</span>
<span class="cm"> * - a list of &quot;index&quot; objects representing the cpu&#39;s local cache hierarchy</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cache_dir</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">;</span> <span class="cm">/* bare (not embedded) kobject for cache</span>
<span class="cm">			       * directory */</span>
	<span class="k">struct</span> <span class="n">cache_index_dir</span> <span class="o">*</span><span class="n">index</span><span class="p">;</span> <span class="cm">/* list of index objects */</span>
<span class="p">};</span>

<span class="cm">/* &quot;index&quot; object: each cpu&#39;s cache directory has an index</span>
<span class="cm"> * subdirectory corresponding to a cache object associated with the</span>
<span class="cm"> * cpu.  This object&#39;s lifetime is managed via the embedded kobject.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cache_index_dir</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache_index_dir</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> <span class="cm">/* next index in parent directory */</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Template for determining which OF properties to query for a given</span>
<span class="cm"> * cache type */</span>
<span class="k">struct</span> <span class="n">cache_type_info</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">size_prop</span><span class="p">;</span>

	<span class="cm">/* Allow for both [di]-cache-line-size and</span>
<span class="cm">	 * [di]-cache-block-size properties.  According to the PowerPC</span>
<span class="cm">	 * Processor binding, -line-size should be provided if it</span>
<span class="cm">	 * differs from the cache block size (that which is operated</span>
<span class="cm">	 * on by cache instructions), so we look for -line-size first.</span>
<span class="cm">	 * See cache_get_line_size(). */</span>

	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">line_size_props</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">nr_sets_prop</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* These are used to index the cache_type_info array. */</span>
<span class="cp">#define CACHE_TYPE_UNIFIED     0</span>
<span class="cp">#define CACHE_TYPE_INSTRUCTION 1</span>
<span class="cp">#define CACHE_TYPE_DATA        2</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cache_type_info</span> <span class="n">cache_type_info</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="cm">/* PowerPC Processor binding says the [di]-cache-*</span>
<span class="cm">		 * must be equal on unified caches, so just use</span>
<span class="cm">		 * d-cache properties. */</span>
		<span class="p">.</span><span class="n">name</span>            <span class="o">=</span> <span class="s">&quot;Unified&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">size_prop</span>       <span class="o">=</span> <span class="s">&quot;d-cache-size&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">line_size_props</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;d-cache-line-size&quot;</span><span class="p">,</span>
				     <span class="s">&quot;d-cache-block-size&quot;</span><span class="p">,</span> <span class="p">},</span>
		<span class="p">.</span><span class="n">nr_sets_prop</span>    <span class="o">=</span> <span class="s">&quot;d-cache-sets&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>            <span class="o">=</span> <span class="s">&quot;Instruction&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">size_prop</span>       <span class="o">=</span> <span class="s">&quot;i-cache-size&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">line_size_props</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;i-cache-line-size&quot;</span><span class="p">,</span>
				     <span class="s">&quot;i-cache-block-size&quot;</span><span class="p">,</span> <span class="p">},</span>
		<span class="p">.</span><span class="n">nr_sets_prop</span>    <span class="o">=</span> <span class="s">&quot;i-cache-sets&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>            <span class="o">=</span> <span class="s">&quot;Data&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">size_prop</span>       <span class="o">=</span> <span class="s">&quot;d-cache-size&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">line_size_props</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;d-cache-line-size&quot;</span><span class="p">,</span>
				     <span class="s">&quot;d-cache-block-size&quot;</span><span class="p">,</span> <span class="p">},</span>
		<span class="p">.</span><span class="n">nr_sets_prop</span>    <span class="o">=</span> <span class="s">&quot;d-cache-sets&quot;</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* Cache object: each instance of this corresponds to a distinct cache</span>
<span class="cm"> * in the system.  There are separate objects for Harvard caches: one</span>
<span class="cm"> * each for instruction and data, and each refers to the same OF node.</span>
<span class="cm"> * The refcount of the OF node is elevated for the lifetime of the</span>
<span class="cm"> * cache object.  A cache object is released when its shared_cpu_map</span>
<span class="cm"> * is cleared (see cache_cpu_clear).</span>
<span class="cm"> *</span>
<span class="cm"> * A cache object is on two lists: an unsorted global list</span>
<span class="cm"> * (cache_list) of cache objects; and a singly-linked list</span>
<span class="cm"> * representing the local cache hierarchy, which is ordered by level</span>
<span class="cm"> * (e.g. L1d -&gt; L1i -&gt; L2 -&gt; L3).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cache</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">ofnode</span><span class="p">;</span>    <span class="cm">/* OF node for this cache, may be cpu */</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="n">shared_cpu_map</span><span class="p">;</span> <span class="cm">/* online CPUs using this cache */</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>                      <span class="cm">/* split cache disambiguation */</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>                     <span class="cm">/* level not explicit in device tree */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>         <span class="cm">/* global list of cache objects */</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">next_local</span><span class="p">;</span>      <span class="cm">/* next cache of &gt;= level */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_dir</span> <span class="o">*</span><span class="p">,</span> <span class="n">cache_dir_pcpu</span><span class="p">);</span>

<span class="cm">/* traversal/modification of this list occurs only at cpu hotplug time;</span>
<span class="cm"> * access is serialized by cpu hotplug locking</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">cache_list</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cache_index_dir</span> <span class="o">*</span><span class="nf">kobj_to_cache_index_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_index_dir</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">cache_type_string</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cache_type_info</span><span class="p">[</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">cache_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">ofnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">ofnode</span> <span class="o">=</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">ofnode</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">__cpuinit</span> <span class="nf">new_cache</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">ofnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cache</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="p">)</span>
		<span class="n">cache_init</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">ofnode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_cache_debugcheck</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">next_local</span> <span class="o">==</span> <span class="n">cache</span><span class="p">,</span>
			  <span class="s">&quot;cache for %s(%s) refers to cache for %s(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">iter</span><span class="o">-&gt;</span><span class="n">ofnode</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span>
			  <span class="n">cache_type_string</span><span class="p">(</span><span class="n">iter</span><span class="p">),</span>
			  <span class="n">cache</span><span class="o">-&gt;</span><span class="n">ofnode</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span>
			  <span class="n">cache_type_string</span><span class="p">(</span><span class="n">cache</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;freeing L%d %s cache for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span>
		 <span class="n">cache_type_string</span><span class="p">(</span><span class="n">cache</span><span class="p">),</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">ofnode</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>

	<span class="n">release_cache_debugcheck</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">ofnode</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_cpu_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">cache</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">shared_cpu_map</span><span class="p">),</span>
			  <span class="s">&quot;CPU %i already accounted in %s(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">cpu</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">ofnode</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span>
			  <span class="n">cache_type_string</span><span class="p">(</span><span class="n">next</span><span class="p">));</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">shared_cpu_map</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">next_local</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_size</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">cache_size</span><span class="p">;</span>

	<span class="n">propname</span> <span class="o">=</span> <span class="n">cache_type_info</span><span class="p">[</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">].</span><span class="n">size_prop</span><span class="p">;</span>

	<span class="n">cache_size</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">ofnode</span><span class="p">,</span> <span class="n">propname</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="n">cache_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_size_kb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache_size</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* not cache_line_size() because that&#39;s a macro in include/linux/cache.h */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_get_line_size</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">line_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">lim</span><span class="p">;</span>

	<span class="n">lim</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cache_type_info</span><span class="p">[</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">].</span><span class="n">line_size_props</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">;</span>

		<span class="n">propname</span> <span class="o">=</span> <span class="n">cache_type_info</span><span class="p">[</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">].</span><span class="n">line_size_props</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">line_size</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">ofnode</span><span class="p">,</span> <span class="n">propname</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">line_size</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">line_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="n">line_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_nr_sets</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">nr_sets</span><span class="p">;</span>

	<span class="n">propname</span> <span class="o">=</span> <span class="n">cache_type_info</span><span class="p">[</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">].</span><span class="n">nr_sets_prop</span><span class="p">;</span>

	<span class="n">nr_sets</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">ofnode</span><span class="p">,</span> <span class="n">propname</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_sets</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="n">nr_sets</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_associativity</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_sets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache_nr_sets</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_sets</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* If the cache is fully associative, there is no need to</span>
<span class="cm">	 * check the other properties.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_sets</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache_get_line_size</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">line_size</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache_size</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nr_sets</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">line_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">/</span> <span class="n">nr_sets</span><span class="p">)</span> <span class="o">/</span> <span class="n">line_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* helper for dealing with split caches */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="nf">cache_find_first_sibling</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CACHE_TYPE_UNIFIED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cache</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ofnode</span> <span class="o">==</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">ofnode</span> <span class="o">&amp;&amp;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next_local</span> <span class="o">==</span> <span class="n">cache</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">iter</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* return the first cache on a local list matching node */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="nf">cache_lookup_by_node</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ofnode</span> <span class="o">!=</span> <span class="n">node</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">cache_find_first_sibling</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">cache_node_is_unified</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;cache-unified&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">__cpuinit</span> <span class="nf">cache_do_one_devnode_unified</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;creating L%d ucache for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">new_cache</span><span class="p">(</span><span class="n">CACHE_TYPE_UNIFIED</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">__cpuinit</span> <span class="nf">cache_do_one_devnode_split</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">dcache</span><span class="p">,</span> <span class="o">*</span><span class="n">icache</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;creating L%d dcache and icache for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span>
		 <span class="n">node</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>

	<span class="n">dcache</span> <span class="o">=</span> <span class="n">new_cache</span><span class="p">(</span><span class="n">CACHE_TYPE_DATA</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="n">icache</span> <span class="o">=</span> <span class="n">new_cache</span><span class="p">(</span><span class="n">CACHE_TYPE_INSTRUCTION</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dcache</span> <span class="o">||</span> <span class="o">!</span><span class="n">icache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dcache</span><span class="o">-&gt;</span><span class="n">next_local</span> <span class="o">=</span> <span class="n">icache</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dcache</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">release_cache</span><span class="p">(</span><span class="n">dcache</span><span class="p">);</span>
	<span class="n">release_cache</span><span class="p">(</span><span class="n">icache</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">__cpuinit</span> <span class="nf">cache_do_one_devnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache_node_is_unified</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">cache_do_one_devnode_unified</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">cache_do_one_devnode_split</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">__cpuinit</span> <span class="nf">cache_lookup_or_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">cache_lookup_by_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">cache</span> <span class="o">&amp;&amp;</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="n">level</span><span class="p">,</span>
		  <span class="s">&quot;cache level mismatch on lookup (got %d, expected %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">cache</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">)</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">cache_do_one_devnode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">link_cache_lists</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">smaller</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">bigger</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">smaller</span><span class="o">-&gt;</span><span class="n">next_local</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smaller</span><span class="o">-&gt;</span><span class="n">next_local</span> <span class="o">==</span> <span class="n">bigger</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span> <span class="cm">/* already linked */</span>
		<span class="n">smaller</span> <span class="o">=</span> <span class="n">smaller</span><span class="o">-&gt;</span><span class="n">next_local</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">smaller</span><span class="o">-&gt;</span><span class="n">next_local</span> <span class="o">=</span> <span class="n">bigger</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">do_subsidiary_caches_debugcheck</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">ofnode</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">do_subsidiary_caches</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">subcache_node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>

	<span class="n">do_subsidiary_caches_debugcheck</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">subcache_node</span> <span class="o">=</span> <span class="n">of_find_next_cache_node</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">ofnode</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">subcache</span><span class="p">;</span>

		<span class="n">level</span><span class="o">++</span><span class="p">;</span>
		<span class="n">subcache</span> <span class="o">=</span> <span class="n">cache_lookup_or_instantiate</span><span class="p">(</span><span class="n">subcache_node</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">subcache_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">subcache</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">link_cache_lists</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">subcache</span><span class="p">);</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">subcache</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">__cpuinit</span> <span class="nf">cache_chain_instantiate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">cpu_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cpu_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;creating cache object(s) for CPU %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>

	<span class="n">cpu_node</span> <span class="o">=</span> <span class="n">of_get_cpu_node</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">cpu_node</span><span class="p">,</span> <span class="s">&quot;no OF node found for CPU %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">cpu_cache</span> <span class="o">=</span> <span class="n">cache_lookup_or_instantiate</span><span class="p">(</span><span class="n">cpu_node</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_cache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">do_subsidiary_caches</span><span class="p">(</span><span class="n">cpu_cache</span><span class="p">);</span>

	<span class="n">cache_cpu_set</span><span class="p">(</span><span class="n">cpu_cache</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">cpu_node</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cpu_cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cache_dir</span> <span class="o">*</span><span class="n">__cpuinit</span> <span class="nf">cacheinfo_create_cache_dir</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_dir</span> <span class="o">*</span><span class="n">cache_dir</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">get_cpu_device</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">);</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no dev for CPU %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;cache&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">cache_dir</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cache_dir</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache_dir</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">cache_dir</span><span class="o">-&gt;</span><span class="n">kobj</span> <span class="o">=</span> <span class="n">kobj</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cache_dir_pcpu</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">per_cpu</span><span class="p">(</span><span class="n">cache_dir_pcpu</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">)</span> <span class="o">=</span> <span class="n">cache_dir</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cache_dir</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_index_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_index_dir</span> <span class="o">*</span><span class="n">index</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">kobj_to_cache_index_dir</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;freeing index directory for L%d %s cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">index</span><span class="o">-&gt;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="n">cache_type_string</span><span class="p">(</span><span class="n">index</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">));</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cache_index_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">kobj_attr</span><span class="p">;</span>

	<span class="n">kobj_attr</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">kobj_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">kobj_attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="nf">index_kobj_to_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_index_dir</span> <span class="o">*</span><span class="n">index</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">kobj_to_cache_index_dir</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">index</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">size_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size_kb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">index_kobj_to_cache</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache_size_kb</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size_kb</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%uK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size_kb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">cache_size_attr</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">size_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">line_size_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">index_kobj_to_cache</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache_get_line_size</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">line_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">line_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">cache_line_size_attr</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">coherency_line_size</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">line_size_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">nr_sets_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_sets</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">index_kobj_to_cache</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache_nr_sets</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_sets</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nr_sets</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">cache_nr_sets_attr</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">number_of_sets</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">nr_sets_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">associativity_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">associativity</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">index_kobj_to_cache</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache_associativity</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">associativity</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">associativity</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">cache_assoc_attr</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">ways_of_associativity</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">associativity_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">type_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">index_kobj_to_cache</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cache_type_string</span><span class="p">(</span><span class="n">cache</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">cache_type_attr</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">type_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">level_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_index_dir</span> <span class="o">*</span><span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">kobj_to_cache_index_dir</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
	<span class="n">cache</span> <span class="o">=</span> <span class="n">index</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">cache_level_attr</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">level_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">shared_cpu_map_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_index_dir</span> <span class="o">*</span><span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">kobj_to_cache_index_dir</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
	<span class="n">cache</span> <span class="o">=</span> <span class="n">index</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">cpumask_scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">shared_cpu_map</span><span class="p">);</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="n">cache_shared_cpu_map_attr</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">shared_cpu_map</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">shared_cpu_map_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/* Attributes which should always be created -- the kobject/sysfs core</span>
<span class="cm"> * does this automatically via kobj_type-&gt;default_attrs.  This is the</span>
<span class="cm"> * minimum data required to uniquely identify a cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">cache_index_default_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">cache_type_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">cache_level_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">cache_shared_cpu_map_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Attributes which should be created if the cache device node has the</span>
<span class="cm"> * right properties -- see cacheinfo_create_index_opt_attrs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">cache_index_opt_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">cache_size_attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">cache_line_size_attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">cache_nr_sets_attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">cache_assoc_attr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">cache_index_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">cache_index_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">cache_index_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">cache_index_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sysfs_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cache_index_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">default_attrs</span> <span class="o">=</span> <span class="n">cache_index_default_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">cacheinfo_create_index_opt_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_index_dir</span> <span class="o">*</span><span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cache_name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cache_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">;</span>
	<span class="n">cache_name</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">ofnode</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">;</span>
	<span class="n">cache_type</span> <span class="o">=</span> <span class="n">cache_type_string</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>

	<span class="cm">/* We don&#39;t want to create an attribute that can&#39;t provide a</span>
<span class="cm">	 * meaningful value.  Check the return value of each optional</span>
<span class="cm">	 * attribute&#39;s -&gt;show method before registering the</span>
<span class="cm">	 * attribute.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cache_index_opt_attrs</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
		<span class="kt">ssize_t</span> <span class="n">rc</span><span class="p">;</span>

		<span class="n">attr</span> <span class="o">=</span> <span class="n">cache_index_opt_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;not creating %s attribute for &quot;</span>
				 <span class="s">&quot;%s(%s) (rc = %zd)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">cache_name</span><span class="p">,</span>
				 <span class="n">cache_type</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sysfs_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">))</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;could not create %s attribute for %s(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">cache_name</span><span class="p">,</span> <span class="n">cache_type</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">cacheinfo_create_index_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache_dir</span> <span class="o">*</span><span class="n">cache_dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_index_dir</span> <span class="o">*</span><span class="n">index_dir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">index_dir</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">index_dir</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">index_dir</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">index_dir</span><span class="o">-&gt;</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">kobject_init_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">index_dir</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache_index_type</span><span class="p">,</span>
				  <span class="n">cache_dir</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="s">&quot;index%d&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">index_dir</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cache_dir</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">cache_dir</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index_dir</span><span class="p">;</span>

	<span class="n">cacheinfo_create_index_opt_attrs</span><span class="p">(</span><span class="n">index_dir</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">index_dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">cacheinfo_sysfs_populate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_dir</span> <span class="o">*</span><span class="n">cache_dir</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cache_dir</span> <span class="o">=</span> <span class="n">cacheinfo_create_cache_dir</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache_dir</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">cache_list</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cacheinfo_create_index_dir</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">cache_dir</span><span class="p">);</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">next_local</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">cacheinfo_cpu_online</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">cache_chain_instantiate</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cacheinfo_sysfs_populate</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU </span><span class="cm">/* functions needed for cpu offline */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="nf">cache_lookup_by_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">cpu_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">cpu_node</span> <span class="o">=</span> <span class="n">of_get_cpu_node</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">cpu_node</span><span class="p">,</span> <span class="s">&quot;no OF node found for CPU %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_node</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">cache_lookup_by_node</span><span class="p">(</span><span class="n">cpu_node</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">cpu_node</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_index_dirs</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_dir</span> <span class="o">*</span><span class="n">cache_dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_index_dir</span> <span class="o">*</span><span class="n">index</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">cache_dir</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cache_index_dir</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

		<span class="n">next</span> <span class="o">=</span> <span class="n">index</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">index</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_cache_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache_dir</span> <span class="o">*</span><span class="n">cache_dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">remove_index_dirs</span><span class="p">(</span><span class="n">cache_dir</span><span class="p">);</span>

	<span class="n">kobject_put</span><span class="p">(</span><span class="n">cache_dir</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">cache_dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_cpu_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">next_local</span><span class="p">;</span>

		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">shared_cpu_map</span><span class="p">),</span>
			  <span class="s">&quot;CPU %i not accounted in %s(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">cpu</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">ofnode</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span>
			  <span class="n">cache_type_string</span><span class="p">(</span><span class="n">cache</span><span class="p">));</span>

		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">shared_cpu_map</span><span class="p">);</span>

		<span class="cm">/* Release the cache object if all the cpus using it</span>
<span class="cm">		 * are offline */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">shared_cpu_map</span><span class="p">))</span>
			<span class="n">release_cache</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>

		<span class="n">cache</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cacheinfo_cpu_offline</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cache_dir</span> <span class="o">*</span><span class="n">cache_dir</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="cm">/* Prevent userspace from seeing inconsistent state - remove</span>
<span class="cm">	 * the sysfs hierarchy first */</span>
	<span class="n">cache_dir</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cache_dir_pcpu</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>

	<span class="cm">/* careful, sysfs population may have failed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache_dir</span><span class="p">)</span>
		<span class="n">remove_cache_dir</span><span class="p">(</span><span class="n">cache_dir</span><span class="p">);</span>

	<span class="n">per_cpu</span><span class="p">(</span><span class="n">cache_dir_pcpu</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* clear the CPU&#39;s bit in its cache chain, possibly freeing</span>
<span class="cm">	 * cache objects */</span>
	<span class="n">cache</span> <span class="o">=</span> <span class="n">cache_lookup_by_cpu</span><span class="p">(</span><span class="n">cpu_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="p">)</span>
		<span class="n">cache_cpu_clear</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">cpu_id</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
