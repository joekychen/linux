<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › kernel › machine_kexec_64.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>machine_kexec_64.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * PPC64 code to handle Linux booting another kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004-2005, IBM Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * Created by: Milton D Miller II</span>
<span class="cm"> *</span>
<span class="cm"> * This source code is licensed under the GNU General Public License,</span>
<span class="cm"> * Version 2.  See the file COPYING for more details.</span>
<span class="cm"> */</span>


<span class="cp">#include &lt;linux/kexec.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/thread_info.h&gt;</span>
<span class="cp">#include &lt;linux/init_task.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>

<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/current.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/paca.h&gt;</span>
<span class="cp">#include &lt;asm/mmu.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;	</span><span class="cm">/* _end */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#include &lt;asm/hw_breakpoint.h&gt;</span>

<span class="kt">int</span> <span class="nf">default_machine_kexec_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>	<span class="cm">/* limits of segment */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">;</span>	<span class="cm">/* limits of blocked memory range */</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">basep</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">sizep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_clear_all</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we use the kernel fault handlers and paging code to</span>
<span class="cm">	 * handle the virtual mode, we must make sure no destination</span>
<span class="cm">	 * overlaps kernel static data or bss.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">nr_segments</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem</span> <span class="o">&lt;</span> <span class="n">__pa</span><span class="p">(</span><span class="n">_end</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETXTBSY</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For non-LPAR, we absolutely can not overwrite the mmu hash</span>
<span class="cm">	 * table, since we are still using the bolted entries in it to</span>
<span class="cm">	 * do the copy.  Check that here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It is safe if the end is below the start of the blocked</span>
<span class="cm">	 * region (end &lt;= low), or if the beginning is after the</span>
<span class="cm">	 * end of the blocked region (begin &gt;= high).  Use the</span>
<span class="cm">	 * boolean identity !(a || b)  === (!a &amp;&amp; !b).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">htab_address</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">low</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">htab_address</span><span class="p">);</span>
		<span class="n">high</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="n">htab_size_bytes</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">nr_segments</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">begin</span> <span class="o">=</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem</span><span class="p">;</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">begin</span> <span class="o">+</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">memsz</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">begin</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">low</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ETXTBSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* We also should not overwrite the tce tables */</span>
	<span class="n">for_each_node_by_type</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;pci&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">basep</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;linux,tce-base&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">sizep</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;linux,tce-size&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">basep</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">sizep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">low</span> <span class="o">=</span> <span class="o">*</span><span class="n">basep</span><span class="p">;</span>
		<span class="n">high</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">sizep</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">nr_segments</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">begin</span> <span class="o">=</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem</span><span class="p">;</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">begin</span> <span class="o">+</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">memsz</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">begin</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">low</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ETXTBSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define IND_FLAGS (IND_DESTINATION | IND_INDIRECTION | IND_DONE | IND_SOURCE)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">copy_segments</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ind</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We rely on kexec_load to create a lists that properly</span>
<span class="cm">	 * initializes these pointers before they are used.</span>
<span class="cm">	 * We will still crash if the list is wrong, but at least</span>
<span class="cm">	 * the compiler will be quiet.</span>
<span class="cm">	 */</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">entry</span> <span class="o">=</span> <span class="n">ind</span><span class="p">;</span> <span class="o">!</span><span class="p">(</span><span class="n">entry</span> <span class="o">&amp;</span> <span class="n">IND_DONE</span><span class="p">);</span> <span class="n">entry</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">entry</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&amp;</span> <span class="n">IND_FLAGS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IND_DESTINATION</span>:
			<span class="n">dest</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IND_INDIRECTION</span>:
			<span class="n">ptr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IND_SOURCE</span>:
			<span class="n">copy_page</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="n">dest</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kexec_copy_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">nr_segments</span> <span class="o">=</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">nr_segments</span><span class="p">;</span>
	<span class="k">struct</span>  <span class="n">kexec_segment</span> <span class="n">ranges</span><span class="p">[</span><span class="n">KEXEC_SEGMENT_MAX</span><span class="p">];</span>

	<span class="cm">/* save the ranges on the stack to efficiently flush the icache */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ranges</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * After this call we may not use anything allocated in dynamic</span>
<span class="cm">	 * memory, including *image.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Only globals and the stack are allowed.</span>
<span class="cm">	 */</span>
	<span class="n">copy_segments</span><span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we need to clear the icache for all dest pages sometime,</span>
<span class="cm">	 * including ones that were in place on the original copy</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_segments</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem</span> <span class="o">+</span> <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">memsz</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">kexec_all_irq_disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kexec_smp_down</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">mb</span><span class="p">();</span> <span class="cm">/* make sure our irqs are disabled before we say they are */</span>
	<span class="n">get_paca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">kexec_state</span> <span class="o">=</span> <span class="n">KEXEC_STATE_IRQS_OFF</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">kexec_all_irq_disabled</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="n">mb</span><span class="p">();</span> <span class="cm">/* make sure all irqs are disabled before this */</span>
	<span class="n">hw_breakpoint_disable</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now every CPU has IRQs off, we can clear out any pending</span>
<span class="cm">	 * IPIs and be sure that no more will come in after this.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">kexec_cpu_down</span><span class="p">)</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">kexec_cpu_down</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">kexec_smp_wait</span><span class="p">();</span>
	<span class="cm">/* NOTREACHED */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kexec_prepare_cpus_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">wait_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">my_cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">notified</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">hw_breakpoint_disable</span><span class="p">();</span>
	<span class="n">my_cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="cm">/* Make sure each CPU has at least made it to the state we need.</span>
<span class="cm">	 *</span>
<span class="cm">	 * FIXME: There is a (slim) chance of a problem if not all of the CPUs</span>
<span class="cm">	 * are correctly onlined.  If somehow we start a CPU on boot with RTAS</span>
<span class="cm">	 * start-cpu, but somehow that CPU doesn&#39;t write callin_cpu_map[] in</span>
<span class="cm">	 * time, the boot CPU will timeout.  If it does eventually execute</span>
<span class="cm">	 * stuff, the secondary will start up (paca[].cpu_start was written) and</span>
<span class="cm">	 * get into a peculiar state.  If the platform supports</span>
<span class="cm">	 * smp_ops-&gt;take_timebase(), the secondary CPU will probably be spinning</span>
<span class="cm">	 * in there.  If not (i.e. pseries), the secondary will continue on and</span>
<span class="cm">	 * try to online itself/idle/etc. If it survives that, we need to find</span>
<span class="cm">	 * these possible-but-not-online-but-should-be CPUs and chaperone them</span>
<span class="cm">	 * into kexec_smp_wait().</span>
<span class="cm">	 */</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">my_cpu</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">paca</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">kexec_state</span> <span class="o">&lt;</span> <span class="n">wait_state</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">barrier</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">notified</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;kexec: waiting for cpu %d &quot;</span>
				       <span class="s">&quot;(physical %d) to enter %i state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">i</span><span class="p">,</span> <span class="n">paca</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hw_cpu_id</span><span class="p">,</span> <span class="n">wait_state</span><span class="p">);</span>
				<span class="n">notified</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mb</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We need to make sure each present CPU is online.  The next kernel will scan</span>
<span class="cm"> * the device tree and assume primary threads are online and query secondary</span>
<span class="cm"> * threads via RTAS to online them if required.  If we don&#39;t online primary</span>
<span class="cm"> * threads, they will be stuck.  However, we also online secondary threads as we</span>
<span class="cm"> * may be using &#39;cede offline&#39;.  In this case RTAS doesn&#39;t see the secondary</span>
<span class="cm"> * threads as offline -- and again, these CPUs will be stuck.</span>
<span class="cm"> *</span>
<span class="cm"> * So, we online all CPUs that should be running, including secondary threads.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wake_offline_cpus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;kexec: Waking offline cpu %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">cpu</span><span class="p">);</span>
			<span class="n">cpu_up</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kexec_prepare_cpus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wake_offline_cpus</span><span class="p">();</span>
	<span class="n">smp_call_function</span><span class="p">(</span><span class="n">kexec_smp_down</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="cm">/* wait */</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">mb</span><span class="p">();</span> <span class="cm">/* make sure IRQs are disabled before we say they are */</span>
	<span class="n">get_paca</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">kexec_state</span> <span class="o">=</span> <span class="n">KEXEC_STATE_IRQS_OFF</span><span class="p">;</span>

	<span class="n">kexec_prepare_cpus_wait</span><span class="p">(</span><span class="n">KEXEC_STATE_IRQS_OFF</span><span class="p">);</span>
	<span class="cm">/* we are sure every CPU has IRQs off at this point */</span>
	<span class="n">kexec_all_irq_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* after we tell the others to go down */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">kexec_cpu_down</span><span class="p">)</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">kexec_cpu_down</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Before removing MMU mappings make sure all CPUs have entered real</span>
<span class="cm">	 * mode:</span>
<span class="cm">	 */</span>
	<span class="n">kexec_prepare_cpus_wait</span><span class="p">(</span><span class="n">KEXEC_STATE_REAL_MODE</span><span class="p">);</span>

	<span class="n">put_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* ! SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kexec_prepare_cpus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * move the secondarys to us so that we can copy</span>
<span class="cm">	 * the new kernel 0-0x100 safely</span>
<span class="cm">	 *</span>
<span class="cm">	 * do this if kexec in setup.c ?</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need to release the cpus if we are ever going from an</span>
<span class="cm">	 * UP to an SMP kernel.</span>
<span class="cm">	 */</span>
	<span class="n">smp_release_cpus</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">kexec_cpu_down</span><span class="p">)</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">kexec_cpu_down</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* SMP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * kexec thread structure and stack.</span>
<span class="cm"> *</span>
<span class="cm"> * We need to make sure that this is 16384-byte aligned due to the</span>
<span class="cm"> * way process stacks are handled.  It also must be statically allocated</span>
<span class="cm"> * or allocated as part of the kimage, because everything else may be</span>
<span class="cm"> * overwritten when we copy the kexec image.  We piggyback on the</span>
<span class="cm"> * &quot;init_task&quot; linker section here to statically allocate a stack.</span>
<span class="cm"> *</span>
<span class="cm"> * We could use a smaller stack if we don&#39;t care about anything using</span>
<span class="cm"> * current, but that audit has not been performed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">union</span> <span class="n">thread_union</span> <span class="n">kexec_stack</span> <span class="n">__init_task_data</span> <span class="o">=</span>
	<span class="p">{</span> <span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * For similar reasons to the stack above, the kexecing CPU needs to be on a</span>
<span class="cm"> * static PACA; we switch to kexec_paca.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">paca_struct</span> <span class="n">kexec_paca</span><span class="p">;</span>

<span class="cm">/* Our assembly helper, in kexec_stub.S */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">kexec_sequence</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">newstack</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">control</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">clear_all</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span> <span class="n">__noreturn</span><span class="p">;</span>

<span class="cm">/* too late to fail here */</span>
<span class="kt">void</span> <span class="nf">default_machine_kexec</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* prepare control code if any */</span>

	<span class="cm">/*</span>
<span class="cm">        * If the kexec boot is the normal one, need to shutdown other cpus</span>
<span class="cm">        * into our wait loop and quiesce interrupts.</span>
<span class="cm">        * Otherwise, in the case of crashed mode (crashing_cpu &gt;= 0),</span>
<span class="cm">        * stopping other CPUs and collecting their pt_regs is done before</span>
<span class="cm">        * using debugger IPI.</span>
<span class="cm">        */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">crashing_cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">kexec_prepare_cpus</span><span class="p">();</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kexec: Starting switchover sequence.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* switch to a staticly allocated stack.  Based on irq stack code.</span>
<span class="cm">	 * XXX: the task struct will likely be invalid once we do the copy!</span>
<span class="cm">	 */</span>
	<span class="n">kexec_stack</span><span class="p">.</span><span class="n">thread_info</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>
	<span class="n">kexec_stack</span><span class="p">.</span><span class="n">thread_info</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* We need a static PACA, too; copy this CPU&#39;s PACA over and switch to</span>
<span class="cm">	 * it.  Also poison per_cpu_offset to catch anyone using non-static</span>
<span class="cm">	 * data.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_paca</span><span class="p">,</span> <span class="n">get_paca</span><span class="p">(),</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">paca_struct</span><span class="p">));</span>
	<span class="n">kexec_paca</span><span class="p">.</span><span class="n">data_offset</span> <span class="o">=</span> <span class="mh">0xedeaddeadeeeeeeeUL</span><span class="p">;</span>
	<span class="n">paca</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">paca_struct</span> <span class="o">*</span><span class="p">)</span><span class="n">RELOC_HIDE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_paca</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span>
		<span class="n">kexec_paca</span><span class="p">.</span><span class="n">paca_index</span><span class="p">;</span>
	<span class="n">setup_paca</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_paca</span><span class="p">);</span>

	<span class="cm">/* XXX: If anyone does &#39;dynamic lppacas&#39; this will also need to be</span>
<span class="cm">	 * switched to a static version!</span>
<span class="cm">	 */</span>

	<span class="cm">/* Some things are best done in assembly.  Finding globals with</span>
<span class="cm">	 * a toc is easier in C, so pass in what we can.</span>
<span class="cm">	 */</span>
	<span class="n">kexec_sequence</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_stack</span><span class="p">,</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span>
			<span class="n">page_address</span><span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">control_code_page</span><span class="p">),</span>
			<span class="n">ppc_md</span><span class="p">.</span><span class="n">hpte_clear_all</span><span class="p">);</span>
	<span class="cm">/* NOTREACHED */</span>
<span class="p">}</span>

<span class="cm">/* Values we need to export to the second kernel via the device tree. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">htab_base</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">property</span> <span class="n">htab_base_prop</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;linux,htab-base&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
	<span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">htab_base</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">property</span> <span class="n">htab_size_prop</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;linux,htab-size&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
	<span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">htab_size_bytes</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">export_htab_values</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>

	<span class="cm">/* On machines with no htab htab_address is NULL */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">htab_address</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/chosen&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* remove any stale propertys so ours can be found */</span>
	<span class="n">prop</span> <span class="o">=</span> <span class="n">of_find_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">htab_base_prop</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span><span class="p">)</span>
		<span class="n">prom_remove_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">prop</span><span class="p">);</span>
	<span class="n">prop</span> <span class="o">=</span> <span class="n">of_find_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">htab_size_prop</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span><span class="p">)</span>
		<span class="n">prom_remove_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">prop</span><span class="p">);</span>

	<span class="n">htab_base</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">htab_address</span><span class="p">);</span>
	<span class="n">prom_add_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">htab_base_prop</span><span class="p">);</span>
	<span class="n">prom_add_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">htab_size_prop</span><span class="p">);</span>

	<span class="n">of_node_put</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">export_htab_values</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
