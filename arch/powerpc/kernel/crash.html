<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › kernel › crash.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>crash.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Architecture specific (PPC64) functions for kexec based crash dumps.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005, IBM Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * Created by: Haren Myneni</span>
<span class="cm"> *</span>
<span class="cm"> * This source code is licensed under the GNU General Public License,</span>
<span class="cm"> * Version 2.  See the file COPYING for more details.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/kexec.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/crash_dump.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/kexec.h&gt;</span>
<span class="cp">#include &lt;asm/kdump.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#include &lt;asm/setjmp.h&gt;</span>
<span class="cp">#include &lt;asm/debug.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * The primary CPU waits a while for all secondary CPUs to enter. This is to</span>
<span class="cm"> * avoid sending an IPI if the secondary CPUs are entering</span>
<span class="cm"> * crash_kexec_secondary on their own (eg via a system reset).</span>
<span class="cm"> *</span>
<span class="cm"> * The secondary timeout has to be longer than the primary. Both timeouts are</span>
<span class="cm"> * in milliseconds.</span>
<span class="cm"> */</span>
<span class="cp">#define PRIMARY_TIMEOUT		500</span>
<span class="cp">#define SECONDARY_TIMEOUT	1000</span>

<span class="cp">#define IPI_TIMEOUT		10000</span>
<span class="cp">#define REAL_MODE_TIMEOUT	10000</span>

<span class="cm">/* This keeps a track of which one is the crashing cpu. */</span>
<span class="kt">int</span> <span class="n">crashing_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">time_to_dump</span><span class="p">;</span>

<span class="cp">#define CRASH_HANDLER_MAX 3</span>
<span class="cm">/* NULL terminated list of shutdown handles */</span>
<span class="k">static</span> <span class="n">crash_shutdown_t</span> <span class="n">crash_shutdown_handles</span><span class="p">[</span><span class="n">CRASH_HANDLER_MAX</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">crash_handlers_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">crash_shutdown_buf</span><span class="p">[</span><span class="n">JMP_BUF_LEN</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">crash_shutdown_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crash_shutdown_cpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">())</span>
		<span class="n">longjmp</span><span class="p">(</span><span class="n">crash_shutdown_buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">cpus_in_crash</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">crash_ipi_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">cpumask_t</span> <span class="n">cpus_state_saved</span> <span class="o">=</span> <span class="n">CPU_MASK_NONE</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">hard_irq_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpus_state_saved</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">crash_save_cpu</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpus_state_saved</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpus_in_crash</span><span class="p">);</span>
	<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Starting the kdump boot.</span>
<span class="cm">	 * This barrier is needed to make sure that all CPUs are stopped.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">time_to_dump</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">kexec_cpu_down</span><span class="p">)</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">kexec_cpu_down</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="n">kexec_smp_wait</span><span class="p">();</span>
<span class="cp">#else</span>
	<span class="k">for</span> <span class="p">(;;);</span>	<span class="cm">/* FIXME */</span>
<span class="cp">#endif</span>

	<span class="cm">/* NOTREACHED */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">crash_kexec_prepare_cpus</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msecs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ncpus</span> <span class="o">=</span> <span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span><span class="cm">/* Excluding the panic cpu */</span>
	<span class="kt">int</span> <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">old_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;Sending IPI to other CPUs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">crash_send_ipi</span><span class="p">(</span><span class="n">crash_ipi_callback</span><span class="p">);</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

<span class="nl">again:</span>
	<span class="cm">/*</span>
<span class="cm">	 * FIXME: Until we will have the way to stop other CPUs reliably,</span>
<span class="cm">	 * the crash CPU will send an IPI and wait for other CPUs to</span>
<span class="cm">	 * respond.</span>
<span class="cm">	 */</span>
	<span class="n">msecs</span> <span class="o">=</span> <span class="n">IPI_TIMEOUT</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpus_in_crash</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ncpus</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">--</span><span class="n">msecs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Would it be better to replace the trap vector here? */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpus_in_crash</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">ncpus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;IPI complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;ERROR: %d cpu(s) not responding</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ncpus</span> <span class="o">-</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpus_in_crash</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have a panic timeout set then we can&#39;t wait indefinitely</span>
<span class="cm">	 * for someone to activate system reset. We also give up on the</span>
<span class="cm">	 * second time through if system reset fail to work.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">panic_timeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">tries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A system reset will cause all CPUs to take an 0x100 exception.</span>
<span class="cm">	 * The primary CPU returns here via setjmp, and the secondary</span>
<span class="cm">	 * CPUs reexecute the crash_kexec_secondary path.</span>
<span class="cm">	 */</span>
	<span class="n">old_handler</span> <span class="o">=</span> <span class="n">__debugger</span><span class="p">;</span>
	<span class="n">__debugger</span> <span class="o">=</span> <span class="n">handle_fault</span><span class="p">;</span>
	<span class="n">crash_shutdown_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">setjmp</span><span class="p">(</span><span class="n">crash_shutdown_buf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;Activate system reset (dumprestart) &quot;</span>
				  <span class="s">&quot;to stop other cpu(s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * A system reset will force all CPUs to execute the</span>
<span class="cm">		 * crash code again. We need to reset cpus_in_crash so we</span>
<span class="cm">		 * wait for everyone to do this.</span>
<span class="cm">		 */</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpus_in_crash</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">smp_mb</span><span class="p">();</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpus_in_crash</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ncpus</span><span class="p">)</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">crash_shutdown_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">__debugger</span> <span class="o">=</span> <span class="n">old_handler</span><span class="p">;</span>

	<span class="n">tries</span><span class="o">++</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function will be called by secondary cpus.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">crash_kexec_secondary</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">msecs</span> <span class="o">=</span> <span class="n">SECONDARY_TIMEOUT</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Wait for the primary crash CPU to signal its progress */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">crashing_cpu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">msecs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* No response, kdump image may not have been loaded */</span>
			<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">crash_ipi_callback</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else	</span><span class="cm">/* ! CONFIG_SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">crash_kexec_prepare_cpus</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * move the secondaries to us so that we can copy</span>
<span class="cm">	 * the new kernel 0-0x100 safely</span>
<span class="cm">	 *</span>
<span class="cm">	 * do this if kexec in setup.c ?</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="n">smp_release_cpus</span><span class="p">();</span>
<span class="cp">#else</span>
	<span class="cm">/* FIXME */</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">crash_kexec_secondary</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/* wait for all the CPUs to hit real mode but timeout if they don&#39;t come in */</span>
<span class="cp">#if defined(CONFIG_SMP) &amp;&amp; defined(CONFIG_PPC_STD_MMU_64)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">crash_kexec_wait_realmode</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msecs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">msecs</span> <span class="o">=</span> <span class="n">REAL_MODE_TIMEOUT</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span> <span class="o">&amp;&amp;</span> <span class="n">msecs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">paca</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">kexec_state</span> <span class="o">&lt;</span> <span class="n">KEXEC_STATE_REAL_MODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">barrier</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_possible</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">msecs</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">msecs</span><span class="o">--</span><span class="p">;</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mb</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">crash_kexec_wait_realmode</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_SMP &amp;&amp; CONFIG_PPC_STD_MMU_64 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Register a function to be called on shutdown.  Only use this if you</span>
<span class="cm"> * can&#39;t reset your device in the second kernel.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">crash_shutdown_register</span><span class="p">(</span><span class="n">crash_shutdown_t</span> <span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crash_handlers_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CRASH_HANDLER_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">crash_shutdown_handles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/* Insert handle at first empty entry */</span>
			<span class="n">crash_shutdown_handles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">CRASH_HANDLER_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Crash shutdown handles full, &quot;</span>
		       <span class="s">&quot;not registered.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crash_handlers_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">crash_shutdown_register</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">crash_shutdown_unregister</span><span class="p">(</span><span class="n">crash_shutdown_t</span> <span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crash_handlers_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CRASH_HANDLER_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">crash_shutdown_handles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">handler</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">CRASH_HANDLER_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Crash shutdown handle not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Shift handles down */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">crash_shutdown_handles</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">crash_shutdown_handles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">crash_shutdown_handles</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crash_handlers_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">crash_shutdown_unregister</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">default_machine_crash_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">old_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This function is only called after the system</span>
<span class="cm">	 * has panicked or is otherwise in a critical state.</span>
<span class="cm">	 * The minimum amount of code to allow a kexec&#39;d kernel</span>
<span class="cm">	 * to run successfully needs to happen here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In practice this means stopping other cpus in</span>
<span class="cm">	 * an SMP system.</span>
<span class="cm">	 * The kernel is broken so disable interrupts.</span>
<span class="cm">	 */</span>
	<span class="n">hard_irq_disable</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make a note of crashing cpu. Will be used in machine_kexec</span>
<span class="cm">	 * such that another IPI will not be sent.</span>
<span class="cm">	 */</span>
	<span class="n">crashing_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we came in via system reset, wait a while for the secondary</span>
<span class="cm">	 * CPUs to enter.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TRAP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x100</span><span class="p">)</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="n">PRIMARY_TIMEOUT</span><span class="p">);</span>

	<span class="n">crash_kexec_prepare_cpus</span><span class="p">(</span><span class="n">crashing_cpu</span><span class="p">);</span>

	<span class="n">crash_save_cpu</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">crashing_cpu</span><span class="p">);</span>

	<span class="n">time_to_dump</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">crash_kexec_wait_realmode</span><span class="p">(</span><span class="n">crashing_cpu</span><span class="p">);</span>

	<span class="n">machine_kexec_mask_interrupts</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call registered shutdown routines safely.  Swap out</span>
<span class="cm">	 * __debugger_fault_handler, and replace on exit.</span>
<span class="cm">	 */</span>
	<span class="n">old_handler</span> <span class="o">=</span> <span class="n">__debugger_fault_handler</span><span class="p">;</span>
	<span class="n">__debugger_fault_handler</span> <span class="o">=</span> <span class="n">handle_fault</span><span class="p">;</span>
	<span class="n">crash_shutdown_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">crash_shutdown_handles</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">setjmp</span><span class="p">(</span><span class="n">crash_shutdown_buf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Insert syncs and delay to ensure</span>
<span class="cm">			 * instructions in the dangerous region don&#39;t</span>
<span class="cm">			 * leak away from this protected region.</span>
<span class="cm">			 */</span>
			<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;sync; isync&quot;</span><span class="p">);</span>
			<span class="cm">/* dangerous region */</span>
			<span class="n">crash_shutdown_handles</span><span class="p">[</span><span class="n">i</span><span class="p">]();</span>
			<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;sync; isync&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">crash_shutdown_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">__debugger_fault_handler</span> <span class="o">=</span> <span class="n">old_handler</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ppc_md</span><span class="p">.</span><span class="n">kexec_cpu_down</span><span class="p">)</span>
		<span class="n">ppc_md</span><span class="p">.</span><span class="n">kexec_cpu_down</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
