<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › kernel › signal_32.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>signal_32.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Signal handling for 32bit PPC and 32bit tasks on 64bit PPC</span>
<span class="cm"> *</span>
<span class="cm"> *  PowerPC version</span>
<span class="cm"> *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)</span>
<span class="cm"> * Copyright (C) 2001 IBM</span>
<span class="cm"> * Copyright (C) 1997,1998 Jakub Jelinek (jj@sunsite.mff.cuni.cz)</span>
<span class="cm"> * Copyright (C) 1997 David S. Miller (davem@caip.rutgers.edu)</span>
<span class="cm"> *</span>
<span class="cm"> *  Derived from &quot;arch/i386/kernel/signal.c&quot;</span>
<span class="cm"> *    Copyright (C) 1991, 1992 Linus Torvalds</span>
<span class="cm"> *    1997-11-28  Modified for POSIX.1b signals by Richard Henderson</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or</span>
<span class="cm"> *  modify it under the terms of the GNU General Public License</span>
<span class="cm"> *  as published by the Free Software Foundation; either version</span>
<span class="cm"> *  2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/binfmts.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/syscalls.h&gt;</span>
<span class="cp">#include &lt;asm/sigcontext.h&gt;</span>
<span class="cp">#include &lt;asm/vdso.h&gt;</span>
<span class="cp">#include &lt;asm/switch_to.h&gt;</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cp">#include &quot;ppc32.h&quot;</span>
<span class="cp">#include &lt;asm/unistd.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;asm/ucontext.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &quot;signal.h&quot;</span>

<span class="cp">#undef DEBUG_SIG</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="cp">#define sys_sigsuspend	compat_sys_sigsuspend</span>
<span class="cp">#define sys_rt_sigsuspend	compat_sys_rt_sigsuspend</span>
<span class="cp">#define sys_rt_sigreturn	compat_sys_rt_sigreturn</span>
<span class="cp">#define sys_sigaction	compat_sys_sigaction</span>
<span class="cp">#define sys_swapcontext	compat_sys_swapcontext</span>
<span class="cp">#define sys_sigreturn	compat_sys_sigreturn</span>

<span class="cp">#define old_sigaction	old_sigaction32</span>
<span class="cp">#define sigcontext	sigcontext32</span>
<span class="cp">#define mcontext	mcontext32</span>
<span class="cp">#define ucontext	ucontext32</span>

<span class="cm">/*</span>
<span class="cm"> * Userspace code may pass a ucontext which doesn&#39;t include VSX added</span>
<span class="cm"> * at the end.  We need to check for this case.</span>
<span class="cm"> */</span>
<span class="cp">#define UCONTEXTSIZEWITHOUTVSX \</span>
<span class="cp">		(sizeof(struct ucontext) - sizeof(elf_vsrreghalf_t32))</span>

<span class="cm">/*</span>
<span class="cm"> * Returning 0 means we return to userspace via</span>
<span class="cm"> * ret_from_except and thus restore all user</span>
<span class="cm"> * registers from *regs.  This is what we need</span>
<span class="cm"> * to do when a signal has been delivered.</span>
<span class="cm"> */</span>

<span class="cp">#define GP_REGS_SIZE	min(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))</span>
<span class="cp">#undef __SIGNAL_FRAMESIZE</span>
<span class="cp">#define __SIGNAL_FRAMESIZE	__SIGNAL_FRAMESIZE32</span>
<span class="cp">#undef ELF_NVRREG</span>
<span class="cp">#define ELF_NVRREG	ELF_NVRREG32</span>

<span class="cm">/*</span>
<span class="cm"> * Functions for flipping sigsets (thanks to brain dead generic</span>
<span class="cm"> * implementation that makes things simple for little endian only)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">put_sigset_t</span><span class="p">(</span><span class="n">compat_sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uset</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">compat_sigset_t</span>	<span class="n">cset</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">_NSIG_WORDS</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">4</span>: <span class="n">cset</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffffffffull</span><span class="p">;</span>
		<span class="n">cset</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>: <span class="n">cset</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffffffffull</span><span class="p">;</span>
		<span class="n">cset</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="n">cset</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffffffffull</span><span class="p">;</span>
		<span class="n">cset</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="n">cset</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffffffffull</span><span class="p">;</span>
		<span class="n">cset</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">uset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uset</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_sigset_t</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span>
			       <span class="k">const</span> <span class="n">compat_sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">compat_sigset_t</span> <span class="n">s32</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s32</span><span class="p">,</span> <span class="n">uset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uset</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Swap the 2 words of the 64-bit sigset_t (they are stored</span>
<span class="cm">	 * in the &quot;wrong&quot; endian in 32-bit user storage).</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">_NSIG_WORDS</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">4</span>: <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">s32</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">|</span> <span class="p">(((</span><span class="kt">long</span><span class="p">)</span><span class="n">s32</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="k">case</span> <span class="mi">3</span>: <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">s32</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">|</span> <span class="p">(((</span><span class="kt">long</span><span class="p">)</span><span class="n">s32</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s32</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span> <span class="p">(((</span><span class="kt">long</span><span class="p">)</span><span class="n">s32</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="n">set</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s32</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="p">(((</span><span class="kt">long</span><span class="p">)</span><span class="n">s32</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_old_sigaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">new_ka</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">old_sigaction</span> <span class="n">__user</span> <span class="o">*</span><span class="n">act</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">compat_old_sigset_t</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">compat_uptr_t</span> <span class="n">handler</span><span class="p">,</span> <span class="n">restorer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="o">-&gt;</span><span class="n">sa_handler</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">__get_user</span><span class="p">(</span><span class="n">restorer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="o">-&gt;</span><span class="n">sa_restorer</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">__get_user</span><span class="p">(</span><span class="n">new_ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="o">-&gt;</span><span class="n">sa_flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">__get_user</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="o">-&gt;</span><span class="n">sa_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">new_ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
	<span class="n">new_ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_restorer</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">restorer</span><span class="p">);</span>
	<span class="n">siginitset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define to_user_ptr(p)		ptr_to_compat(p)</span>
<span class="cp">#define from_user_ptr(p)	compat_ptr(p)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">save_general_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">mcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">elf_greg_t64</span> <span class="o">*</span><span class="n">gregs</span> <span class="o">=</span> <span class="p">(</span><span class="n">elf_greg_t64</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">FULL_REGS</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">PT_RESULT</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">14</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">FULL_REGS</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">gregs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">mc_gregs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">restore_general_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">mcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">elf_greg_t64</span> <span class="o">*</span><span class="n">gregs</span> <span class="o">=</span> <span class="p">(</span><span class="n">elf_greg_t64</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">PT_RESULT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="n">PT_MSR</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">PT_SOFTE</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">gregs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">sr</span><span class="o">-&gt;</span><span class="n">mc_gregs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>

<span class="cp">#define GP_REGS_SIZE	min(sizeof(elf_gregset_t), sizeof(struct pt_regs))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">put_sigset_t</span><span class="p">(</span><span class="n">sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uset</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">uset</span><span class="p">,</span> <span class="n">set</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uset</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_sigset_t</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">const</span> <span class="n">sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="n">uset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uset</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_old_sigaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">new_ka</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">old_sigaction</span> <span class="n">__user</span> <span class="o">*</span><span class="n">act</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">old_sigset_t</span> <span class="n">mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">act</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">act</span><span class="p">))</span> <span class="o">||</span>
			<span class="n">__get_user</span><span class="p">(</span><span class="n">new_ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="o">-&gt;</span><span class="n">sa_handler</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">__get_user</span><span class="p">(</span><span class="n">new_ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_restorer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="o">-&gt;</span><span class="n">sa_restorer</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">__get_user</span><span class="p">(</span><span class="n">new_ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="o">-&gt;</span><span class="n">sa_flags</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">__get_user</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="o">-&gt;</span><span class="n">sa_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">siginitset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define to_user_ptr(p)		((unsigned long)(p))</span>
<span class="cp">#define from_user_ptr(p)	((void __user *)(p))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">save_general_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">mcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">FULL_REGS</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">__copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">mc_gregs</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">GP_REGS_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">restore_general_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">mcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* copy up to but not including MSR */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sr</span><span class="o">-&gt;</span><span class="n">mc_gregs</span><span class="p">,</span>
				<span class="n">PT_MSR</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">elf_greg_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="cm">/* copy from orig_r3 (the word after the MSR) up to the end */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">orig_gpr3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sr</span><span class="o">-&gt;</span><span class="n">mc_gregs</span><span class="p">[</span><span class="n">PT_ORIG_R3</span><span class="p">],</span>
				<span class="n">GP_REGS_SIZE</span> <span class="o">-</span> <span class="n">PT_ORIG_R3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">elf_greg_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Atomically swap in the new signal mask, and wait for a signal.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">sys_sigsuspend</span><span class="p">(</span><span class="n">old_sigset_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigset_t</span> <span class="n">blocked</span><span class="p">;</span>
	<span class="n">siginitset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocked</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocked</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">sys_sigaction</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">old_sigaction</span> <span class="n">__user</span> <span class="o">*</span><span class="n">act</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">old_sigaction</span> <span class="n">__user</span> <span class="o">*</span><span class="n">oact</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">k_sigaction</span> <span class="n">new_ka</span><span class="p">,</span> <span class="n">old_ka</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sig</span> <span class="o">=</span> <span class="o">-</span><span class="n">sig</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">act</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_old_sigaction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ka</span><span class="p">,</span> <span class="n">act</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_sigaction</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">act</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">new_ka</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">oact</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">old_ka</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">oact</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">oact</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">oact</span><span class="p">))</span> <span class="o">||</span>
		    <span class="n">__put_user</span><span class="p">(</span><span class="n">to_user_ptr</span><span class="p">(</span><span class="n">old_ka</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span><span class="p">),</span>
			    <span class="o">&amp;</span><span class="n">oact</span><span class="o">-&gt;</span><span class="n">sa_handler</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">__put_user</span><span class="p">(</span><span class="n">to_user_ptr</span><span class="p">(</span><span class="n">old_ka</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_restorer</span><span class="p">),</span>
			    <span class="o">&amp;</span><span class="n">oact</span><span class="o">-&gt;</span><span class="n">sa_restorer</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">__put_user</span><span class="p">(</span><span class="n">old_ka</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oact</span><span class="o">-&gt;</span><span class="n">sa_flags</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">__put_user</span><span class="p">(</span><span class="n">old_ka</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">oact</span><span class="o">-&gt;</span><span class="n">sa_mask</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When we have signals to deliver, we set up on the</span>
<span class="cm"> * user stack, going down from the original stack pointer:</span>
<span class="cm"> *	an ABI gap of 56 words</span>
<span class="cm"> *	an mcontext struct</span>
<span class="cm"> *	a sigcontext struct</span>
<span class="cm"> *	a gap of __SIGNAL_FRAMESIZE bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Each of these things must be a multiple of 16 bytes in size. The following</span>
<span class="cm"> * structure represent all of this except the __SIGNAL_FRAMESIZE gap</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sigframe</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sigcontext</span> <span class="n">sctx</span><span class="p">;</span>		<span class="cm">/* the sigcontext */</span>
	<span class="k">struct</span> <span class="n">mcontext</span>	<span class="n">mctx</span><span class="p">;</span>		<span class="cm">/* all the register values */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Programs using the rs6000/xcoff abi can save up to 19 gp</span>
<span class="cm">	 * regs and 18 fp regs below sp before decrementing it.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="n">abigap</span><span class="p">[</span><span class="mi">56</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* We use the mc_pad field for the signal return trampoline. */</span>
<span class="cp">#define tramp	mc_pad</span>

<span class="cm">/*</span>
<span class="cm"> *  When we have rt signals to deliver, we set up on the</span>
<span class="cm"> *  user stack, going down from the original stack pointer:</span>
<span class="cm"> *	one rt_sigframe struct (siginfo + ucontext + ABI gap)</span>
<span class="cm"> *	a gap of __SIGNAL_FRAMESIZE+16 bytes</span>
<span class="cm"> *  (the +16 is to get the siginfo and ucontext in the same</span>
<span class="cm"> *  positions as in older kernels).</span>
<span class="cm"> *</span>
<span class="cm"> *  Each of these things must be a multiple of 16 bytes in size.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rt_sigframe</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="n">compat_siginfo_t</span> <span class="n">info</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">info</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">ucontext</span>	<span class="n">uc</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Programs using the rs6000/xcoff abi can save up to 19 gp</span>
<span class="cm">	 * regs and 18 fp regs below sp before decrementing it.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="n">abigap</span><span class="p">[</span><span class="mi">56</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_VSX</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">copy_fpr_to_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">double</span> <span class="n">buf</span><span class="p">[</span><span class="n">ELF_NFPREG</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* save FPR copy to local buffer then write to the thread_struct */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ELF_NFPREG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">TS_FPR</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpscr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">__copy_to_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ELF_NFPREG</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">copy_fpr_from_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">double</span> <span class="n">buf</span><span class="p">[</span><span class="n">ELF_NFPREG</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">ELF_NFPREG</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ELF_NFPREG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">TS_FPR</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpscr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">copy_vsx_to_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">double</span> <span class="n">buf</span><span class="p">[</span><span class="n">ELF_NVSRHALFREG</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* save FPR copy to local buffer then write to the thread_struct */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ELF_NVSRHALFREG</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">TS_VSRLOWOFFSET</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">__copy_to_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ELF_NVSRHALFREG</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">copy_vsx_from_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">double</span> <span class="n">buf</span><span class="p">[</span><span class="n">ELF_NVSRHALFREG</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">ELF_NVSRHALFREG</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ELF_NVSRHALFREG</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">TS_VSRLOWOFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">copy_fpr_to_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__copy_to_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpr</span><span class="p">,</span>
			      <span class="n">ELF_NFPREG</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">copy_fpr_from_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
					<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__copy_from_user</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpr</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span>
			      <span class="n">ELF_NFPREG</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Save the current user registers on the user stack.</span>
<span class="cm"> * We only save the altivec/spe registers if the process has used</span>
<span class="cm"> * altivec/spe instructions at some point.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">save_user_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">sigret</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ctx_has_vsx_region</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msr</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span><span class="p">;</span>

	<span class="cm">/* Make sure floating point registers are stored in regs */</span>
	<span class="n">flush_fp_to_thread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="cm">/* save general registers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">save_general_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">frame</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_ALTIVEC</span>
	<span class="cm">/* save altivec registers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">used_vr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush_altivec_to_thread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">mc_vregs</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vr</span><span class="p">,</span>
				   <span class="n">ELF_NVRREG</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vector128</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* set MSR_VEC in the saved MSR value to indicate that</span>
<span class="cm">		   frame-&gt;mc_vregs contains valid data */</span>
		<span class="n">msr</span> <span class="o">|=</span> <span class="n">MSR_VEC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* else assert((regs-&gt;msr &amp; MSR_VEC) == 0) */</span>

	<span class="cm">/* We always copy to/from vrsave, it&#39;s 0 if we don&#39;t have or don&#39;t</span>
<span class="cm">	 * use altivec. Since VSCR only contains 32 bits saved in the least</span>
<span class="cm">	 * significant bits of a vector, we &quot;cheat&quot; and stuff VRSAVE in the</span>
<span class="cm">	 * most significant bits of that same vector. --BenH</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vrsave</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">mc_vregs</span><span class="p">[</span><span class="mi">32</span><span class="p">]))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ALTIVEC */</span><span class="cp"></span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_fpr_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">mc_fregs</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_VSX</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy VSR 0-31 upper half from thread_struct to local</span>
<span class="cm">	 * buffer, then write that to userspace.  Also set MSR_VSX in</span>
<span class="cm">	 * the saved MSR value to indicate that frame-&gt;mc_vregs</span>
<span class="cm">	 * contains valid data</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">used_vsr</span> <span class="o">&amp;&amp;</span> <span class="n">ctx_has_vsx_region</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__giveup_vsx</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_vsx_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">mc_vsregs</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">msr</span> <span class="o">|=</span> <span class="n">MSR_VSX</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_VSX */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_SPE</span>
	<span class="cm">/* save spe registers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">used_spe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush_spe_to_thread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">mc_vregs</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">evr</span><span class="p">,</span>
				   <span class="n">ELF_NEVRREG</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* set MSR_SPE in the saved MSR value to indicate that</span>
<span class="cm">		   frame-&gt;mc_vregs contains valid data */</span>
		<span class="n">msr</span> <span class="o">|=</span> <span class="n">MSR_SPE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* else assert((regs-&gt;msr &amp; MSR_SPE) == 0) */</span>

	<span class="cm">/* We always copy to/from spefscr */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">spefscr</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">mc_vregs</span> <span class="o">+</span> <span class="n">ELF_NEVRREG</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SPE */</span><span class="cp"></span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="n">msr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">mc_gregs</span><span class="p">[</span><span class="n">PT_MSR</span><span class="p">]))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set up the sigreturn trampoline: li r0,sigret; sc */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="mh">0x38000000UL</span> <span class="o">+</span> <span class="n">sigret</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		    <span class="o">||</span> <span class="n">__put_user</span><span class="p">(</span><span class="mh">0x44000002UL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Restore the current user register values from the user stack,</span>
<span class="cm"> * (except for MSR).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">restore_user_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">mcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">save_r2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msr</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_VSX</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * restore general registers but not including MSR or SOFTE. Also</span>
<span class="cm">	 * take care of keeping r2 (TLS) intact if not a signal</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig</span><span class="p">)</span>
		<span class="n">save_r2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">restore_general_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">sr</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">trap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">msr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sr</span><span class="o">-&gt;</span><span class="n">mc_gregs</span><span class="p">[</span><span class="n">PT_MSR</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig</span><span class="p">)</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">save_r2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* if doing signal return, restore the previous little-endian mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span><span class="p">)</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">=</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MSR_LE</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_LE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do this before updating the thread state in</span>
<span class="cm">	 * current-&gt;thread.fpr/vr/evr.  That way, if we get preempted</span>
<span class="cm">	 * and another task grabs the FPU/Altivec/SPE, it won&#39;t be</span>
<span class="cm">	 * tempted to save the current CPU state into the thread_struct</span>
<span class="cm">	 * and corrupt what we are writing there.</span>
<span class="cm">	 */</span>
	<span class="n">discard_lazy_cpu_state</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_ALTIVEC</span>
	<span class="cm">/*</span>
<span class="cm">	 * Force the process to reload the altivec registers from</span>
<span class="cm">	 * current-&gt;thread when it next does altivec instructions</span>
<span class="cm">	 */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSR_VEC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_VEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* restore altivec registers from the stack */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sr</span><span class="o">-&gt;</span><span class="n">mc_vregs</span><span class="p">,</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="n">sr</span><span class="o">-&gt;</span><span class="n">mc_vregs</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">used_vr</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ELF_NVRREG</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vector128</span><span class="p">));</span>

	<span class="cm">/* Always get VRSAVE back */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vrsave</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sr</span><span class="o">-&gt;</span><span class="n">mc_vregs</span><span class="p">[</span><span class="mi">32</span><span class="p">]))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ALTIVEC */</span><span class="cp"></span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_fpr_from_user</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sr</span><span class="o">-&gt;</span><span class="n">mc_fregs</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_VSX</span>
	<span class="cm">/*</span>
<span class="cm">	 * Force the process to reload the VSX registers from</span>
<span class="cm">	 * current-&gt;thread when it next does VSX instruction.</span>
<span class="cm">	 */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSR_VSX</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_VSX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Restore altivec registers from the stack to a local</span>
<span class="cm">		 * buffer, then write this out to the thread_struct</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_vsx_from_user</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sr</span><span class="o">-&gt;</span><span class="n">mc_vsregs</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">used_vsr</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">TS_VSRLOWOFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_VSX */</span><span class="cp"></span>
	<span class="cm">/*</span>
<span class="cm">	 * force the process to reload the FP registers from</span>
<span class="cm">	 * current-&gt;thread when it next does FP instructions</span>
<span class="cm">	 */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MSR_FP</span> <span class="o">|</span> <span class="n">MSR_FE0</span> <span class="o">|</span> <span class="n">MSR_FE1</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SPE</span>
	<span class="cm">/* force the process to reload the spe registers from</span>
<span class="cm">	   current-&gt;thread when it next does spe instructions */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSR_SPE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_SPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* restore spe registers from the stack */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">evr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sr</span><span class="o">-&gt;</span><span class="n">mc_vregs</span><span class="p">,</span>
				     <span class="n">ELF_NEVRREG</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">used_spe</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">evr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ELF_NEVRREG</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>

	<span class="cm">/* Always get SPEFSCR back */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">spefscr</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sr</span><span class="o">-&gt;</span><span class="n">mc_vregs</span> <span class="o">+</span> <span class="n">ELF_NEVRREG</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SPE */</span><span class="cp"></span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
<span class="kt">long</span> <span class="nf">compat_sys_rt_sigaction</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sigaction32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">act</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sigaction32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">oact</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sigsetsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">k_sigaction</span> <span class="n">new_ka</span><span class="p">,</span> <span class="n">old_ka</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* XXX: Don&#39;t preclude handling different sized sigset_t&#39;s.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigsetsize</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">compat_sigset_t</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">act</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">compat_uptr_t</span> <span class="n">handler</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="o">-&gt;</span><span class="n">sa_handler</span><span class="p">);</span>
		<span class="n">new_ka</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">get_sigset_t</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ka</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="o">-&gt;</span><span class="n">sa_mask</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">new_ka</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="o">-&gt;</span><span class="n">sa_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_sigaction</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">act</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">new_ka</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">oact</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">old_ka</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">oact</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">to_user_ptr</span><span class="p">(</span><span class="n">old_ka</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">oact</span><span class="o">-&gt;</span><span class="n">sa_handler</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">put_sigset_t</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oact</span><span class="o">-&gt;</span><span class="n">sa_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_ka</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">old_ka</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oact</span><span class="o">-&gt;</span><span class="n">sa_flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Note: it is necessary to treat how as an unsigned int, with the</span>
<span class="cm"> * corresponding cast to a signed int to insure that the proper</span>
<span class="cm"> * conversion (sign extension) between the register representation</span>
<span class="cm"> * of a signed int (msr in 32-bit mode) and the register representation</span>
<span class="cm"> * of a signed int (msr in 64-bit mode) is performed.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">compat_sys_rt_sigprocmask</span><span class="p">(</span><span class="n">u32</span> <span class="n">how</span><span class="p">,</span> <span class="n">compat_sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span>
		<span class="n">compat_sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">oset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sigsetsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigset_t</span> <span class="n">s</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">up</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">mm_segment_t</span> <span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_sigset_t</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="n">set</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="cm">/* This is valid because of the set_fs() */</span>
	<span class="n">up</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sys_rt_sigprocmask</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">how</span><span class="p">,</span> <span class="n">set</span> <span class="o">?</span> <span class="n">up</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">oset</span> <span class="o">?</span> <span class="n">up</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span>
				 <span class="n">sigsetsize</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oset</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_sigset_t</span><span class="p">(</span><span class="n">oset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">compat_sys_rt_sigpending</span><span class="p">(</span><span class="n">compat_sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="n">compat_size_t</span> <span class="n">sigsetsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigset_t</span> <span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">mm_segment_t</span> <span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="cm">/* The __user pointer cast is valid because of the set_fs() */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sys_rt_sigpending</span><span class="p">((</span><span class="n">sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="n">sigsetsize</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_sigset_t</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">copy_siginfo_to_user32</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_siginfo</span> <span class="n">__user</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span> <span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* If you change siginfo_t structure, please be sure</span>
<span class="cm">	 * this code is fixed accordingly.</span>
<span class="cm">	 * It should never copy any pad contained in the structure</span>
<span class="cm">	 * to avoid security leaks, but must copy the generic</span>
<span class="cm">	 * 3 ints plus the relevant union member.</span>
<span class="cm">	 * This routine must convert siginfo from 64bit to 32bit as well</span>
<span class="cm">	 * at the same time.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_errno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_errno</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">((</span><span class="kt">short</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_code</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">_sifields</span><span class="p">.</span><span class="n">_pad</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">_sifields</span><span class="p">.</span><span class="n">_pad</span><span class="p">,</span>
				      <span class="n">SI_PAD_SIZE32</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">switch</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">__SI_CHLD</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span>:
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_utime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_utime</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_stime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_stime</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">__SI_FAULT</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span>:
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_addr</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">__SI_POLL</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span>:
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_band</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_band</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_fd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">__SI_TIMER</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span>:
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_tid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_tid</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_overrun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_overrun</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_int</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_int</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">__SI_RT</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span>: <span class="cm">/* This is not generated by the kernel as of now.  */</span>
	<span class="k">case</span> <span class="n">__SI_MESGQ</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span>:
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_int</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_int</span><span class="p">);</span>
		<span class="cm">/* fallthrough */</span>
	<span class="k">case</span> <span class="n">__SI_KILL</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span>:
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define copy_siginfo_to_user	copy_siginfo_to_user32</span>

<span class="kt">int</span> <span class="nf">copy_siginfo_from_user32</span><span class="p">(</span><span class="n">siginfo_t</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">compat_siginfo</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">to</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">copy_from_user</span><span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">_sifields</span><span class="p">.</span><span class="n">_pad</span><span class="p">,</span>
			   <span class="n">from</span><span class="o">-&gt;</span><span class="n">_sifields</span><span class="p">.</span><span class="n">_pad</span><span class="p">,</span> <span class="n">SI_PAD_SIZE32</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Note: it is necessary to treat pid and sig as unsigned ints, with the</span>
<span class="cm"> * corresponding cast to a signed int to insure that the proper conversion</span>
<span class="cm"> * (sign extension) between the register representation of a signed int</span>
<span class="cm"> * (msr in 32-bit mode) and the register representation of a signed int</span>
<span class="cm"> * (msr in 64-bit mode) is performed.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">compat_sys_rt_sigqueueinfo</span><span class="p">(</span><span class="n">u32</span> <span class="n">pid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sig</span><span class="p">,</span> <span class="n">compat_siginfo_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">siginfo_t</span> <span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">mm_segment_t</span> <span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_siginfo_from_user32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">uinfo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">set_fs</span> <span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="cm">/* The __user pointer cast is valid becasuse of the set_fs() */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sys_rt_sigqueueinfo</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">sig</span><span class="p">,</span> <span class="p">(</span><span class="n">siginfo_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="n">set_fs</span> <span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> *  Start Alternate signal stack support</span>
<span class="cm"> *</span>
<span class="cm"> *  System Calls</span>
<span class="cm"> *       sigaltatck               compat_sys_sigaltstack</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">compat_sys_sigaltstack</span><span class="p">(</span><span class="n">u32</span> <span class="n">__new</span><span class="p">,</span> <span class="n">u32</span> <span class="n">__old</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r5</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">r6</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r7</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r8</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">stack_32_t</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">newstack</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">__new</span><span class="p">);</span>
	<span class="n">stack_32_t</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">oldstack</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">__old</span><span class="p">);</span>
	<span class="n">stack_t</span> <span class="n">uss</span><span class="p">,</span> <span class="n">uoss</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">mm_segment_t</span> <span class="n">old_fs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">;</span>
	<span class="n">compat_uptr_t</span> <span class="n">ss_sp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * set sp to the user stack on entry to the system call</span>
<span class="cm">	 * the system call router sets R9 to the saved registers</span>
<span class="cm">	 */</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* Put new stack info in local 64 bit stack struct */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newstack</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ss_sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newstack</span><span class="o">-&gt;</span><span class="n">ss_sp</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">__get_user</span><span class="p">(</span><span class="n">uss</span><span class="p">.</span><span class="n">ss_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newstack</span><span class="o">-&gt;</span><span class="n">ss_flags</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">__get_user</span><span class="p">(</span><span class="n">uss</span><span class="p">.</span><span class="n">ss_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newstack</span><span class="o">-&gt;</span><span class="n">ss_size</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">uss</span><span class="p">.</span><span class="n">ss_sp</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">ss_sp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="cm">/* The __user pointer casts are valid because of the set_fs() */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_sigaltstack</span><span class="p">(</span>
		<span class="n">newstack</span> <span class="o">?</span> <span class="p">(</span><span class="n">stack_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">uss</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span>
		<span class="n">oldstack</span> <span class="o">?</span> <span class="p">(</span><span class="n">stack_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">uoss</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span>
		<span class="n">sp</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>
	<span class="cm">/* Copy the stack information to the user output buffer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">oldstack</span>  <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">ptr_to_compat</span><span class="p">(</span><span class="n">uoss</span><span class="p">.</span><span class="n">ss_sp</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">oldstack</span><span class="o">-&gt;</span><span class="n">ss_sp</span><span class="p">)</span> <span class="o">||</span>
		 <span class="n">__put_user</span><span class="p">(</span><span class="n">uoss</span><span class="p">.</span><span class="n">ss_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldstack</span><span class="o">-&gt;</span><span class="n">ss_flags</span><span class="p">)</span> <span class="o">||</span>
		 <span class="n">__put_user</span><span class="p">(</span><span class="n">uoss</span><span class="p">.</span><span class="n">ss_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldstack</span><span class="o">-&gt;</span><span class="n">ss_size</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Set up a signal frame for a &quot;real-time&quot; signal handler</span>
<span class="cm"> * (one which gets siginfo).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">handle_rt_signal32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">ka</span><span class="p">,</span>
		<span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">oldset</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_sigframe</span> <span class="n">__user</span> <span class="o">*</span><span class="n">rt_sf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newsp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set up Signal Frame */</span>
	<span class="cm">/* Put a Real Time Context onto stack */</span>
	<span class="n">rt_sf</span> <span class="o">=</span> <span class="n">get_sigframe</span><span class="p">(</span><span class="n">ka</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rt_sf</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">rt_sf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rt_sf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>

	<span class="cm">/* Put the siginfo &amp; fill in most of the ucontext */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_siginfo_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_sf</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt_sf</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_flags</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt_sf</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_link</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt_sf</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_sp</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">sas_ss_flags</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
			  <span class="o">&amp;</span><span class="n">rt_sf</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_flags</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt_sf</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_stack</span><span class="p">.</span><span class="n">ss_size</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">to_user_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_sf</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_mcontext</span><span class="p">),</span>
		    <span class="o">&amp;</span><span class="n">rt_sf</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_regs</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">put_sigset_t</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_sf</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_sigmask</span><span class="p">,</span> <span class="n">oldset</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>

	<span class="cm">/* Save user registers on the stack */</span>
	<span class="n">frame</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_sf</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_mcontext</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vdso32_rt_sigtramp</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">vdso_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">save_user_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">vdso_base</span> <span class="o">+</span> <span class="n">vdso32_rt_sigtramp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">save_user_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">__NR_rt_sigreturn</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">tramp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpscr</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* turn off all fp exceptions */</span>

	<span class="cm">/* create a stack frame for the caller of the handler */</span>
	<span class="n">newsp</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">rt_sf</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">__SIGNAL_FRAMESIZE</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">newsp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>

	<span class="cm">/* Fill registers for signal handler */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">newsp</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">rt_sf</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">rt_sf</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">rt_sf</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span><span class="p">;</span>
	<span class="cm">/* enter the signal handler in big-endian mode */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSR_LE</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">badframe:</span>
<span class="cp">#ifdef DEBUG_SIG</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;badframe in handle_rt_signal, regs=%p frame=%p newsp=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">newsp</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">show_unhandled_signals</span><span class="p">)</span>
		<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_INFO</span>
				   <span class="s">&quot;%s[%d]: bad frame in handle_rt_signal32: &quot;</span>
				   <span class="s">&quot;%p nip %08lx lr %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				   <span class="n">addr</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

	<span class="n">force_sigsegv</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_setcontext</span><span class="p">(</span><span class="k">struct</span> <span class="n">ucontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ucp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigset_t</span> <span class="n">set</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">mcp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_sigset_t</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ucp</span><span class="o">-&gt;</span><span class="n">uc_sigmask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="p">{</span>
		<span class="n">u32</span> <span class="n">cmcp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">cmcp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ucp</span><span class="o">-&gt;</span><span class="n">uc_regs</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">mcp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="n">u64</span><span class="p">)</span><span class="n">cmcp</span><span class="p">;</span>
		<span class="cm">/* no need to check access_ok(mcp), since mcp &lt; 4GB */</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">mcp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ucp</span><span class="o">-&gt;</span><span class="n">uc_regs</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">mcp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mcp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">set_current_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">restore_user_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">mcp</span><span class="p">,</span> <span class="n">sig</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">sys_swapcontext</span><span class="p">(</span><span class="k">struct</span> <span class="n">ucontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">old_ctx</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ucontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">new_ctx</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">ctx_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r6</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r7</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r8</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctx_has_vsx_region</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_msr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">mcp</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">cmcp</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get pointer to the real mcontext.  No need for</span>
<span class="cm">		 * access_ok since we are dealing with compat</span>
<span class="cm">		 * pointers.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">cmcp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_ctx</span><span class="o">-&gt;</span><span class="n">uc_regs</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">mcp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="n">u64</span><span class="p">)</span><span class="n">cmcp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">new_msr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mcp</span><span class="o">-&gt;</span><span class="n">mc_gregs</span><span class="p">[</span><span class="n">PT_MSR</span><span class="p">]))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check that the context is not smaller than the original</span>
<span class="cm">	 * size (with VMX but without VSX)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx_size</span> <span class="o">&lt;</span> <span class="n">UCONTEXTSIZEWITHOUTVSX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the new context state sets the MSR VSX bits but</span>
<span class="cm">	 * it doesn&#39;t provide VSX state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ctx_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ucontext</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">new_msr</span> <span class="o">&amp;</span> <span class="n">MSR_VSX</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/* Does the context have enough room to store VSX data? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx_size</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ucontext</span><span class="p">))</span>
		<span class="n">ctx_has_vsx_region</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="cm">/* Context size is for future use. Right now, we only make sure</span>
<span class="cm">	 * we are passed something we understand</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ucontext</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_ctx</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">mctx</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * old_ctx might not be 16-byte aligned, in which</span>
<span class="cm">		 * case old_ctx-&gt;uc_mcontext won&#39;t be either.</span>
<span class="cm">		 * Because we have the old_ctx-&gt;uc_pad2 field</span>
<span class="cm">		 * before old_ctx-&gt;uc_mcontext, we need to round down</span>
<span class="cm">		 * from &amp;old_ctx-&gt;uc_mcontext to a 16-byte boundary.</span>
<span class="cm">		 */</span>
		<span class="n">mctx</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">old_ctx</span><span class="o">-&gt;</span><span class="n">uc_mcontext</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xfUL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">old_ctx</span><span class="p">,</span> <span class="n">ctx_size</span><span class="p">)</span>
		    <span class="o">||</span> <span class="n">save_user_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">mctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx_has_vsx_region</span><span class="p">)</span>
		    <span class="o">||</span> <span class="n">put_sigset_t</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_ctx</span><span class="o">-&gt;</span><span class="n">uc_sigmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">)</span>
		    <span class="o">||</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">to_user_ptr</span><span class="p">(</span><span class="n">mctx</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">old_ctx</span><span class="o">-&gt;</span><span class="n">uc_regs</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">new_ctx</span><span class="p">,</span> <span class="n">ctx_size</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">new_ctx</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">new_ctx</span> <span class="o">+</span> <span class="n">ctx_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we get a fault copying the context into the kernel&#39;s</span>
<span class="cm">	 * image of the user&#39;s registers, we can&#39;t just return -EFAULT</span>
<span class="cm">	 * because the user&#39;s registers will be corrupted.  For instance</span>
<span class="cm">	 * the NIP value may have been updated but not some of the</span>
<span class="cm">	 * other registers.  Given that we have done the access_ok</span>
<span class="cm">	 * and successfully read the first and last bytes of the region</span>
<span class="cm">	 * above, this should only happen in an out-of-memory situation</span>
<span class="cm">	 * or if another thread unmaps the region containing the context.</span>
<span class="cm">	 * We kill the task with a SIGSEGV in this situation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_setcontext</span><span class="p">(</span><span class="n">new_ctx</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">do_exit</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">);</span>

	<span class="n">set_thread_flag</span><span class="p">(</span><span class="n">TIF_RESTOREALL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">sys_rt_sigreturn</span><span class="p">(</span><span class="kt">int</span> <span class="n">r3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r4</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r5</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r6</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r7</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r8</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_sigframe</span> <span class="n">__user</span> <span class="o">*</span><span class="n">rt_sf</span><span class="p">;</span>

	<span class="cm">/* Always make any pending restarted system calls return -EINTR */</span>
	<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">restart_block</span><span class="p">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">do_no_restart_syscall</span><span class="p">;</span>

	<span class="n">rt_sf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt_sigframe</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">__SIGNAL_FRAMESIZE</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">rt_sf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rt_sf</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_setcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_sf</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s not clear whether or why it is desirable to save the</span>
<span class="cm">	 * sigaltstack setting on signal delivery and restore it on</span>
<span class="cm">	 * signal return.  But other architectures do this and we have</span>
<span class="cm">	 * always done it up until now so it is probably better not to</span>
<span class="cm">	 * change it.  -- paulus</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="cm">/*</span>
<span class="cm">	 * We use the compat_sys_ version that does the 32/64 bits conversion</span>
<span class="cm">	 * and takes userland pointer directly. What about error checking ?</span>
<span class="cm">	 * nobody does any...</span>
<span class="cm">	 */</span>
	<span class="n">compat_sys_sigaltstack</span><span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">u64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rt_sf</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_stack</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">do_sigaltstack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_sf</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">.</span><span class="n">uc_stack</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="cp">#endif</span>
	<span class="n">set_thread_flag</span><span class="p">(</span><span class="n">TIF_RESTOREALL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">bad:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">show_unhandled_signals</span><span class="p">)</span>
		<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_INFO</span>
				   <span class="s">&quot;%s[%d]: bad frame in sys_rt_sigreturn: &quot;</span>
				   <span class="s">&quot;%p nip %08lx lr %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				   <span class="n">rt_sf</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC32</span>
<span class="kt">int</span> <span class="nf">sys_debug_setcontext</span><span class="p">(</span><span class="k">struct</span> <span class="n">ucontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">ndbg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sig_dbg_op</span> <span class="n">__user</span> <span class="o">*</span><span class="n">dbg</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">r6</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r7</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r8</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sig_dbg_op</span> <span class="n">op</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_msr</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PPC_ADV_DEBUG_REGS</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_dbcr0</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dbcr0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ndbg</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="n">dbg</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">op</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">dbg_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SIG_DBG_SINGLE_STEPPING</span>:
<span class="cp">#ifdef CONFIG_PPC_ADV_DEBUG_REGS</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">dbg_value</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">new_msr</span> <span class="o">|=</span> <span class="n">MSR_DE</span><span class="p">;</span>
				<span class="n">new_dbcr0</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DBCR0_IDM</span> <span class="o">|</span> <span class="n">DBCR0_IC</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">new_dbcr0</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DBCR0_IC</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DBCR_ACTIVE_EVENTS</span><span class="p">(</span><span class="n">new_dbcr0</span><span class="p">,</span>
						<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dbcr1</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">new_msr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSR_DE</span><span class="p">;</span>
					<span class="n">new_dbcr0</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DBCR0_IDM</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
<span class="cp">#else</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">dbg_value</span><span class="p">)</span>
				<span class="n">new_msr</span> <span class="o">|=</span> <span class="n">MSR_SE</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">new_msr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSR_SE</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SIG_DBG_BRANCH_TRACING</span>:
<span class="cp">#ifdef CONFIG_PPC_ADV_DEBUG_REGS</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#else</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">dbg_value</span><span class="p">)</span>
				<span class="n">new_msr</span> <span class="o">|=</span> <span class="n">MSR_BE</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">new_msr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSR_BE</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* We wait until here to actually install the values in the</span>
<span class="cm">	   registers so if we fail in the above loop, it will not</span>
<span class="cm">	   affect the contents of these registers.  After this point,</span>
<span class="cm">	   failure is a problem, anyway, and it&#39;s very unlikely unless</span>
<span class="cm">	   the user is really doing something wrong. */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">=</span> <span class="n">new_msr</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PPC_ADV_DEBUG_REGS</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dbcr0</span> <span class="o">=</span> <span class="n">new_dbcr0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="p">))</span>
	    <span class="o">||</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">ctx</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we get a fault copying the context into the kernel&#39;s</span>
<span class="cm">	 * image of the user&#39;s registers, we can&#39;t just return -EFAULT</span>
<span class="cm">	 * because the user&#39;s registers will be corrupted.  For instance</span>
<span class="cm">	 * the NIP value may have been updated but not some of the</span>
<span class="cm">	 * other registers.  Given that we have done the access_ok</span>
<span class="cm">	 * and successfully read the first and last bytes of the region</span>
<span class="cm">	 * above, this should only happen in an out-of-memory situation</span>
<span class="cm">	 * or if another thread unmaps the region containing the context.</span>
<span class="cm">	 * We kill the task with a SIGSEGV in this situation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_setcontext</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">show_unhandled_signals</span><span class="p">)</span>
			<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s[%d]: bad frame in &quot;</span>
					   <span class="s">&quot;sys_debug_setcontext: %p nip %08lx &quot;</span>
					   <span class="s">&quot;lr %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
					   <span class="n">ctx</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

		<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s not clear whether or why it is desirable to save the</span>
<span class="cm">	 * sigaltstack setting on signal delivery and restore it on</span>
<span class="cm">	 * signal return.  But other architectures do this and we have</span>
<span class="cm">	 * always done it up until now so it is probably better not to</span>
<span class="cm">	 * change it.  -- paulus</span>
<span class="cm">	 */</span>
	<span class="n">do_sigaltstack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">uc_stack</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="n">set_thread_flag</span><span class="p">(</span><span class="n">TIF_RESTOREALL</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * OK, we&#39;re invoking a handler</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">handle_signal32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">ka</span><span class="p">,</span>
		    <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">oldset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sigcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sigframe</span> <span class="n">__user</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newsp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set up Signal Frame */</span>
	<span class="n">frame</span> <span class="o">=</span> <span class="n">get_sigframe</span><span class="p">(</span><span class="n">ka</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">frame</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">frame</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>
	<span class="n">sc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sigcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">sctx</span><span class="p">;</span>

<span class="cp">#if _NSIG != 64</span>
<span class="cp">#error &quot;Please adjust handle_signal()&quot;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="n">to_user_ptr</span><span class="p">(</span><span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">oldset</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">oldmask</span><span class="p">)</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	    <span class="o">||</span> <span class="n">__put_user</span><span class="p">((</span><span class="n">oldset</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">_unused</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="cp">#else</span>
	    <span class="o">||</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">oldset</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">_unused</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="cp">#endif</span>
	    <span class="o">||</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">to_user_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">mctx</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vdso32_sigtramp</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">vdso_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">save_user_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">mctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">vdso_base</span> <span class="o">+</span> <span class="n">vdso32_sigtramp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">save_user_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">mctx</span><span class="p">,</span> <span class="n">__NR_sigreturn</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">mctx</span><span class="p">.</span><span class="n">tramp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpscr</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* turn off all fp exceptions */</span>

	<span class="cm">/* create a stack frame for the caller of the handler */</span>
	<span class="n">newsp</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">frame</span><span class="p">)</span> <span class="o">-</span> <span class="n">__SIGNAL_FRAMESIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">newsp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>

	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">newsp</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">sc</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span><span class="p">;</span>
	<span class="cm">/* enter the signal handler in big-endian mode */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSR_LE</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">badframe:</span>
<span class="cp">#ifdef DEBUG_SIG</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;badframe in handle_signal, regs=%p frame=%p newsp=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">newsp</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">show_unhandled_signals</span><span class="p">)</span>
		<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_INFO</span>
				   <span class="s">&quot;%s[%d]: bad frame in handle_signal32: &quot;</span>
				   <span class="s">&quot;%p nip %08lx lr %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				   <span class="n">frame</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

	<span class="n">force_sigsegv</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do a signal return; undo the signal stack.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">sys_sigreturn</span><span class="p">(</span><span class="kt">int</span> <span class="n">r3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r4</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r5</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r6</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r7</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r8</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sigcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sigcontext</span> <span class="n">sigctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">set</span><span class="p">;</span>

	<span class="cm">/* Always make any pending restarted system calls return -EINTR */</span>
	<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">restart_block</span><span class="p">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">do_no_restart_syscall</span><span class="p">;</span>

	<span class="n">sc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sigcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">__SIGNAL_FRAMESIZE</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">sc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigctx</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sigctx</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note that PPC32 puts the upper 32 bits of the sigmask in the</span>
<span class="cm">	 * unused part of the signal stackframe</span>
<span class="cm">	 */</span>
	<span class="n">set</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigctx</span><span class="p">.</span><span class="n">oldmask</span> <span class="o">+</span> <span class="p">((</span><span class="kt">long</span><span class="p">)(</span><span class="n">sigctx</span><span class="p">.</span><span class="n">_unused</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">set</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigctx</span><span class="p">.</span><span class="n">oldmask</span><span class="p">;</span>
	<span class="n">set</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigctx</span><span class="p">.</span><span class="n">_unused</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="cp">#endif</span>
	<span class="n">set_current_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">);</span>

	<span class="n">sr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mcontext</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">from_user_ptr</span><span class="p">(</span><span class="n">sigctx</span><span class="p">.</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">sr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sr</span><span class="p">))</span>
	    <span class="o">||</span> <span class="n">restore_user_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">badframe</span><span class="p">;</span>

	<span class="n">set_thread_flag</span><span class="p">(</span><span class="n">TIF_RESTOREALL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">badframe:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">show_unhandled_signals</span><span class="p">)</span>
		<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_INFO</span>
				   <span class="s">&quot;%s[%d]: bad frame in sys_sigreturn: &quot;</span>
				   <span class="s">&quot;%p nip %08lx lr %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
				   <span class="n">addr</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
