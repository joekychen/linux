<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › sysdev › bestcomm › bestcomm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>bestcomm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Public header for the MPC52xx processor BestComm driver</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006      Sylvain Munaut &lt;tnt@246tNt.com&gt;</span>
<span class="cm"> * Copyright (C) 2005      Varma Electronics Oy,</span>
<span class="cm"> *                         ( by Andrey Volkov &lt;avolkov@varma-el.com&gt; )</span>
<span class="cm"> * Copyright (C) 2003-2004 MontaVista, Software, Inc.</span>
<span class="cm"> *                         ( by Dale Farnsworth &lt;dfarnsworth@mvista.com&gt; )</span>
<span class="cm"> *</span>
<span class="cm"> * This file is licensed under the terms of the GNU General Public License</span>
<span class="cm"> * version 2. This program is licensed &quot;as is&quot; without any warranty of any</span>
<span class="cm"> * kind, whether express or implied.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __BESTCOMM_H__</span>
<span class="cp">#define __BESTCOMM_H__</span>

<span class="cm">/**</span>
<span class="cm"> * struct bcom_bd - Structure describing a generic BestComm buffer descriptor</span>
<span class="cm"> * @status: The current status of this buffer. Exact meaning depends on the</span>
<span class="cm"> *          task type</span>
<span class="cm"> * @data: An array of u32 extra data.  Size of array is task dependent.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Don&#39;t dereference a bcom_bd pointer as an array.  The size of the</span>
<span class="cm"> *       bcom_bd is variable.  Use bcom_get_bd() instead.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bcom_bd</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* variable payload size */</span>
<span class="p">};</span>

<span class="cm">/* ======================================================================== */</span>
<span class="cm">/* Generic task management                                                   */</span>
<span class="cm">/* ======================================================================== */</span>

<span class="cm">/**</span>
<span class="cm"> * struct bcom_task - Structure describing a loaded BestComm task</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is never built by the driver it self. It&#39;s built and</span>
<span class="cm"> * filled the intermediate layer of the BestComm API, the task dependent</span>
<span class="cm"> * support code.</span>
<span class="cm"> *</span>
<span class="cm"> * Most likely you don&#39;t need to poke around inside this structure. The</span>
<span class="cm"> * fields are exposed in the header just for the sake of inline functions</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bcom_task</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">tasknum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">irq</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">bcom_bd</span>	<span class="o">*</span><span class="n">bd</span><span class="p">;</span>
	<span class="n">phys_addr_t</span>	<span class="n">bd_pa</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">**</span><span class="n">cookie</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">outdex</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">num_bd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">bd_size</span><span class="p">;</span>

	<span class="kt">void</span><span class="o">*</span>		<span class="n">priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define BCOM_FLAGS_NONE         0x00000000ul</span>
<span class="cp">#define BCOM_FLAGS_ENABLE_TASK  (1ul &lt;&lt;  0)</span>

<span class="cm">/**</span>
<span class="cm"> * bcom_enable - Enable a BestComm task</span>
<span class="cm"> * @tsk: The BestComm task structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function makes sure the given task is enabled and can be run</span>
<span class="cm"> * by the BestComm engine as needed</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bcom_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_task</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bcom_disable - Disable a BestComm task</span>
<span class="cm"> * @tsk: The BestComm task structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function disable a given task, making sure it&#39;s not executed</span>
<span class="cm"> * by the BestComm engine.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bcom_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_task</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * bcom_get_task_irq - Returns the irq number of a BestComm task</span>
<span class="cm"> * @tsk: The BestComm task structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">bcom_get_task_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_task</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ======================================================================== */</span>
<span class="cm">/* BD based tasks helpers                                                   */</span>
<span class="cm">/* ======================================================================== */</span>

<span class="cp">#define BCOM_BD_READY	0x40000000ul</span>

<span class="cm">/** _bcom_next_index - Get next input index.</span>
<span class="cm"> * @tsk: pointer to task structure</span>
<span class="cm"> *</span>
<span class="cm"> * Support function; Device drivers should not call this</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">_bcom_next_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_task</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">num_bd</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** _bcom_next_outdex - Get next output index.</span>
<span class="cm"> * @tsk: pointer to task structure</span>
<span class="cm"> *</span>
<span class="cm"> * Support function; Device drivers should not call this</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">_bcom_next_outdex</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_task</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">outdex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">num_bd</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">outdex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bcom_queue_empty - Checks if a BestComm task BD queue is empty</span>
<span class="cm"> * @tsk: The BestComm task structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">bcom_queue_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_task</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">outdex</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bcom_queue_full - Checks if a BestComm task BD queue is full</span>
<span class="cm"> * @tsk: The BestComm task structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">bcom_queue_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_task</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">outdex</span> <span class="o">==</span> <span class="n">_bcom_next_index</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bcom_get_bd - Get a BD from the queue</span>
<span class="cm"> * @tsk: The BestComm task structure</span>
<span class="cm"> * index: Index of the BD to fetch</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">bcom_bd</span>
<span class="o">*</span><span class="nf">bcom_get_bd</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_task</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* A cast to (void*) so the address can be incremented by the</span>
<span class="cm">	 * real size instead of by sizeof(struct bcom_bd) */</span>
	<span class="k">return</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">bd</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">index</span> <span class="o">*</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">bd_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bcom_buffer_done - Checks if a BestComm </span>
<span class="cm"> * @tsk: The BestComm task structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">bcom_buffer_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_task</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcom_bd</span> <span class="o">*</span><span class="n">bd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bcom_queue_empty</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bd</span> <span class="o">=</span> <span class="n">bcom_get_bd</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">outdex</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">BCOM_BD_READY</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bcom_prepare_next_buffer - clear status of next available buffer.</span>
<span class="cm"> * @tsk: The BestComm task structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns pointer to next buffer descriptor</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">bcom_bd</span> <span class="o">*</span>
<span class="nf">bcom_prepare_next_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_task</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcom_bd</span> <span class="o">*</span><span class="n">bd</span><span class="p">;</span>

	<span class="n">bd</span> <span class="o">=</span> <span class="n">bcom_get_bd</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">bd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* cleanup last status */</span>
	<span class="k">return</span> <span class="n">bd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">bcom_submit_next_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_task</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bcom_bd</span> <span class="o">*</span><span class="n">bd</span> <span class="o">=</span> <span class="n">bcom_get_bd</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>

	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">[</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>	<span class="cm">/* ensure the bd is really up-to-date */</span>
	<span class="n">bd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">BCOM_BD_READY</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">_bcom_next_index</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BCOM_FLAGS_ENABLE_TASK</span><span class="p">)</span>
		<span class="n">bcom_enable</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">bcom_retrieve_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_task</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">p_status</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bcom_bd</span> <span class="o">**</span><span class="n">p_bd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">[</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">outdex</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">bcom_bd</span> <span class="o">*</span><span class="n">bd</span> <span class="o">=</span> <span class="n">bcom_get_bd</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">outdex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p_status</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p_status</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p_bd</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p_bd</span> <span class="o">=</span> <span class="n">bd</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">outdex</span> <span class="o">=</span> <span class="n">_bcom_next_outdex</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cookie</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __BESTCOMM_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
<span class="n">start</span> <span class="o">=</span> <span class="n">start_pa</span><span class="p">;</span>
		<span class="n">tdt</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="n">start_pa</span> <span class="o">+</span> <span class="p">((</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">desc_size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">var</span> <span class="o">=</span> <span class="n">bcom_task_var</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">inc</span> <span class="o">=</span> <span class="n">bcom_task_inc</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="cm">/* Clear &amp; copy */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">BCOM_VAR_SIZE</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">BCOM_INC_SIZE</span><span class="p">);</span>

	<span class="n">desc_src</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">hdr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">var_src</span> <span class="o">=</span> <span class="n">desc_src</span> <span class="o">+</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">desc_size</span><span class="p">;</span>
	<span class="n">inc_src</span> <span class="o">=</span> <span class="n">var_src</span> <span class="o">+</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">var_size</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">desc_src</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">desc_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">first_var</span><span class="p">,</span> <span class="n">var_src</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">var_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="n">inc_src</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">inc_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bcom_load_image</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">bcom_set_initiator</span><span class="p">(</span><span class="kt">int</span> <span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">initiator</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_descs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next_drd_has_initiator</span><span class="p">;</span>

	<span class="n">bcom_set_tcr_initiator</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">initiator</span><span class="p">);</span>

	<span class="cm">/* Just setting tcr is apparently not enough due to some problem */</span>
	<span class="cm">/* with it. So we just go thru all the microcode and replace in  */</span>
	<span class="cm">/* the DRD directly */</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">bcom_task_desc</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">next_drd_has_initiator</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">num_descs</span> <span class="o">=</span> <span class="n">bcom_task_num_descs</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">num_descs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">desc</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bcom_desc_is_drd</span><span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_drd_has_initiator</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bcom_desc_initiator</span><span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">BCOM_INITIATOR_ALWAYS</span><span class="p">)</span>
				<span class="n">bcom_set_desc_initiator</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">initiator</span><span class="p">);</span>
		<span class="n">next_drd_has_initiator</span> <span class="o">=</span> <span class="o">!</span><span class="n">bcom_drd_is_extended</span><span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bcom_set_initiator</span><span class="p">);</span>


<span class="cm">/* Public API */</span>

<span class="kt">void</span>
<span class="nf">bcom_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_task</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bcom_enable_task</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">tasknum</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bcom_enable</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">bcom_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_task</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bcom_disable_task</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">tasknum</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bcom_disable</span><span class="p">);</span>


<span class="cm">/* ======================================================================== */</span>
<span class="cm">/* Engine init/cleanup                                                      */</span>
<span class="cm">/* ======================================================================== */</span>

<span class="cm">/* Function Descriptor table */</span>
<span class="cm">/* this will need to be updated if Freescale changes their task code FDT */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">fdt_ops</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0xa0045670</span><span class="p">,</span>	<span class="cm">/* FDT[48] - load_acc()	  */</span>
	<span class="mh">0x80045670</span><span class="p">,</span>	<span class="cm">/* FDT[49] - unload_acc() */</span>
	<span class="mh">0x21800000</span><span class="p">,</span>	<span class="cm">/* FDT[50] - and()        */</span>
	<span class="mh">0x21e00000</span><span class="p">,</span>	<span class="cm">/* FDT[51] - or()         */</span>
	<span class="mh">0x21500000</span><span class="p">,</span>	<span class="cm">/* FDT[52] - xor()        */</span>
	<span class="mh">0x21400000</span><span class="p">,</span>	<span class="cm">/* FDT[53] - andn()       */</span>
	<span class="mh">0x21500000</span><span class="p">,</span>	<span class="cm">/* FDT[54] - not()        */</span>
	<span class="mh">0x20400000</span><span class="p">,</span>	<span class="cm">/* FDT[55] - add()        */</span>
	<span class="mh">0x20500000</span><span class="p">,</span>	<span class="cm">/* FDT[56] - sub()        */</span>
	<span class="mh">0x20800000</span><span class="p">,</span>	<span class="cm">/* FDT[57] - lsh()        */</span>
	<span class="mh">0x20a00000</span><span class="p">,</span>	<span class="cm">/* FDT[58] - rsh()        */</span>
	<span class="mh">0xc0170000</span><span class="p">,</span>	<span class="cm">/* FDT[59] - crc8()       */</span>
	<span class="mh">0xc0145670</span><span class="p">,</span>	<span class="cm">/* FDT[60] - crc16()      */</span>
	<span class="mh">0xc0345670</span><span class="p">,</span>	<span class="cm">/* FDT[61] - crc32()      */</span>
	<span class="mh">0xa0076540</span><span class="p">,</span>	<span class="cm">/* FDT[62] - endian32()   */</span>
	<span class="mh">0xa0000760</span><span class="p">,</span>	<span class="cm">/* FDT[63] - endian16()   */</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">bcom_engine_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">task</span><span class="p">;</span>
	<span class="n">phys_addr_t</span> <span class="n">tdt_pa</span><span class="p">,</span> <span class="n">ctx_pa</span><span class="p">,</span> <span class="n">var_pa</span><span class="p">,</span> <span class="n">fdt_pa</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tdt_size</span><span class="p">,</span> <span class="n">ctx_size</span><span class="p">,</span> <span class="n">var_size</span><span class="p">,</span> <span class="n">fdt_size</span><span class="p">;</span>

	<span class="cm">/* Allocate &amp; clear SRAM zones for FDT, TDTs, contexts and vars/incs */</span>
	<span class="n">tdt_size</span> <span class="o">=</span> <span class="n">BCOM_MAX_TASKS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_tdt</span><span class="p">);</span>
	<span class="n">ctx_size</span> <span class="o">=</span> <span class="n">BCOM_MAX_TASKS</span> <span class="o">*</span> <span class="n">BCOM_CTX_SIZE</span><span class="p">;</span>
	<span class="n">var_size</span> <span class="o">=</span> <span class="n">BCOM_MAX_TASKS</span> <span class="o">*</span> <span class="p">(</span><span class="n">BCOM_VAR_SIZE</span> <span class="o">+</span> <span class="n">BCOM_INC_SIZE</span><span class="p">);</span>
	<span class="n">fdt_size</span> <span class="o">=</span> <span class="n">BCOM_FDT_SIZE</span><span class="p">;</span>

	<span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">tdt</span> <span class="o">=</span> <span class="n">bcom_sram_alloc</span><span class="p">(</span><span class="n">tdt_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">tdt_pa</span><span class="p">);</span>
	<span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">bcom_sram_alloc</span><span class="p">(</span><span class="n">ctx_size</span><span class="p">,</span> <span class="n">BCOM_CTX_ALIGN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx_pa</span><span class="p">);</span>
	<span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">var</span> <span class="o">=</span> <span class="n">bcom_sram_alloc</span><span class="p">(</span><span class="n">var_size</span><span class="p">,</span> <span class="n">BCOM_VAR_ALIGN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">var_pa</span><span class="p">);</span>
	<span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">fdt</span> <span class="o">=</span> <span class="n">bcom_sram_alloc</span><span class="p">(</span><span class="n">fdt_size</span><span class="p">,</span> <span class="n">BCOM_FDT_ALIGN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdt_pa</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">tdt</span> <span class="o">||</span> <span class="o">!</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">||</span> <span class="o">!</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">var</span> <span class="o">||</span> <span class="o">!</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;DMA: SRAM alloc failed in engine init !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">bcom_sram_free</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">tdt</span><span class="p">);</span>
		<span class="n">bcom_sram_free</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">bcom_sram_free</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">);</span>
		<span class="n">bcom_sram_free</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">tdt</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">tdt_size</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">ctx_size</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">var_size</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">fdt_size</span><span class="p">);</span>

	<span class="cm">/* Copy the FDT for the EU#3 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="p">[</span><span class="mi">48</span><span class="p">],</span> <span class="n">fdt_ops</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fdt_ops</span><span class="p">));</span>

	<span class="cm">/* Initialize Task base structure */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">task</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">task</span><span class="o">&lt;</span><span class="n">BCOM_MAX_TASKS</span><span class="p">;</span> <span class="n">task</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">tcr</span><span class="p">[</span><span class="n">task</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">out_8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ipr</span><span class="p">[</span><span class="n">task</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">tdt</span><span class="p">[</span><span class="n">task</span><span class="p">].</span><span class="n">context</span>	<span class="o">=</span> <span class="n">ctx_pa</span><span class="p">;</span>
		<span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">tdt</span><span class="p">[</span><span class="n">task</span><span class="p">].</span><span class="n">var</span>	<span class="o">=</span> <span class="n">var_pa</span><span class="p">;</span>
		<span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">tdt</span><span class="p">[</span><span class="n">task</span><span class="p">].</span><span class="n">fdt</span>	<span class="o">=</span> <span class="n">fdt_pa</span><span class="p">;</span>

		<span class="n">var_pa</span> <span class="o">+=</span> <span class="n">BCOM_VAR_SIZE</span> <span class="o">+</span> <span class="n">BCOM_INC_SIZE</span><span class="p">;</span>
		<span class="n">ctx_pa</span> <span class="o">+=</span> <span class="n">BCOM_CTX_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">taskBar</span><span class="p">,</span> <span class="n">tdt_pa</span><span class="p">);</span>

	<span class="cm">/* Init &#39;always&#39; initiator */</span>
	<span class="n">out_8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ipr</span><span class="p">[</span><span class="n">BCOM_INITIATOR_ALWAYS</span><span class="p">],</span> <span class="n">BCOM_IPR_ALWAYS</span><span class="p">);</span>

	<span class="cm">/* Disable COMM Bus Prefetch on the original 5200; it&#39;s broken */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_SVR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MPC5200_SVR_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">MPC5200_SVR</span><span class="p">)</span>
		<span class="n">bcom_disable_prefetch</span><span class="p">();</span>

	<span class="cm">/* Init lock */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">bcom_engine_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">task</span><span class="p">;</span>

	<span class="cm">/* Stop all tasks */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">task</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">task</span><span class="o">&lt;</span><span class="n">BCOM_MAX_TASKS</span><span class="p">;</span> <span class="n">task</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">tcr</span><span class="p">[</span><span class="n">task</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">out_8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ipr</span><span class="p">[</span><span class="n">task</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">taskBar</span><span class="p">,</span> <span class="mi">0ul</span><span class="p">);</span>

	<span class="cm">/* Release the SRAM zones */</span>
	<span class="n">bcom_sram_free</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">tdt</span><span class="p">);</span>
	<span class="n">bcom_sram_free</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">bcom_sram_free</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">);</span>
	<span class="n">bcom_sram_free</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* ======================================================================== */</span>
<span class="cm">/* OF platform driver                                                       */</span>
<span class="cm">/* ======================================================================== */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">mpc52xx_bcom_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">ofn_sram</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="n">res_bcom</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

	<span class="cm">/* Inform user we&#39;re ok so far */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;DMA: MPC52xx BestComm driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Get the bestcomm node */</span>
	<span class="n">of_node_get</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">);</span>

	<span class="cm">/* Prepare SRAM */</span>
	<span class="n">ofn_sram</span> <span class="o">=</span> <span class="n">of_find_matching_node</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mpc52xx_sram_ids</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ofn_sram</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">DRIVER_NAME</span> <span class="s">&quot;: &quot;</span>
			<span class="s">&quot;No SRAM found in device tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_ofput</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">bcom_sram_init</span><span class="p">(</span><span class="n">ofn_sram</span><span class="p">,</span> <span class="n">DRIVER_NAME</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">ofn_sram</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">DRIVER_NAME</span> <span class="s">&quot;: &quot;</span>
			<span class="s">&quot;Error in SRAM init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_ofput</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get a clean struct */</span>
	<span class="n">bcom_eng</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bcom_engine</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bcom_eng</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">DRIVER_NAME</span> <span class="s">&quot;: &quot;</span>
			<span class="s">&quot;Can&#39;t allocate state structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_sramclean</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Save the node */</span>
	<span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">ofnode</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>

	<span class="cm">/* Get, reserve &amp; map io */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_address_to_resource</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res_bcom</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">DRIVER_NAME</span> <span class="s">&quot;: &quot;</span>
			<span class="s">&quot;Can&#39;t get resource</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_sramclean</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">res_bcom</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mpc52xx_sdma</span><span class="p">),</span>
				<span class="n">DRIVER_NAME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">DRIVER_NAME</span> <span class="s">&quot;: &quot;</span>
			<span class="s">&quot;Can&#39;t request registers region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_sramclean</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">regs_base</span> <span class="o">=</span> <span class="n">res_bcom</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
	<span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">res_bcom</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mpc52xx_sdma</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">DRIVER_NAME</span> <span class="s">&quot;: &quot;</span>
			<span class="s">&quot;Can&#39;t map registers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now, do the real init */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">bcom_engine_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_unmap</span><span class="p">;</span>

	<span class="cm">/* Done ! */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;DMA: MPC52xx BestComm engine @%08lx ok !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">regs_base</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Error path */</span>
<span class="nl">error_unmap:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
<span class="nl">error_release:</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">res_bcom</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mpc52xx_sdma</span><span class="p">));</span>
<span class="nl">error_sramclean:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bcom_eng</span><span class="p">);</span>
	<span class="n">bcom_sram_cleanup</span><span class="p">();</span>
<span class="nl">error_ofput:</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;DMA: MPC52xx BestComm init failed !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">mpc52xx_bcom_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Clean up the engine */</span>
	<span class="n">bcom_engine_cleanup</span><span class="p">();</span>

	<span class="cm">/* Cleanup SRAM */</span>
	<span class="n">bcom_sram_cleanup</span><span class="p">();</span>

	<span class="cm">/* Release regs */</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">regs_base</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mpc52xx_sdma</span><span class="p">));</span>

	<span class="cm">/* Release the node */</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">bcom_eng</span><span class="o">-&gt;</span><span class="n">ofnode</span><span class="p">);</span>

	<span class="cm">/* Release memory */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bcom_eng</span><span class="p">);</span>
	<span class="n">bcom_eng</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">mpc52xx_bcom_of_match</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;fsl,mpc5200-bestcomm&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;mpc5200-bestcomm&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{},</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">of</span><span class="p">,</span> <span class="n">mpc52xx_bcom_of_match</span><span class="p">);</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">mpc52xx_bcom_of_platform_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">mpc52xx_bcom_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">mpc52xx_bcom_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRIVER_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">mpc52xx_bcom_of_match</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>


<span class="cm">/* ======================================================================== */</span>
<span class="cm">/* Module                                                                   */</span>
<span class="cm">/* ======================================================================== */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">mpc52xx_bcom_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpc52xx_bcom_of_platform_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span>
<span class="nf">mpc52xx_bcom_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mpc52xx_bcom_of_platform_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* If we&#39;re not a module, we must make sure everything is setup before  */</span>
<span class="cm">/* anyone tries to use us ... that&#39;s why we use subsys_initcall instead */</span>
<span class="cm">/* of module_init. */</span>
<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">mpc52xx_bcom_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">mpc52xx_bcom_exit</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Freescale MPC52xx BestComm DMA&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Sylvain Munaut &lt;tnt@246tNt.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Andrey Volkov &lt;avolkov@varma-el.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Dale Farnsworth &lt;dfarnsworth@mvista.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
