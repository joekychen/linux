<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › sysdev › ge › ge_pic.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ge_pic.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Interrupt handling for GE FPGA based PIC</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Martyn Welch &lt;martyn.welch@ge.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * 2008 (c) GE Intelligent Platforms Embedded Systems, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is licensed under the terms of the GNU General Public License</span>
<span class="cm"> * version 2.  This program is licensed &quot;as is&quot; without any warranty of any</span>
<span class="cm"> * kind, whether express or implied.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>

<span class="cp">#include &quot;ge_pic.h&quot;</span>

<span class="cp">#define DEBUG</span>
<span class="cp">#undef DEBUG</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define DBG(fmt...) do { printk(KERN_DEBUG &quot;gef_pic: &quot; fmt); } while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG(fmt...) do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#define GEF_PIC_NUM_IRQS	32</span>

<span class="cm">/* Interrupt Controller Interface Registers */</span>
<span class="cp">#define GEF_PIC_INTR_STATUS	0x0000</span>

<span class="cp">#define GEF_PIC_INTR_MASK(cpu)	(0x0010 + (0x4 * cpu))</span>
<span class="cp">#define GEF_PIC_CPU0_INTR_MASK	GEF_PIC_INTR_MASK(0)</span>
<span class="cp">#define GEF_PIC_CPU1_INTR_MASK	GEF_PIC_INTR_MASK(1)</span>

<span class="cp">#define GEF_PIC_MCP_MASK(cpu)	(0x0018 + (0x4 * cpu))</span>
<span class="cp">#define GEF_PIC_CPU0_MCP_MASK	GEF_PIC_MCP_MASK(0)</span>
<span class="cp">#define GEF_PIC_CPU1_MCP_MASK	GEF_PIC_MCP_MASK(1)</span>


<span class="k">static</span> <span class="n">DEFINE_RAW_SPINLOCK</span><span class="p">(</span><span class="n">gef_pic_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">gef_pic_irq_reg_base</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_domain</span> <span class="o">*</span><span class="n">gef_pic_irq_host</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gef_pic_cascade_irq</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt Controller Handling</span>
<span class="cm"> *</span>
<span class="cm"> * The interrupt controller handles interrupts for most on board interrupts,</span>
<span class="cm"> * apart from PCI interrupts. For example on SBC610:</span>
<span class="cm"> *</span>
<span class="cm"> * 17:31 RO Reserved</span>
<span class="cm"> * 16    RO PCI Express Doorbell 3 Status</span>
<span class="cm"> * 15    RO PCI Express Doorbell 2 Status</span>
<span class="cm"> * 14    RO PCI Express Doorbell 1 Status</span>
<span class="cm"> * 13    RO PCI Express Doorbell 0 Status</span>
<span class="cm"> * 12    RO Real Time Clock Interrupt Status</span>
<span class="cm"> * 11    RO Temperature Interrupt Status</span>
<span class="cm"> * 10    RO Temperature Critical Interrupt Status</span>
<span class="cm"> * 9     RO Ethernet PHY1 Interrupt Status</span>
<span class="cm"> * 8     RO Ethernet PHY3 Interrupt Status</span>
<span class="cm"> * 7     RO PEX8548 Interrupt Status</span>
<span class="cm"> * 6     RO Reserved</span>
<span class="cm"> * 5     RO Watchdog 0 Interrupt Status</span>
<span class="cm"> * 4     RO Watchdog 1 Interrupt Status</span>
<span class="cm"> * 3     RO AXIS Message FIFO A Interrupt Status</span>
<span class="cm"> * 2     RO AXIS Message FIFO B Interrupt Status</span>
<span class="cm"> * 1     RO AXIS Message FIFO C Interrupt Status</span>
<span class="cm"> * 0     RO AXIS Message FIFO D Interrupt Status</span>
<span class="cm"> *</span>
<span class="cm"> * Interrupts can be forwarded to one of two output lines. Nothing</span>
<span class="cm"> * clever is done, so if the masks are incorrectly set, a single input</span>
<span class="cm"> * interrupt could generate interrupts on both output lines!</span>
<span class="cm"> *</span>
<span class="cm"> * The dual lines are there to allow the chained interrupts to be easily</span>
<span class="cm"> * passed into two different cores. We currently do not use this functionality</span>
<span class="cm"> * in this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Controller can also be configured to generate Machine checks (MCP), again on</span>
<span class="cm"> * two lines, to be attached to two different cores. It is suggested that these</span>
<span class="cm"> * should be masked out.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">gef_pic_cascade</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">irq_desc_get_chip</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cascade_irq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if we actually have an interrupt, call generic handling code if</span>
<span class="cm">	 * we do.</span>
<span class="cm">	 */</span>
	<span class="n">cascade_irq</span> <span class="o">=</span> <span class="n">gef_pic_get_irq</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cascade_irq</span> <span class="o">!=</span> <span class="n">NO_IRQ</span><span class="p">)</span>
		<span class="n">generic_handle_irq</span><span class="p">(</span><span class="n">cascade_irq</span><span class="p">);</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_eoi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gef_pic_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hwirq</span> <span class="o">=</span> <span class="n">irqd_to_hwirq</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gef_pic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">gef_pic_irq_reg_base</span> <span class="o">+</span> <span class="n">GEF_PIC_INTR_MASK</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hwirq</span><span class="p">);</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">gef_pic_irq_reg_base</span> <span class="o">+</span> <span class="n">GEF_PIC_INTR_MASK</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gef_pic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gef_pic_mask_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Don&#39;t think we actually have to do anything to ack an interrupt,</span>
<span class="cm">	 * we just need to clear down the devices interrupt and it will go away</span>
<span class="cm">	 */</span>
	<span class="n">gef_pic_mask</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gef_pic_unmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hwirq</span> <span class="o">=</span> <span class="n">irqd_to_hwirq</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gef_pic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">gef_pic_irq_reg_base</span> <span class="o">+</span> <span class="n">GEF_PIC_INTR_MASK</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hwirq</span><span class="p">);</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">gef_pic_irq_reg_base</span> <span class="o">+</span> <span class="n">GEF_PIC_INTR_MASK</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gef_pic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">gef_pic_chip</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;gefp&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span>	<span class="o">=</span> <span class="n">gef_pic_mask</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask_ack</span>	<span class="o">=</span> <span class="n">gef_pic_mask_ack</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span>	<span class="o">=</span> <span class="n">gef_pic_unmask</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* When an interrupt is being configured, this call allows some flexibilty</span>
<span class="cm"> * in deciding which irq_chip structure is used</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gef_pic_host_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_domain</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">virq</span><span class="p">,</span>
			  <span class="n">irq_hw_number_t</span> <span class="n">hwirq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* All interrupts are LEVEL sensitive */</span>
	<span class="n">irq_set_status_flags</span><span class="p">(</span><span class="n">virq</span><span class="p">,</span> <span class="n">IRQ_LEVEL</span><span class="p">);</span>
	<span class="n">irq_set_chip_and_handler</span><span class="p">(</span><span class="n">virq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gef_pic_chip</span><span class="p">,</span> <span class="n">handle_level_irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gef_pic_host_xlate</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_domain</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span>
			    <span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">intspec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">intsize</span><span class="p">,</span>
			    <span class="n">irq_hw_number_t</span> <span class="o">*</span><span class="n">out_hwirq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">out_flags</span><span class="p">)</span>
<span class="p">{</span>

	<span class="o">*</span><span class="n">out_hwirq</span> <span class="o">=</span> <span class="n">intspec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intsize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">*</span><span class="n">out_flags</span> <span class="o">=</span> <span class="n">intspec</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">out_flags</span> <span class="o">=</span> <span class="n">IRQ_TYPE_LEVEL_HIGH</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">irq_domain_ops</span> <span class="n">gef_pic_host_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">map</span>	<span class="o">=</span> <span class="n">gef_pic_host_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xlate</span>	<span class="o">=</span> <span class="n">gef_pic_host_xlate</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Initialisation of PIC, this should be called in BSP</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">gef_pic_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Map the devices registers into memory */</span>
	<span class="n">gef_pic_irq_reg_base</span> <span class="o">=</span> <span class="n">of_iomap</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gef_pic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Initialise everything as masked. */</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">gef_pic_irq_reg_base</span> <span class="o">+</span> <span class="n">GEF_PIC_CPU0_INTR_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">gef_pic_irq_reg_base</span> <span class="o">+</span> <span class="n">GEF_PIC_CPU1_INTR_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">out_be32</span><span class="p">(</span><span class="n">gef_pic_irq_reg_base</span> <span class="o">+</span> <span class="n">GEF_PIC_CPU0_MCP_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="n">gef_pic_irq_reg_base</span> <span class="o">+</span> <span class="n">GEF_PIC_CPU1_MCP_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gef_pic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Map controller */</span>
	<span class="n">gef_pic_cascade_irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gef_pic_cascade_irq</span> <span class="o">==</span> <span class="n">NO_IRQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SBC610: failed to map cascade interrupt&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Setup an irq_domain structure */</span>
	<span class="n">gef_pic_irq_host</span> <span class="o">=</span> <span class="n">irq_domain_add_linear</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">GEF_PIC_NUM_IRQS</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">gef_pic_host_ops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gef_pic_irq_host</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Chain with parent controller */</span>
	<span class="n">irq_set_chained_handler</span><span class="p">(</span><span class="n">gef_pic_cascade_irq</span><span class="p">,</span> <span class="n">gef_pic_cascade</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called when we receive an interrupt with apparently comes from this</span>
<span class="cm"> * chip - check, returning the highest interrupt generated or return NO_IRQ</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">gef_pic_get_irq</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cause</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">active</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">virq</span> <span class="o">=</span> <span class="n">NO_IRQ</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hwirq</span><span class="p">;</span>

	<span class="n">cause</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">gef_pic_irq_reg_base</span> <span class="o">+</span> <span class="n">GEF_PIC_INTR_STATUS</span><span class="p">);</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="n">in_be32</span><span class="p">(</span><span class="n">gef_pic_irq_reg_base</span> <span class="o">+</span> <span class="n">GEF_PIC_INTR_MASK</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="n">active</span> <span class="o">=</span> <span class="n">cause</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">hwirq</span> <span class="o">=</span> <span class="n">GEF_PIC_NUM_IRQS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">hwirq</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">hwirq</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">active</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">hwirq</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">virq</span> <span class="o">=</span> <span class="n">irq_linear_revmap</span><span class="p">(</span><span class="n">gef_pic_irq_host</span><span class="p">,</span>
			<span class="p">(</span><span class="n">irq_hw_number_t</span><span class="p">)</span><span class="n">hwirq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">virq</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
