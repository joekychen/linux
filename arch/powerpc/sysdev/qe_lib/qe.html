<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › sysdev › qe_lib › qe.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>qe.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2006-2010 Freescale Semicondutor, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: 	Shlomi Gridish &lt;gridish@freescale.com&gt;</span>
<span class="cm"> * 		Li Yang &lt;leoli@freescale.com&gt;</span>
<span class="cm"> * Based on cpm2_common.c from Dan Malek (dmalek@jlc.net)</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * General Purpose functions for the global management of the</span>
<span class="cm"> * QUICC Engine (QE).</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute  it and/or modify it</span>
<span class="cm"> * under  the terms of  the GNU General  Public License as published by the</span>
<span class="cm"> * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/param.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>
<span class="cp">#include &lt;linux/of_platform.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/immap_qe.h&gt;</span>
<span class="cp">#include &lt;asm/qe.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/rheap.h&gt;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">qe_snums_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">qe_sdma_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">qe_lock</span><span class="p">);</span>
<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">cmxgcr_lock</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cmxgcr_lock</span><span class="p">);</span>

<span class="cm">/* QE snum state */</span>
<span class="k">enum</span> <span class="n">qe_snum_state</span> <span class="p">{</span>
	<span class="n">QE_SNUM_STATE_USED</span><span class="p">,</span>
	<span class="n">QE_SNUM_STATE_FREE</span>
<span class="p">};</span>

<span class="cm">/* QE snum */</span>
<span class="k">struct</span> <span class="n">qe_snum</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">qe_snum_state</span> <span class="n">state</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* We allocate this here because it is used almost exclusively for</span>
<span class="cm"> * the communication processor devices.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qe_immap</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">qe_immr</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">qe_immr</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">qe_snum</span> <span class="n">snums</span><span class="p">[</span><span class="n">QE_NUM_OF_SNUM</span><span class="p">];</span>	<span class="cm">/* Dynamically allocated SNUMs */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">qe_num_of_snum</span><span class="p">;</span>

<span class="k">static</span> <span class="n">phys_addr_t</span> <span class="n">qebase</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="n">phys_addr_t</span> <span class="nf">get_qe_base</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">qe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qebase</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">qebase</span><span class="p">;</span>

	<span class="n">qe</span> <span class="o">=</span> <span class="n">of_find_compatible_node</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;fsl,qe&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qe</span> <span class="o">=</span> <span class="n">of_find_node_by_type</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;qe&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qe</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">qebase</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">qe</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">prop</span><span class="p">))</span>
		<span class="n">qebase</span> <span class="o">=</span> <span class="n">of_translate_address</span><span class="p">(</span><span class="n">qe</span><span class="p">,</span> <span class="n">prop</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">qe</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">qebase</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_qe_base</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">qe_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qe_immr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">qe_immr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">get_qe_base</span><span class="p">(),</span> <span class="n">QE_IMMAP_SIZE</span><span class="p">);</span>

	<span class="n">qe_snums_init</span><span class="p">();</span>

	<span class="n">qe_issue_cmd</span><span class="p">(</span><span class="n">QE_RESET</span><span class="p">,</span> <span class="n">QE_CR_SUBBLOCK_INVALID</span><span class="p">,</span>
		     <span class="n">QE_CR_PROTOCOL_UNSPECIFIED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Reclaim the MURAM memory for our use. */</span>
	<span class="n">qe_muram_init</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qe_sdma_init</span><span class="p">())</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;sdma init failed!&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">qe_issue_cmd</span><span class="p">(</span><span class="n">u32</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">device</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mcn_protocol</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cmd_input</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mcn_shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev_shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">QE_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_immr</span><span class="o">-&gt;</span><span class="n">cp</span><span class="p">.</span><span class="n">cecr</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">|</span> <span class="n">QE_CR_FLG</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">QE_ASSIGN_PAGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Here device is the SNUM, not sub-block */</span>
			<span class="n">dev_shift</span> <span class="o">=</span> <span class="n">QE_CR_SNUM_SHIFT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">QE_ASSIGN_RISC</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Here device is the SNUM, and mcnProtocol is</span>
<span class="cm">			 * e_QeCmdRiscAssignment value */</span>
			<span class="n">dev_shift</span> <span class="o">=</span> <span class="n">QE_CR_SNUM_SHIFT</span><span class="p">;</span>
			<span class="n">mcn_shift</span> <span class="o">=</span> <span class="n">QE_CR_MCN_RISC_ASSIGN_SHIFT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">==</span> <span class="n">QE_CR_SUBBLOCK_USB</span><span class="p">)</span>
				<span class="n">mcn_shift</span> <span class="o">=</span> <span class="n">QE_CR_MCN_USB_SHIFT</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">mcn_shift</span> <span class="o">=</span> <span class="n">QE_CR_MCN_NORMAL_SHIFT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_immr</span><span class="o">-&gt;</span><span class="n">cp</span><span class="p">.</span><span class="n">cecdr</span><span class="p">,</span> <span class="n">cmd_input</span><span class="p">);</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_immr</span><span class="o">-&gt;</span><span class="n">cp</span><span class="p">.</span><span class="n">cecr</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">cmd</span> <span class="o">|</span> <span class="n">QE_CR_FLG</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">device</span> <span class="o">&lt;&lt;</span> <span class="n">dev_shift</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span>
			  <span class="n">mcn_protocol</span> <span class="o">&lt;&lt;</span> <span class="n">mcn_shift</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* wait for the QE_CR_FLG to clear */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">spin_event_timeout</span><span class="p">((</span><span class="n">in_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_immr</span><span class="o">-&gt;</span><span class="n">cp</span><span class="p">.</span><span class="n">cecr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">QE_CR_FLG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
			   <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* On timeout (e.g. failure), the expression will be false (ret == 0),</span>
<span class="cm">	   otherwise it will be true (ret == 1). */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">qe_issue_cmd</span><span class="p">);</span>

<span class="cm">/* Set a baud rate generator. This needs lots of work. There are</span>
<span class="cm"> * 16 BRGs, which can be connected to the QE channels or output</span>
<span class="cm"> * as clocks. The BRGs are in two different block of internal</span>
<span class="cm"> * memory mapped space.</span>
<span class="cm"> * The BRG clock is the QE clock divided by 2.</span>
<span class="cm"> * It was set up long ago during the initial boot phase and is</span>
<span class="cm"> * is given to us.</span>
<span class="cm"> * Baud rate clocks are zero-based in the driver code (as that maps</span>
<span class="cm"> * to port numbers). Documentation uses 1-based numbering.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">brg_clk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">qe_get_brg_clk</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">qe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">brg_clk</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">brg_clk</span><span class="p">;</span>

	<span class="n">qe</span> <span class="o">=</span> <span class="n">of_find_compatible_node</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;fsl,qe&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qe</span> <span class="o">=</span> <span class="n">of_find_node_by_type</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;qe&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qe</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">brg_clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">qe</span><span class="p">,</span> <span class="s">&quot;brg-frequency&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">prop</span><span class="p">))</span>
		<span class="n">brg_clk</span> <span class="o">=</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>

	<span class="n">of_node_put</span><span class="p">(</span><span class="n">qe</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">brg_clk</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">qe_get_brg_clk</span><span class="p">);</span>

<span class="cm">/* Program the BRG to the given sampling rate and multiplier</span>
<span class="cm"> *</span>
<span class="cm"> * @brg: the BRG, QE_BRG1 - QE_BRG16</span>
<span class="cm"> * @rate: the desired sampling rate</span>
<span class="cm"> * @multiplier: corresponds to the value programmed in GUMR_L[RDCR] or</span>
<span class="cm"> * GUMR_L[TDCR].  E.g., if this BRG is the RX clock, and GUMR_L[RDCR]=01,</span>
<span class="cm"> * then &#39;multiplier&#39; should be 8.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">qe_setbrg</span><span class="p">(</span><span class="k">enum</span> <span class="n">qe_clock</span> <span class="n">brg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rate</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">multiplier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">divisor</span><span class="p">,</span> <span class="n">tempval</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">div16</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">brg</span> <span class="o">&lt;</span> <span class="n">QE_BRG1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">brg</span> <span class="o">&gt;</span> <span class="n">QE_BRG16</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">divisor</span> <span class="o">=</span> <span class="n">qe_get_brg_clk</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">rate</span> <span class="o">*</span> <span class="n">multiplier</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">divisor</span> <span class="o">&gt;</span> <span class="n">QE_BRGC_DIVISOR_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">div16</span> <span class="o">=</span> <span class="n">QE_BRGC_DIV16</span><span class="p">;</span>
		<span class="n">divisor</span> <span class="o">/=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Errata QE_General4, which affects some MPC832x and MPC836x SOCs, says</span>
<span class="cm">	   that the BRG divisor must be even if you&#39;re not using divide-by-16</span>
<span class="cm">	   mode. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">div16</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">divisor</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">divisor</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">))</span>
		<span class="n">divisor</span><span class="o">++</span><span class="p">;</span>

	<span class="n">tempval</span> <span class="o">=</span> <span class="p">((</span><span class="n">divisor</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">QE_BRGC_DIVISOR_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">QE_BRGC_ENABLE</span> <span class="o">|</span> <span class="n">div16</span><span class="p">;</span>

	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_immr</span><span class="o">-&gt;</span><span class="n">brg</span><span class="p">.</span><span class="n">brgc</span><span class="p">[</span><span class="n">brg</span> <span class="o">-</span> <span class="n">QE_BRG1</span><span class="p">],</span> <span class="n">tempval</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">qe_setbrg</span><span class="p">);</span>

<span class="cm">/* Convert a string to a QE clock source enum</span>
<span class="cm"> *</span>
<span class="cm"> * This function takes a string, typically from a property in the device</span>
<span class="cm"> * tree, and returns the corresponding &quot;enum qe_clock&quot; value.</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">qe_clock</span> <span class="nf">qe_clock_source</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">QE_CLK_NONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s">&quot;brg&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">source</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">))</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">QE_BRG1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">QE_CLK_DUMMY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s">&quot;clk&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">source</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">24</span><span class="p">))</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">QE_CLK1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">QE_CLK_DUMMY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">QE_CLK_DUMMY</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">qe_clock_source</span><span class="p">);</span>

<span class="cm">/* Initialize SNUMs (thread serial numbers) according to</span>
<span class="cm"> * QE Module Control chapter, SNUM table</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qe_snums_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">snum_init_76</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x05</span><span class="p">,</span> <span class="mh">0x0C</span><span class="p">,</span> <span class="mh">0x0D</span><span class="p">,</span> <span class="mh">0x14</span><span class="p">,</span> <span class="mh">0x15</span><span class="p">,</span> <span class="mh">0x1C</span><span class="p">,</span> <span class="mh">0x1D</span><span class="p">,</span>
		<span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span> <span class="mh">0x2C</span><span class="p">,</span> <span class="mh">0x2D</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">,</span> <span class="mh">0x35</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x89</span><span class="p">,</span>
		<span class="mh">0x98</span><span class="p">,</span> <span class="mh">0x99</span><span class="p">,</span> <span class="mh">0xA8</span><span class="p">,</span> <span class="mh">0xA9</span><span class="p">,</span> <span class="mh">0xB8</span><span class="p">,</span> <span class="mh">0xB9</span><span class="p">,</span> <span class="mh">0xC8</span><span class="p">,</span> <span class="mh">0xC9</span><span class="p">,</span>
		<span class="mh">0xD8</span><span class="p">,</span> <span class="mh">0xD9</span><span class="p">,</span> <span class="mh">0xE8</span><span class="p">,</span> <span class="mh">0xE9</span><span class="p">,</span> <span class="mh">0x44</span><span class="p">,</span> <span class="mh">0x45</span><span class="p">,</span> <span class="mh">0x4C</span><span class="p">,</span> <span class="mh">0x4D</span><span class="p">,</span>
		<span class="mh">0x54</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x5C</span><span class="p">,</span> <span class="mh">0x5D</span><span class="p">,</span> <span class="mh">0x64</span><span class="p">,</span> <span class="mh">0x65</span><span class="p">,</span> <span class="mh">0x6C</span><span class="p">,</span> <span class="mh">0x6D</span><span class="p">,</span>
		<span class="mh">0x74</span><span class="p">,</span> <span class="mh">0x75</span><span class="p">,</span> <span class="mh">0x7C</span><span class="p">,</span> <span class="mh">0x7D</span><span class="p">,</span> <span class="mh">0x84</span><span class="p">,</span> <span class="mh">0x85</span><span class="p">,</span> <span class="mh">0x8C</span><span class="p">,</span> <span class="mh">0x8D</span><span class="p">,</span>
		<span class="mh">0x94</span><span class="p">,</span> <span class="mh">0x95</span><span class="p">,</span> <span class="mh">0x9C</span><span class="p">,</span> <span class="mh">0x9D</span><span class="p">,</span> <span class="mh">0xA4</span><span class="p">,</span> <span class="mh">0xA5</span><span class="p">,</span> <span class="mh">0xAC</span><span class="p">,</span> <span class="mh">0xAD</span><span class="p">,</span>
		<span class="mh">0xB4</span><span class="p">,</span> <span class="mh">0xB5</span><span class="p">,</span> <span class="mh">0xBC</span><span class="p">,</span> <span class="mh">0xBD</span><span class="p">,</span> <span class="mh">0xC4</span><span class="p">,</span> <span class="mh">0xC5</span><span class="p">,</span> <span class="mh">0xCC</span><span class="p">,</span> <span class="mh">0xCD</span><span class="p">,</span>
		<span class="mh">0xD4</span><span class="p">,</span> <span class="mh">0xD5</span><span class="p">,</span> <span class="mh">0xDC</span><span class="p">,</span> <span class="mh">0xDD</span><span class="p">,</span> <span class="mh">0xE4</span><span class="p">,</span> <span class="mh">0xE5</span><span class="p">,</span> <span class="mh">0xEC</span><span class="p">,</span> <span class="mh">0xED</span><span class="p">,</span>
		<span class="mh">0xF4</span><span class="p">,</span> <span class="mh">0xF5</span><span class="p">,</span> <span class="mh">0xFC</span><span class="p">,</span> <span class="mh">0xFD</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">snum_init_46</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x05</span><span class="p">,</span> <span class="mh">0x0C</span><span class="p">,</span> <span class="mh">0x0D</span><span class="p">,</span> <span class="mh">0x14</span><span class="p">,</span> <span class="mh">0x15</span><span class="p">,</span> <span class="mh">0x1C</span><span class="p">,</span> <span class="mh">0x1D</span><span class="p">,</span>
		<span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span> <span class="mh">0x2C</span><span class="p">,</span> <span class="mh">0x2D</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">,</span> <span class="mh">0x35</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x89</span><span class="p">,</span>
		<span class="mh">0x98</span><span class="p">,</span> <span class="mh">0x99</span><span class="p">,</span> <span class="mh">0xA8</span><span class="p">,</span> <span class="mh">0xA9</span><span class="p">,</span> <span class="mh">0xB8</span><span class="p">,</span> <span class="mh">0xB9</span><span class="p">,</span> <span class="mh">0xC8</span><span class="p">,</span> <span class="mh">0xC9</span><span class="p">,</span>
		<span class="mh">0xD8</span><span class="p">,</span> <span class="mh">0xD9</span><span class="p">,</span> <span class="mh">0xE8</span><span class="p">,</span> <span class="mh">0xE9</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x09</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x19</span><span class="p">,</span>
		<span class="mh">0x28</span><span class="p">,</span> <span class="mh">0x29</span><span class="p">,</span> <span class="mh">0x38</span><span class="p">,</span> <span class="mh">0x39</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x49</span><span class="p">,</span> <span class="mh">0x58</span><span class="p">,</span> <span class="mh">0x59</span><span class="p">,</span>
		<span class="mh">0x68</span><span class="p">,</span> <span class="mh">0x69</span><span class="p">,</span> <span class="mh">0x78</span><span class="p">,</span> <span class="mh">0x79</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x81</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">snum_init</span><span class="p">;</span>

	<span class="n">qe_num_of_snum</span> <span class="o">=</span> <span class="n">qe_get_num_of_snums</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qe_num_of_snum</span> <span class="o">==</span> <span class="mi">76</span><span class="p">)</span>
		<span class="n">snum_init</span> <span class="o">=</span> <span class="n">snum_init_76</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">snum_init</span> <span class="o">=</span> <span class="n">snum_init_46</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qe_num_of_snum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snums</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num</span> <span class="o">=</span> <span class="n">snum_init</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">snums</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">state</span> <span class="o">=</span> <span class="n">QE_SNUM_STATE_FREE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">qe_get_snum</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">snum</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qe_num_of_snum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">snums</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">state</span> <span class="o">==</span> <span class="n">QE_SNUM_STATE_FREE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snums</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">state</span> <span class="o">=</span> <span class="n">QE_SNUM_STATE_USED</span><span class="p">;</span>
			<span class="n">snum</span> <span class="o">=</span> <span class="n">snums</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snum</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">qe_get_snum</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">qe_put_snum</span><span class="p">(</span><span class="n">u8</span> <span class="n">snum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qe_num_of_snum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">snums</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num</span> <span class="o">==</span> <span class="n">snum</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snums</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">state</span> <span class="o">=</span> <span class="n">QE_SNUM_STATE_FREE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">qe_put_snum</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qe_sdma_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sdma</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">sdma</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qe_immr</span><span class="o">-&gt;</span><span class="n">sdma</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sdma_buf_offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdma</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* allocate 2 internal temporary buffers (512 bytes size each) for</span>
<span class="cm">	 * the SDMA */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">sdma_buf_offset</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sdma_buf_offset</span> <span class="o">=</span> <span class="n">qe_muram_alloc</span><span class="p">(</span><span class="mi">512</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">sdma_buf_offset</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdma</span><span class="o">-&gt;</span><span class="n">sdebcr</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">sdma_buf_offset</span> <span class="o">&amp;</span> <span class="n">QE_SDEBCR_BA_MASK</span><span class="p">);</span>
 	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdma</span><span class="o">-&gt;</span><span class="n">sdmr</span><span class="p">,</span> <span class="p">(</span><span class="n">QE_SDMR_GLB_1_MSK</span> <span class="o">|</span>
 					<span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">QE_SDMR_CEN_SHIFT</span><span class="p">)));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The maximum number of RISCs we support */</span>
<span class="cp">#define MAX_QE_RISC     4</span>

<span class="cm">/* Firmware information stored here for qe_get_firmware_info() */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">qe_firmware_info</span> <span class="n">qe_firmware_info</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Set to 1 if QE firmware has been uploaded, and therefore</span>
<span class="cm"> * qe_firmware_info contains valid data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">qe_firmware_uploaded</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Upload a QE microcode</span>
<span class="cm"> *</span>
<span class="cm"> * This function is a worker function for qe_upload_firmware().  It does</span>
<span class="cm"> * the actual uploading of the microcode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qe_upload_microcode</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">qe_microcode</span> <span class="o">*</span><span class="n">ucode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">code</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ucode</span><span class="o">-&gt;</span><span class="n">code_offset</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ucode</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">||</span> <span class="n">ucode</span><span class="o">-&gt;</span><span class="n">minor</span> <span class="o">||</span> <span class="n">ucode</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;qe-firmware: &quot;</span>
			<span class="s">&quot;uploading microcode &#39;%s&#39; version %u.%u.%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ucode</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">ucode</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">,</span> <span class="n">ucode</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">,</span> <span class="n">ucode</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;qe-firmware: &quot;</span>
			<span class="s">&quot;uploading microcode &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ucode</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="cm">/* Use auto-increment */</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_immr</span><span class="o">-&gt;</span><span class="n">iram</span><span class="p">.</span><span class="n">iadd</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ucode</span><span class="o">-&gt;</span><span class="n">iram_offset</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">QE_IRAM_IADD_AIE</span> <span class="o">|</span> <span class="n">QE_IRAM_IADD_BADDR</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ucode</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_immr</span><span class="o">-&gt;</span><span class="n">iram</span><span class="p">.</span><span class="n">idata</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">code</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Upload a microcode to the I-RAM at a specific address.</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/powerpc/qe_firmware.txt for information on QE microcode</span>
<span class="cm"> * uploading.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently, only version 1 is supported, so the &#39;version&#39; field must be</span>
<span class="cm"> * set to 1.</span>
<span class="cm"> *</span>
<span class="cm"> * The SOC model and revision are not validated, they are only displayed for</span>
<span class="cm"> * informational purposes.</span>
<span class="cm"> *</span>
<span class="cm"> * &#39;calc_size&#39; is the calculated size, in bytes, of the firmware structure and</span>
<span class="cm"> * all of the microcode structures, minus the CRC.</span>
<span class="cm"> *</span>
<span class="cm"> * &#39;length&#39; is the size that the structure says it is, including the CRC.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">qe_upload_firmware</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">qe_firmware</span> <span class="o">*</span><span class="n">firmware</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">crc</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">calc_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">qe_firmware</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">qe_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firmware</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;qe-firmware: invalid pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">firmware</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="cm">/* Check the magic */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;Q&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;E&#39;</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;F&#39;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;qe-firmware: not a microcode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check the version */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;qe-firmware: unsupported version</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Validate some of the fields */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">firmware</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">firmware</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">MAX_QE_RISC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;qe-firmware: invalid data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Validate the length and check if there&#39;s a CRC */</span>
	<span class="n">calc_size</span> <span class="o">+=</span> <span class="p">(</span><span class="n">firmware</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">qe_microcode</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">firmware</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * For situations where the second RISC uses the same microcode</span>
<span class="cm">		 * as the first, the &#39;code_offset&#39; and &#39;count&#39; fields will be</span>
<span class="cm">		 * zero, so it&#39;s okay to add those.</span>
<span class="cm">		 */</span>
		<span class="n">calc_size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be32</span><span class="p">)</span> <span class="o">*</span>
			<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">firmware</span><span class="o">-&gt;</span><span class="n">microcode</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span><span class="p">);</span>

	<span class="cm">/* Validate the length */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">!=</span> <span class="n">calc_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be32</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;qe-firmware: invalid length</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Validate the CRC */</span>
	<span class="n">crc</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">firmware</span> <span class="o">+</span> <span class="n">calc_size</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crc</span> <span class="o">!=</span> <span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">firmware</span><span class="p">,</span> <span class="n">calc_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;qe-firmware: firmware CRC is invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the microcode calls for it, split the I-RAM.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firmware</span><span class="o">-&gt;</span><span class="n">split</span><span class="p">)</span>
		<span class="n">setbits16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_immr</span><span class="o">-&gt;</span><span class="n">cp</span><span class="p">.</span><span class="n">cercr</span><span class="p">,</span> <span class="n">QE_CP_CERCR_CIR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">firmware</span><span class="o">-&gt;</span><span class="n">soc</span><span class="p">.</span><span class="n">model</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			<span class="s">&quot;qe-firmware: firmware &#39;%s&#39; for %u V%u.%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">firmware</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">firmware</span><span class="o">-&gt;</span><span class="n">soc</span><span class="p">.</span><span class="n">model</span><span class="p">),</span>
			<span class="n">firmware</span><span class="o">-&gt;</span><span class="n">soc</span><span class="p">.</span><span class="n">major</span><span class="p">,</span> <span class="n">firmware</span><span class="o">-&gt;</span><span class="n">soc</span><span class="p">.</span><span class="n">minor</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;qe-firmware: firmware &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">firmware</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The QE only supports one microcode per RISC, so clear out all the</span>
<span class="cm">	 * saved microcode information and put in the new.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_firmware_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">qe_firmware_info</span><span class="p">));</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">qe_firmware_info</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">firmware</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">qe_firmware_info</span><span class="p">.</span><span class="n">extended_modes</span> <span class="o">=</span> <span class="n">firmware</span><span class="o">-&gt;</span><span class="n">extended_modes</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">qe_firmware_info</span><span class="p">.</span><span class="n">vtraps</span><span class="p">,</span> <span class="n">firmware</span><span class="o">-&gt;</span><span class="n">vtraps</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">firmware</span><span class="o">-&gt;</span><span class="n">vtraps</span><span class="p">));</span>

	<span class="cm">/* Loop through each microcode. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">firmware</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">qe_microcode</span> <span class="o">*</span><span class="n">ucode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">firmware</span><span class="o">-&gt;</span><span class="n">microcode</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/* Upload a microcode if it&#39;s present */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ucode</span><span class="o">-&gt;</span><span class="n">code_offset</span><span class="p">)</span>
			<span class="n">qe_upload_microcode</span><span class="p">(</span><span class="n">firmware</span><span class="p">,</span> <span class="n">ucode</span><span class="p">);</span>

		<span class="cm">/* Program the traps for this processor */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">trap</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ucode</span><span class="o">-&gt;</span><span class="n">traps</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">trap</span><span class="p">)</span>
				<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_immr</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tibcr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">trap</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Enable traps */</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_immr</span><span class="o">-&gt;</span><span class="n">rsp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">eccr</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ucode</span><span class="o">-&gt;</span><span class="n">eccr</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">qe_firmware_uploaded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">qe_upload_firmware</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Get info on the currently-loaded firmware</span>
<span class="cm"> *</span>
<span class="cm"> * This function also checks the device tree to see if the boot loader has</span>
<span class="cm"> * uploaded a firmware already.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qe_firmware_info</span> <span class="o">*</span><span class="nf">qe_get_firmware_info</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">initialized</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">qe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">fw</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sprop</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we haven&#39;t checked yet, and a driver hasn&#39;t uploaded a firmware</span>
<span class="cm">	 * yet, then check the device tree for information.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qe_firmware_uploaded</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">qe_firmware_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">initialized</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Newer device trees have an &quot;fsl,qe&quot; compatible property for the QE</span>
<span class="cm">	 * node, but we still need to support older device trees.</span>
<span class="cm">	*/</span>
	<span class="n">qe</span> <span class="o">=</span> <span class="n">of_find_compatible_node</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;fsl,qe&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qe</span> <span class="o">=</span> <span class="n">of_find_node_by_type</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;qe&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qe</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Find the &#39;firmware&#39; child node */</span>
	<span class="n">for_each_child_of_node</span><span class="p">(</span><span class="n">qe</span><span class="p">,</span> <span class="n">fw</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;firmware&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">of_node_put</span><span class="p">(</span><span class="n">qe</span><span class="p">);</span>

	<span class="cm">/* Did we find the &#39;firmware&#39; node? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">qe_firmware_uploaded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Copy the data into qe_firmware_info*/</span>
	<span class="n">sprop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">fw</span><span class="p">,</span> <span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sprop</span><span class="p">)</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">qe_firmware_info</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">sprop</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">qe_firmware_info</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">of_find_property</span><span class="p">(</span><span class="n">fw</span><span class="p">,</span> <span class="s">&quot;extended-modes&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">iprop</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

		<span class="n">qe_firmware_info</span><span class="p">.</span><span class="n">extended_modes</span> <span class="o">=</span> <span class="o">*</span><span class="n">iprop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">of_find_property</span><span class="p">(</span><span class="n">fw</span><span class="p">,</span> <span class="s">&quot;virtual-traps&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">==</span> <span class="mi">32</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">iprop</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">qe_firmware_info</span><span class="p">.</span><span class="n">vtraps</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">qe_firmware_info</span><span class="p">.</span><span class="n">vtraps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">iprop</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">of_node_put</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">qe_firmware_info</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">qe_get_firmware_info</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">qe_get_num_of_risc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">qe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_of_risc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>

	<span class="n">qe</span> <span class="o">=</span> <span class="n">of_find_compatible_node</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;fsl,qe&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qe</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Older devices trees did not have an &quot;fsl,qe&quot;</span>
<span class="cm">		 * compatible property, so we need to look for</span>
<span class="cm">		 * the QE node by name.</span>
<span class="cm">		 */</span>
		<span class="n">qe</span> <span class="o">=</span> <span class="n">of_find_node_by_type</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;qe&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qe</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">num_of_risc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">qe</span><span class="p">,</span> <span class="s">&quot;fsl,qe-num-riscs&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">prop</span><span class="p">))</span>
		<span class="n">num_of_risc</span> <span class="o">=</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>

	<span class="n">of_node_put</span><span class="p">(</span><span class="n">qe</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">num_of_risc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">qe_get_num_of_risc</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">qe_get_num_of_snums</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">qe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_of_snums</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>

	<span class="n">num_of_snums</span> <span class="o">=</span> <span class="mi">28</span><span class="p">;</span> <span class="cm">/* The default number of snum for threads is 28 */</span>
	<span class="n">qe</span> <span class="o">=</span> <span class="n">of_find_compatible_node</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;fsl,qe&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qe</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Older devices trees did not have an &quot;fsl,qe&quot;</span>
<span class="cm">		 * compatible property, so we need to look for</span>
<span class="cm">		 * the QE node by name.</span>
<span class="cm">		 */</span>
		<span class="n">qe</span> <span class="o">=</span> <span class="n">of_find_node_by_type</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;qe&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qe</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">num_of_snums</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">qe</span><span class="p">,</span> <span class="s">&quot;fsl,qe-num-snums&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">prop</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">num_of_snums</span> <span class="o">=</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">num_of_snums</span> <span class="o">&lt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">num_of_snums</span> <span class="o">&gt;</span> <span class="n">QE_NUM_OF_SNUM</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* No QE ever has fewer than 28 SNUMs */</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;QE: number of snum is invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">of_node_put</span><span class="p">(</span><span class="n">qe</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">of_node_put</span><span class="p">(</span><span class="n">qe</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">num_of_snums</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">qe_get_num_of_snums</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_SUSPEND) &amp;&amp; defined(CONFIG_PPC_85xx)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qe_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">ofdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qe_alive_during_sleep</span><span class="p">())</span>
		<span class="n">qe_reset</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qe_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">ofdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">qe_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;fsl,qe&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">qe_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;fsl-qe&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">qe_ids</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">qe_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">qe_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">qe_drv_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">device_initcall</span><span class="p">(</span><span class="n">qe_drv_init</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* defined(CONFIG_SUSPEND) &amp;&amp; defined(CONFIG_PPC_85xx) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
