<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › perf › core-fsl-emb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>core-fsl-emb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Performance event support - Freescale Embedded Performance Monitor</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2008-2009 Paul Mackerras, IBM Corporation.</span>
<span class="cm"> * Copyright 2010 Freescale Semiconductor, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/perf_event.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;asm/reg_fsl_emb.h&gt;</span>
<span class="cp">#include &lt;asm/pmc.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/firmware.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>

<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">n_events</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">disabled</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">pmcs_enabled</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span><span class="p">,</span> <span class="n">cpu_hw_events</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fsl_emb_pmu</span> <span class="o">*</span><span class="n">ppmu</span><span class="p">;</span>

<span class="cm">/* Number of perf_events counting hardware events */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">num_events</span><span class="p">;</span>
<span class="cm">/* Used to avoid races in calling reserve/release_pmc_hardware */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">pmc_reserve_mutex</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * If interrupts were soft-disabled when a PMU interrupt occurs, treat</span>
<span class="cm"> * it as an NMI.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">perf_intr_is_nmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef __powerpc64__</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">softe</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">perf_event_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Read one performance monitor counter (PMC).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">read_pmc</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">mfpmr</span><span class="p">(</span><span class="n">PMRN_PMC0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">mfpmr</span><span class="p">(</span><span class="n">PMRN_PMC1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">mfpmr</span><span class="p">(</span><span class="n">PMRN_PMC2</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">mfpmr</span><span class="p">(</span><span class="n">PMRN_PMC3</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;oops trying to read PMC%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write one PMC.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_pmc</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMC0</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMC1</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMC2</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMC3</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;oops trying to write PMC%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">isync</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write one local control A register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_pmlca</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMLCA0</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMLCA1</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMLCA2</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMLCA3</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;oops trying to write PMLCA%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">isync</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write one local control B register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_pmlcb</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMLCB0</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMLCB1</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMLCB2</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMLCB3</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;oops trying to write PMLCB%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">isync</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_emb_pmu_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">val</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">prev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Performance monitor interrupts come even when interrupts</span>
<span class="cm">	 * are soft-disabled, as long as interrupts are hard-enabled.</span>
<span class="cm">	 * Therefore we treat them like NMIs.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">);</span>
		<span class="n">barrier</span><span class="p">();</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">read_pmc</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">local64_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">);</span>

	<span class="cm">/* The counters are only 32 bits wide */</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">prev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffffffful</span><span class="p">;</span>
	<span class="n">local64_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">local64_sub</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_left</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disable all events to prevent PMU interrupts and to allow</span>
<span class="cm"> * events to be added or removed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_emb_pmu_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check if we ever enabled the PMU on this cpu.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">pmcs_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ppc_enable_pmcs</span><span class="p">();</span>
			<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">pmcs_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_events</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Set the &#39;freeze all counters&#39; bit, and disable</span>
<span class="cm">			 * interrupts.  The barrier is to make sure the</span>
<span class="cm">			 * mtpmr has been executed and the PMU has frozen</span>
<span class="cm">			 * the events before we return.</span>
<span class="cm">			 */</span>

			<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMGC0</span><span class="p">,</span> <span class="n">PMGC0_FAC</span><span class="p">);</span>
			<span class="n">isync</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Re-enable all events if disable == 0.</span>
<span class="cm"> * If we were previously disabled and events were added, then</span>
<span class="cm"> * put the new config on the PMU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_emb_pmu_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ppc_set_pmu_inuse</span><span class="p">(</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMGC0</span><span class="p">,</span> <span class="n">PMGC0_PMIE</span> <span class="o">|</span> <span class="n">PMGC0_FCECE</span><span class="p">);</span>
		<span class="n">isync</span><span class="p">();</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">collect_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_count</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">ctrs</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_software_event</span><span class="p">(</span><span class="n">group</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">max_count</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">ctrs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="p">;</span>
		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_software_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">max_count</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">ctrs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>
			<span class="n">n</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* context locked on entry */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_emb_pmu_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_counters</span> <span class="o">=</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">n_counter</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span> <span class="o">&amp;</span> <span class="n">FSL_EMB_EVENT_RESTRICTED</span><span class="p">)</span>
		<span class="n">num_counters</span> <span class="o">=</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">n_restricted</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate counters from top-down, so that restricted-capable</span>
<span class="cm">	 * counters are kept free as long as possible.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">num_counters</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>
	<span class="o">++</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_period</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s64</span> <span class="n">left</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_left</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="mh">0x80000000L</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="mh">0x80000000L</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_EF_START</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_HES_STOPPED</span> <span class="o">|</span> <span class="n">PERF_HES_UPTODATE</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">write_pmc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="n">write_pmlcb</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">write_pmlca</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config_base</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">put_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* context locked on entry */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_emb_pmu_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">;</span>

	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">fsl_emb_pmu_read</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">event</span> <span class="o">!=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">]);</span>

	<span class="n">write_pmlca</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">write_pmlcb</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">write_pmc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * TODO: if at least one restricted event exists, and we</span>
<span class="cm">	 * just freed up a non-restricted-capable counter, and</span>
<span class="cm">	 * there is a restricted-capable counter occupied by</span>
<span class="cm">	 * a non-restricted event, migrate that event to the</span>
<span class="cm">	 * vacated counter.</span>
<span class="cm">	 */</span>

	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="o">--</span><span class="p">;</span>

 <span class="nl">out:</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">put_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_emb_pmu_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ef_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">left</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_period</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ef_flags</span> <span class="o">&amp;</span> <span class="n">PERF_EF_RELOAD</span><span class="p">)</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_UPTODATE</span><span class="p">));</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">left</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_left</span><span class="p">);</span>
	<span class="n">write_pmc</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>

	<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_emb_pmu_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ef_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_period</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>

	<span class="n">fsl_emb_pmu_read</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">|=</span> <span class="n">PERF_HES_STOPPED</span> <span class="o">|</span> <span class="n">PERF_HES_UPTODATE</span><span class="p">;</span>
	<span class="n">write_pmc</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release the PMU if this is the last perf_event.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_perf_event_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_events</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmc_reserve_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_events</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">release_pmc_hardware</span><span class="p">();</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmc_reserve_mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Translate a generic cache event_id config to a raw event_id code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hw_perf_cache_event</span><span class="p">(</span><span class="n">u64</span> <span class="n">config</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">eventp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">cache_events</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* unpack config */</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">config</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="n">config</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">config</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">PERF_COUNT_HW_CACHE_MAX</span> <span class="o">||</span>
	    <span class="n">op</span> <span class="o">&gt;=</span> <span class="n">PERF_COUNT_HW_CACHE_OP_MAX</span> <span class="o">||</span>
	    <span class="n">result</span> <span class="o">&gt;=</span> <span class="n">PERF_COUNT_HW_CACHE_RESULT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ev</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">cache_events</span><span class="p">)[</span><span class="n">type</span><span class="p">][</span><span class="n">op</span><span class="p">][</span><span class="n">result</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">eventp</span> <span class="o">=</span> <span class="n">ev</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_emb_pmu_event_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">events</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_restricted</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PERF_TYPE_HARDWARE</span>:
		<span class="n">ev</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ev</span> <span class="o">&gt;=</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">n_generic</span> <span class="o">||</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">generic_events</span><span class="p">[</span><span class="n">ev</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="n">ev</span> <span class="o">=</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">generic_events</span><span class="p">[</span><span class="n">ev</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PERF_TYPE_HW_CACHE</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">hw_perf_cache_event</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PERF_TYPE_RAW</span>:
		<span class="n">ev</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">xlate_event</span><span class="p">(</span><span class="n">ev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span> <span class="o">&amp;</span> <span class="n">FSL_EMB_EVENT_VALID</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is in a group, check if it can go on with all the</span>
<span class="cm">	 * other hardware events in the group.  We assume the event</span>
<span class="cm">	 * hasn&#39;t been linked into its leader&#39;s sibling list at this point.</span>
<span class="cm">	 */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">!=</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">collect_events</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">,</span>
		                   <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">n_counter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">events</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span> <span class="o">&amp;</span> <span class="n">FSL_EMB_EVENT_RESTRICTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num_restricted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span> <span class="o">&amp;</span> <span class="n">FSL_EMB_EVENT_RESTRICTED</span><span class="p">)</span>
				<span class="n">num_restricted</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">num_restricted</span> <span class="o">&gt;=</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">n_restricted</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config_base</span> <span class="o">=</span> <span class="n">PMLCA_CE</span> <span class="o">|</span> <span class="n">PMLCA_FCM1</span> <span class="o">|</span>
	                        <span class="p">(</span><span class="n">u32</span><span class="p">)((</span><span class="n">ev</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PMLCA_EVENT_MASK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_user</span><span class="p">)</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config_base</span> <span class="o">|=</span> <span class="n">PMLCA_FCU</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_kernel</span><span class="p">)</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config_base</span> <span class="o">|=</span> <span class="n">PMLCA_FCS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_idle</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">last_period</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_period</span><span class="p">;</span>
	<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_left</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">last_period</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if we need to reserve the PMU.</span>
<span class="cm">	 * If no events are currently in use, then we have to take a</span>
<span class="cm">	 * mutex to ensure that we don&#39;t race with another task doing</span>
<span class="cm">	 * reserve_pmc_hardware or release_pmc_hardware.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_events</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmc_reserve_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_events</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">reserve_pmc_hardware</span><span class="p">(</span><span class="n">perf_event_interrupt</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_events</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmc_reserve_mutex</span><span class="p">);</span>

		<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMGC0</span><span class="p">,</span> <span class="n">PMGC0_FAC</span><span class="p">);</span>
		<span class="n">isync</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">hw_perf_event_destroy</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pmu</span> <span class="n">fsl_emb_pmu</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">pmu_enable</span>	<span class="o">=</span> <span class="n">fsl_emb_pmu_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pmu_disable</span>	<span class="o">=</span> <span class="n">fsl_emb_pmu_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">event_init</span>	<span class="o">=</span> <span class="n">fsl_emb_pmu_event_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">add</span>		<span class="o">=</span> <span class="n">fsl_emb_pmu_add</span><span class="p">,</span>
	<span class="p">.</span><span class="n">del</span>		<span class="o">=</span> <span class="n">fsl_emb_pmu_del</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>		<span class="o">=</span> <span class="n">fsl_emb_pmu_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">fsl_emb_pmu_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">fsl_emb_pmu_read</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * A counter has overflowed; update its count and record</span>
<span class="cm"> * things if requested.  Note that interrupts are hard-disabled</span>
<span class="cm"> * here so there is no possibility of being interrupted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">record_and_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">period</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_period</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">prev</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">left</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">record</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_pmc</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we don&#39;t have to worry about interrupts here */</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">);</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">prev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffffffful</span><span class="p">;</span>
	<span class="n">local64_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if the total period for this event has expired,</span>
<span class="cm">	 * and update for the next period.</span>
<span class="cm">	 */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">left</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_left</span><span class="p">)</span> <span class="o">-</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">period</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">left</span> <span class="o">+=</span> <span class="n">period</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">left</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
			<span class="n">record</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">last_period</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_period</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="mh">0x80000000LL</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="mh">0x80000000LL</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">write_pmc</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_left</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
	<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finally record data if requested.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">record</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="n">data</span><span class="p">;</span>

		<span class="n">perf_sample_data_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">last_period</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">perf_event_overflow</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span>
			<span class="n">fsl_emb_pmu_stop</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nmi</span><span class="p">;</span>

	<span class="n">nmi</span> <span class="o">=</span> <span class="n">perf_intr_is_nmi</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nmi</span><span class="p">)</span>
		<span class="n">nmi_enter</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">irq_enter</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">n_counter</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">read_pmc</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* event has overflowed */</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">record_and_restart</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Disabled counter is negative,</span>
<span class="cm">				 * reset it just in case.</span>
<span class="cm">				 */</span>
				<span class="n">write_pmc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* PMM will keep counters frozen until we return from the interrupt. */</span>
	<span class="n">mtmsr</span><span class="p">(</span><span class="n">mfmsr</span><span class="p">()</span> <span class="o">|</span> <span class="n">MSR_PMM</span><span class="p">);</span>
	<span class="n">mtpmr</span><span class="p">(</span><span class="n">PMRN_PMGC0</span><span class="p">,</span> <span class="n">PMGC0_PMIE</span> <span class="o">|</span> <span class="n">PMGC0_FCECE</span><span class="p">);</span>
	<span class="n">isync</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nmi</span><span class="p">)</span>
		<span class="n">nmi_exit</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">irq_exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">hw_perf_event_setup</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">cpuhw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cpuhw</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">register_fsl_emb_pmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_emb_pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppmu</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>		<span class="cm">/* something&#39;s already registered */</span>

	<span class="n">ppmu</span> <span class="o">=</span> <span class="n">pmu</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s performance monitor hardware support registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">perf_pmu_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsl_emb_pmu</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">PERF_TYPE_RAW</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
