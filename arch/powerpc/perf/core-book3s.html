<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › perf › core-book3s.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>core-book3s.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Performance event support - powerpc architecture code</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2008-2009 Paul Mackerras, IBM Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/perf_event.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;asm/reg.h&gt;</span>
<span class="cp">#include &lt;asm/pmc.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/firmware.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>

<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">n_events</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_percpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">disabled</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_added</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_limited</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">pmcs_enabled</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">events</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmcr</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">limited_counter</span><span class="p">[</span><span class="n">MAX_LIMITED_HWCOUNTERS</span><span class="p">];</span>
	<span class="n">u8</span>  <span class="n">limited_hwidx</span><span class="p">[</span><span class="n">MAX_LIMITED_HWCOUNTERS</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">alternatives</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">][</span><span class="n">MAX_EVENT_ALTERNATIVES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">amasks</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">][</span><span class="n">MAX_EVENT_ALTERNATIVES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avalues</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">][</span><span class="n">MAX_EVENT_ALTERNATIVES</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group_flag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_txn_start</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span><span class="p">,</span> <span class="n">cpu_hw_events</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">power_pmu</span> <span class="o">*</span><span class="n">ppmu</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Normally, to ignore kernel events we set the FCS (freeze counters</span>
<span class="cm"> * in supervisor mode) bit in MMCR0, but if the kernel runs with the</span>
<span class="cm"> * hypervisor bit set in the MSR, or if we are running on a processor</span>
<span class="cm"> * where the hypervisor bit is forced to 1 (as on Apple G5 processors),</span>
<span class="cm"> * then we need to use the FCHV bit to ignore kernel events.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freeze_events_kernel</span> <span class="o">=</span> <span class="n">MMCR0_FCS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * 32-bit doesn&#39;t have MMCRA but does have an MMCR2,</span>
<span class="cm"> * and a few other names are different.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PPC32</span>

<span class="cp">#define MMCR0_FCHV		0</span>
<span class="cp">#define MMCR0_PMCjCE		MMCR0_PMCnCE</span>

<span class="cp">#define SPRN_MMCRA		SPRN_MMCR2</span>
<span class="cp">#define MMCRA_SAMPLE_ENABLE	0</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">perf_ip_adjust</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_get_data_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">addrp</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">perf_get_misc_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_read_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">perf_intr_is_nmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC32 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Things that are specific to 64-bit implementations.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PPC64</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">perf_ip_adjust</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmcra</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">dsisr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mmcra</span> <span class="o">&amp;</span> <span class="n">MMCRA_SAMPLE_ENABLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PPMU_ALT_SIPR</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">slot</span> <span class="o">=</span> <span class="p">(</span><span class="n">mmcra</span> <span class="o">&amp;</span> <span class="n">MMCRA_SLOT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">MMCRA_SLOT_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The user wants a data address recorded.</span>
<span class="cm"> * If we&#39;re not doing instruction sampling, give them the SDAR</span>
<span class="cm"> * (sampled data address).  If we are doing instruction sampling, then</span>
<span class="cm"> * only give them the SDAR if it corresponds to the instruction</span>
<span class="cm"> * pointed to by SIAR; this is indicated by the [POWER6_]MMCRA_SDSYNC</span>
<span class="cm"> * bit in MMCRA.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_get_data_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">addrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmcra</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">dsisr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sdsync</span> <span class="o">=</span> <span class="p">(</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PPMU_ALT_SIPR</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">POWER6_MMCRA_SDSYNC</span> <span class="o">:</span> <span class="n">MMCRA_SDSYNC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mmcra</span> <span class="o">&amp;</span> <span class="n">MMCRA_SAMPLE_ENABLE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">mmcra</span> <span class="o">&amp;</span> <span class="n">sdsync</span><span class="p">))</span>
		<span class="o">*</span><span class="n">addrp</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_SDAR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">perf_flags_from_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_PR</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PERF_RECORD_MISC_USER</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_HV</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">freeze_events_kernel</span> <span class="o">!=</span> <span class="n">MMCR0_FCHV</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PERF_RECORD_MISC_HYPERVISOR</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">PERF_RECORD_MISC_KERNEL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">perf_get_misc_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmcra</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">dsisr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sihv</span> <span class="o">=</span> <span class="n">MMCRA_SIHV</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sipr</span> <span class="o">=</span> <span class="n">MMCRA_SIPR</span><span class="p">;</span>

	<span class="cm">/* Not a PMU interrupt: Make up flags from regs-&gt;msr */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TRAP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xf00</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">perf_flags_from_msr</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t support continuous sampling and this</span>
<span class="cm">	 * is not a marked event, same deal</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PPMU_NO_CONT_SAMPLING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">mmcra</span> <span class="o">&amp;</span> <span class="n">MMCRA_SAMPLE_ENABLE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">perf_flags_from_msr</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t have flags in MMCRA, rather than using</span>
<span class="cm">	 * the MSR, we intuit the flags from the address in</span>
<span class="cm">	 * SIAR which should give slightly more reliable</span>
<span class="cm">	 * results</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PPMU_NO_SIPR</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">siar</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_SIAR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">siar</span> <span class="o">&gt;=</span> <span class="n">PAGE_OFFSET</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">PERF_RECORD_MISC_KERNEL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">PERF_RECORD_MISC_USER</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PPMU_ALT_SIPR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sihv</span> <span class="o">=</span> <span class="n">POWER6_MMCRA_SIHV</span><span class="p">;</span>
		<span class="n">sipr</span> <span class="o">=</span> <span class="n">POWER6_MMCRA_SIPR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* PR has priority over HV, so order below is important */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmcra</span> <span class="o">&amp;</span> <span class="n">sipr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PERF_RECORD_MISC_USER</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mmcra</span> <span class="o">&amp;</span> <span class="n">sihv</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">freeze_events_kernel</span> <span class="o">!=</span> <span class="n">MMCR0_FCHV</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PERF_RECORD_MISC_HYPERVISOR</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">PERF_RECORD_MISC_KERNEL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Overload regs-&gt;dsisr to store MMCRA so we only need to read it once</span>
<span class="cm"> * on each interrupt.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_read_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">dsisr</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_MMCRA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If interrupts were soft-disabled when a PMU interrupt occurs, treat</span>
<span class="cm"> * it as an NMI.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">perf_intr_is_nmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">softe</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">perf_event_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">perf_event_print_debug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read one performance monitor counter (PMC).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">read_pmc</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_PMC1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_PMC2</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_PMC3</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_PMC4</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">5</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_PMC5</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">6</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_PMC6</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="k">case</span> <span class="mi">7</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_PMC7</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_PMC8</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;oops trying to read PMC%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write one PMC.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_pmc</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_PMC1</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_PMC2</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_PMC3</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_PMC4</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">5</span>:
		<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_PMC5</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">6</span>:
		<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_PMC6</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PPC64</span>
	<span class="k">case</span> <span class="mi">7</span>:
		<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_PMC7</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_PMC8</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;oops trying to write PMC%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if a set of events can all go on the PMU at once.</span>
<span class="cm"> * If they can&#39;t, this will look at alternative codes for the events</span>
<span class="cm"> * and see if any combination of alternative codes is feasible.</span>
<span class="cm"> * The feasible set is returned in event_id[].</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">power_check_constraints</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span><span class="p">,</span>
				   <span class="n">u64</span> <span class="n">event_id</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cflags</span><span class="p">[],</span>
				   <span class="kt">int</span> <span class="n">n_ev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">nv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">smasks</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">],</span> <span class="n">svalues</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">n_alt</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">],</span> <span class="n">choice</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addf</span> <span class="o">=</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">add_fields</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tadd</span> <span class="o">=</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">test_adder</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n_ev</span> <span class="o">&gt;</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">n_counter</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* First see if the events will go on as-is */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_ev</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cflags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">PPMU_LIMITED_PMC_REQD</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">limited_pmc_event</span><span class="p">(</span><span class="n">event_id</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">get_alternatives</span><span class="p">(</span><span class="n">event_id</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cflags</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					       <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">alternatives</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">event_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">alternatives</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">get_constraint</span><span class="p">(</span><span class="n">event_id</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">amasks</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
					 <span class="o">&amp;</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">avalues</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_ev</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nv</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">|</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">avalues</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">avalues</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">addf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((((</span><span class="n">nv</span> <span class="o">+</span> <span class="n">tadd</span><span class="p">)</span> <span class="o">^</span> <span class="n">value</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="p">(((</span><span class="n">nv</span> <span class="o">+</span> <span class="n">tadd</span><span class="p">)</span> <span class="o">^</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">avalues</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span>
		     <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">amasks</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">nv</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">amasks</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">n_ev</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* all OK */</span>

	<span class="cm">/* doesn&#39;t work, gather alternatives... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">get_alternatives</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_ev</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">choice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">n_alt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">get_alternatives</span><span class="p">(</span><span class="n">event_id</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cflags</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						  <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">alternatives</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n_alt</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
			<span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">get_constraint</span><span class="p">(</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">alternatives</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
					     <span class="o">&amp;</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">amasks</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
					     <span class="o">&amp;</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">avalues</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* enumerate all possibilities and see if any will work */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">nv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_ev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* we&#39;re backtracking, restore context */</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">svalues</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">smasks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">j</span> <span class="o">=</span> <span class="n">choice</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * See if any alternative k for event_id i,</span>
<span class="cm">		 * where k &gt; j, will satisfy the constraints.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">n_alt</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">nv</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">|</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">avalues</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">avalues</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">addf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((((</span><span class="n">nv</span> <span class="o">+</span> <span class="n">tadd</span><span class="p">)</span> <span class="o">^</span> <span class="n">value</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(((</span><span class="n">nv</span> <span class="o">+</span> <span class="n">tadd</span><span class="p">)</span> <span class="o">^</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">avalues</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
			     <span class="o">&amp;</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">amasks</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">n_alt</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * No feasible alternative, backtrack</span>
<span class="cm">			 * to event_id i-1 and continue enumerating its</span>
<span class="cm">			 * alternatives from where we got up to.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Found a feasible alternative for event_id i,</span>
<span class="cm">			 * remember where we got up to with this event_id,</span>
<span class="cm">			 * go on to the next event_id, and start with</span>
<span class="cm">			 * the first alternative for it.</span>
<span class="cm">			 */</span>
			<span class="n">choice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
			<span class="n">svalues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
			<span class="n">smasks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">nv</span><span class="p">;</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">amasks</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
			<span class="o">++</span><span class="n">i</span><span class="p">;</span>
			<span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* OK, we have a feasible combination, tell the caller the solution */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_ev</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">event_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">alternatives</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">choice</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if newly-added events have consistent settings for</span>
<span class="cm"> * exclude_{user,kernel,hv} with each other and any previously</span>
<span class="cm"> * added events.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_excludes</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">**</span><span class="n">ctrs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cflags</span><span class="p">[],</span>
			  <span class="kt">int</span> <span class="n">n_prev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">eu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ek</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">first</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">n_prev</span> <span class="o">+</span> <span class="n">n_new</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cflags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">PPMU_LIMITED_PMC_OK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cflags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PPMU_LIMITED_PMC_REQD</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">ctrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eu</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_user</span><span class="p">;</span>
			<span class="n">ek</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_kernel</span><span class="p">;</span>
			<span class="n">eh</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_hv</span><span class="p">;</span>
			<span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_user</span> <span class="o">!=</span> <span class="n">eu</span> <span class="o">||</span>
			   <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_kernel</span> <span class="o">!=</span> <span class="n">ek</span> <span class="o">||</span>
			   <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_hv</span> <span class="o">!=</span> <span class="n">eh</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eu</span> <span class="o">||</span> <span class="n">ek</span> <span class="o">||</span> <span class="n">eh</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cflags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">PPMU_LIMITED_PMC_OK</span><span class="p">)</span>
				<span class="n">cflags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">PPMU_LIMITED_PMC_REQD</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">check_and_compute_delta</span><span class="p">(</span><span class="n">u64</span> <span class="n">prev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">prev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffffffful</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * POWER7 can roll back counter values, if the new value is smaller</span>
<span class="cm">	 * than the previous value it will cause the delta and the counter to</span>
<span class="cm">	 * have bogus values unless we rolled a counter over.  If a coutner is</span>
<span class="cm">	 * rolled back, it will be smaller, but within 256, which is the maximum</span>
<span class="cm">	 * number of events to rollback at once.  If we dectect a rollback</span>
<span class="cm">	 * return 0.  This can lead to a small lack of precision in the</span>
<span class="cm">	 * counters.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&gt;</span> <span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">prev</span> <span class="o">-</span> <span class="n">val</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">)</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">power_pmu_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">val</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">prev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Performance monitor interrupts come even when interrupts</span>
<span class="cm">	 * are soft-disabled, as long as interrupts are hard-enabled.</span>
<span class="cm">	 * Therefore we treat them like NMIs.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">);</span>
		<span class="n">barrier</span><span class="p">();</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">read_pmc</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">);</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">check_and_compute_delta</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">delta</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">local64_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">);</span>

	<span class="n">local64_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">local64_sub</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_left</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * On some machines, PMC5 and PMC6 can&#39;t be written, don&#39;t respect</span>
<span class="cm"> * the freeze conditions, and don&#39;t generate interrupts.  This tells</span>
<span class="cm"> * us if `event&#39; is using such a PMC.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_limited_pmc</span><span class="p">(</span><span class="kt">int</span> <span class="n">pmcnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PPMU_LIMITED_PMC5_6</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pmcnum</span> <span class="o">==</span> <span class="mi">5</span> <span class="o">||</span> <span class="n">pmcnum</span> <span class="o">==</span> <span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">freeze_limited_counters</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmc5</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmc6</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_limited</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">limited_counter</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="o">?</span> <span class="n">pmc5</span> <span class="o">:</span> <span class="n">pmc6</span><span class="p">;</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">);</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">check_and_compute_delta</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span><span class="p">)</span>
			<span class="n">local64_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">thaw_limited_counters</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmc5</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmc6</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">,</span> <span class="n">prev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_limited</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">limited_counter</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">limited_hwidx</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="o">?</span> <span class="n">pmc5</span> <span class="o">:</span> <span class="n">pmc6</span><span class="p">;</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_and_compute_delta</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
			<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Since limited events don&#39;t respect the freeze conditions, we</span>
<span class="cm"> * have to read them immediately after freezing or unfreezing the</span>
<span class="cm"> * other events.  We try to keep the values from the limited</span>
<span class="cm"> * events as consistent as possible by keeping the delay (in</span>
<span class="cm"> * cycles and instructions) between freezing/unfreezing and reading</span>
<span class="cm"> * the limited events as small and consistent as possible.</span>
<span class="cm"> * Therefore, if any limited events are in use, we read them</span>
<span class="cm"> * both, and always in the same order, to minimize variability,</span>
<span class="cm"> * and do it inside the same asm that writes MMCR0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_mmcr0</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmcr0</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmc5</span><span class="p">,</span> <span class="n">pmc6</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_limited</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_MMCR0</span><span class="p">,</span> <span class="n">mmcr0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write MMCR0, then read PMC5 and PMC6 immediately.</span>
<span class="cm">	 * To ensure we don&#39;t get a performance monitor interrupt</span>
<span class="cm">	 * between writing MMCR0 and freezing/thawing the limited</span>
<span class="cm">	 * events, we first write MMCR0 with the event overflow</span>
<span class="cm">	 * interrupt enable bits turned off.</span>
<span class="cm">	 */</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;mtspr %3,%2; mfspr %0,%4; mfspr %1,%5&quot;</span>
		     <span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">pmc5</span><span class="p">),</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">pmc6</span><span class="p">)</span>
		     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">mmcr0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MMCR0_PMC1CE</span> <span class="o">|</span> <span class="n">MMCR0_PMCjCE</span><span class="p">)),</span>
		       <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">SPRN_MMCR0</span><span class="p">),</span>
		       <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">SPRN_PMC5</span><span class="p">),</span> <span class="s">&quot;i&quot;</span> <span class="p">(</span><span class="n">SPRN_PMC6</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mmcr0</span> <span class="o">&amp;</span> <span class="n">MMCR0_FC</span><span class="p">)</span>
		<span class="n">freeze_limited_counters</span><span class="p">(</span><span class="n">cpuhw</span><span class="p">,</span> <span class="n">pmc5</span><span class="p">,</span> <span class="n">pmc6</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">thaw_limited_counters</span><span class="p">(</span><span class="n">cpuhw</span><span class="p">,</span> <span class="n">pmc5</span><span class="p">,</span> <span class="n">pmc6</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write the full MMCR0 including the event overflow interrupt</span>
<span class="cm">	 * enable bits, if necessary.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmcr0</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MMCR0_PMC1CE</span> <span class="o">|</span> <span class="n">MMCR0_PMCjCE</span><span class="p">))</span>
		<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_MMCR0</span><span class="p">,</span> <span class="n">mmcr0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disable all events to prevent PMU interrupts and to allow</span>
<span class="cm"> * events to be added or removed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">power_pmu_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ppmu</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_added</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check if we ever enabled the PMU on this cpu.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">pmcs_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ppc_enable_pmcs</span><span class="p">();</span>
			<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">pmcs_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Disable instruction sampling if it was enabled</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MMCRA_SAMPLE_ENABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_MMCRA</span><span class="p">,</span>
			      <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MMCRA_SAMPLE_ENABLE</span><span class="p">);</span>
			<span class="n">mb</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set the &#39;freeze counters&#39; bit.</span>
<span class="cm">		 * The barrier is to make sure the mtspr has been</span>
<span class="cm">		 * executed and the PMU has frozen the events</span>
<span class="cm">		 * before we return.</span>
<span class="cm">		 */</span>
		<span class="n">write_mmcr0</span><span class="p">(</span><span class="n">cpuhw</span><span class="p">,</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_MMCR0</span><span class="p">)</span> <span class="o">|</span> <span class="n">MMCR0_FC</span><span class="p">);</span>
		<span class="n">mb</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Re-enable all events if disable == 0.</span>
<span class="cm"> * If we were previously disabled and events were added, then</span>
<span class="cm"> * put the new config on the PMU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">power_pmu_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">left</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hwc_index</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">n_lim</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ppmu</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we didn&#39;t change anything, or only removed events,</span>
<span class="cm">	 * no need to recalculate MMCR* settings and reset the PMCs.</span>
<span class="cm">	 * Just reenable the PMU with the current MMCR* settings</span>
<span class="cm">	 * (possibly updated for removal of events).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_added</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_MMCRA</span><span class="p">,</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MMCRA_SAMPLE_ENABLE</span><span class="p">);</span>
		<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_MMCR1</span><span class="p">,</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ppc_set_pmu_inuse</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_enable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute MMCR* values for the new set of events</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">compute_mmcr</span><span class="p">(</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">,</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">,</span> <span class="n">hwc_index</span><span class="p">,</span>
			       <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* shouldn&#39;t ever get here */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;oops compute_mmcr failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add in MMCR0 freeze bits corresponding to the</span>
<span class="cm">	 * attr.exclude_* bits for the first event.</span>
<span class="cm">	 * We have already checked that all events have the</span>
<span class="cm">	 * same values for these bits as the first event.</span>
<span class="cm">	 */</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_user</span><span class="p">)</span>
		<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">MMCR0_FCP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_kernel</span><span class="p">)</span>
		<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">freeze_events_kernel</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_hv</span><span class="p">)</span>
		<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">MMCR0_FCHV</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write the new configuration to MMCR* with the freeze</span>
<span class="cm">	 * bit set and set the hardware events to their initial values.</span>
<span class="cm">	 * Then unfreeze the events.</span>
<span class="cm">	 */</span>
	<span class="n">ppc_set_pmu_inuse</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_MMCRA</span><span class="p">,</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MMCRA_SAMPLE_ENABLE</span><span class="p">);</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_MMCR1</span><span class="p">,</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_MMCR0</span><span class="p">,</span> <span class="p">(</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MMCR0_PMC1CE</span> <span class="o">|</span> <span class="n">MMCR0_PMCjCE</span><span class="p">))</span>
				<span class="o">|</span> <span class="n">MMCR0_FC</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read off any pre-existing events that need to move</span>
<span class="cm">	 * to another PMC.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">!=</span> <span class="n">hwc_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">power_pmu_read</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
			<span class="n">write_pmc</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the PMCs for all the new and moved events.</span>
<span class="cm">	 */</span>
	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_limited</span> <span class="o">=</span> <span class="n">n_lim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">hwc_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_limited_pmc</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">limited_counter</span><span class="p">[</span><span class="n">n_lim</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>
			<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">limited_hwidx</span><span class="p">[</span><span class="n">n_lim</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
			<span class="o">++</span><span class="n">n_lim</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_period</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">left</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_left</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="mh">0x80000000L</span><span class="p">)</span>
				<span class="n">val</span> <span class="o">=</span> <span class="mh">0x80000000L</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">write_pmc</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_limited</span> <span class="o">=</span> <span class="n">n_lim</span><span class="p">;</span>
	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">MMCR0_PMXE</span> <span class="o">|</span> <span class="n">MMCR0_FCECE</span><span class="p">;</span>

 <span class="nl">out_enable:</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">write_mmcr0</span><span class="p">(</span><span class="n">cpuhw</span><span class="p">,</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable instruction sampling if necessary</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MMCRA_SAMPLE_ENABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mb</span><span class="p">();</span>
		<span class="n">mtspr</span><span class="p">(</span><span class="n">SPRN_MMCRA</span><span class="p">,</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">collect_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_count</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">ctrs</span><span class="p">[],</span> <span class="n">u64</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_software_event</span><span class="p">(</span><span class="n">group</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">max_count</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">ctrs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="p">;</span>
		<span class="n">flags</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">event_base</span><span class="p">;</span>
		<span class="n">events</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_software_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">max_count</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">ctrs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>
			<span class="n">flags</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">event_base</span><span class="p">;</span>
			<span class="n">events</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a event to the PMU.</span>
<span class="cm"> * If all events are not already frozen, then we disable and</span>
<span class="cm"> * re-enable the PMU in order to get hw_perf_enable to do the</span>
<span class="cm"> * actual work of reconfiguring the PMU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">power_pmu_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ef_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add the event to the list (if there is room)</span>
<span class="cm">	 * and check whether the total set is still feasible.</span>
<span class="cm">	 */</span>
	<span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="n">n0</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n0</span> <span class="o">&gt;=</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">n_counter</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">n0</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>
	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">n0</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span><span class="p">;</span>
	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">n0</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">event_base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ef_flags</span> <span class="o">&amp;</span> <span class="n">PERF_EF_START</span><span class="p">))</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_HES_STOPPED</span> <span class="o">|</span> <span class="n">PERF_HES_UPTODATE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If group events scheduling transaction was started,</span>
<span class="cm">	 * skip the schedulability test here, it will be performed</span>
<span class="cm">	 * at commit time(-&gt;commit_txn) as a whole</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">group_flag</span> <span class="o">&amp;</span> <span class="n">PERF_EVENT_TXN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nocheck</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_excludes</span><span class="p">(</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">power_check_constraints</span><span class="p">(</span><span class="n">cpuhw</span><span class="p">,</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">,</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">n0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">n0</span><span class="p">];</span>

<span class="nl">nocheck:</span>
	<span class="o">++</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span>
	<span class="o">++</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_added</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a event from the PMU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">power_pmu_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ef_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>

	<span class="n">power_pmu_read</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="o">--</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span>
			<span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">disable_pmc</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">write_pmc</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_limited</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">limited_counter</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_limited</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_limited</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">limited_counter</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">limited_counter</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">limited_hwidx</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">limited_hwidx</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="o">--</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_limited</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* disable exceptions if no events are running */</span>
		<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MMCR0_PMXE</span> <span class="o">|</span> <span class="n">MMCR0_FCECE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * POWER-PMU does not support disabling individual counters, hence</span>
<span class="cm"> * program their cycle counter to their max value and ignore the interrupts.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">power_pmu_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ef_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">left</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">||</span> <span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_period</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ef_flags</span> <span class="o">&amp;</span> <span class="n">PERF_EF_RELOAD</span><span class="p">)</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_UPTODATE</span><span class="p">));</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">left</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_left</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="mh">0x80000000L</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mh">0x80000000L</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>

	<span class="n">write_pmc</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">power_pmu_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ef_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">||</span> <span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_period</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>

	<span class="n">power_pmu_read</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">|=</span> <span class="n">PERF_HES_STOPPED</span> <span class="o">|</span> <span class="n">PERF_HES_UPTODATE</span><span class="p">;</span>
	<span class="n">write_pmc</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start group events scheduling transaction</span>
<span class="cm"> * Set the flag to make pmu::enable() not perform the</span>
<span class="cm"> * schedulability test, it will be performed at commit time</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">power_pmu_start_txn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">group_flag</span> <span class="o">|=</span> <span class="n">PERF_EVENT_TXN</span><span class="p">;</span>
	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_txn_start</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stop group events scheduling transaction</span>
<span class="cm"> * Clear the flag and pmu::enable() will perform the</span>
<span class="cm"> * schedulability test.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">power_pmu_cancel_txn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">group_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PERF_EVENT_TXN</span><span class="p">;</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Commit group events scheduling transaction</span>
<span class="cm"> * Perform the group schedulability test as a whole</span>
<span class="cm"> * Return 0 if success</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">power_pmu_commit_txn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ppmu</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_excludes</span><span class="p">(</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">power_check_constraints</span><span class="p">(</span><span class="n">cpuhw</span><span class="p">,</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">,</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_txn_start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">group_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PERF_EVENT_TXN</span><span class="p">;</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return 1 if we might be able to put event on a limited PMC,</span>
<span class="cm"> * or 0 if not.</span>
<span class="cm"> * A event can only go on a limited PMC if it counts something</span>
<span class="cm"> * that a limited PMC can count, doesn&#39;t require interrupts, and</span>
<span class="cm"> * doesn&#39;t exclude any processor mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">can_go_on_limited_pmc</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ev</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">alt</span><span class="p">[</span><span class="n">MAX_EVENT_ALTERNATIVES</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_user</span>
	    <span class="o">||</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_kernel</span>
	    <span class="o">||</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_hv</span>
	    <span class="o">||</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_period</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">limited_pmc_event</span><span class="p">(</span><span class="n">ev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The requested event_id isn&#39;t on a limited PMC already;</span>
<span class="cm">	 * see if any alternative code goes on a limited PMC.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">get_alternatives</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">|=</span> <span class="n">PPMU_LIMITED_PMC_OK</span> <span class="o">|</span> <span class="n">PPMU_LIMITED_PMC_REQD</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">get_alternatives</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">alt</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find an alternative event_id that goes on a normal PMC, if possible,</span>
<span class="cm"> * and return the event_id code, or 0 if there is no such alternative.</span>
<span class="cm"> * (Note: event_id code 0 is &quot;don&#39;t count&quot; on all machines.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">normal_pmc_alternative</span><span class="p">(</span><span class="n">u64</span> <span class="n">ev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">alt</span><span class="p">[</span><span class="n">MAX_EVENT_ALTERNATIVES</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PPMU_LIMITED_PMC_OK</span> <span class="o">|</span> <span class="n">PPMU_LIMITED_PMC_REQD</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">get_alternatives</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">alt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* Number of perf_events counting hardware events */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">num_events</span><span class="p">;</span>
<span class="cm">/* Used to avoid races in calling reserve/release_pmc_hardware */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">pmc_reserve_mutex</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Release the PMU if this is the last perf_event.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_perf_event_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_events</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmc_reserve_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_events</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">release_pmc_hardware</span><span class="p">();</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmc_reserve_mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Translate a generic cache event_id config to a raw event_id code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hw_perf_cache_event</span><span class="p">(</span><span class="n">u64</span> <span class="n">config</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">eventp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">cache_events</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* unpack config */</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">config</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="n">config</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">config</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">PERF_COUNT_HW_CACHE_MAX</span> <span class="o">||</span>
	    <span class="n">op</span> <span class="o">&gt;=</span> <span class="n">PERF_COUNT_HW_CACHE_OP_MAX</span> <span class="o">||</span>
	    <span class="n">result</span> <span class="o">&gt;=</span> <span class="n">PERF_COUNT_HW_CACHE_RESULT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ev</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">cache_events</span><span class="p">)[</span><span class="n">type</span><span class="p">][</span><span class="n">op</span><span class="p">][</span><span class="n">result</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">eventp</span> <span class="o">=</span> <span class="n">ev</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">power_pmu_event_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">ctrs</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">events</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cflags</span><span class="p">[</span><span class="n">MAX_HWEVENTS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ppmu</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="cm">/* does not support taken branch sampling */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_branch_stack</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PERF_TYPE_HARDWARE</span>:
		<span class="n">ev</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ev</span> <span class="o">&gt;=</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">n_generic</span> <span class="o">||</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">generic_events</span><span class="p">[</span><span class="n">ev</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="n">ev</span> <span class="o">=</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">generic_events</span><span class="p">[</span><span class="n">ev</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PERF_TYPE_HW_CACHE</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">hw_perf_cache_event</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PERF_TYPE_RAW</span>:
		<span class="n">ev</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config_base</span> <span class="o">=</span> <span class="n">ev</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are not running on a hypervisor, force the</span>
<span class="cm">	 * exclude_hv bit to 0 so that we don&#39;t care what</span>
<span class="cm">	 * the user set it to.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firmware_has_feature</span><span class="p">(</span><span class="n">FW_FEATURE_LPAR</span><span class="p">))</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_hv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a per-task event, then we can use</span>
<span class="cm">	 * PM_RUN_* events interchangeably with their non RUN_*</span>
<span class="cm">	 * equivalents, e.g. PM_RUN_CYC instead of PM_CYC.</span>
<span class="cm">	 * XXX we should check if the task is an idle task.</span>
<span class="cm">	 */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attach_state</span> <span class="o">&amp;</span> <span class="n">PERF_ATTACH_TASK</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">PPMU_ONLY_COUNT_RUN</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this machine has limited events, check whether this</span>
<span class="cm">	 * event_id could go on a limited event.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PPMU_LIMITED_PMC5_6</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">can_go_on_limited_pmc</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">ev</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">PPMU_LIMITED_PMC_OK</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">limited_pmc_event</span><span class="p">(</span><span class="n">ev</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The requested event_id is on a limited PMC,</span>
<span class="cm">			 * but we can&#39;t use a limited PMC; see if any</span>
<span class="cm">			 * alternative goes on a normal PMC.</span>
<span class="cm">			 */</span>
			<span class="n">ev</span> <span class="o">=</span> <span class="n">normal_pmc_alternative</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is in a group, check if it can go on with all the</span>
<span class="cm">	 * other hardware events in the group.  We assume the event</span>
<span class="cm">	 * hasn&#39;t been linked into its leader&#39;s sibling list at this point.</span>
<span class="cm">	 */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">!=</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">collect_events</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">,</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">n_counter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				   <span class="n">ctrs</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">cflags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">events</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">ev</span><span class="p">;</span>
	<span class="n">ctrs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>
	<span class="n">cflags</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_excludes</span><span class="p">(</span><span class="n">ctrs</span><span class="p">,</span> <span class="n">cflags</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">power_check_constraints</span><span class="p">(</span><span class="n">cpuhw</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">cflags</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">put_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">event_base</span> <span class="o">=</span> <span class="n">cflags</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">last_period</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_period</span><span class="p">;</span>
	<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_left</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">last_period</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if we need to reserve the PMU.</span>
<span class="cm">	 * If no events are currently in use, then we have to take a</span>
<span class="cm">	 * mutex to ensure that we don&#39;t race with another task doing</span>
<span class="cm">	 * reserve_pmc_hardware or release_pmc_hardware.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_events</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmc_reserve_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_events</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">reserve_pmc_hardware</span><span class="p">(</span><span class="n">perf_event_interrupt</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_events</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmc_reserve_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">hw_perf_event_destroy</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">power_pmu_event_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pmu</span> <span class="n">power_pmu</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">pmu_enable</span>	<span class="o">=</span> <span class="n">power_pmu_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pmu_disable</span>	<span class="o">=</span> <span class="n">power_pmu_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">event_init</span>	<span class="o">=</span> <span class="n">power_pmu_event_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">add</span>		<span class="o">=</span> <span class="n">power_pmu_add</span><span class="p">,</span>
	<span class="p">.</span><span class="n">del</span>		<span class="o">=</span> <span class="n">power_pmu_del</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>		<span class="o">=</span> <span class="n">power_pmu_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">power_pmu_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">power_pmu_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start_txn</span>	<span class="o">=</span> <span class="n">power_pmu_start_txn</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cancel_txn</span>	<span class="o">=</span> <span class="n">power_pmu_cancel_txn</span><span class="p">,</span>
	<span class="p">.</span><span class="n">commit_txn</span>	<span class="o">=</span> <span class="n">power_pmu_commit_txn</span><span class="p">,</span>
	<span class="p">.</span><span class="n">event_idx</span>	<span class="o">=</span> <span class="n">power_pmu_event_idx</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * A counter has overflowed; update its count and record</span>
<span class="cm"> * things if requested.  Note that interrupts are hard-disabled</span>
<span class="cm"> * here so there is no possibility of being interrupted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">record_and_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">period</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_period</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">prev</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">left</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">record</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_pmc</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we don&#39;t have to worry about interrupts here */</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">);</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">check_and_compute_delta</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">local64_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if the total period for this event has expired,</span>
<span class="cm">	 * and update for the next period.</span>
<span class="cm">	 */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">left</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_left</span><span class="p">)</span> <span class="o">-</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">period</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">left</span> <span class="o">+=</span> <span class="n">period</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">left</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
			<span class="n">record</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">last_period</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_period</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="mh">0x80000000LL</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="mh">0x80000000LL</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">write_pmc</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_left</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
	<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finally record data if requested.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">record</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="n">data</span><span class="p">;</span>

		<span class="n">perf_sample_data_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">~</span><span class="mi">0ULL</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">last_period</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_ADDR</span><span class="p">)</span>
			<span class="n">perf_get_data_addr</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">perf_event_overflow</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span>
			<span class="n">power_pmu_stop</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from generic code to get the misc flags (i.e. processor mode)</span>
<span class="cm"> * for an event_id.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">perf_misc_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">perf_get_misc_flags</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">?</span> <span class="n">PERF_RECORD_MISC_USER</span> <span class="o">:</span>
		<span class="n">PERF_RECORD_MISC_KERNEL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from generic code to get the instruction pointer</span>
<span class="cm"> * for an event_id.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">perf_instruction_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmcra</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">dsisr</span><span class="p">;</span>

	<span class="cm">/* Not a PMU interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TRAP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xf00</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">;</span>

	<span class="cm">/* Processor doesn&#39;t support sampling non marked events */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PPMU_NO_CONT_SAMPLING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">mmcra</span> <span class="o">&amp;</span> <span class="n">MMCRA_SAMPLE_ENABLE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_SIAR</span><span class="p">)</span> <span class="o">+</span> <span class="n">perf_ip_adjust</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">pmc_overflow</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Events on POWER7 can roll back if a speculative event doesn&#39;t</span>
<span class="cm">	 * eventually complete. Unfortunately in some rare cases they will</span>
<span class="cm">	 * raise a performance monitor exception. We need to catch this to</span>
<span class="cm">	 * ensure we reset the PMC. In all cases the PMC will be 256 or less</span>
<span class="cm">	 * cycles from overflow.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We only do this if the first pass fails to find any overflowing</span>
<span class="cm">	 * PMCs because a user might set a period of less than 256 and we</span>
<span class="cm">	 * don&#39;t want to mistakenly reset them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__is_processor</span><span class="p">(</span><span class="n">PV_POWER7</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="mh">0x80000000</span> <span class="o">-</span> <span class="n">val</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">256</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Performance monitor interrupt stuff</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nmi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_limited</span><span class="p">)</span>
		<span class="n">freeze_limited_counters</span><span class="p">(</span><span class="n">cpuhw</span><span class="p">,</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_PMC5</span><span class="p">),</span>
					<span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_PMC6</span><span class="p">));</span>

	<span class="n">perf_read_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="n">nmi</span> <span class="o">=</span> <span class="n">perf_intr_is_nmi</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nmi</span><span class="p">)</span>
		<span class="n">nmi_enter</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">irq_enter</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">||</span> <span class="n">is_limited_pmc</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">read_pmc</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* event has overflowed */</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">record_and_restart</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * In case we didn&#39;t find and reset the event that caused</span>
<span class="cm">	 * the interrupt, scan all events and reset any that are</span>
<span class="cm">	 * negative, to avoid getting continual interrupts.</span>
<span class="cm">	 * Any that we processed in the previous loop will not be negative.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ppmu</span><span class="o">-&gt;</span><span class="n">n_counter</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_limited_pmc</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">read_pmc</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmc_overflow</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
				<span class="n">write_pmc</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset MMCR0 to its normal value.  This will set PMXE and</span>
<span class="cm">	 * clear FC (freeze counters) and PMAO (perf mon alert occurred)</span>
<span class="cm">	 * and thus allow interrupts to occur again.</span>
<span class="cm">	 * XXX might want to use MSR.PM to keep the events frozen until</span>
<span class="cm">	 * we get back out of this interrupt.</span>
<span class="cm">	 */</span>
	<span class="n">write_mmcr0</span><span class="p">(</span><span class="n">cpuhw</span><span class="p">,</span> <span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nmi</span><span class="p">)</span>
		<span class="n">nmi_exit</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">irq_exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">power_pmu_setup</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuhw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ppmu</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cpuhw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cpuhw</span><span class="p">));</span>
	<span class="n">cpuhw</span><span class="o">-&gt;</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MMCR0_FC</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span>
<span class="nf">power_pmu_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CPU_TASKS_FROZEN</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
		<span class="n">power_pmu_setup</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">register_power_pmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">power_pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppmu</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>		<span class="cm">/* something&#39;s already registered */</span>

	<span class="n">ppmu</span> <span class="o">=</span> <span class="n">pmu</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s performance monitor hardware support registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

<span class="cp">#ifdef MSR_HV</span>
	<span class="cm">/*</span>
<span class="cm">	 * Use FCHV to ignore kernel events if MSR.HV is set.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mfmsr</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">MSR_HV</span><span class="p">)</span>
		<span class="n">freeze_events_kernel</span> <span class="o">=</span> <span class="n">MMCR0_FCHV</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PPC64 */</span><span class="cp"></span>

	<span class="n">perf_pmu_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">power_pmu</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">PERF_TYPE_RAW</span><span class="p">);</span>
	<span class="n">perf_cpu_notifier</span><span class="p">(</span><span class="n">power_pmu_notifier</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
