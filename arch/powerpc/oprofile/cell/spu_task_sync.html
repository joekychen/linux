<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › oprofile › cell › spu_task_sync.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>spu_task_sync.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Cell Broadband Engine OProfile Support</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright IBM Corporation 2006</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Maynard Johnson &lt;maynardj@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cm">/* The purpose of this file is to handle SPU event task switching</span>
<span class="cm"> * and to record SPU context information into the OProfile</span>
<span class="cm"> * event buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Additionally, the spu_sync_buffer function is provided as a helper</span>
<span class="cm"> * for recoding actual SPU program counter samples to the event buffer.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/dcookies.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/numa.h&gt;</span>
<span class="cp">#include &lt;linux/oprofile.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &quot;pr_util.h&quot;</span>

<span class="cp">#define RELEASE_ALL 9999</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">buffer_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">cache_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">num_spu_nodes</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">spu_prof_num_nodes</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">spu_buffer</span> <span class="n">spu_buff</span><span class="p">[</span><span class="n">MAX_NUMNODES</span> <span class="o">*</span> <span class="n">SPUS_PER_NODE</span><span class="p">];</span>
<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">spu_work</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">max_spu_buff</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">spu_buff_add</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">spu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* spu buff is a circular buffer.  Add entries to the</span>
<span class="cm">	 * head.  Head is the index to store the next value.</span>
<span class="cm">	 * The buffer is full when there is one available entry</span>
<span class="cm">	 * in the queue, i.e. head and tail can&#39;t be equal.</span>
<span class="cm">	 * That way we can tell the difference between the</span>
<span class="cm">	 * buffer being full versus empty.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  ASSUPTION: the buffer_lock is held when this function</span>
<span class="cm">	 *             is called to lock the buffer, head and tail.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">full</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">head</span> <span class="o">&gt;=</span> <span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">head</span> <span class="o">-</span> <span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">tail</span><span class="p">)</span>
		    <span class="o">&lt;</span>  <span class="p">(</span><span class="n">max_spu_buff</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">tail</span> <span class="o">&gt;</span> <span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">tail</span> <span class="o">-</span> <span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">head</span><span class="p">)</span>
		    <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">full</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">buff</span><span class="p">[</span><span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
		<span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">head</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">head</span> <span class="o">&gt;=</span> <span class="n">max_spu_buff</span><span class="p">)</span>
			<span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* From the user&#39;s perspective make the SPU buffer</span>
<span class="cm">		 * size management/overflow look like we are using</span>
<span class="cm">		 * per cpu buffers.  The user uses the same</span>
<span class="cm">		 * per cpu parameter to adjust the SPU buffer size.</span>
<span class="cm">		 * Increment the sample_lost_overflow to inform</span>
<span class="cm">		 * the user the buffer size needs to be increased.</span>
<span class="cm">		 */</span>
		<span class="n">oprofile_cpu_buffer_inc_smpl_lost</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This function copies the per SPU buffers to the</span>
<span class="cm"> * OProfile kernel buffer.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sync_spu_buff</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">spu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">curr_head</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">spu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">spu</span> <span class="o">&lt;</span> <span class="n">num_spu_nodes</span><span class="p">;</span> <span class="n">spu</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* In case there was an issue and the buffer didn&#39;t</span>
<span class="cm">		 * get created skip it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">buff</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Hold the lock to make sure the head/tail</span>
<span class="cm">		 * doesn&#39;t change while spu_buff_add() is</span>
<span class="cm">		 * deciding if the buffer is full or not.</span>
<span class="cm">		 * Being a little paranoid.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">curr_head</span> <span class="o">=</span> <span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">head</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Transfer the current contents to the kernel buffer.</span>
<span class="cm">		 * data can still be added to the head of the buffer.</span>
<span class="cm">		 */</span>
		<span class="n">oprofile_put_buff</span><span class="p">(</span><span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">buff</span><span class="p">,</span>
				  <span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">tail</span><span class="p">,</span>
				  <span class="n">curr_head</span><span class="p">,</span> <span class="n">max_spu_buff</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">tail</span> <span class="o">=</span> <span class="n">curr_head</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wq_sync_spu_buff</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* move data from spu buffers to kernel buffer */</span>
	<span class="n">sync_spu_buff</span><span class="p">();</span>

	<span class="cm">/* only reschedule if profiling is not done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spu_prof_running</span><span class="p">)</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_work</span><span class="p">,</span> <span class="n">DEFAULT_TIMER_EXPIRE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Container for caching information about an active SPU task. */</span>
<span class="k">struct</span> <span class="n">cached_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vma_to_fileoffset_map</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">the_spu</span><span class="p">;</span>	<span class="cm">/* needed to access pointer to local_store */</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">cache_ref</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cached_info</span> <span class="o">*</span><span class="n">spu_info</span><span class="p">[</span><span class="n">MAX_NUMNODES</span> <span class="o">*</span> <span class="mi">8</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_cached_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cached_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cached_info</span><span class="p">,</span> <span class="n">cache_ref</span><span class="p">);</span>
	<span class="n">vma_map_free</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Return the cached_info for the passed SPU number.</span>
<span class="cm"> * ATTENTION:  Callers are responsible for obtaining the</span>
<span class="cm"> *	       cache_lock if needed prior to invoking this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cached_info</span> <span class="o">*</span><span class="nf">get_cached_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">the_spu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">spu_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cached_info</span> <span class="o">*</span><span class="n">ret_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spu_num</span> <span class="o">&gt;=</span> <span class="n">num_spu_nodes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SPU_PROF: &quot;</span>
		       <span class="s">&quot;%s, line %d: Invalid index %d into spu info cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">spu_num</span><span class="p">);</span>
		<span class="n">ret_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spu_info</span><span class="p">[</span><span class="n">spu_num</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">the_spu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="n">spu_get_profile_private_kref</span><span class="p">(</span><span class="n">the_spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spu_info</span><span class="p">[</span><span class="n">spu_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cached_info</span><span class="p">,</span> <span class="n">cache_ref</span><span class="p">);</span>
			<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_info</span><span class="p">[</span><span class="n">spu_num</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cache_ref</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret_info</span> <span class="o">=</span> <span class="n">spu_info</span><span class="p">[</span><span class="n">spu_num</span><span class="p">];</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret_info</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Looks for cached info for the passed spu.  If not found, the</span>
<span class="cm"> * cached info is created for the passed spu.</span>
<span class="cm"> * Returns 0 for success; otherwise, -1 for error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">prepare_cached_spu_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">objectId</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vma_to_fileoffset_map</span> <span class="o">*</span><span class="n">new_map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cached_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="cm">/* We won&#39;t bother getting cache_lock here since</span>
<span class="cm">	 * don&#39;t do anything with the cached_info that&#39;s returned.</span>
<span class="cm">	 */</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">get_cached_info</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Found cached SPU info.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Create cached_info and set spu_info[spu-&gt;number] to point to it.</span>
<span class="cm">	 * spu-&gt;number is a system-wide value, not a per-node value.</span>
<span class="cm">	 */</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cached_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SPU_PROF: &quot;</span>
		       <span class="s">&quot;%s, line %d: create vma_map failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_alloc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">new_map</span> <span class="o">=</span> <span class="n">create_vma_map</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">objectId</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SPU_PROF: &quot;</span>
		       <span class="s">&quot;%s, line %d: create vma_map failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_alloc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Created vma_map</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">map</span> <span class="o">=</span> <span class="n">new_map</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">the_spu</span> <span class="o">=</span> <span class="n">spu</span><span class="p">;</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cache_ref</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">spu_info</span><span class="p">[</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="cm">/* Increment count before passing off ref to SPUFS. */</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cache_ref</span><span class="p">);</span>

	<span class="cm">/* We increment the module refcount here since SPUFS is</span>
<span class="cm">	 * responsible for the final destruction of the cached_info,</span>
<span class="cm">	 * and it must be able to access the destroy_cached_info()</span>
<span class="cm">	 * function defined in the OProfile module.  We decrement</span>
<span class="cm">	 * the module refcount in destroy_cached_info.</span>
<span class="cm">	 */</span>
	<span class="n">try_module_get</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
	<span class="n">spu_set_profile_private_kref</span><span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cache_ref</span><span class="p">,</span>
				<span class="n">destroy_cached_info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">err_alloc:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE:  The caller is responsible for locking the</span>
<span class="cm"> *	  cache_lock prior to calling this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">release_cached_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">spu_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spu_index</span> <span class="o">==</span> <span class="n">RELEASE_ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">num_spu_nodes</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spu_index</span> <span class="o">&gt;=</span> <span class="n">num_spu_nodes</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SPU_PROF: &quot;</span>
				<span class="s">&quot;%s, line %d: &quot;</span>
				<span class="s">&quot;Invalid index %d into spu info cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">spu_index</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">spu_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">spu_index</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spu_info</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_info</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cache_ref</span><span class="p">,</span>
				 <span class="n">destroy_cached_info</span><span class="p">);</span>
			<span class="n">spu_info</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The source code for fast_get_dcookie was &quot;borrowed&quot;</span>
<span class="cm"> * from drivers/oprofile/buffer_sync.c.</span>
<span class="cm"> */</span>

<span class="cm">/* Optimisation. We can manage without taking the dcookie sem</span>
<span class="cm"> * because we cannot reach this code without at least one</span>
<span class="cm"> * dcookie user still being registered (namely, the reader</span>
<span class="cm"> * of the event buffer).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">fast_get_dcookie</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cookie</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_COOKIE</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">;</span>
	<span class="n">get_dcookie</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cookie</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cookie</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Look up the dcookie for the task&#39;s first VM_EXECUTABLE mapping,</span>
<span class="cm"> * which corresponds loosely to &quot;application name&quot;. Also, determine</span>
<span class="cm"> * the offset for the SPU ELF object.  If computed offset is</span>
<span class="cm"> * non-zero, it implies an embedded SPU object; otherwise, it&#39;s a</span>
<span class="cm"> * separate SPU binary, in which case we retrieve it&#39;s dcookie.</span>
<span class="cm"> * For the embedded case, we must determine if SPU ELF is embedded</span>
<span class="cm"> * in the executable application or another file (i.e., shared lib).</span>
<span class="cm"> * If embedded in a shared lib, we must get the dcookie and return</span>
<span class="cm"> * that to the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">get_exec_dcookie_and_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offsetp</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">spu_bin_dcookie</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spu_ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">app_cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">my_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">app</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXECUTABLE</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">app_cookie</span> <span class="o">=</span> <span class="n">fast_get_dcookie</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;got dcookie for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="n">app</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;</span> <span class="n">spu_ref</span> <span class="o">||</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&lt;=</span> <span class="n">spu_ref</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">my_offset</span> <span class="o">=</span> <span class="n">spu_ref</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_no_image_cookie</span><span class="p">;</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Found spu ELF at %X(object-id:%lx) for file %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">my_offset</span><span class="p">,</span> <span class="n">spu_ref</span><span class="p">,</span>
			 <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="o">*</span><span class="n">offsetp</span> <span class="o">=</span> <span class="n">my_offset</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">spu_bin_dcookie</span> <span class="o">=</span> <span class="n">fast_get_dcookie</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;got dcookie for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">app_cookie</span><span class="p">;</span>

<span class="nl">fail_no_image_cookie:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SPU_PROF: &quot;</span>
		<span class="s">&quot;%s, line %d: Cannot find dcookie for SPU binary</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/* This function finds or creates cached context information for the</span>
<span class="cm"> * passed SPU and records SPU context information into the OProfile</span>
<span class="cm"> * event buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_context_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">spu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">objectId</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spu_cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">app_dcookie</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">prepare_cached_spu_info</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="n">objectId</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Get dcookie first because a mutex_lock is taken in that</span>
<span class="cm">	 * code path, so interrupts must not be disabled.</span>
<span class="cm">	 */</span>
	<span class="n">app_dcookie</span> <span class="o">=</span> <span class="n">get_exec_dcookie_and_offset</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spu_cookie</span><span class="p">,</span> <span class="n">objectId</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">app_dcookie</span> <span class="o">||</span> <span class="o">!</span><span class="n">spu_cookie</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span>  <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Record context info in event buffer */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">spu_buff_add</span><span class="p">(</span><span class="n">ESCAPE_CODE</span><span class="p">,</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
	<span class="n">spu_buff_add</span><span class="p">(</span><span class="n">SPU_CTX_SWITCH_CODE</span><span class="p">,</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
	<span class="n">spu_buff_add</span><span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
	<span class="n">spu_buff_add</span><span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
	<span class="n">spu_buff_add</span><span class="p">(</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">,</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
	<span class="n">spu_buff_add</span><span class="p">(</span><span class="n">app_dcookie</span><span class="p">,</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
	<span class="n">spu_buff_add</span><span class="p">(</span><span class="n">spu_cookie</span><span class="p">,</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
	<span class="n">spu_buff_add</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>

	<span class="cm">/* Set flag to indicate SPU PC data can now be written out.  If</span>
<span class="cm">	 * the SPU program counter data is seen before an SPU context</span>
<span class="cm">	 * record is seen, the postprocessing will fail.</span>
<span class="cm">	 */</span>
	<span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">].</span><span class="n">ctx_sw_seen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">smp_wmb</span><span class="p">();</span>	<span class="cm">/* insure spu event buffer updates are written */</span>
			<span class="cm">/* don&#39;t want entries intermingled... */</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is invoked on either a bind_context or unbind_context.</span>
<span class="cm"> * If called for an unbind_context, the val arg is 0; otherwise,</span>
<span class="cm"> * it is the object-id value for the spu context.</span>
<span class="cm"> * The data arg is of type &#39;struct spu *&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">spu_active_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">the_spu</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;SPU event notification arrived</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">release_cached_info</span><span class="p">(</span><span class="n">the_spu</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">process_context_switch</span><span class="p">(</span><span class="n">the_spu</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">spu_active</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">spu_active_notify</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">number_of_online_nodes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">u32</span> <span class="n">cpu</span><span class="p">;</span> <span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">nodes</span><span class="p">)</span>
                        <span class="n">nodes</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">nodes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">oprofile_spu_buff_create</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">spu</span><span class="p">;</span>

	<span class="n">max_spu_buff</span> <span class="o">=</span> <span class="n">oprofile_get_cpu_buffer_size</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">spu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">spu</span> <span class="o">&lt;</span> <span class="n">num_spu_nodes</span><span class="p">;</span> <span class="n">spu</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* create circular buffers to store the data in.</span>
<span class="cm">		 * use locks to manage accessing the buffers</span>
<span class="cm">		 */</span>
		<span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Create a buffer for each SPU.  Can&#39;t reliably</span>
<span class="cm">		 * create a single buffer for all spus due to not</span>
<span class="cm">		 * enough contiguous kernel memory.</span>
<span class="cm">		 */</span>

		<span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">buff</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="n">max_spu_buff</span>
					      <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)),</span>
					     <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">buff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SPU_PROF: &quot;</span>
			       <span class="s">&quot;%s, line %d:  oprofile_spu_buff_create &quot;</span>
		       <span class="s">&quot;failed to allocate spu buffer %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>

			<span class="cm">/* release the spu buffers that have been allocated */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">spu</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">buff</span><span class="p">);</span>
				<span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">buff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">spu</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The main purpose of this function is to synchronize</span>
<span class="cm"> * OProfile with SPUFS by registering to be notified of</span>
<span class="cm"> * SPU task switches.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: When profiling SPUs, we must ensure that only</span>
<span class="cm"> * spu_sync_start is invoked and not the generic sync_start</span>
<span class="cm"> * in drivers/oprofile/oprof.c.	 A return value of</span>
<span class="cm"> * SKIP_GENERIC_SYNC or SYNC_START_ERROR will</span>
<span class="cm"> * accomplish this.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spu_sync_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">spu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SKIP_GENERIC_SYNC</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">register_ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spu_prof_num_nodes</span> <span class="o">=</span> <span class="n">number_of_online_nodes</span><span class="p">();</span>
	<span class="n">num_spu_nodes</span> <span class="o">=</span> <span class="n">spu_prof_num_nodes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_work</span><span class="p">,</span> <span class="n">wq_sync_spu_buff</span><span class="p">);</span>

	<span class="cm">/* create buffer for storing the SPU data to put in</span>
<span class="cm">	 * the kernel buffer.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">oprofile_spu_buff_create</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">spu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">spu</span> <span class="o">&lt;</span> <span class="n">num_spu_nodes</span><span class="p">;</span> <span class="n">spu</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spu_buff_add</span><span class="p">(</span><span class="n">ESCAPE_CODE</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>
		<span class="n">spu_buff_add</span><span class="p">(</span><span class="n">SPU_PROFILING_CODE</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>
		<span class="n">spu_buff_add</span><span class="p">(</span><span class="n">num_spu_nodes</span><span class="p">,</span> <span class="n">spu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">spu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">spu</span> <span class="o">&lt;</span> <span class="n">num_spu_nodes</span><span class="p">;</span> <span class="n">spu</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">ctx_sw_seen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spu_buff</span><span class="p">[</span><span class="n">spu</span><span class="p">].</span><span class="n">last_guard_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Register for SPU events  */</span>
	<span class="n">register_ret</span> <span class="o">=</span> <span class="n">spu_switch_event_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_active</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">register_ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SYNC_START_ERROR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;spu_sync_start -- running.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Record SPU program counter samples to the oprofile event buffer. */</span>
<span class="kt">void</span> <span class="nf">spu_sync_buffer</span><span class="p">(</span><span class="kt">int</span> <span class="n">spu_num</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">samples</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">num_samples</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">file_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vma_to_fileoffset_map</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spu</span> <span class="o">*</span><span class="n">the_spu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">spu_num_ll</span> <span class="o">=</span> <span class="n">spu_num</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">spu_num_shifted</span> <span class="o">=</span> <span class="n">spu_num_ll</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cached_info</span> <span class="o">*</span><span class="n">c_info</span><span class="p">;</span>

	<span class="cm">/* We need to obtain the cache_lock here because it&#39;s</span>
<span class="cm">	 * possible that after getting the cached_info, the SPU job</span>
<span class="cm">	 * corresponding to this cached_info may end, thus resulting</span>
<span class="cm">	 * in the destruction of the cached_info.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">c_info</span> <span class="o">=</span> <span class="n">get_cached_info</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">spu_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This legitimately happens when the SPU task ends before all</span>
<span class="cm">		 * samples are recorded.</span>
<span class="cm">		 * No big deal -- so we just drop a few samples.</span>
<span class="cm">		 */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;SPU_PROF: No cached SPU contex &quot;</span>
			  <span class="s">&quot;for SPU #%d. Dropping samples.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">spu_num</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">map</span> <span class="o">=</span> <span class="n">c_info</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">;</span>
	<span class="n">the_spu</span> <span class="o">=</span> <span class="n">c_info</span><span class="o">-&gt;</span><span class="n">the_spu</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_samples</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sample</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">samples</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">grd_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">file_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">file_offset</span> <span class="o">=</span> <span class="n">vma_map_lookup</span><span class="p">(</span> <span class="n">map</span><span class="p">,</span> <span class="n">sample</span><span class="p">,</span> <span class="n">the_spu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grd_val</span><span class="p">);</span>

		<span class="cm">/* If overlays are used by this SPU application, the guard</span>
<span class="cm">		 * value is non-zero, indicating which overlay section is in</span>
<span class="cm">		 * use.	 We need to discard samples taken during the time</span>
<span class="cm">		 * period which an overlay occurs (i.e., guard value changes).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">grd_val</span> <span class="o">&amp;&amp;</span> <span class="n">grd_val</span> <span class="o">!=</span> <span class="n">spu_buff</span><span class="p">[</span><span class="n">spu_num</span><span class="p">].</span><span class="n">last_guard_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spu_buff</span><span class="p">[</span><span class="n">spu_num</span><span class="p">].</span><span class="n">last_guard_val</span> <span class="o">=</span> <span class="n">grd_val</span><span class="p">;</span>
			<span class="cm">/* Drop the rest of the samples. */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* We must ensure that the SPU context switch has been written</span>
<span class="cm">		 * out before samples for the SPU.  Otherwise, the SPU context</span>
<span class="cm">		 * information is not available and the postprocessing of the</span>
<span class="cm">		 * SPU PC will fail with no available anonymous map information.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spu_buff</span><span class="p">[</span><span class="n">spu_num</span><span class="p">].</span><span class="n">ctx_sw_seen</span><span class="p">)</span>
			<span class="n">spu_buff_add</span><span class="p">((</span><span class="n">file_offset</span> <span class="o">|</span> <span class="n">spu_num_shifted</span><span class="p">),</span>
					 <span class="n">spu_num</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">spu_sync_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spu_switch_event_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_active</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SPU_PROF: &quot;</span>
		       <span class="s">&quot;%s, line %d: spu_switch_event_unregister &quot;</span>	\
		       <span class="s">&quot;returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="cm">/* flush any remaining data in the per SPU buffers */</span>
	<span class="n">sync_spu_buff</span><span class="p">();</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">release_cached_info</span><span class="p">(</span><span class="n">RELEASE_ALL</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* remove scheduled work queue item rather then waiting</span>
<span class="cm">	 * for every queued entry to execute.  Then flush pending</span>
<span class="cm">	 * system wide buffer to event buffer.</span>
<span class="cm">	 */</span>
	<span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spu_work</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">num_spu_nodes</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spu_buff</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">ctx_sw_seen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * spu_sys_buff will be null if there was a problem</span>
<span class="cm">		 * allocating the buffer.  Only delete if it exists.</span>
<span class="cm">		 */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">spu_buff</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">buff</span><span class="p">);</span>
		<span class="n">spu_buff</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">buff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;spu_sync_stop -- done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
