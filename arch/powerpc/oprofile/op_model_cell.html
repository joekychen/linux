<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › oprofile › op_model_cell.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>op_model_cell.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Cell Broadband Engine OProfile Support</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright IBM Corporation 2006</span>
<span class="cm"> *</span>
<span class="cm"> * Author: David Erb (djerb@us.ibm.com)</span>
<span class="cm"> * Modifications:</span>
<span class="cm"> *	   Carl Love &lt;carll@us.ibm.com&gt;</span>
<span class="cm"> *	   Maynard Johnson &lt;maynardj@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/cpufreq.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/oprofile.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;asm/cell-pmu.h&gt;</span>
<span class="cp">#include &lt;asm/cputable.h&gt;</span>
<span class="cp">#include &lt;asm/firmware.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/oprofile_impl.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/reg.h&gt;</span>
<span class="cp">#include &lt;asm/rtas.h&gt;</span>
<span class="cp">#include &lt;asm/cell-regs.h&gt;</span>

<span class="cp">#include &quot;../platforms/cell/interrupt.h&quot;</span>
<span class="cp">#include &quot;cell/pr_util.h&quot;</span>

<span class="cp">#define PPU_PROFILING            0</span>
<span class="cp">#define SPU_PROFILING_CYCLES     1</span>
<span class="cp">#define SPU_PROFILING_EVENTS     2</span>

<span class="cp">#define SPU_EVENT_NUM_START      4100</span>
<span class="cp">#define SPU_EVENT_NUM_STOP       4399</span>
<span class="cp">#define SPU_PROFILE_EVENT_ADDR          4363  </span><span class="cm">/* spu, address trace, decimal */</span><span class="cp"></span>
<span class="cp">#define SPU_PROFILE_EVENT_ADDR_MASK_A   0x146 </span><span class="cm">/* sub unit set to zero */</span><span class="cp"></span>
<span class="cp">#define SPU_PROFILE_EVENT_ADDR_MASK_B   0x186 </span><span class="cm">/* sub unit set to zero */</span><span class="cp"></span>

<span class="cp">#define NUM_SPUS_PER_NODE    8</span>
<span class="cp">#define SPU_CYCLES_EVENT_NUM 2	</span><span class="cm">/*  event number for SPU_CYCLES */</span><span class="cp"></span>

<span class="cp">#define PPU_CYCLES_EVENT_NUM 1	</span><span class="cm">/*  event number for CYCLES */</span><span class="cp"></span>
<span class="cp">#define PPU_CYCLES_GRP_NUM   1	</span><span class="cm">/* special group number for identifying</span>
<span class="cm">				 * PPU_CYCLES event</span>
<span class="cm">				 */</span><span class="cp"></span>
<span class="cp">#define CBE_COUNT_ALL_CYCLES 0x42800000 </span><span class="cm">/* PPU cycle event specifier */</span><span class="cp"></span>

<span class="cp">#define NUM_THREADS 2         </span><span class="cm">/* number of physical threads in</span>
<span class="cm">			       * physical processor</span>
<span class="cm">			       */</span><span class="cp"></span>
<span class="cp">#define NUM_DEBUG_BUS_WORDS 4</span>
<span class="cp">#define NUM_INPUT_BUS_WORDS 2</span>

<span class="cp">#define MAX_SPU_COUNT 0xFFFFFF	</span><span class="cm">/* maximum 24 bit LFSR value */</span><span class="cp"></span>

<span class="cm">/* Minimum HW interval timer setting to send value to trace buffer is 10 cycle.</span>
<span class="cm"> * To configure counter to send value every N cycles set counter to</span>
<span class="cm"> * 2^32 - 1 - N.</span>
<span class="cm"> */</span>
<span class="cp">#define NUM_INTERVAL_CYC  0xFFFFFFFF - 10</span>

<span class="cm">/*</span>
<span class="cm"> * spu_cycle_reset is the number of cycles between samples.</span>
<span class="cm"> * This variable is used for SPU profiling and should ONLY be set</span>
<span class="cm"> * at the beginning of cell_reg_setup; otherwise, it&#39;s read-only.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">spu_cycle_reset</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">profiling_mode</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">spu_evnt_phys_spu_indx</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">pmc_cntrl_data</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vcntr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">evnts</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">masks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">enabled</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * ibm,cbe-perftools rtas parameters</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pm_signal</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">cpu</span><span class="p">;</span>		<span class="cm">/* Processor to modify */</span>
	<span class="n">u16</span> <span class="n">sub_unit</span><span class="p">;</span>		<span class="cm">/* hw subunit this applies to (if applicable)*/</span>
	<span class="kt">short</span> <span class="kt">int</span> <span class="n">signal_group</span><span class="p">;</span> <span class="cm">/* Signal Group to Enable/Disable */</span>
	<span class="n">u8</span> <span class="n">bus_word</span><span class="p">;</span>		<span class="cm">/* Enable/Disable on this Trace/Trigger/Event</span>
<span class="cm">				 * Bus Word(s) (bitmask)</span>
<span class="cm">				 */</span>
	<span class="n">u8</span> <span class="n">bit</span><span class="p">;</span>			<span class="cm">/* Trigger/Event bit (if applicable) */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * rtas call arguments</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SUBFUNC_RESET</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SUBFUNC_ACTIVATE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">SUBFUNC_DEACTIVATE</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>

	<span class="n">PASSTHRU_IGNORE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">PASSTHRU_ENABLE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">PASSTHRU_DISABLE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pm_cntrl</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">enable</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">stop_at_max</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">trace_mode</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">freeze</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">count_mode</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">spu_addr_trace</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">trace_buf_ovflw</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">group_control</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">debug_bus_control</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pm_cntrl</span> <span class="n">pm_cntrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pm07_cntrl</span><span class="p">[</span><span class="n">NR_PHYS_CTRS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">pm_regs</span><span class="p">;</span>

<span class="cp">#define GET_SUB_UNIT(x) ((x &amp; 0x0000f000) &gt;&gt; 12)</span>
<span class="cp">#define GET_BUS_WORD(x) ((x &amp; 0x000000f0) &gt;&gt; 4)</span>
<span class="cp">#define GET_BUS_TYPE(x) ((x &amp; 0x00000300) &gt;&gt; 8)</span>
<span class="cp">#define GET_POLARITY(x) ((x &amp; 0x00000002) &gt;&gt; 1)</span>
<span class="cp">#define GET_COUNT_CYCLES(x) (x &amp; 0x00000001)</span>
<span class="cp">#define GET_INPUT_CONTROL(x) ((x &amp; 0x00000004) &gt;&gt; 2)</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">[</span><span class="n">NR_PHYS_CTRS</span><span class="p">],</span> <span class="n">pmc_values</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spu_pm_cnt</span><span class="p">[</span><span class="n">MAX_NUMNODES</span> <span class="o">*</span> <span class="n">NUM_SPUS_PER_NODE</span><span class="p">];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pmc_cntrl_data</span> <span class="n">pmc_cntrl</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">][</span><span class="n">NR_PHYS_CTRS</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * The CELL profiling code makes rtas calls to setup the debug bus to</span>
<span class="cm"> * route the performance signals.  Additionally, SPU profiling requires</span>
<span class="cm"> * a second rtas call to setup the hardware to capture the SPU PCs.</span>
<span class="cm"> * The EIO error value is returned if the token lookups or the rtas</span>
<span class="cm"> * call fail.  The EIO error number is the best choice of the existing</span>
<span class="cm"> * error numbers.  The probability of rtas related error is very low.  But</span>
<span class="cm"> * by returning EIO and printing additional information to dmsg the user</span>
<span class="cm"> * will know that OProfile did not start and dmesg will tell them why.</span>
<span class="cm"> * OProfile does not support returning errors on Stop.	Not a huge issue</span>
<span class="cm"> * since failure to reset the debug bus or stop the SPU PC collection is</span>
<span class="cm"> * not a fatel issue.  Chances are if the Stop failed, Start doesn&#39;t work</span>
<span class="cm"> * either.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Interpetation of hdw_thread:</span>
<span class="cm"> * 0 - even virtual cpus 0, 2, 4,...</span>
<span class="cm"> * 1 - odd virtual cpus 1, 3, 5, ...</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: this is strictly wrong, we need to clean this up in a number</span>
<span class="cm"> * of places. It works for now. -arnd</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">hdw_thread</span><span class="p">;</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">virt_cntr_inter_mask</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer_virt_cntr</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer_spu_event_swap</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * pm_signal needs to be global since it is initialized in</span>
<span class="cm"> * cell_reg_setup at the time when the necessary information</span>
<span class="cm"> * is available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pm_signal</span> <span class="n">pm_signal</span><span class="p">[</span><span class="n">NR_PHYS_CTRS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pm_rtas_token</span><span class="p">;</span>    <span class="cm">/* token for debug bus setup call */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">spu_rtas_token</span><span class="p">;</span>   <span class="cm">/* token for SPU cycle profiling */</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">reset_value</span><span class="p">[</span><span class="n">NR_PHYS_CTRS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">num_counters</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">oprofile_running</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">cntr_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">ctr_enabled</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">input_bus</span><span class="p">[</span><span class="n">NUM_INPUT_BUS_WORDS</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * Firmware interface functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rtas_ibm_cbe_perftools</span><span class="p">(</span><span class="kt">int</span> <span class="n">subfunc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">passthru</span><span class="p">,</span>
		       <span class="kt">void</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">paddr</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">pm_rtas_token</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">subfunc</span><span class="p">,</span>
			 <span class="n">passthru</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pm_rtas_reset_signals</span><span class="p">(</span><span class="n">u32</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pm_signal</span> <span class="n">pm_signal_local</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The debug bus is being set to the passthru disable state.</span>
<span class="cm">	 * However, the FW still expects atleast one legal signal routing</span>
<span class="cm">	 * entry or it will return an error on the arguments.	If we don&#39;t</span>
<span class="cm">	 * supply a valid entry, we must ignore all return values.  Ignoring</span>
<span class="cm">	 * all return values means we might miss an error we should be</span>
<span class="cm">	 * concerned about.</span>
<span class="cm">	 */</span>

	<span class="cm">/*  fw expects physical cpu #. */</span>
	<span class="n">pm_signal_local</span><span class="p">.</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="n">pm_signal_local</span><span class="p">.</span><span class="n">signal_group</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
	<span class="n">pm_signal_local</span><span class="p">.</span><span class="n">bus_word</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pm_signal_local</span><span class="p">.</span><span class="n">sub_unit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pm_signal_local</span><span class="p">.</span><span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rtas_ibm_cbe_perftools</span><span class="p">(</span><span class="n">SUBFUNC_RESET</span><span class="p">,</span> <span class="n">PASSTHRU_DISABLE</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">pm_signal_local</span><span class="p">,</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm_signal</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * Not a fatal error. For Oprofile stop, the oprofile</span>
<span class="cm">		 * functions do not support returning an error for</span>
<span class="cm">		 * failure to stop OProfile.</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: rtas returned: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pm_rtas_activate_signals</span><span class="p">(</span><span class="n">u32</span> <span class="n">node</span><span class="p">,</span> <span class="n">u32</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pm_signal</span> <span class="n">pm_signal_local</span><span class="p">[</span><span class="n">NR_PHYS_CTRS</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is no debug setup required for the cycles event.</span>
<span class="cm">	 * Note that only events in the same group can be used.</span>
<span class="cm">	 * Otherwise, there will be conflicts in correctly routing</span>
<span class="cm">	 * the signals on the debug bus.  It is the responsibility</span>
<span class="cm">	 * of the OProfile user tool to check the events are in</span>
<span class="cm">	 * the same group.</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pm_signal</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">signal_group</span> <span class="o">!=</span> <span class="n">PPU_CYCLES_GRP_NUM</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* fw expects physical cpu # */</span>
			<span class="n">pm_signal_local</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
			<span class="n">pm_signal_local</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">signal_group</span>
				<span class="o">=</span> <span class="n">pm_signal</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">signal_group</span><span class="p">;</span>
			<span class="n">pm_signal_local</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bus_word</span> <span class="o">=</span> <span class="n">pm_signal</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">bus_word</span><span class="p">;</span>
			<span class="n">pm_signal_local</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sub_unit</span> <span class="o">=</span> <span class="n">pm_signal</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">sub_unit</span><span class="p">;</span>
			<span class="n">pm_signal_local</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bit</span> <span class="o">=</span> <span class="n">pm_signal</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">bit</span><span class="p">;</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rtas_ibm_cbe_perftools</span><span class="p">(</span><span class="n">SUBFUNC_ACTIVATE</span><span class="p">,</span> <span class="n">PASSTHRU_ENABLE</span><span class="p">,</span>
					     <span class="n">pm_signal_local</span><span class="p">,</span>
					     <span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm_signal</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: rtas returned: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * PM Signal functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_pm_event</span><span class="p">(</span><span class="n">u32</span> <span class="n">ctr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">,</span> <span class="n">u32</span> <span class="n">unit_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pm_signal</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">signal_bit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bus_word</span><span class="p">,</span> <span class="n">bus_type</span><span class="p">,</span> <span class="n">count_cycles</span><span class="p">,</span> <span class="n">polarity</span><span class="p">,</span> <span class="n">input_control</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">PPU_CYCLES_EVENT_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Special Event: Count all cpu cycles */</span>
		<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm07_cntrl</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span> <span class="o">=</span> <span class="n">CBE_COUNT_ALL_CYCLES</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pm_signal</span><span class="p">[</span><span class="n">ctr</span><span class="p">]);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">signal_group</span> <span class="o">=</span> <span class="n">PPU_CYCLES_GRP_NUM</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">bus_word</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sub_unit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm07_cntrl</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bus_word</span> <span class="o">=</span> <span class="n">GET_BUS_WORD</span><span class="p">(</span><span class="n">unit_mask</span><span class="p">);</span>
	<span class="n">bus_type</span> <span class="o">=</span> <span class="n">GET_BUS_TYPE</span><span class="p">(</span><span class="n">unit_mask</span><span class="p">);</span>
	<span class="n">count_cycles</span> <span class="o">=</span> <span class="n">GET_COUNT_CYCLES</span><span class="p">(</span><span class="n">unit_mask</span><span class="p">);</span>
	<span class="n">polarity</span> <span class="o">=</span> <span class="n">GET_POLARITY</span><span class="p">(</span><span class="n">unit_mask</span><span class="p">);</span>
	<span class="n">input_control</span> <span class="o">=</span> <span class="n">GET_INPUT_CONTROL</span><span class="p">(</span><span class="n">unit_mask</span><span class="p">);</span>
	<span class="n">signal_bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">event</span> <span class="o">%</span> <span class="mi">100</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pm_signal</span><span class="p">[</span><span class="n">ctr</span><span class="p">]);</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">signal_group</span> <span class="o">=</span> <span class="n">event</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">bus_word</span> <span class="o">=</span> <span class="n">bus_word</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">sub_unit</span> <span class="o">=</span> <span class="n">GET_SUB_UNIT</span><span class="p">(</span><span class="n">unit_mask</span><span class="p">);</span>

	<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm07_cntrl</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm07_cntrl</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span> <span class="o">|=</span> <span class="n">PM07_CTR_COUNT_CYCLES</span><span class="p">(</span><span class="n">count_cycles</span><span class="p">);</span>
	<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm07_cntrl</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span> <span class="o">|=</span> <span class="n">PM07_CTR_POLARITY</span><span class="p">(</span><span class="n">polarity</span><span class="p">);</span>
	<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm07_cntrl</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span> <span class="o">|=</span> <span class="n">PM07_CTR_INPUT_CONTROL</span><span class="p">(</span><span class="n">input_control</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some of the islands signal selection is based on 64 bit words.</span>
<span class="cm">	 * The debug bus words are 32 bits, the input words to the performance</span>
<span class="cm">	 * counters are defined as 32 bits.  Need to convert the 64 bit island</span>
<span class="cm">	 * specification to the appropriate 32 input bit and bus word for the</span>
<span class="cm">	 * performance counter event selection.	 See the CELL Performance</span>
<span class="cm">	 * monitoring signals manual and the Perf cntr hardware descriptions</span>
<span class="cm">	 * for the details.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input_control</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_bit</span> <span class="o">&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">signal_bit</span> <span class="o">-=</span> <span class="mi">32</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bus_word</span> <span class="o">==</span> <span class="mh">0x3</span><span class="p">)</span>
				<span class="n">bus_word</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_word</span> <span class="o">==</span> <span class="mh">0xc</span><span class="p">)</span>
				<span class="n">bus_word</span> <span class="o">=</span> <span class="mh">0x8</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">bus_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">signal_group</span> <span class="o">&gt;=</span> <span class="mi">60</span><span class="p">)</span>
			<span class="n">bus_type</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bus_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">signal_group</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">)</span>
			<span class="n">bus_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm07_cntrl</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span> <span class="o">|=</span> <span class="n">PM07_CTR_INPUT_MUX</span><span class="p">(</span><span class="n">signal_bit</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm07_cntrl</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">bit</span> <span class="o">=</span> <span class="n">signal_bit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_DEBUG_BUS_WORDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bus_word</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pm_regs</span><span class="p">.</span><span class="n">debug_bus_control</span> <span class="o">|=</span>
				<span class="p">(</span><span class="n">bus_type</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">30</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)));</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">NUM_INPUT_BUS_WORDS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">input_bus</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">input_bus</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
					<span class="n">pm_regs</span><span class="p">.</span><span class="n">group_control</span> <span class="o">|=</span>
						<span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">30</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="p">)));</span>

					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_pm_cntrl</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Oprofile will use 32 bit counters, set bits 7:10 to 0</span>
<span class="cm">	 * pmregs.pm_cntrl is a global</span>
<span class="cm">	 */</span>

	<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">enable</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CBE_PM_ENABLE_PERF_MON</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">stop_at_max</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CBE_PM_STOP_AT_MAX</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">trace_mode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CBE_PM_TRACE_MODE_SET</span><span class="p">(</span><span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">trace_mode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">trace_buf_ovflw</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CBE_PM_TRACE_BUF_OVFLW</span><span class="p">(</span><span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">trace_buf_ovflw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">freeze</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CBE_PM_FREEZE_ALL_CTRS</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">|=</span> <span class="n">CBE_PM_SPU_ADDR_TRACE_SET</span><span class="p">(</span><span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">spu_addr_trace</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Routine set_count_mode must be called previously to set</span>
<span class="cm">	 * the count mode based on the user selection of user and kernel.</span>
<span class="cm">	 */</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">CBE_PM_COUNT_MODE_SET</span><span class="p">(</span><span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">count_mode</span><span class="p">);</span>
	<span class="n">cbe_write_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pm_control</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">set_count_mode</span><span class="p">(</span><span class="n">u32</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">u32</span> <span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The user must specify user and kernel if they want them. If</span>
<span class="cm">	 *  neither is specified, OProfile will count in hypervisor mode.</span>
<span class="cm">	 *  pm_regs.pm_cntrl is a global</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kernel</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="p">)</span>
			<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">count_mode</span> <span class="o">=</span> <span class="n">CBE_COUNT_ALL_MODES</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">count_mode</span> <span class="o">=</span>
				<span class="n">CBE_COUNT_SUPERVISOR_MODE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="p">)</span>
			<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">count_mode</span> <span class="o">=</span> <span class="n">CBE_COUNT_PROBLEM_MODE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">count_mode</span> <span class="o">=</span>
				<span class="n">CBE_COUNT_HYPERVISOR_MODE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enable_ctr</span><span class="p">(</span><span class="n">u32</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pm07_cntrl</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">pm07_cntrl</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span> <span class="o">|=</span> <span class="n">CBE_PM_CTR_ENABLE</span><span class="p">;</span>
	<span class="n">cbe_write_pm07_control</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">ctr</span><span class="p">,</span> <span class="n">pm07_cntrl</span><span class="p">[</span><span class="n">ctr</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Oprofile is expected to collect data on all CPUs simultaneously.</span>
<span class="cm"> * However, there is one set of performance counters per node.	There are</span>
<span class="cm"> * two hardware threads or virtual CPUs on each node.  Hence, OProfile must</span>
<span class="cm"> * multiplex in time the performance counter collection on the two virtual</span>
<span class="cm"> * CPUs.  The multiplexing of the performance counters is done by this</span>
<span class="cm"> * virtual counter routine.</span>
<span class="cm"> *</span>
<span class="cm"> * The pmc_values used below is defined as &#39;per-cpu&#39; but its use is</span>
<span class="cm"> * more akin to &#39;per-node&#39;.  We need to store two sets of counter</span>
<span class="cm"> * values per node -- one for the previous run and one for the next.</span>
<span class="cm"> * The per-cpu[NR_PHYS_CTRS] gives us the storage we need.  Each odd/even</span>
<span class="cm"> * pair of per-cpu arrays is used for storing the previous and next</span>
<span class="cm"> * pmc values for a given node.</span>
<span class="cm"> * NOTE: We use the per-cpu variable to improve cache performance.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will alternate loading the virtual counters for</span>
<span class="cm"> * virtual CPUs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_virtual_cntr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">prev_hdw_thread</span><span class="p">,</span> <span class="n">next_hdw_thread</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure that the interrupt_hander and the virt counter are</span>
<span class="cm">	 * not both playing with the counters on the same node.</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cntr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">prev_hdw_thread</span> <span class="o">=</span> <span class="n">hdw_thread</span><span class="p">;</span>

	<span class="cm">/* switch the cpu handling the interrupts */</span>
	<span class="n">hdw_thread</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">^</span> <span class="n">hdw_thread</span><span class="p">;</span>
	<span class="n">next_hdw_thread</span> <span class="o">=</span> <span class="n">hdw_thread</span><span class="p">;</span>

	<span class="n">pm_regs</span><span class="p">.</span><span class="n">group_control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pm_regs</span><span class="p">.</span><span class="n">debug_bus_control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_INPUT_BUS_WORDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">input_bus</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There are some per thread events.  Must do the</span>
<span class="cm">	 * set event, for the thread that is being started</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_counters</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">set_pm_event</span><span class="p">(</span><span class="n">i</span><span class="p">,</span>
			<span class="n">pmc_cntrl</span><span class="p">[</span><span class="n">next_hdw_thread</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">evnts</span><span class="p">,</span>
			<span class="n">pmc_cntrl</span><span class="p">[</span><span class="n">next_hdw_thread</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">masks</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following is done only once per each node, but</span>
<span class="cm">	 * we need cpu #, not node #, to pass to the cbe_xxx functions.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cbe_get_hw_thread_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * stop counters, save counter values, restore counts</span>
<span class="cm">		 * for previous thread</span>
<span class="cm">		 */</span>
		<span class="n">cbe_disable_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">cbe_disable_pm_interrupts</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_counters</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">pmc_values</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">+</span> <span class="n">prev_hdw_thread</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span>
				<span class="o">=</span> <span class="n">cbe_read_ctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">pmc_values</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">+</span> <span class="n">next_hdw_thread</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span>
			    <span class="o">==</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span>
				<span class="cm">/* If the cntr value is 0xffffffff, we must</span>
<span class="cm">				 * reset that to 0xfffffff0 when the current</span>
<span class="cm">				 * thread is restarted.	 This will generate a</span>
<span class="cm">				 * new interrupt and make sure that we never</span>
<span class="cm">				 * restore the counters to the max value.  If</span>
<span class="cm">				 * the counters were restored to the max value,</span>
<span class="cm">				 * they do not increment and no interrupts are</span>
<span class="cm">				 * generated.  Hence no more samples will be</span>
<span class="cm">				 * collected on that cpu.</span>
<span class="cm">				 */</span>
				<span class="n">cbe_write_ctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mh">0xFFFFFFF0</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">cbe_write_ctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					      <span class="n">per_cpu</span><span class="p">(</span><span class="n">pmc_values</span><span class="p">,</span>
						      <span class="n">cpu</span> <span class="o">+</span>
						      <span class="n">next_hdw_thread</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Switch to the other thread. Change the interrupt</span>
<span class="cm">		 * and control regs to be scheduled on the CPU</span>
<span class="cm">		 * corresponding to the thread to execute.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_counters</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmc_cntrl</span><span class="p">[</span><span class="n">next_hdw_thread</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * There are some per thread events.</span>
<span class="cm">				 * Must do the set event, enable_cntr</span>
<span class="cm">				 * for each cpu.</span>
<span class="cm">				 */</span>
				<span class="n">enable_ctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					   <span class="n">pm_regs</span><span class="p">.</span><span class="n">pm07_cntrl</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">cbe_write_pm07_control</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Enable interrupts on the CPU thread that is starting */</span>
		<span class="n">cbe_enable_pm_interrupts</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">next_hdw_thread</span><span class="p">,</span>
					 <span class="n">virt_cntr_inter_mask</span><span class="p">);</span>
		<span class="n">cbe_enable_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cntr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer_virt_cntr</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_virt_cntrs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer_virt_cntr</span><span class="p">);</span>
	<span class="n">timer_virt_cntr</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">cell_virtual_cntr</span><span class="p">;</span>
	<span class="n">timer_virt_cntr</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
	<span class="n">timer_virt_cntr</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer_virt_cntr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cell_reg_setup_spu_cycles</span><span class="p">(</span><span class="k">struct</span> <span class="n">op_counter_config</span> <span class="o">*</span><span class="n">ctr</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">op_system_config</span> <span class="o">*</span><span class="n">sys</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_ctrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spu_cycle_reset</span> <span class="o">=</span> <span class="n">ctr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Each node will need to make the rtas call to start</span>
<span class="cm">	 * and stop SPU profiling.  Get the token once and store it.</span>
<span class="cm">	 */</span>
	<span class="n">spu_rtas_token</span> <span class="o">=</span> <span class="n">rtas_token</span><span class="p">(</span><span class="s">&quot;ibm,cbe-spu-perftools&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">spu_rtas_token</span> <span class="o">==</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;%s: rtas token ibm,cbe-spu-perftools unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Unfortunately, the hardware will only support event profiling</span>
<span class="cm"> * on one SPU per node at a time.  Therefore, we must time slice</span>
<span class="cm"> * the profiling across all SPUs in the node.  Note, we do this</span>
<span class="cm"> * in parallel for each node.  The following routine is called</span>
<span class="cm"> * periodically based on kernel timer to switch which SPU is</span>
<span class="cm"> * being monitored in a round robbin fashion.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">spu_evnt_swap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cur_phys_spu</span><span class="p">,</span> <span class="n">nxt_phys_spu</span><span class="p">,</span> <span class="n">cur_spu_evnt_phys_spu_indx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">interrupt_mask</span><span class="p">;</span>


	<span class="cm">/* enable interrupts on cntr 0 */</span>
	<span class="n">interrupt_mask</span> <span class="o">=</span> <span class="n">CBE_PM_CTR_OVERFLOW_INTR</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">hdw_thread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Make sure spu event interrupt handler and spu event swap</span>
<span class="cm">	 * don&#39;t access the counters simultaneously.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cntr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">cur_spu_evnt_phys_spu_indx</span> <span class="o">=</span> <span class="n">spu_evnt_phys_spu_indx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="p">(</span><span class="n">spu_evnt_phys_spu_indx</span><span class="p">)</span> <span class="o">==</span> <span class="n">NUM_SPUS_PER_NODE</span><span class="p">)</span>
		<span class="n">spu_evnt_phys_spu_indx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pm_signal</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sub_unit</span> <span class="o">=</span> <span class="n">spu_evnt_phys_spu_indx</span><span class="p">;</span>
	<span class="n">pm_signal</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">sub_unit</span> <span class="o">=</span> <span class="n">spu_evnt_phys_spu_indx</span><span class="p">;</span>
	<span class="n">pm_signal</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">sub_unit</span> <span class="o">=</span> <span class="n">spu_evnt_phys_spu_indx</span><span class="p">;</span>

	<span class="cm">/* switch the SPU being profiled on each node */</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cbe_get_hw_thread_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">node</span> <span class="o">=</span> <span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">cur_phys_spu</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span> <span class="o">*</span> <span class="n">NUM_SPUS_PER_NODE</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">cur_spu_evnt_phys_spu_indx</span><span class="p">;</span>
		<span class="n">nxt_phys_spu</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span> <span class="o">*</span> <span class="n">NUM_SPUS_PER_NODE</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">spu_evnt_phys_spu_indx</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * stop counters, save counter values, restore counts</span>
<span class="cm">		 * for previous physical SPU</span>
<span class="cm">		 */</span>
		<span class="n">cbe_disable_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">cbe_disable_pm_interrupts</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

		<span class="n">spu_pm_cnt</span><span class="p">[</span><span class="n">cur_phys_spu</span><span class="p">]</span>
			<span class="o">=</span> <span class="n">cbe_read_ctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* restore previous count for the next spu to sample */</span>
		<span class="cm">/* NOTE, hardware issue, counter will not start if the</span>
<span class="cm">		 * counter value is at max (0xFFFFFFFF).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spu_pm_cnt</span><span class="p">[</span><span class="n">nxt_phys_spu</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span>
			<span class="n">cbe_write_ctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xFFFFFFF0</span><span class="p">);</span>
		 <span class="k">else</span>
			 <span class="n">cbe_write_ctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">spu_pm_cnt</span><span class="p">[</span><span class="n">nxt_phys_spu</span><span class="p">]);</span>

		<span class="n">pm_rtas_reset_signals</span><span class="p">(</span><span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>

		<span class="cm">/* setup the debug bus measure the one event and</span>
<span class="cm">		 * the two events to route the next SPU&#39;s PC on</span>
<span class="cm">		 * the debug bus</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pm_rtas_activate_signals</span><span class="p">(</span><span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: pm_rtas_activate_signals failed, &quot;</span>
			       <span class="s">&quot;SPU event swap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

		<span class="cm">/* clear the trace buffer, don&#39;t want to take PC for</span>
<span class="cm">		 * previous SPU*/</span>
		<span class="n">cbe_write_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">trace_address</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">enable_ctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pm_regs</span><span class="p">.</span><span class="n">pm07_cntrl</span><span class="p">);</span>

		<span class="cm">/* Enable interrupts on the CPU thread that is starting */</span>
		<span class="n">cbe_enable_pm_interrupts</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">hdw_thread</span><span class="p">,</span>
					 <span class="n">interrupt_mask</span><span class="p">);</span>
		<span class="n">cbe_enable_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cntr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* swap approximately every 0.1 seconds */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer_spu_event_swap</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">25</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_spu_event_swap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer_spu_event_swap</span><span class="p">);</span>
	<span class="n">timer_spu_event_swap</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">spu_evnt_swap</span><span class="p">;</span>
	<span class="n">timer_spu_event_swap</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
	<span class="n">timer_spu_event_swap</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">25</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer_spu_event_swap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cell_reg_setup_spu_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">op_counter_config</span> <span class="o">*</span><span class="n">ctr</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">op_system_config</span> <span class="o">*</span><span class="n">sys</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_ctrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* routine is called once for all nodes */</span>

	<span class="n">spu_evnt_phys_spu_indx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * For all events except PPU CYCLEs, each node will need to make</span>
<span class="cm">	 * the rtas cbe-perftools call to setup and reset the debug bus.</span>
<span class="cm">	 * Make the token lookup call once and store it in the global</span>
<span class="cm">	 * variable pm_rtas_token.</span>
<span class="cm">	 */</span>
	<span class="n">pm_rtas_token</span> <span class="o">=</span> <span class="n">rtas_token</span><span class="p">(</span><span class="s">&quot;ibm,cbe-perftools&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pm_rtas_token</span> <span class="o">==</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;%s: rtas token ibm,cbe-perftools unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* setup the pm_control register settings,</span>
<span class="cm">	 * settings will be written per node by the</span>
<span class="cm">	 * cell_cpu_setup() function.</span>
<span class="cm">	 */</span>
	<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">trace_buf_ovflw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Use the occurrence trace mode to have SPU PC saved</span>
<span class="cm">	 * to the trace buffer.  Occurrence data in trace buffer</span>
<span class="cm">	 * is not used.  Bit 2 must be set to store SPU addresses.</span>
<span class="cm">	 */</span>
	<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">trace_mode</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">spu_addr_trace</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>  <span class="cm">/* using debug bus</span>
<span class="cm">						   event 2 &amp; 3 */</span>

	<span class="cm">/* setup the debug bus event array with the SPU PC routing events.</span>
<span class="cm">	*  Note, pm_signal[0] will be filled in by set_pm_event() call below.</span>
<span class="cm">	*/</span>
	<span class="n">pm_signal</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">signal_group</span> <span class="o">=</span> <span class="n">SPU_PROFILE_EVENT_ADDR</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">pm_signal</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">bus_word</span> <span class="o">=</span> <span class="n">GET_BUS_WORD</span><span class="p">(</span><span class="n">SPU_PROFILE_EVENT_ADDR_MASK_A</span><span class="p">);</span>
	<span class="n">pm_signal</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">bit</span> <span class="o">=</span> <span class="n">SPU_PROFILE_EVENT_ADDR</span> <span class="o">%</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">pm_signal</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">sub_unit</span> <span class="o">=</span> <span class="n">spu_evnt_phys_spu_indx</span><span class="p">;</span>

	<span class="n">pm_signal</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">signal_group</span> <span class="o">=</span> <span class="n">SPU_PROFILE_EVENT_ADDR</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">pm_signal</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">bus_word</span> <span class="o">=</span> <span class="n">GET_BUS_WORD</span><span class="p">(</span><span class="n">SPU_PROFILE_EVENT_ADDR_MASK_B</span><span class="p">);</span>
	<span class="n">pm_signal</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">bit</span> <span class="o">=</span> <span class="n">SPU_PROFILE_EVENT_ADDR</span> <span class="o">%</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">pm_signal</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">sub_unit</span> <span class="o">=</span> <span class="n">spu_evnt_phys_spu_indx</span><span class="p">;</span>

	<span class="cm">/* Set the user selected spu event to profile on,</span>
<span class="cm">	 * note, only one SPU profiling event is supported</span>
<span class="cm">	 */</span>
	<span class="n">num_counters</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Only support one SPU event at a time */</span>
	<span class="n">set_pm_event</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ctr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">event</span><span class="p">,</span> <span class="n">ctr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">unit_mask</span><span class="p">);</span>

	<span class="n">reset_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span> <span class="o">-</span> <span class="n">ctr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>

	<span class="cm">/* global, used by cell_cpu_setup */</span>
	<span class="n">ctr_enabled</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Initialize the count for each SPU to the reset value */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span> <span class="o">*</span> <span class="n">NUM_SPUS_PER_NODE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">spu_pm_cnt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">reset_value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cell_reg_setup_ppu</span><span class="p">(</span><span class="k">struct</span> <span class="n">op_counter_config</span> <span class="o">*</span><span class="n">ctr</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">op_system_config</span> <span class="o">*</span><span class="n">sys</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_ctrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* routine is called once for all nodes */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">num_counters</span> <span class="o">=</span> <span class="n">num_ctrs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">num_ctrs</span> <span class="o">&gt;</span> <span class="n">NR_PHYS_CTRS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;%s: Oprofile, number of specified events &quot;</span> \
		       <span class="s">&quot;exceeds number of physical counters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_count_mode</span><span class="p">(</span><span class="n">sys</span><span class="o">-&gt;</span><span class="n">enable_kernel</span><span class="p">,</span> <span class="n">sys</span><span class="o">-&gt;</span><span class="n">enable_user</span><span class="p">);</span>

	<span class="cm">/* Setup the thread 0 events */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_ctrs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">pmc_cntrl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">evnts</span> <span class="o">=</span> <span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">event</span><span class="p">;</span>
		<span class="n">pmc_cntrl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">masks</span> <span class="o">=</span> <span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">unit_mask</span><span class="p">;</span>
		<span class="n">pmc_cntrl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">enabled</span> <span class="o">=</span> <span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">enabled</span><span class="p">;</span>
		<span class="n">pmc_cntrl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">vcntr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">pmc_values</span><span class="p">,</span> <span class="n">j</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup the thread 1 events, map the thread 0 event to the</span>
<span class="cm">	 * equivalent thread 1 event.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_ctrs</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">event</span> <span class="o">&gt;=</span> <span class="mi">2100</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">event</span> <span class="o">&lt;=</span> <span class="mi">2111</span><span class="p">))</span>
			<span class="n">pmc_cntrl</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">evnts</span> <span class="o">=</span> <span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">event</span> <span class="o">+</span> <span class="mi">19</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">event</span> <span class="o">==</span> <span class="mi">2203</span><span class="p">)</span>
			<span class="n">pmc_cntrl</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">evnts</span> <span class="o">=</span> <span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">event</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">event</span> <span class="o">&gt;=</span> <span class="mi">2200</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">event</span> <span class="o">&lt;=</span> <span class="mi">2215</span><span class="p">))</span>
			<span class="n">pmc_cntrl</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">evnts</span> <span class="o">=</span> <span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">event</span> <span class="o">+</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pmc_cntrl</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">evnts</span> <span class="o">=</span> <span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">event</span><span class="p">;</span>

		<span class="n">pmc_cntrl</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">masks</span> <span class="o">=</span> <span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">unit_mask</span><span class="p">;</span>
		<span class="n">pmc_cntrl</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">enabled</span> <span class="o">=</span> <span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">enabled</span><span class="p">;</span>
		<span class="n">pmc_cntrl</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">vcntr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_INPUT_BUS_WORDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">input_bus</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Our counters count up, and &quot;count&quot; refers to</span>
<span class="cm">	 * how much before the next interrupt, and we interrupt</span>
<span class="cm">	 * on overflow.	 So we calculate the starting value</span>
<span class="cm">	 * which will give us &quot;count&quot; until overflow.</span>
<span class="cm">	 * Then we set the events on the enabled counters.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_counters</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* start with virtual counter set 0 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmc_cntrl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Using 32bit counters, reset max - count */</span>
			<span class="n">reset_value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span> <span class="o">-</span> <span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>
			<span class="n">set_pm_event</span><span class="p">(</span><span class="n">i</span><span class="p">,</span>
				     <span class="n">pmc_cntrl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">evnts</span><span class="p">,</span>
				     <span class="n">pmc_cntrl</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">masks</span><span class="p">);</span>

			<span class="cm">/* global, used by cell_cpu_setup */</span>
			<span class="n">ctr_enabled</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* initialize the previous counts for the virtual cntrs */</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_counters</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">pmc_values</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">reset_value</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* This function is called once for all cpus combined */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cell_reg_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">op_counter_config</span> <span class="o">*</span><span class="n">ctr</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">op_system_config</span> <span class="o">*</span><span class="n">sys</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_ctrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">spu_cycle_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* initialize the spu_arr_trace value, will be reset if</span>
<span class="cm">	 * doing spu event profiling.</span>
<span class="cm">	 */</span>
	<span class="n">pm_regs</span><span class="p">.</span><span class="n">group_control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pm_regs</span><span class="p">.</span><span class="n">debug_bus_control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">stop_at_max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">trace_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">freeze</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">trace_buf_ovflw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pm_regs</span><span class="p">.</span><span class="n">pm_cntrl</span><span class="p">.</span><span class="n">spu_addr_trace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For all events except PPU CYCLEs, each node will need to make</span>
<span class="cm">	 * the rtas cbe-perftools call to setup and reset the debug bus.</span>
<span class="cm">	 * Make the token lookup call once and store it in the global</span>
<span class="cm">	 * variable pm_rtas_token.</span>
<span class="cm">	 */</span>
	<span class="n">pm_rtas_token</span> <span class="o">=</span> <span class="n">rtas_token</span><span class="p">(</span><span class="s">&quot;ibm,cbe-perftools&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pm_rtas_token</span> <span class="o">==</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;%s: rtas token ibm,cbe-perftools unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">event</span> <span class="o">==</span> <span class="n">SPU_CYCLES_EVENT_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">profiling_mode</span> <span class="o">=</span> <span class="n">SPU_PROFILING_CYCLES</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cell_reg_setup_spu_cycles</span><span class="p">(</span><span class="n">ctr</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span> <span class="n">num_ctrs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ctr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">event</span> <span class="o">&gt;=</span> <span class="n">SPU_EVENT_NUM_START</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">ctr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">event</span> <span class="o">&lt;=</span> <span class="n">SPU_EVENT_NUM_STOP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">profiling_mode</span> <span class="o">=</span> <span class="n">SPU_PROFILING_EVENTS</span><span class="p">;</span>
		<span class="n">spu_cycle_reset</span> <span class="o">=</span> <span class="n">ctr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>

		<span class="cm">/* for SPU event profiling, need to setup the</span>
<span class="cm">		 * pm_signal array with the events to route the</span>
<span class="cm">		 * SPU PC before making the FW call.  Note, only</span>
<span class="cm">		 * one SPU event for profiling can be specified</span>
<span class="cm">		 * at a time.</span>
<span class="cm">		 */</span>
		<span class="n">cell_reg_setup_spu_events</span><span class="p">(</span><span class="n">ctr</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span> <span class="n">num_ctrs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">profiling_mode</span> <span class="o">=</span> <span class="n">PPU_PROFILING</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cell_reg_setup_ppu</span><span class="p">(</span><span class="n">ctr</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span> <span class="n">num_ctrs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/* This function is called once for each cpu */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cell_cpu_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">op_counter_config</span> <span class="o">*</span><span class="n">cntr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">u32</span> <span class="n">num_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Cycle based SPU profiling does not use the performance</span>
<span class="cm">	 * counters.  The trace array is configured to collect</span>
<span class="cm">	 * the data.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">profiling_mode</span> <span class="o">==</span> <span class="n">SPU_PROFILING_CYCLES</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* There is one performance monitor per processor chip (i.e. node),</span>
<span class="cm">	 * so we only need to perform this function once per node.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cbe_get_hw_thread_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Stop all counters */</span>
	<span class="n">cbe_disable_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">cbe_disable_pm_interrupts</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">cbe_write_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pm_start_stop</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cbe_write_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">group_control</span><span class="p">,</span> <span class="n">pm_regs</span><span class="p">.</span><span class="n">group_control</span><span class="p">);</span>
	<span class="n">cbe_write_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">debug_bus_control</span><span class="p">,</span> <span class="n">pm_regs</span><span class="p">.</span><span class="n">debug_bus_control</span><span class="p">);</span>
	<span class="n">write_pm_cntrl</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_counters</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctr_enabled</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pm_signal</span><span class="p">[</span><span class="n">num_enabled</span><span class="p">].</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
			<span class="n">num_enabled</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The pm_rtas_activate_signals will return -EIO if the FW</span>
<span class="cm">	 * call failed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">profiling_mode</span> <span class="o">==</span> <span class="n">SPU_PROFILING_EVENTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* For SPU event profiling also need to setup the</span>
<span class="cm">		 * pm interval timer</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pm_rtas_activate_signals</span><span class="p">(</span><span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span>
					       <span class="n">num_enabled</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
		<span class="cm">/* store PC from debug bus to Trace buffer as often</span>
<span class="cm">		 * as possible (every 10 cycles)</span>
<span class="cm">		 */</span>
		<span class="n">cbe_write_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pm_interval</span><span class="p">,</span> <span class="n">NUM_INTERVAL_CYC</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="n">pm_rtas_activate_signals</span><span class="p">(</span><span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span>
						<span class="n">num_enabled</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define ENTRIES	 303</span>
<span class="cp">#define MAXLFSR	 0xFFFFFF</span>

<span class="cm">/* precomputed table of 24 bit LFSR values */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">initial_lfsr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
 <span class="mi">8221349</span><span class="p">,</span> <span class="mi">12579195</span><span class="p">,</span> <span class="mi">5379618</span><span class="p">,</span> <span class="mi">10097839</span><span class="p">,</span> <span class="mi">7512963</span><span class="p">,</span> <span class="mi">7519310</span><span class="p">,</span> <span class="mi">3955098</span><span class="p">,</span> <span class="mi">10753424</span><span class="p">,</span>
 <span class="mi">15507573</span><span class="p">,</span> <span class="mi">7458917</span><span class="p">,</span> <span class="mi">285419</span><span class="p">,</span> <span class="mi">2641121</span><span class="p">,</span> <span class="mi">9780088</span><span class="p">,</span> <span class="mi">3915503</span><span class="p">,</span> <span class="mi">6668768</span><span class="p">,</span> <span class="mi">1548716</span><span class="p">,</span>
 <span class="mi">4885000</span><span class="p">,</span> <span class="mi">8774424</span><span class="p">,</span> <span class="mi">9650099</span><span class="p">,</span> <span class="mi">2044357</span><span class="p">,</span> <span class="mi">2304411</span><span class="p">,</span> <span class="mi">9326253</span><span class="p">,</span> <span class="mi">10332526</span><span class="p">,</span> <span class="mi">4421547</span><span class="p">,</span>
 <span class="mi">3440748</span><span class="p">,</span> <span class="mi">10179459</span><span class="p">,</span> <span class="mi">13332843</span><span class="p">,</span> <span class="mi">10375561</span><span class="p">,</span> <span class="mi">1313462</span><span class="p">,</span> <span class="mi">8375100</span><span class="p">,</span> <span class="mi">5198480</span><span class="p">,</span> <span class="mi">6071392</span><span class="p">,</span>
 <span class="mi">9341783</span><span class="p">,</span> <span class="mi">1526887</span><span class="p">,</span> <span class="mi">3985002</span><span class="p">,</span> <span class="mi">1439429</span><span class="p">,</span> <span class="mi">13923762</span><span class="p">,</span> <span class="mi">7010104</span><span class="p">,</span> <span class="mi">11969769</span><span class="p">,</span> <span class="mi">4547026</span><span class="p">,</span>
 <span class="mi">2040072</span><span class="p">,</span> <span class="mi">4025602</span><span class="p">,</span> <span class="mi">3437678</span><span class="p">,</span> <span class="mi">7939992</span><span class="p">,</span> <span class="mi">11444177</span><span class="p">,</span> <span class="mi">4496094</span><span class="p">,</span> <span class="mi">9803157</span><span class="p">,</span> <span class="mi">10745556</span><span class="p">,</span>
 <span class="mi">3671780</span><span class="p">,</span> <span class="mi">4257846</span><span class="p">,</span> <span class="mi">5662259</span><span class="p">,</span> <span class="mi">13196905</span><span class="p">,</span> <span class="mi">3237343</span><span class="p">,</span> <span class="mi">12077182</span><span class="p">,</span> <span class="mi">16222879</span><span class="p">,</span> <span class="mi">7587769</span><span class="p">,</span>
 <span class="mi">14706824</span><span class="p">,</span> <span class="mi">2184640</span><span class="p">,</span> <span class="mi">12591135</span><span class="p">,</span> <span class="mi">10420257</span><span class="p">,</span> <span class="mi">7406075</span><span class="p">,</span> <span class="mi">3648978</span><span class="p">,</span> <span class="mi">11042541</span><span class="p">,</span> <span class="mi">15906893</span><span class="p">,</span>
 <span class="mi">11914928</span><span class="p">,</span> <span class="mi">4732944</span><span class="p">,</span> <span class="mi">10695697</span><span class="p">,</span> <span class="mi">12928164</span><span class="p">,</span> <span class="mi">11980531</span><span class="p">,</span> <span class="mi">4430912</span><span class="p">,</span> <span class="mi">11939291</span><span class="p">,</span> <span class="mi">2917017</span><span class="p">,</span>
 <span class="mi">6119256</span><span class="p">,</span> <span class="mi">4172004</span><span class="p">,</span> <span class="mi">9373765</span><span class="p">,</span> <span class="mi">8410071</span><span class="p">,</span> <span class="mi">14788383</span><span class="p">,</span> <span class="mi">5047459</span><span class="p">,</span> <span class="mi">5474428</span><span class="p">,</span> <span class="mi">1737756</span><span class="p">,</span>
 <span class="mi">15967514</span><span class="p">,</span> <span class="mi">13351758</span><span class="p">,</span> <span class="mi">6691285</span><span class="p">,</span> <span class="mi">8034329</span><span class="p">,</span> <span class="mi">2856544</span><span class="p">,</span> <span class="mi">14394753</span><span class="p">,</span> <span class="mi">11310160</span><span class="p">,</span> <span class="mi">12149558</span><span class="p">,</span>
 <span class="mi">7487528</span><span class="p">,</span> <span class="mi">7542781</span><span class="p">,</span> <span class="mi">15668898</span><span class="p">,</span> <span class="mi">12525138</span><span class="p">,</span> <span class="mi">12790975</span><span class="p">,</span> <span class="mi">3707933</span><span class="p">,</span> <span class="mi">9106617</span><span class="p">,</span> <span class="mi">1965401</span><span class="p">,</span>
 <span class="mi">16219109</span><span class="p">,</span> <span class="mi">12801644</span><span class="p">,</span> <span class="mi">2443203</span><span class="p">,</span> <span class="mi">4909502</span><span class="p">,</span> <span class="mi">8762329</span><span class="p">,</span> <span class="mi">3120803</span><span class="p">,</span> <span class="mi">6360315</span><span class="p">,</span> <span class="mi">9309720</span><span class="p">,</span>
 <span class="mi">15164599</span><span class="p">,</span> <span class="mi">10844842</span><span class="p">,</span> <span class="mi">4456529</span><span class="p">,</span> <span class="mi">6667610</span><span class="p">,</span> <span class="mi">14924259</span><span class="p">,</span> <span class="mi">884312</span><span class="p">,</span> <span class="mi">6234963</span><span class="p">,</span> <span class="mi">3326042</span><span class="p">,</span>
 <span class="mi">15973422</span><span class="p">,</span> <span class="mi">13919464</span><span class="p">,</span> <span class="mi">5272099</span><span class="p">,</span> <span class="mi">6414643</span><span class="p">,</span> <span class="mi">3909029</span><span class="p">,</span> <span class="mi">2764324</span><span class="p">,</span> <span class="mi">5237926</span><span class="p">,</span> <span class="mi">4774955</span><span class="p">,</span>
 <span class="mi">10445906</span><span class="p">,</span> <span class="mi">4955302</span><span class="p">,</span> <span class="mi">5203726</span><span class="p">,</span> <span class="mi">10798229</span><span class="p">,</span> <span class="mi">11443419</span><span class="p">,</span> <span class="mi">2303395</span><span class="p">,</span> <span class="mi">333836</span><span class="p">,</span> <span class="mi">9646934</span><span class="p">,</span>
 <span class="mi">3464726</span><span class="p">,</span> <span class="mi">4159182</span><span class="p">,</span> <span class="mi">568492</span><span class="p">,</span> <span class="mi">995747</span><span class="p">,</span> <span class="mi">10318756</span><span class="p">,</span> <span class="mi">13299332</span><span class="p">,</span> <span class="mi">4836017</span><span class="p">,</span> <span class="mi">8237783</span><span class="p">,</span>
 <span class="mi">3878992</span><span class="p">,</span> <span class="mi">2581665</span><span class="p">,</span> <span class="mi">11394667</span><span class="p">,</span> <span class="mi">5672745</span><span class="p">,</span> <span class="mi">14412947</span><span class="p">,</span> <span class="mi">3159169</span><span class="p">,</span> <span class="mi">9094251</span><span class="p">,</span> <span class="mi">16467278</span><span class="p">,</span>
 <span class="mi">8671392</span><span class="p">,</span> <span class="mi">15230076</span><span class="p">,</span> <span class="mi">4843545</span><span class="p">,</span> <span class="mi">7009238</span><span class="p">,</span> <span class="mi">15504095</span><span class="p">,</span> <span class="mi">1494895</span><span class="p">,</span> <span class="mi">9627886</span><span class="p">,</span> <span class="mi">14485051</span><span class="p">,</span>
 <span class="mi">8304291</span><span class="p">,</span> <span class="mi">252817</span><span class="p">,</span> <span class="mi">12421642</span><span class="p">,</span> <span class="mi">16085736</span><span class="p">,</span> <span class="mi">4774072</span><span class="p">,</span> <span class="mi">2456177</span><span class="p">,</span> <span class="mi">4160695</span><span class="p">,</span> <span class="mi">15409741</span><span class="p">,</span>
 <span class="mi">4902868</span><span class="p">,</span> <span class="mi">5793091</span><span class="p">,</span> <span class="mi">13162925</span><span class="p">,</span> <span class="mi">16039714</span><span class="p">,</span> <span class="mi">782255</span><span class="p">,</span> <span class="mi">11347835</span><span class="p">,</span> <span class="mi">14884586</span><span class="p">,</span> <span class="mi">366972</span><span class="p">,</span>
 <span class="mi">16308990</span><span class="p">,</span> <span class="mi">11913488</span><span class="p">,</span> <span class="mi">13390465</span><span class="p">,</span> <span class="mi">2958444</span><span class="p">,</span> <span class="mi">10340278</span><span class="p">,</span> <span class="mi">1177858</span><span class="p">,</span> <span class="mi">1319431</span><span class="p">,</span> <span class="mi">10426302</span><span class="p">,</span>
 <span class="mi">2868597</span><span class="p">,</span> <span class="mi">126119</span><span class="p">,</span> <span class="mi">5784857</span><span class="p">,</span> <span class="mi">5245324</span><span class="p">,</span> <span class="mi">10903900</span><span class="p">,</span> <span class="mi">16436004</span><span class="p">,</span> <span class="mi">3389013</span><span class="p">,</span> <span class="mi">1742384</span><span class="p">,</span>
 <span class="mi">14674502</span><span class="p">,</span> <span class="mi">10279218</span><span class="p">,</span> <span class="mi">8536112</span><span class="p">,</span> <span class="mi">10364279</span><span class="p">,</span> <span class="mi">6877778</span><span class="p">,</span> <span class="mi">14051163</span><span class="p">,</span> <span class="mi">1025130</span><span class="p">,</span> <span class="mi">6072469</span><span class="p">,</span>
 <span class="mi">1988305</span><span class="p">,</span> <span class="mi">8354440</span><span class="p">,</span> <span class="mi">8216060</span><span class="p">,</span> <span class="mi">16342977</span><span class="p">,</span> <span class="mi">13112639</span><span class="p">,</span> <span class="mi">3976679</span><span class="p">,</span> <span class="mi">5913576</span><span class="p">,</span> <span class="mi">8816697</span><span class="p">,</span>
 <span class="mi">6879995</span><span class="p">,</span> <span class="mi">14043764</span><span class="p">,</span> <span class="mi">3339515</span><span class="p">,</span> <span class="mi">9364420</span><span class="p">,</span> <span class="mi">15808858</span><span class="p">,</span> <span class="mi">12261651</span><span class="p">,</span> <span class="mi">2141560</span><span class="p">,</span> <span class="mi">5636398</span><span class="p">,</span>
 <span class="mi">10345425</span><span class="p">,</span> <span class="mi">10414756</span><span class="p">,</span> <span class="mi">781725</span><span class="p">,</span> <span class="mi">6155650</span><span class="p">,</span> <span class="mi">4746914</span><span class="p">,</span> <span class="mi">5078683</span><span class="p">,</span> <span class="mi">7469001</span><span class="p">,</span> <span class="mi">6799140</span><span class="p">,</span>
 <span class="mi">10156444</span><span class="p">,</span> <span class="mi">9667150</span><span class="p">,</span> <span class="mi">10116470</span><span class="p">,</span> <span class="mi">4133858</span><span class="p">,</span> <span class="mi">2121972</span><span class="p">,</span> <span class="mi">1124204</span><span class="p">,</span> <span class="mi">1003577</span><span class="p">,</span> <span class="mi">1611214</span><span class="p">,</span>
 <span class="mi">14304602</span><span class="p">,</span> <span class="mi">16221850</span><span class="p">,</span> <span class="mi">13878465</span><span class="p">,</span> <span class="mi">13577744</span><span class="p">,</span> <span class="mi">3629235</span><span class="p">,</span> <span class="mi">8772583</span><span class="p">,</span> <span class="mi">10881308</span><span class="p">,</span> <span class="mi">2410386</span><span class="p">,</span>
 <span class="mi">7300044</span><span class="p">,</span> <span class="mi">5378855</span><span class="p">,</span> <span class="mi">9301235</span><span class="p">,</span> <span class="mi">12755149</span><span class="p">,</span> <span class="mi">4977682</span><span class="p">,</span> <span class="mi">8083074</span><span class="p">,</span> <span class="mi">10327581</span><span class="p">,</span> <span class="mi">6395087</span><span class="p">,</span>
 <span class="mi">9155434</span><span class="p">,</span> <span class="mi">15501696</span><span class="p">,</span> <span class="mi">7514362</span><span class="p">,</span> <span class="mi">14520507</span><span class="p">,</span> <span class="mi">15808945</span><span class="p">,</span> <span class="mi">3244584</span><span class="p">,</span> <span class="mi">4741962</span><span class="p">,</span> <span class="mi">9658130</span><span class="p">,</span>
 <span class="mi">14336147</span><span class="p">,</span> <span class="mi">8654727</span><span class="p">,</span> <span class="mi">7969093</span><span class="p">,</span> <span class="mi">15759799</span><span class="p">,</span> <span class="mi">14029445</span><span class="p">,</span> <span class="mi">5038459</span><span class="p">,</span> <span class="mi">9894848</span><span class="p">,</span> <span class="mi">8659300</span><span class="p">,</span>
 <span class="mi">13699287</span><span class="p">,</span> <span class="mi">8834306</span><span class="p">,</span> <span class="mi">10712885</span><span class="p">,</span> <span class="mi">14753895</span><span class="p">,</span> <span class="mi">10410465</span><span class="p">,</span> <span class="mi">3373251</span><span class="p">,</span> <span class="mi">309501</span><span class="p">,</span> <span class="mi">9561475</span><span class="p">,</span>
 <span class="mi">5526688</span><span class="p">,</span> <span class="mi">14647426</span><span class="p">,</span> <span class="mi">14209836</span><span class="p">,</span> <span class="mi">5339224</span><span class="p">,</span> <span class="mi">207299</span><span class="p">,</span> <span class="mi">14069911</span><span class="p">,</span> <span class="mi">8722990</span><span class="p">,</span> <span class="mi">2290950</span><span class="p">,</span>
 <span class="mi">3258216</span><span class="p">,</span> <span class="mi">12505185</span><span class="p">,</span> <span class="mi">6007317</span><span class="p">,</span> <span class="mi">9218111</span><span class="p">,</span> <span class="mi">14661019</span><span class="p">,</span> <span class="mi">10537428</span><span class="p">,</span> <span class="mi">11731949</span><span class="p">,</span> <span class="mi">9027003</span><span class="p">,</span>
 <span class="mi">6641507</span><span class="p">,</span> <span class="mi">9490160</span><span class="p">,</span> <span class="mi">200241</span><span class="p">,</span> <span class="mi">9720425</span><span class="p">,</span> <span class="mi">16277895</span><span class="p">,</span> <span class="mi">10816638</span><span class="p">,</span> <span class="mi">1554761</span><span class="p">,</span> <span class="mi">10431375</span><span class="p">,</span>
 <span class="mi">7467528</span><span class="p">,</span> <span class="mi">6790302</span><span class="p">,</span> <span class="mi">3429078</span><span class="p">,</span> <span class="mi">14633753</span><span class="p">,</span> <span class="mi">14428997</span><span class="p">,</span> <span class="mi">11463204</span><span class="p">,</span> <span class="mi">3576212</span><span class="p">,</span> <span class="mi">2003426</span><span class="p">,</span>
 <span class="mi">6123687</span><span class="p">,</span> <span class="mi">820520</span><span class="p">,</span> <span class="mi">9992513</span><span class="p">,</span> <span class="mi">15784513</span><span class="p">,</span> <span class="mi">5778891</span><span class="p">,</span> <span class="mi">6428165</span><span class="p">,</span> <span class="mi">8388607</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The hardware uses an LFSR counting sequence to determine when to capture</span>
<span class="cm"> * the SPU PCs.	 An LFSR sequence is like a puesdo random number sequence</span>
<span class="cm"> * where each number occurs once in the sequence but the sequence is not in</span>
<span class="cm"> * numerical order. The SPU PC capture is done when the LFSR sequence reaches</span>
<span class="cm"> * the last value in the sequence.  Hence the user specified value N</span>
<span class="cm"> * corresponds to the LFSR number that is N from the end of the sequence.</span>
<span class="cm"> *</span>
<span class="cm"> * To avoid the time to compute the LFSR, a lookup table is used.  The 24 bit</span>
<span class="cm"> * LFSR sequence is broken into four ranges.  The spacing of the precomputed</span>
<span class="cm"> * values is adjusted in each range so the error between the user specifed</span>
<span class="cm"> * number (N) of events between samples and the actual number of events based</span>
<span class="cm"> * on the precomputed value will be les then about 6.2%.  Note, if the user</span>
<span class="cm"> * specifies N &lt; 2^16, the LFSR value that is 2^16 from the end will be used.</span>
<span class="cm"> * This is to prevent the loss of samples because the trace buffer is full.</span>
<span class="cm"> *</span>
<span class="cm"> *	   User specified N		     Step between	   Index in</span>
<span class="cm"> *					 precomputed values	 precomputed</span>
<span class="cm"> *								    table</span>
<span class="cm"> * 0		    to	2^16-1			----		      0</span>
<span class="cm"> * 2^16	    to	2^16+2^19-1		2^12		    1 to 128</span>
<span class="cm"> * 2^16+2^19	    to	2^16+2^19+2^22-1	2^15		  129 to 256</span>
<span class="cm"> * 2^16+2^19+2^22  to	2^24-1			2^18		  257 to 302</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * For example, the LFSR values in the second range are computed for 2^16,</span>
<span class="cm"> * 2^16+2^12, ... , 2^19-2^16, 2^19 and stored in the table at indicies</span>
<span class="cm"> * 1, 2,..., 127, 128.</span>
<span class="cm"> *</span>
<span class="cm"> * The 24 bit LFSR value for the nth number in the sequence can be</span>
<span class="cm"> * calculated using the following code:</span>
<span class="cm"> *</span>
<span class="cm"> * #define size 24</span>
<span class="cm"> * int calculate_lfsr(int n)</span>
<span class="cm"> * {</span>
<span class="cm"> *	int i;</span>
<span class="cm"> *	unsigned int newlfsr0;</span>
<span class="cm"> *	unsigned int lfsr = 0xFFFFFF;</span>
<span class="cm"> *	unsigned int howmany = n;</span>
<span class="cm"> *</span>
<span class="cm"> *	for (i = 2; i &lt; howmany + 2; i++) {</span>
<span class="cm"> *		newlfsr0 = (((lfsr &gt;&gt; (size - 1 - 0)) &amp; 1) ^</span>
<span class="cm"> *		((lfsr &gt;&gt; (size - 1 - 1)) &amp; 1) ^</span>
<span class="cm"> *		(((lfsr &gt;&gt; (size - 1 - 6)) &amp; 1) ^</span>
<span class="cm"> *		((lfsr &gt;&gt; (size - 1 - 23)) &amp; 1)));</span>
<span class="cm"> *</span>
<span class="cm"> *		lfsr &gt;&gt;= 1;</span>
<span class="cm"> *		lfsr = lfsr | (newlfsr0 &lt;&lt; (size - 1));</span>
<span class="cm"> *	}</span>
<span class="cm"> *	return lfsr;</span>
<span class="cm"> * }</span>
<span class="cm"> */</span>

<span class="cp">#define V2_16  (0x1 &lt;&lt; 16)</span>
<span class="cp">#define V2_19  (0x1 &lt;&lt; 19)</span>
<span class="cp">#define V2_22  (0x1 &lt;&lt; 22)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">calculate_lfsr</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The ranges and steps are in powers of 2 so the calculations</span>
<span class="cm">	 * can be done using shifts rather then divide.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">n</span> <span class="o">-</span> <span class="n">V2_16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">19</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">V2_16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">n</span> <span class="o">-</span> <span class="n">V2_16</span> <span class="o">-</span> <span class="n">V2_19</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">V2_16</span> <span class="o">-</span> <span class="n">V2_19</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">128</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">n</span> <span class="o">-</span> <span class="n">V2_16</span> <span class="o">-</span> <span class="n">V2_19</span> <span class="o">-</span> <span class="n">V2_22</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">V2_16</span> <span class="o">-</span> <span class="n">V2_19</span> <span class="o">-</span> <span class="n">V2_22</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">18</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">256</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">ENTRIES</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* make sure index is valid */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">ENTRIES</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">ENTRIES</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">initial_lfsr</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pm_rtas_activate_spu_profiling</span><span class="p">(</span><span class="n">u32</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pm_signal</span> <span class="n">pm_signal_local</span><span class="p">[</span><span class="n">NUM_SPUS_PER_NODE</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up the rtas call to configure the debug bus to</span>
<span class="cm">	 * route the SPU PCs.  Setup the pm_signal for each SPU</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pm_signal_local</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm_signal_local</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
		<span class="n">pm_signal_local</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">signal_group</span> <span class="o">=</span> <span class="mi">41</span><span class="p">;</span>
		<span class="cm">/* spu i on word (i/2) */</span>
		<span class="n">pm_signal_local</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bus_word</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* spu i */</span>
		<span class="n">pm_signal_local</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sub_unit</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">pm_signal_local</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bit</span> <span class="o">=</span> <span class="mi">63</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rtas_ibm_cbe_perftools</span><span class="p">(</span><span class="n">SUBFUNC_ACTIVATE</span><span class="p">,</span>
				     <span class="n">PASSTHRU_ENABLE</span><span class="p">,</span> <span class="n">pm_signal_local</span><span class="p">,</span>
				     <span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pm_signal_local</span><span class="p">)</span>
				      <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm_signal</span><span class="p">)));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: rtas returned: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CPU_FREQ</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">oprof_cpufreq_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpufreq_freqs</span> <span class="o">*</span><span class="n">frq</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">==</span> <span class="n">CPUFREQ_PRECHANGE</span> <span class="o">&amp;&amp;</span> <span class="n">frq</span><span class="o">-&gt;</span><span class="n">old</span> <span class="o">&lt;</span> <span class="n">frq</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">CPUFREQ_POSTCHANGE</span> <span class="o">&amp;&amp;</span> <span class="n">frq</span><span class="o">-&gt;</span><span class="n">old</span> <span class="o">&gt;</span> <span class="n">frq</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">CPUFREQ_RESUMECHANGE</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="n">CPUFREQ_SUSPENDCHANGE</span><span class="p">))</span>
		<span class="n">set_spu_profiling_frequency</span><span class="p">(</span><span class="n">frq</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">,</span> <span class="n">spu_cycle_reset</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">cpu_freq_notifier_block</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span>	<span class="o">=</span> <span class="n">oprof_cpufreq_notify</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Note the generic OProfile stop calls do not support returning</span>
<span class="cm"> * an error on stop.  Hence, will not return an error if the FW</span>
<span class="cm"> * calls fail on stop.	Failure to reset the debug bus is not an issue.</span>
<span class="cm"> * Failure to disable the SPU profiling is not an issue.  The FW calls</span>
<span class="cm"> * to enable the performance counters and debug bus will work even if</span>
<span class="cm"> * the hardware was not cleanly reset.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_global_stop_spu_cycles</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">subfunc</span><span class="p">,</span> <span class="n">rtn_value</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lfsr_value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">oprofile_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_CPU_FREQ</span>
	<span class="n">cpufreq_unregister_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_freq_notifier_block</span><span class="p">,</span>
				    <span class="n">CPUFREQ_TRANSITION_NOTIFIER</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cbe_get_hw_thread_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">subfunc</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/*</span>
<span class="cm">				 * 2 - activate SPU tracing,</span>
<span class="cm">				 * 3 - deactivate</span>
<span class="cm">				 */</span>
		<span class="n">lfsr_value</span> <span class="o">=</span> <span class="mh">0x8f100000</span><span class="p">;</span>

		<span class="n">rtn_value</span> <span class="o">=</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">spu_rtas_token</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				      <span class="n">subfunc</span><span class="p">,</span> <span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span>
				      <span class="n">lfsr_value</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rtn_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;%s: rtas call ibm,cbe-spu-perftools &quot;</span> \
			       <span class="s">&quot;failed, return = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">rtn_value</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Deactivate the signals */</span>
		<span class="n">pm_rtas_reset_signals</span><span class="p">(</span><span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">stop_spu_profiling_cycles</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_global_stop_spu_events</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">oprofile_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">stop_spu_profiling_events</span><span class="p">();</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cbe_get_hw_thread_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cbe_sync_irq</span><span class="p">(</span><span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="cm">/* Stop the counters */</span>
		<span class="n">cbe_disable_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">cbe_write_pm07_control</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Deactivate the signals */</span>
		<span class="n">pm_rtas_reset_signals</span><span class="p">(</span><span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>

		<span class="cm">/* Deactivate interrupts */</span>
		<span class="n">cbe_disable_pm_interrupts</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer_spu_event_swap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_global_stop_ppu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This routine will be called once for the system.</span>
<span class="cm">	 * There is one performance monitor per node, so we</span>
<span class="cm">	 * only need to perform this function once per node.</span>
<span class="cm">	 */</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer_virt_cntr</span><span class="p">);</span>
	<span class="n">oprofile_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cbe_get_hw_thread_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cbe_sync_irq</span><span class="p">(</span><span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="cm">/* Stop the counters */</span>
		<span class="n">cbe_disable_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

		<span class="cm">/* Deactivate the signals */</span>
		<span class="n">pm_rtas_reset_signals</span><span class="p">(</span><span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>

		<span class="cm">/* Deactivate interrupts */</span>
		<span class="n">cbe_disable_pm_interrupts</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_global_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">profiling_mode</span> <span class="o">==</span> <span class="n">PPU_PROFILING</span><span class="p">)</span>
		<span class="n">cell_global_stop_ppu</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">profiling_mode</span> <span class="o">==</span> <span class="n">SPU_PROFILING_EVENTS</span><span class="p">)</span>
		<span class="n">cell_global_stop_spu_events</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">cell_global_stop_spu_cycles</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cell_global_start_spu_cycles</span><span class="p">(</span><span class="k">struct</span> <span class="n">op_counter_config</span> <span class="o">*</span><span class="n">ctr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">subfunc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lfsr_value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rtas_error</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_khzfreq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The SPU profiling uses time-based profiling based on</span>
<span class="cm">	 * cpu frequency, so if configured with the CPU_FREQ</span>
<span class="cm">	 * option, we should detect frequency changes and react</span>
<span class="cm">	 * accordingly.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_CPU_FREQ</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">cpufreq_register_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_freq_notifier_block</span><span class="p">,</span>
					<span class="n">CPUFREQ_TRANSITION_NOTIFIER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* this is not a fatal error */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;CPU freq change registration failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ret</span><span class="p">);</span>

	<span class="k">else</span>
		<span class="n">cpu_khzfreq</span> <span class="o">=</span> <span class="n">cpufreq_quick_get</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
<span class="cp">#endif</span>

	<span class="n">set_spu_profiling_frequency</span><span class="p">(</span><span class="n">cpu_khzfreq</span><span class="p">,</span> <span class="n">spu_cycle_reset</span><span class="p">);</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cbe_get_hw_thread_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Setup SPU cycle-based profiling.</span>
<span class="cm">		 * Set perf_mon_control bit 0 to a zero before</span>
<span class="cm">		 * enabling spu collection hardware.</span>
<span class="cm">		 */</span>
		<span class="n">cbe_write_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pm_control</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">spu_cycle_reset</span> <span class="o">&gt;</span> <span class="n">MAX_SPU_COUNT</span><span class="p">)</span>
			<span class="cm">/* use largest possible value */</span>
			<span class="n">lfsr_value</span> <span class="o">=</span> <span class="n">calculate_lfsr</span><span class="p">(</span><span class="n">MAX_SPU_COUNT</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">lfsr_value</span> <span class="o">=</span> <span class="n">calculate_lfsr</span><span class="p">(</span><span class="n">spu_cycle_reset</span><span class="p">);</span>

		<span class="cm">/* must use a non zero value. Zero disables data collection. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lfsr_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">lfsr_value</span> <span class="o">=</span> <span class="n">calculate_lfsr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">lfsr_value</span> <span class="o">=</span> <span class="n">lfsr_value</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="cm">/* shift lfsr to correct</span>
<span class="cm">						* register location</span>
<span class="cm">						*/</span>

		<span class="cm">/* debug bus setup */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pm_rtas_activate_spu_profiling</span><span class="p">(</span><span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rtas_error</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>


		<span class="n">subfunc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* 2 - activate SPU tracing, 3 - deactivate */</span>

		<span class="cm">/* start profiling */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">spu_rtas_token</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">subfunc</span><span class="p">,</span>
				<span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">lfsr_value</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;%s: rtas call ibm,cbe-spu-perftools failed, &quot;</span> \
			       <span class="s">&quot;return = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">rtas_error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rtas_error</span> <span class="o">=</span> <span class="n">start_spu_profiling_cycles</span><span class="p">(</span><span class="n">spu_cycle_reset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtas_error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_stop</span><span class="p">;</span>

	<span class="n">oprofile_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_stop:</span>
	<span class="n">cell_global_stop_spu_cycles</span><span class="p">();</span>	<span class="cm">/* clean up the PMU/debug bus */</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rtas_error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cell_global_start_spu_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">op_counter_config</span> <span class="o">*</span><span class="n">ctr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">interrupt_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rtn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hdw_thread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* spu event profiling, uses the performance counters to generate</span>
<span class="cm">	 * an interrupt.  The hardware is setup to store the SPU program</span>
<span class="cm">	 * counter into the trace array.  The occurrence mode is used to</span>
<span class="cm">	 * enable storing data to the trace buffer.  The bits are set</span>
<span class="cm">	 * to send/store the SPU address in the trace buffer.  The debug</span>
<span class="cm">	 * bus must be setup to route the SPU program counter onto the</span>
<span class="cm">	 * debug bus.  The occurrence data in the trace buffer is not used.</span>
<span class="cm">	 */</span>

	<span class="cm">/* This routine gets called once for the system.</span>
<span class="cm">	 * There is one performance monitor per node, so we</span>
<span class="cm">	 * only need to perform this function once per node.</span>
<span class="cm">	 */</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cbe_get_hw_thread_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Setup SPU event-based profiling.</span>
<span class="cm">		 * Set perf_mon_control bit 0 to a zero before</span>
<span class="cm">		 * enabling spu collection hardware.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Only support one SPU event on one SPU per node.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctr_enabled</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cbe_write_ctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reset_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">enable_ctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pm_regs</span><span class="p">.</span><span class="n">pm07_cntrl</span><span class="p">);</span>
			<span class="n">interrupt_mask</span> <span class="o">|=</span>
				<span class="n">CBE_PM_CTR_OVERFLOW_INTR</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Disable counter */</span>
			<span class="n">cbe_write_pm07_control</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">cbe_get_and_clear_pm_interrupts</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">cbe_enable_pm_interrupts</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">hdw_thread</span><span class="p">,</span> <span class="n">interrupt_mask</span><span class="p">);</span>
		<span class="n">cbe_enable_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

		<span class="cm">/* clear the trace buffer */</span>
		<span class="n">cbe_write_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">trace_address</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Start the timer to time slice collecting the event profile</span>
<span class="cm">	 * on each of the SPUs.  Note, can collect profile on one SPU</span>
<span class="cm">	 * per node at a time.</span>
<span class="cm">	 */</span>
	<span class="n">start_spu_event_swap</span><span class="p">();</span>
	<span class="n">start_spu_profiling_events</span><span class="p">();</span>
	<span class="n">oprofile_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">rtn</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cell_global_start_ppu</span><span class="p">(</span><span class="k">struct</span> <span class="n">op_counter_config</span> <span class="o">*</span><span class="n">ctr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">interrupt_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* This routine gets called once for the system.</span>
<span class="cm">	 * There is one performance monitor per node, so we</span>
<span class="cm">	 * only need to perform this function once per node.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cbe_get_hw_thread_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">interrupt_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_counters</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ctr_enabled</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">cbe_write_ctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">reset_value</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">enable_ctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pm_regs</span><span class="p">.</span><span class="n">pm07_cntrl</span><span class="p">);</span>
				<span class="n">interrupt_mask</span> <span class="o">|=</span> <span class="n">CBE_PM_CTR_OVERFLOW_INTR</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Disable counter */</span>
				<span class="n">cbe_write_pm07_control</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">cbe_get_and_clear_pm_interrupts</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">cbe_enable_pm_interrupts</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">hdw_thread</span><span class="p">,</span> <span class="n">interrupt_mask</span><span class="p">);</span>
		<span class="n">cbe_enable_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">virt_cntr_inter_mask</span> <span class="o">=</span> <span class="n">interrupt_mask</span><span class="p">;</span>
	<span class="n">oprofile_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE: start_virt_cntrs will result in cell_virtual_cntr() being</span>
<span class="cm">	 * executed which manipulates the PMU.	We start the &quot;virtual counter&quot;</span>
<span class="cm">	 * here so that we do not need to synchronize access to the PMU in</span>
<span class="cm">	 * the above for-loop.</span>
<span class="cm">	 */</span>
	<span class="n">start_virt_cntrs</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cell_global_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">op_counter_config</span> <span class="o">*</span><span class="n">ctr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">profiling_mode</span> <span class="o">==</span> <span class="n">SPU_PROFILING_CYCLES</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cell_global_start_spu_cycles</span><span class="p">(</span><span class="n">ctr</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">profiling_mode</span> <span class="o">==</span> <span class="n">SPU_PROFILING_EVENTS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cell_global_start_spu_events</span><span class="p">(</span><span class="n">ctr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">cell_global_start_ppu</span><span class="p">(</span><span class="n">ctr</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* The SPU interrupt handler</span>
<span class="cm"> *</span>
<span class="cm"> * SPU event profiling works as follows:</span>
<span class="cm"> * The pm_signal[0] holds the one SPU event to be measured.  It is routed on</span>
<span class="cm"> * the debug bus using word 0 or 1.  The value of pm_signal[1] and</span>
<span class="cm"> * pm_signal[2] contain the necessary events to route the SPU program</span>
<span class="cm"> * counter for the selected SPU onto the debug bus using words 2 and 3.</span>
<span class="cm"> * The pm_interval register is setup to write the SPU PC value into the</span>
<span class="cm"> * trace buffer at the maximum rate possible.  The trace buffer is configured</span>
<span class="cm"> * to store the PCs, wrapping when it is full.  The performance counter is</span>
<span class="cm"> * initialized to the max hardware count minus the number of events, N, between</span>
<span class="cm"> * samples.  Once the N events have occurred, a HW counter overflow occurs</span>
<span class="cm"> * causing the generation of a HW counter interrupt which also stops the</span>
<span class="cm"> * writing of the SPU PC values to the trace buffer.  Hence the last PC</span>
<span class="cm"> * written to the trace buffer is the SPU PC that we want.  Unfortunately,</span>
<span class="cm"> * we have to read from the beginning of the trace buffer to get to the</span>
<span class="cm"> * last value written.  We just hope the PPU has nothing better to do then</span>
<span class="cm"> * service this interrupt. The PC for the specific SPU being profiled is</span>
<span class="cm"> * extracted from the trace buffer processed and stored.  The trace buffer</span>
<span class="cm"> * is cleared, interrupts are cleared, the counter is reset to max - N.</span>
<span class="cm"> * A kernel timer is used to periodically call the routine spu_evnt_swap()</span>
<span class="cm"> * to switch to the next physical SPU in the node to profile in round robbin</span>
<span class="cm"> * order.  This way data is collected for all SPUs on the node. It does mean</span>
<span class="cm"> * that we need to use a relatively small value of N to ensure enough samples</span>
<span class="cm"> * on each SPU are collected each SPU is being profiled 1/8 of the time.</span>
<span class="cm"> * It may also be necessary to use a longer sample collection period.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_handle_interrupt_spu</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">op_counter_config</span> <span class="o">*</span><span class="n">ctr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_tmp</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">trace_entry</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">interrupt_mask</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">trace_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">last_trace_buffer</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sample</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">trace_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sample_array_lock_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">spu_num</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Make sure spu event interrupt handler and spu event swap</span>
<span class="cm">	 * don&#39;t access the counters simultaneously.</span>
<span class="cm">	 */</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cntr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">cpu_tmp</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">cbe_disable_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">interrupt_mask</span> <span class="o">=</span> <span class="n">cbe_get_and_clear_pm_interrupts</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">sample</span> <span class="o">=</span> <span class="mh">0xABCDEF</span><span class="p">;</span>
	<span class="n">trace_entry</span> <span class="o">=</span> <span class="mh">0xfedcba</span><span class="p">;</span>
	<span class="n">last_trace_buffer</span> <span class="o">=</span> <span class="mh">0xdeadbeaf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">oprofile_running</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">interrupt_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* disable writes to trace buff */</span>
		<span class="n">cbe_write_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pm_interval</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* only have one perf cntr being used, cntr 0 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">interrupt_mask</span> <span class="o">&amp;</span> <span class="n">CBE_PM_CTR_OVERFLOW_INTR</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
		    <span class="o">&amp;&amp;</span> <span class="n">ctr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">enabled</span><span class="p">)</span>
			<span class="cm">/* The SPU PC values will be read</span>
<span class="cm">			 * from the trace buffer, reset counter</span>
<span class="cm">			 */</span>

			<span class="n">cbe_write_ctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reset_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="n">trace_addr</span> <span class="o">=</span> <span class="n">cbe_read_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">trace_address</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">trace_addr</span> <span class="o">&amp;</span> <span class="n">CBE_PM_TRACE_BUF_EMPTY</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* There is data in the trace buffer to process</span>
<span class="cm">			 * Read the buffer until you get to the last</span>
<span class="cm">			 * entry.  This is the value we want.</span>
<span class="cm">			 */</span>

			<span class="n">cbe_read_trace_buffer</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">trace_buffer</span><span class="p">);</span>
			<span class="n">trace_addr</span> <span class="o">=</span> <span class="n">cbe_read_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">trace_address</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* SPU Address 16 bit count format for 128 bit</span>
<span class="cm">		 * HW trace buffer is used for the SPU PC storage</span>
<span class="cm">		 *    HDR bits          0:15</span>
<span class="cm">		 *    SPU Addr 0 bits   16:31</span>
<span class="cm">		 *    SPU Addr 1 bits   32:47</span>
<span class="cm">		 *    unused bits       48:127</span>
<span class="cm">		 *</span>
<span class="cm">		 * HDR: bit4 = 1 SPU Address 0 valid</span>
<span class="cm">		 * HDR: bit5 = 1 SPU Address 1 valid</span>
<span class="cm">		 *  - unfortunately, the valid bits don&#39;t seem to work</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note trace_buffer[0] holds bits 0:63 of the HW</span>
<span class="cm">		 * trace buffer, trace_buffer[1] holds bits 64:127</span>
<span class="cm">		 */</span>

		<span class="n">trace_entry</span> <span class="o">=</span> <span class="n">trace_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="o">&amp;</span> <span class="mh">0x00000000FFFF0000</span><span class="p">;</span>

		<span class="cm">/* only top 16 of the 18 bit SPU PC address</span>
<span class="cm">		 * is stored in trace buffer, hence shift right</span>
<span class="cm">		 * by 16 -2 bits */</span>
		<span class="n">sample</span> <span class="o">=</span> <span class="n">trace_entry</span> <span class="o">&gt;&gt;</span> <span class="mi">14</span><span class="p">;</span>
		<span class="n">last_trace_buffer</span> <span class="o">=</span> <span class="n">trace_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="n">spu_num</span> <span class="o">=</span> <span class="n">spu_evnt_phys_spu_indx</span>
			<span class="o">+</span> <span class="p">(</span><span class="n">cbe_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">*</span> <span class="n">NUM_SPUS_PER_NODE</span><span class="p">);</span>

		<span class="cm">/* make sure only one process at a time is calling</span>
<span class="cm">		 * spu_sync_buffer()</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oprof_spu_smpl_arry_lck</span><span class="p">,</span>
				  <span class="n">sample_array_lock_flags</span><span class="p">);</span>
		<span class="n">spu_sync_buffer</span><span class="p">(</span><span class="n">spu_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oprof_spu_smpl_arry_lck</span><span class="p">,</span>
				       <span class="n">sample_array_lock_flags</span><span class="p">);</span>

		<span class="n">smp_wmb</span><span class="p">();</span>    <span class="cm">/* insure spu event buffer updates are written</span>
<span class="cm">			       * don&#39;t want events intermingled... */</span>

		<span class="cm">/* The counters were frozen by the interrupt.</span>
<span class="cm">		 * Reenable the interrupt and restart the counters.</span>
<span class="cm">		 */</span>
		<span class="n">cbe_write_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pm_interval</span><span class="p">,</span> <span class="n">NUM_INTERVAL_CYC</span><span class="p">);</span>
		<span class="n">cbe_enable_pm_interrupts</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">hdw_thread</span><span class="p">,</span>
					 <span class="n">virt_cntr_inter_mask</span><span class="p">);</span>

		<span class="cm">/* clear the trace buffer, re-enable writes to trace buff */</span>
		<span class="n">cbe_write_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">trace_address</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cbe_write_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pm_interval</span><span class="p">,</span> <span class="n">NUM_INTERVAL_CYC</span><span class="p">);</span>

		<span class="cm">/* The writes to the various performance counters only writes</span>
<span class="cm">		 * to a latch.  The new values (interrupt setting bits, reset</span>
<span class="cm">		 * counter value etc.) are not copied to the actual registers</span>
<span class="cm">		 * until the performance monitor is enabled.  In order to get</span>
<span class="cm">		 * this to work as desired, the performance monitor needs to</span>
<span class="cm">		 * be disabled while writing to the latches.  This is a</span>
<span class="cm">		 * HW design issue.</span>
<span class="cm">		 */</span>
		<span class="n">write_pm_cntrl</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">cbe_enable_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cntr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_handle_interrupt_ppu</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">op_counter_config</span> <span class="o">*</span><span class="n">ctr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_kernel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">interrupt_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to make sure the interrupt handler and the virt counter</span>
<span class="cm">	 * routine are not running at the same time. See the</span>
<span class="cm">	 * cell_virtual_cntr() routine for additional comments.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cntr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to disable and reenable the performance counters</span>
<span class="cm">	 * to get the desired behavior from the hardware.  This</span>
<span class="cm">	 * is hardware specific.</span>
<span class="cm">	 */</span>

	<span class="n">cbe_disable_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">interrupt_mask</span> <span class="o">=</span> <span class="n">cbe_get_and_clear_pm_interrupts</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the interrupt mask has been cleared, then the virt cntr</span>
<span class="cm">	 * has cleared the interrupt.  When the thread that generated</span>
<span class="cm">	 * the interrupt is restored, the data count will be restored to</span>
<span class="cm">	 * 0xffffff0 to cause the interrupt to be regenerated.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">oprofile_running</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">interrupt_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pc</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">nip</span><span class="p">;</span>
		<span class="n">is_kernel</span> <span class="o">=</span> <span class="n">is_kernel_addr</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_counters</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">interrupt_mask</span> <span class="o">&amp;</span> <span class="n">CBE_PM_CTR_OVERFLOW_INTR</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
			    <span class="o">&amp;&amp;</span> <span class="n">ctr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">oprofile_add_ext_sample</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_kernel</span><span class="p">);</span>
				<span class="n">cbe_write_ctr</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">reset_value</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The counters were frozen by the interrupt.</span>
<span class="cm">		 * Reenable the interrupt and restart the counters.</span>
<span class="cm">		 * If there was a race between the interrupt handler and</span>
<span class="cm">		 * the virtual counter routine.	 The virtual counter</span>
<span class="cm">		 * routine may have cleared the interrupts.  Hence must</span>
<span class="cm">		 * use the virt_cntr_inter_mask to re-enable the interrupts.</span>
<span class="cm">		 */</span>
		<span class="n">cbe_enable_pm_interrupts</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">hdw_thread</span><span class="p">,</span>
					 <span class="n">virt_cntr_inter_mask</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The writes to the various performance counters only writes</span>
<span class="cm">		 * to a latch.	The new values (interrupt setting bits, reset</span>
<span class="cm">		 * counter value etc.) are not copied to the actual registers</span>
<span class="cm">		 * until the performance monitor is enabled.  In order to get</span>
<span class="cm">		 * this to work as desired, the performance monitor needs to</span>
<span class="cm">		 * be disabled while writing to the latches.  This is a</span>
<span class="cm">		 * HW design issue.</span>
<span class="cm">		 */</span>
		<span class="n">cbe_enable_pm</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cntr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cell_handle_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">op_counter_config</span> <span class="o">*</span><span class="n">ctr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">profiling_mode</span> <span class="o">==</span> <span class="n">PPU_PROFILING</span><span class="p">)</span>
		<span class="n">cell_handle_interrupt_ppu</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">ctr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cell_handle_interrupt_spu</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">ctr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called from the generic OProfile</span>
<span class="cm"> * driver.  When profiling PPUs, we need to do the</span>
<span class="cm"> * generic sync start; otherwise, do spu_sync_start.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cell_sync_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">profiling_mode</span> <span class="o">==</span> <span class="n">SPU_PROFILING_CYCLES</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">profiling_mode</span> <span class="o">==</span> <span class="n">SPU_PROFILING_EVENTS</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">spu_sync_start</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">DO_GENERIC_SYNC</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cell_sync_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">profiling_mode</span> <span class="o">==</span> <span class="n">SPU_PROFILING_CYCLES</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">profiling_mode</span> <span class="o">==</span> <span class="n">SPU_PROFILING_EVENTS</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">spu_sync_stop</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">op_powerpc_model</span> <span class="n">op_model_cell</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">reg_setup</span> <span class="o">=</span> <span class="n">cell_reg_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cpu_setup</span> <span class="o">=</span> <span class="n">cell_cpu_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">global_start</span> <span class="o">=</span> <span class="n">cell_global_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">global_stop</span> <span class="o">=</span> <span class="n">cell_global_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_start</span> <span class="o">=</span> <span class="n">cell_sync_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_stop</span> <span class="o">=</span> <span class="n">cell_sync_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">handle_interrupt</span> <span class="o">=</span> <span class="n">cell_handle_interrupt</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
