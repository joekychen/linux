<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › kvm › book3s_hv.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>book3s_hv.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2011 Paul Mackerras, IBM Corp. &lt;paulus@au1.ibm.com&gt;</span>
<span class="cm"> * Copyright (C) 2009. SUSE Linux Products GmbH. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> *    Paul Mackerras &lt;paulus@au1.ibm.com&gt;</span>
<span class="cm"> *    Alexander Graf &lt;agraf@suse.de&gt;</span>
<span class="cm"> *    Kevin Wolf &lt;mail@kevin-wolf.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Description: KVM functions specific to running on Book 3S</span>
<span class="cm"> * processors in hypervisor mode (specifically POWER7 and later).</span>
<span class="cm"> *</span>
<span class="cm"> * This file is derived from arch/powerpc/kvm/book3s.c,</span>
<span class="cm"> * by Alexander Graf &lt;agraf@suse.de&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License, version 2, as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kvm_host.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/preempt.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/anon_inodes.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/page-flags.h&gt;</span>

<span class="cp">#include &lt;asm/reg.h&gt;</span>
<span class="cp">#include &lt;asm/cputable.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/kvm_ppc.h&gt;</span>
<span class="cp">#include &lt;asm/kvm_book3s.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/lppaca.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/cputhreads.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/hvcall.h&gt;</span>
<span class="cp">#include &lt;asm/switch_to.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>

<span class="cm">/* #define EXIT_DEBUG */</span>
<span class="cm">/* #define EXIT_DEBUG_SIMPLE */</span>
<span class="cm">/* #define EXIT_DEBUG_INT */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">kvmppc_end_cede</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">kvmppc_hv_setup_rma</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvmppc_core_vcpu_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvmppc_vcore</span> <span class="o">*</span><span class="n">vc</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vcore</span><span class="p">;</span>

	<span class="n">local_paca</span><span class="o">-&gt;</span><span class="n">kvm_hstate</span><span class="p">.</span><span class="n">kvm_vcpu</span> <span class="o">=</span> <span class="n">vcpu</span><span class="p">;</span>
	<span class="n">local_paca</span><span class="o">-&gt;</span><span class="n">kvm_hstate</span><span class="p">.</span><span class="n">kvm_vcore</span> <span class="o">=</span> <span class="n">vc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runner</span> <span class="o">==</span> <span class="n">vcpu</span> <span class="o">&amp;&amp;</span> <span class="n">vc</span><span class="o">-&gt;</span><span class="n">vcore_state</span> <span class="o">!=</span> <span class="n">VCORE_INACTIVE</span><span class="p">)</span>
		<span class="n">vc</span><span class="o">-&gt;</span><span class="n">stolen_tb</span> <span class="o">+=</span> <span class="n">mftb</span><span class="p">()</span> <span class="o">-</span> <span class="n">vc</span><span class="o">-&gt;</span><span class="n">preempt_tb</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvmppc_core_vcpu_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvmppc_vcore</span> <span class="o">*</span><span class="n">vc</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vcore</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runner</span> <span class="o">==</span> <span class="n">vcpu</span> <span class="o">&amp;&amp;</span> <span class="n">vc</span><span class="o">-&gt;</span><span class="n">vcore_state</span> <span class="o">!=</span> <span class="n">VCORE_INACTIVE</span><span class="p">)</span>
		<span class="n">vc</span><span class="o">-&gt;</span><span class="n">preempt_tb</span> <span class="o">=</span> <span class="n">mftb</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvmppc_set_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">msr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">.</span><span class="n">msr</span> <span class="o">=</span> <span class="n">msr</span><span class="p">;</span>
	<span class="n">kvmppc_end_cede</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvmppc_set_pvr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pvr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pvr</span> <span class="o">=</span> <span class="n">pvr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvmppc_dump_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;vcpu %p (%d):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">vcpu_id</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;pc  = %.16lx  msr = %.16llx  trap = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pc</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">.</span><span class="n">msr</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">trap</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;r%2d = %.16lx  r%d = %.16lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">r</span><span class="p">,</span> <span class="n">kvmppc_get_gpr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span>
		       <span class="n">r</span><span class="o">+</span><span class="mi">16</span><span class="p">,</span> <span class="n">kvmppc_get_gpr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">r</span><span class="o">+</span><span class="mi">16</span><span class="p">));</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ctr = %.16lx  lr  = %.16lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ctr</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lr</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;srr0 = %.16llx srr1 = %.16llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">.</span><span class="n">srr0</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">.</span><span class="n">srr1</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;sprg0 = %.16llx sprg1 = %.16llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">.</span><span class="n">sprg0</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">.</span><span class="n">sprg1</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;sprg2 = %.16llx sprg3 = %.16llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">.</span><span class="n">sprg2</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">.</span><span class="n">sprg3</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;cr = %.8x  xer = %.16lx  dsisr = %.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cr</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">xer</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">.</span><span class="n">dsisr</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;dar = %.16llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">.</span><span class="n">dar</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;fault dar = %.16lx dsisr = %.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">fault_dar</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">fault_dsisr</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;SLB (%d entries):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb_max</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb_max</span><span class="p">;</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;  ESID = %.16llx VSID = %.16llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">orige</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">origv</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;lpcr = %.16lx sdr1 = %.16lx last_inst = %.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpcr</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">sdr1</span><span class="p">,</span>
	       <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_inst</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="nf">kvmppc_find_vcpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">kvm_for_each_vcpu</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">kvm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">vcpu_id</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_vpa</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lppaca</span> <span class="o">*</span><span class="n">vpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vpa</span><span class="o">-&gt;</span><span class="n">shared_proc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vpa</span><span class="o">-&gt;</span><span class="n">yield_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Length for a per-processor buffer is passed in at offset 4 in the buffer */</span>
<span class="k">struct</span> <span class="n">reg_vpa</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">hword</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">word</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vpa_is_registered</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvmppc_vpa</span> <span class="o">*</span><span class="n">vpap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vpap</span><span class="o">-&gt;</span><span class="n">update_pending</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">vpap</span><span class="o">-&gt;</span><span class="n">next_gpa</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vpap</span><span class="o">-&gt;</span><span class="n">pinned_addr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">do_h_register_vpa</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vcpuid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="n">nb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">tvcpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">subfunc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvmppc_vpa</span> <span class="o">*</span><span class="n">vpap</span><span class="p">;</span>

	<span class="n">tvcpu</span> <span class="o">=</span> <span class="n">kvmppc_find_vcpu</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vcpuid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tvcpu</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">H_PARAMETER</span><span class="p">;</span>

	<span class="n">subfunc</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&gt;&gt;</span> <span class="n">H_VPA_FUNC_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">H_VPA_FUNC_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">subfunc</span> <span class="o">==</span> <span class="n">H_VPA_REG_VPA</span> <span class="o">||</span> <span class="n">subfunc</span> <span class="o">==</span> <span class="n">H_VPA_REG_DTL</span> <span class="o">||</span>
	    <span class="n">subfunc</span> <span class="o">==</span> <span class="n">H_VPA_REG_SLB</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Registering new area - address must be cache-line aligned */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vpa</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">L1_CACHE_BYTES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">||</span> <span class="o">!</span><span class="n">vpa</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">H_PARAMETER</span><span class="p">;</span>

		<span class="cm">/* convert logical addr to kernel addr and read length */</span>
		<span class="n">va</span> <span class="o">=</span> <span class="n">kvmppc_pin_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vpa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">va</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">H_PARAMETER</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">subfunc</span> <span class="o">==</span> <span class="n">H_VPA_REG_VPA</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">reg_vpa</span> <span class="o">*</span><span class="p">)</span><span class="n">va</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">.</span><span class="n">hword</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">len</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">reg_vpa</span> <span class="o">*</span><span class="p">)</span><span class="n">va</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">.</span><span class="n">word</span><span class="p">;</span>
		<span class="n">kvmppc_unpin_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">va</span><span class="p">);</span>

		<span class="cm">/* Check length */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">nb</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">reg_vpa</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">H_PARAMETER</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vpa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">H_PARAMETER</span><span class="p">;</span>
	<span class="n">vpap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tvcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa_update_lock</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">subfunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">H_VPA_REG_VPA</span>:		<span class="cm">/* register VPA */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lppaca</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">vpap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tvcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">H_VPA_REG_DTL</span>:		<span class="cm">/* register DTL */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dtl_entry</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">len</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dtl_entry</span><span class="p">);</span>

		<span class="cm">/* Check that they have previously registered a VPA */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">H_RESOURCE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vpa_is_registered</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tvcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">vpap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tvcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">H_VPA_REG_SLB</span>:		<span class="cm">/* register SLB shadow buffer */</span>
		<span class="cm">/* Check that they have previously registered a VPA */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">H_RESOURCE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vpa_is_registered</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tvcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">vpap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tvcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb_shadow</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">H_VPA_DEREG_VPA</span>:		<span class="cm">/* deregister VPA */</span>
		<span class="cm">/* Check they don&#39;t still have a DTL or SLB buf registered */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">H_RESOURCE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vpa_is_registered</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tvcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">vpa_is_registered</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tvcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb_shadow</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">vpap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tvcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">H_VPA_DEREG_DTL</span>:		<span class="cm">/* deregister DTL */</span>
		<span class="n">vpap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tvcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">H_VPA_DEREG_SLB</span>:		<span class="cm">/* deregister SLB shadow buffer */</span>
		<span class="n">vpap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tvcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb_shadow</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vpap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vpap</span><span class="o">-&gt;</span><span class="n">next_gpa</span> <span class="o">=</span> <span class="n">vpa</span><span class="p">;</span>
		<span class="n">vpap</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">vpap</span><span class="o">-&gt;</span><span class="n">update_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tvcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa_update_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvmppc_update_vpa</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvmppc_vpa</span> <span class="o">*</span><span class="n">vpap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpa</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to pin the page pointed to by vpap-&gt;next_gpa,</span>
<span class="cm">	 * but we can&#39;t call kvmppc_pin_guest_page under the lock</span>
<span class="cm">	 * as it does get_user_pages() and down_read().  So we</span>
<span class="cm">	 * have to drop the lock, pin the page, then get the lock</span>
<span class="cm">	 * again and check that a new area didn&#39;t get registered</span>
<span class="cm">	 * in the meantime.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">gpa</span> <span class="o">=</span> <span class="n">vpap</span><span class="o">-&gt;</span><span class="n">next_gpa</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa_update_lock</span><span class="p">);</span>
		<span class="n">va</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">nb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gpa</span><span class="p">)</span>
			<span class="n">va</span> <span class="o">=</span> <span class="n">kvmppc_pin_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vpap</span><span class="o">-&gt;</span><span class="n">next_gpa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nb</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa_update_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gpa</span> <span class="o">==</span> <span class="n">vpap</span><span class="o">-&gt;</span><span class="n">next_gpa</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* sigh... unpin that one and try again */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">va</span><span class="p">)</span>
			<span class="n">kvmppc_unpin_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">va</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vpap</span><span class="o">-&gt;</span><span class="n">update_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">va</span> <span class="o">&amp;&amp;</span> <span class="n">nb</span> <span class="o">&lt;</span> <span class="n">vpap</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If it&#39;s now too short, it must be that userspace</span>
<span class="cm">		 * has changed the mappings underlying guest memory,</span>
<span class="cm">		 * so unregister the region.</span>
<span class="cm">		 */</span>
		<span class="n">kvmppc_unpin_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">va</span><span class="p">);</span>
		<span class="n">va</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vpap</span><span class="o">-&gt;</span><span class="n">pinned_addr</span><span class="p">)</span>
		<span class="n">kvmppc_unpin_guest_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vpap</span><span class="o">-&gt;</span><span class="n">pinned_addr</span><span class="p">);</span>
	<span class="n">vpap</span><span class="o">-&gt;</span><span class="n">pinned_addr</span> <span class="o">=</span> <span class="n">va</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">va</span><span class="p">)</span>
		<span class="n">vpap</span><span class="o">-&gt;</span><span class="n">pinned_end</span> <span class="o">=</span> <span class="n">va</span> <span class="o">+</span> <span class="n">vpap</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvmppc_update_vpas</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa_update_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa</span><span class="p">.</span><span class="n">update_pending</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvmppc_update_vpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa</span><span class="p">);</span>
		<span class="n">init_vpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa</span><span class="p">.</span><span class="n">pinned_addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl</span><span class="p">.</span><span class="n">update_pending</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvmppc_update_vpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl_ptr</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl</span><span class="p">.</span><span class="n">pinned_addr</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb_shadow</span><span class="p">.</span><span class="n">update_pending</span><span class="p">)</span>
		<span class="n">kvmppc_update_vpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb_shadow</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa_update_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvmppc_create_dtl_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvmppc_vcore</span> <span class="o">*</span><span class="n">vc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dtl_entry</span> <span class="o">*</span><span class="n">dt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lppaca</span> <span class="o">*</span><span class="n">vpa</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_stolen</span><span class="p">;</span>

	<span class="n">dt</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl_ptr</span><span class="p">;</span>
	<span class="n">vpa</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa</span><span class="p">.</span><span class="n">pinned_addr</span><span class="p">;</span>
	<span class="n">old_stolen</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">stolen_logged</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">stolen_logged</span> <span class="o">=</span> <span class="n">vc</span><span class="o">-&gt;</span><span class="n">stolen_tb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dt</span> <span class="o">||</span> <span class="o">!</span><span class="n">vpa</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dtl_entry</span><span class="p">));</span>
	<span class="n">dt</span><span class="o">-&gt;</span><span class="n">dispatch_reason</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">dt</span><span class="o">-&gt;</span><span class="n">processor_id</span> <span class="o">=</span> <span class="n">vc</span><span class="o">-&gt;</span><span class="n">pcpu</span> <span class="o">+</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptid</span><span class="p">;</span>
	<span class="n">dt</span><span class="o">-&gt;</span><span class="n">timebase</span> <span class="o">=</span> <span class="n">mftb</span><span class="p">();</span>
	<span class="n">dt</span><span class="o">-&gt;</span><span class="n">enqueue_to_dispatch_time</span> <span class="o">=</span> <span class="n">vc</span><span class="o">-&gt;</span><span class="n">stolen_tb</span> <span class="o">-</span> <span class="n">old_stolen</span><span class="p">;</span>
	<span class="n">dt</span><span class="o">-&gt;</span><span class="n">srr0</span> <span class="o">=</span> <span class="n">kvmppc_get_pc</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">dt</span><span class="o">-&gt;</span><span class="n">srr1</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">.</span><span class="n">msr</span><span class="p">;</span>
	<span class="o">++</span><span class="n">dt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dt</span> <span class="o">==</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl</span><span class="p">.</span><span class="n">pinned_end</span><span class="p">)</span>
		<span class="n">dt</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl</span><span class="p">.</span><span class="n">pinned_addr</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl_ptr</span> <span class="o">=</span> <span class="n">dt</span><span class="p">;</span>
	<span class="cm">/* order writing *dt vs. writing vpa-&gt;dtl_idx */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">vpa</span><span class="o">-&gt;</span><span class="n">dtl_idx</span> <span class="o">=</span> <span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvmppc_pseries_do_hcall</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">req</span> <span class="o">=</span> <span class="n">kvmppc_get_gpr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">target</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">H_SUCCESS</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">tvcpu</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">H_ENTER</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kvmppc_virtmode_h_enter</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvmppc_get_gpr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
					      <span class="n">kvmppc_get_gpr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
					      <span class="n">kvmppc_get_gpr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
					      <span class="n">kvmppc_get_gpr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">7</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">H_CEDE</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">H_PROD</span>:
		<span class="n">target</span> <span class="o">=</span> <span class="n">kvmppc_get_gpr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">tvcpu</span> <span class="o">=</span> <span class="n">kvmppc_find_vcpu</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tvcpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">H_PARAMETER</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tvcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">prodded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ceded</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
				<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">halt_wakeup</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">H_CONFER</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">H_REGISTER_VPA</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_h_register_vpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvmppc_get_gpr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
					<span class="n">kvmppc_get_gpr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
					<span class="n">kvmppc_get_gpr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">RESUME_HOST</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kvmppc_set_gpr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hcall_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">RESUME_GUEST</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvmppc_handle_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">run</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">RESUME_HOST</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">sum_exits</span><span class="o">++</span><span class="p">;</span>

	<span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_UNKNOWN</span><span class="p">;</span>
	<span class="n">run</span><span class="o">-&gt;</span><span class="n">ready_for_interrupt_injection</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">trap</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* We&#39;re good on these - the host merely wanted to get our attention */</span>
	<span class="k">case</span> <span class="n">BOOK3S_INTERRUPT_HV_DECREMENTER</span>:
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">dec_exits</span><span class="o">++</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">RESUME_GUEST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOOK3S_INTERRUPT_EXTERNAL</span>:
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">ext_intr_exits</span><span class="o">++</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">RESUME_GUEST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOOK3S_INTERRUPT_PERFMON</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">RESUME_GUEST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOOK3S_INTERRUPT_PROGRAM</span>:
	<span class="p">{</span>
		<span class="n">ulong</span> <span class="n">flags</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Normally program interrupts are delivered directly</span>
<span class="cm">		 * to the guest by the hardware, but we can get here</span>
<span class="cm">		 * as a result of a hypervisor emulation interrupt</span>
<span class="cm">		 * (e40) getting turned into a 700 by BML RTAS.</span>
<span class="cm">		 */</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">.</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="mh">0x1f0000ull</span><span class="p">;</span>
		<span class="n">kvmppc_core_queue_program</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">RESUME_GUEST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">BOOK3S_INTERRUPT_SYSCALL</span>:
	<span class="p">{</span>
		<span class="cm">/* hcall - punt to userspace */</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">.</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_PR</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* sc 1 from userspace - reflect to guest syscall */</span>
			<span class="n">kvmppc_book3s_queue_irqprio</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">BOOK3S_INTERRUPT_SYSCALL</span><span class="p">);</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">RESUME_GUEST</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">run</span><span class="o">-&gt;</span><span class="n">papr_hcall</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">kvmppc_get_gpr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">run</span><span class="o">-&gt;</span><span class="n">papr_hcall</span><span class="p">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kvmppc_get_gpr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_PAPR_HCALL</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hcall_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">RESUME_HOST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We get these next two if the guest accesses a page which it thinks</span>
<span class="cm">	 * it has mapped but which is not actually present, either because</span>
<span class="cm">	 * it is for an emulated I/O device or because the corresonding</span>
<span class="cm">	 * host page has been paged out.  Any other HDSI/HISI interrupts</span>
<span class="cm">	 * have been handled already.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">BOOK3S_INTERRUPT_H_DATA_STORAGE</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvmppc_book3s_hv_page_fault</span><span class="p">(</span><span class="n">run</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span>
				<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">fault_dar</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">fault_dsisr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOOK3S_INTERRUPT_H_INST_STORAGE</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvmppc_book3s_hv_page_fault</span><span class="p">(</span><span class="n">run</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span>
				<span class="n">kvmppc_get_pc</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * This occurs if the guest executes an illegal instruction.</span>
<span class="cm">	 * We just generate a program interrupt to the guest, since</span>
<span class="cm">	 * we don&#39;t emulate any guest instructions at this stage.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">BOOK3S_INTERRUPT_H_EMUL_ASSIST</span>:
		<span class="n">kvmppc_core_queue_program</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mh">0x80000</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">RESUME_GUEST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">kvmppc_dump_regs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;trap=0x%x | pc=0x%lx | msr=0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">trap</span><span class="p">,</span> <span class="n">kvmppc_get_pc</span><span class="p">(</span><span class="n">vcpu</span><span class="p">),</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">.</span><span class="n">msr</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">RESUME_HOST</span><span class="p">;</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_get_sregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
                                  <span class="k">struct</span> <span class="n">kvm_sregs</span> <span class="o">*</span><span class="n">sregs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">sregs</span><span class="o">-&gt;</span><span class="n">pvr</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pvr</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">sregs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_sregs</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb_max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sregs</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ppc64</span><span class="p">.</span><span class="n">slb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">slbe</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">orige</span><span class="p">;</span>
		<span class="n">sregs</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ppc64</span><span class="p">.</span><span class="n">slb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">slbv</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">origv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_set_sregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
                                  <span class="k">struct</span> <span class="n">kvm_sregs</span> <span class="o">*</span><span class="n">sregs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">kvmppc_set_pvr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">pvr</span><span class="p">);</span>

	<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb_nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sregs</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ppc64</span><span class="p">.</span><span class="n">slb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">slbe</span> <span class="o">&amp;</span> <span class="n">SLB_ESID_V</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">orige</span> <span class="o">=</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ppc64</span><span class="p">.</span><span class="n">slb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">slbe</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">origv</span> <span class="o">=</span> <span class="n">sregs</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ppc64</span><span class="p">.</span><span class="n">slb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">slbv</span><span class="p">;</span>
			<span class="o">++</span><span class="n">j</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb_max</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_vcpu_ioctl_get_one_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_one_reg</span> <span class="o">*</span><span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_REG_PPC_HIOR</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_vcpu_ioctl_set_one_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_one_reg</span> <span class="o">*</span><span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_REG_PPC_HIOR</span>:
	<span class="p">{</span>
		<span class="n">u64</span> <span class="n">hior</span><span class="p">;</span>
		<span class="cm">/* Only allow this to be set to zero */</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">hior</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hior</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvmppc_core_check_processor_compat</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_HVMODE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="nf">kvmppc_core_vcpu_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">core</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvmppc_vcore</span> <span class="o">*</span><span class="n">vcore</span><span class="p">;</span>

	<span class="n">core</span> <span class="o">=</span> <span class="n">id</span> <span class="o">/</span> <span class="n">threads_per_core</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">core</span> <span class="o">&gt;=</span> <span class="n">KVM_MAX_VCORES</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">vcpu</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">kvm_vcpu_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kvm_vcpu_init</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_vcpu</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shared</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmcr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MMCR0_FC</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ctrl</span> <span class="o">=</span> <span class="n">CTRL_RUNLATCH</span><span class="p">;</span>
	<span class="cm">/* default to host PVR, since we can&#39;t spoof it */</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pvr</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_PVR</span><span class="p">);</span>
	<span class="n">kvmppc_set_pvr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pvr</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa_update_lock</span><span class="p">);</span>

	<span class="n">kvmppc_mmu_book3s_hv_init</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We consider the vcpu stopped until we see the first run ioctl for it.</span>
<span class="cm">	 */</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">KVMPPC_VCPU_STOPPED</span><span class="p">;</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cpu_run</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">vcore</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vcores</span><span class="p">[</span><span class="n">core</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcore</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vcore</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvmppc_vcore</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcore</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcore</span><span class="o">-&gt;</span><span class="n">runnable_threads</span><span class="p">);</span>
			<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcore</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcore</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
			<span class="n">vcore</span><span class="o">-&gt;</span><span class="n">preempt_tb</span> <span class="o">=</span> <span class="n">mftb</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vcores</span><span class="p">[</span><span class="n">core</span><span class="p">]</span> <span class="o">=</span> <span class="n">vcore</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcore</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_vcpu</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcore</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="o">++</span><span class="n">vcore</span><span class="o">-&gt;</span><span class="n">num_threads</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcore</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vcore</span> <span class="o">=</span> <span class="n">vcore</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">stolen_logged</span> <span class="o">=</span> <span class="n">vcore</span><span class="o">-&gt;</span><span class="n">stolen_tb</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cpu_type</span> <span class="o">=</span> <span class="n">KVM_CPU_3S_64</span><span class="p">;</span>
	<span class="n">kvmppc_sanity_check</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">vcpu</span><span class="p">;</span>

<span class="nl">free_vcpu:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">kvm_vcpu_cache</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvmppc_core_vcpu_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa_update_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl</span><span class="p">.</span><span class="n">pinned_addr</span><span class="p">)</span>
		<span class="n">kvmppc_unpin_guest_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl</span><span class="p">.</span><span class="n">pinned_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb_shadow</span><span class="p">.</span><span class="n">pinned_addr</span><span class="p">)</span>
		<span class="n">kvmppc_unpin_guest_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb_shadow</span><span class="p">.</span><span class="n">pinned_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa</span><span class="p">.</span><span class="n">pinned_addr</span><span class="p">)</span>
		<span class="n">kvmppc_unpin_guest_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa</span><span class="p">.</span><span class="n">pinned_addr</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa_update_lock</span><span class="p">);</span>
	<span class="n">kvm_vcpu_uninit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">kvm_vcpu_cache</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvmppc_set_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dec_nsec</span><span class="p">,</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">get_tb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">&gt;</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dec_expires</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* decrementer has already gone negative */</span>
		<span class="n">kvmppc_core_queue_dec</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">kvmppc_core_prepare_to_enter</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dec_nsec</span> <span class="o">=</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dec_expires</span> <span class="o">-</span> <span class="n">now</span><span class="p">)</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span>
		   <span class="o">/</span> <span class="n">tb_ticks_per_sec</span><span class="p">;</span>
	<span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dec_timer</span><span class="p">,</span> <span class="n">ktime_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dec_nsec</span><span class="p">),</span>
		      <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">timer_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvmppc_end_cede</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ceded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">timer_running</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hrtimer_try_to_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dec_timer</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">timer_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__kvmppc_vcore_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">xics_wake_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvmppc_remove_runnable</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvmppc_vcore</span> <span class="o">*</span><span class="n">vc</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">state</span> <span class="o">!=</span> <span class="n">KVMPPC_VCPU_RUNNABLE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">KVMPPC_VCPU_BUSY_IN_HOST</span><span class="p">;</span>
	<span class="o">--</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">n_runnable</span><span class="p">;</span>
	<span class="o">++</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">n_busy</span><span class="p">;</span>
	<span class="cm">/* decrement the physical thread id of each following vcpu */</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">vcpu</span><span class="p">;</span>
	<span class="n">list_for_each_entry_continue</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runnable_threads</span><span class="p">,</span> <span class="n">arch</span><span class="p">.</span><span class="n">run_list</span><span class="p">)</span>
		<span class="o">--</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptid</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">run_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvmppc_grab_hwthread</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">paca_struct</span> <span class="o">*</span><span class="n">tpaca</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="n">tpaca</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">paca</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>

	<span class="cm">/* Ensure the thread won&#39;t go into the kernel if it wakes */</span>
	<span class="n">tpaca</span><span class="o">-&gt;</span><span class="n">kvm_hstate</span><span class="p">.</span><span class="n">hwthread_req</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the thread is already executing in the kernel (e.g. handling</span>
<span class="cm">	 * a stray interrupt), wait for it to get back to nap mode.</span>
<span class="cm">	 * The smp_mb() is to ensure that our setting of hwthread_req</span>
<span class="cm">	 * is visible before we look at hwthread_state, so if this</span>
<span class="cm">	 * races with the code at system_reset_pSeries and the thread</span>
<span class="cm">	 * misses our setting of hwthread_req, we are sure to see its</span>
<span class="cm">	 * setting of hwthread_state, and vice versa.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tpaca</span><span class="o">-&gt;</span><span class="n">kvm_hstate</span><span class="p">.</span><span class="n">hwthread_state</span> <span class="o">==</span> <span class="n">KVM_HWTHREAD_IN_KERNEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">timeout</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;KVM: couldn&#39;t grab cpu %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvmppc_release_hwthread</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">paca_struct</span> <span class="o">*</span><span class="n">tpaca</span><span class="p">;</span>

	<span class="n">tpaca</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">paca</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">tpaca</span><span class="o">-&gt;</span><span class="n">kvm_hstate</span><span class="p">.</span><span class="n">hwthread_req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tpaca</span><span class="o">-&gt;</span><span class="n">kvm_hstate</span><span class="p">.</span><span class="n">kvm_vcpu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvmppc_start_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">paca_struct</span> <span class="o">*</span><span class="n">tpaca</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvmppc_vcore</span> <span class="o">*</span><span class="n">vc</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vcore</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">timer_running</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hrtimer_try_to_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dec_timer</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">timer_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">vc</span><span class="o">-&gt;</span><span class="n">pcpu</span> <span class="o">+</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptid</span><span class="p">;</span>
	<span class="n">tpaca</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">paca</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">tpaca</span><span class="o">-&gt;</span><span class="n">kvm_hstate</span><span class="p">.</span><span class="n">kvm_vcpu</span> <span class="o">=</span> <span class="n">vcpu</span><span class="p">;</span>
	<span class="n">tpaca</span><span class="o">-&gt;</span><span class="n">kvm_hstate</span><span class="p">.</span><span class="n">kvm_vcore</span> <span class="o">=</span> <span class="n">vc</span><span class="p">;</span>
	<span class="n">tpaca</span><span class="o">-&gt;</span><span class="n">kvm_hstate</span><span class="p">.</span><span class="n">napping</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">vc</span><span class="o">-&gt;</span><span class="n">pcpu</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
<span class="cp">#if defined(CONFIG_PPC_ICP_NATIVE) &amp;&amp; defined(CONFIG_SMP)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvmppc_grab_hwthread</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">xics_wake_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="o">++</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">n_woken</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvmppc_wait_for_nap</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvmppc_vcore</span> <span class="o">*</span><span class="n">vc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">HMT_low</span><span class="p">();</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">nap_count</span> <span class="o">&lt;</span> <span class="n">vc</span><span class="o">-&gt;</span><span class="n">n_woken</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1000000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;kvmppc_wait_for_nap timeout %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">vc</span><span class="o">-&gt;</span><span class="n">nap_count</span><span class="p">,</span> <span class="n">vc</span><span class="o">-&gt;</span><span class="n">n_woken</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">HMT_medium</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check that we are on thread 0 and that any other threads in</span>
<span class="cm"> * this core are off-line.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">on_primary_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">thr</span> <span class="o">=</span> <span class="n">cpu_thread_in_core</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">thr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">thr</span> <span class="o">&lt;</span> <span class="n">threads_per_core</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span> <span class="o">+</span> <span class="n">thr</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Run a set of guest threads on a physical core.</span>
<span class="cm"> * Called with vc-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvmppc_run_core</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvmppc_vcore</span> <span class="o">*</span><span class="n">vc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">*</span><span class="n">vcpu0</span><span class="p">,</span> <span class="o">*</span><span class="n">vnext</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ptid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">need_vpa_update</span><span class="p">;</span>

	<span class="cm">/* don&#39;t start if any threads have a signal pending */</span>
	<span class="n">need_vpa_update</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runnable_threads</span><span class="p">,</span> <span class="n">arch</span><span class="p">.</span><span class="n">run_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">run_task</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">need_vpa_update</span> <span class="o">|=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpa</span><span class="p">.</span><span class="n">update_pending</span> <span class="o">|</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slb_shadow</span><span class="p">.</span><span class="n">update_pending</span> <span class="o">|</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtl</span><span class="p">.</span><span class="n">update_pending</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize *vc, in particular vc-&gt;vcore_state, so we can</span>
<span class="cm">	 * drop the vcore lock if necessary.</span>
<span class="cm">	 */</span>
	<span class="n">vc</span><span class="o">-&gt;</span><span class="n">n_woken</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vc</span><span class="o">-&gt;</span><span class="n">nap_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vc</span><span class="o">-&gt;</span><span class="n">entry_exit_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vc</span><span class="o">-&gt;</span><span class="n">vcore_state</span> <span class="o">=</span> <span class="n">VCORE_RUNNING</span><span class="p">;</span>
	<span class="n">vc</span><span class="o">-&gt;</span><span class="n">in_guest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vc</span><span class="o">-&gt;</span><span class="n">napping_threads</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Updating any of the vpas requires calling kvmppc_pin_guest_page,</span>
<span class="cm">	 * which can&#39;t be called with any spinlocks held.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_vpa_update</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runnable_threads</span><span class="p">,</span> <span class="n">arch</span><span class="p">.</span><span class="n">run_list</span><span class="p">)</span>
			<span class="n">kvmppc_update_vpas</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure we are running on thread 0, and that</span>
<span class="cm">	 * secondary threads are offline.</span>
<span class="cm">	 * XXX we should also block attempts to bring any</span>
<span class="cm">	 * secondary threads online.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">threads_per_core</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">on_primary_thread</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runnable_threads</span><span class="p">,</span> <span class="n">arch</span><span class="p">.</span><span class="n">run_list</span><span class="p">)</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Assign physical thread IDs, first to non-ceded vcpus</span>
<span class="cm">	 * and then to ceded ones.</span>
<span class="cm">	 */</span>
	<span class="n">ptid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vcpu0</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runnable_threads</span><span class="p">,</span> <span class="n">arch</span><span class="p">.</span><span class="n">run_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ceded</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptid</span><span class="p">)</span>
				<span class="n">vcpu0</span> <span class="o">=</span> <span class="n">vcpu</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptid</span> <span class="o">=</span> <span class="n">ptid</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* nothing to run */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runnable_threads</span><span class="p">,</span> <span class="n">arch</span><span class="p">.</span><span class="n">run_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ceded</span><span class="p">)</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptid</span> <span class="o">=</span> <span class="n">ptid</span><span class="o">++</span><span class="p">;</span>

	<span class="n">vc</span><span class="o">-&gt;</span><span class="n">stolen_tb</span> <span class="o">+=</span> <span class="n">mftb</span><span class="p">()</span> <span class="o">-</span> <span class="n">vc</span><span class="o">-&gt;</span><span class="n">preempt_tb</span><span class="p">;</span>
	<span class="n">vc</span><span class="o">-&gt;</span><span class="n">pcpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runnable_threads</span><span class="p">,</span> <span class="n">arch</span><span class="p">.</span><span class="n">run_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvmppc_start_thread</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">kvmppc_create_dtl_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Grab any remaining hw threads so they can&#39;t go into the kernel */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ptid</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads_per_core</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">kvmppc_grab_hwthread</span><span class="p">(</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">pcpu</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">kvm_guest_enter</span><span class="p">();</span>
	<span class="n">__kvmppc_vcore_entry</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">vcpu0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads_per_core</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">kvmppc_release_hwthread</span><span class="p">(</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">pcpu</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* disable sending of IPIs on virtual external irqs */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runnable_threads</span><span class="p">,</span> <span class="n">arch</span><span class="p">.</span><span class="n">run_list</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* wait for secondary threads to finish writing their state to memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">nap_count</span> <span class="o">&lt;</span> <span class="n">vc</span><span class="o">-&gt;</span><span class="n">n_woken</span><span class="p">)</span>
		<span class="n">kvmppc_wait_for_nap</span><span class="p">(</span><span class="n">vc</span><span class="p">);</span>
	<span class="cm">/* prevent other vcpu threads from doing kvmppc_start_thread() now */</span>
	<span class="n">vc</span><span class="o">-&gt;</span><span class="n">vcore_state</span> <span class="o">=</span> <span class="n">VCORE_EXITING</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* make sure updates to secondary vcpu structs are visible now */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="n">kvm_guest_exit</span><span class="p">();</span>

	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="n">kvm_resched</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">get_tb</span><span class="p">();</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runnable_threads</span><span class="p">,</span> <span class="n">arch</span><span class="p">.</span><span class="n">run_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* cancel pending dec exception if dec is positive */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">&lt;</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dec_expires</span> <span class="o">&amp;&amp;</span>
		    <span class="n">kvmppc_core_pending_dec</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="n">kvmppc_core_dequeue_dec</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">RESUME_GUEST</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">trap</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">kvmppc_handle_exit</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">kvm_run</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span>
						 <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">run_task</span><span class="p">);</span>

		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">trap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ceded</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">RESUME_GUEST</span><span class="p">)</span>
				<span class="n">kvmppc_end_cede</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">kvmppc_set_timer</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">vc</span><span class="o">-&gt;</span><span class="n">vcore_state</span> <span class="o">=</span> <span class="n">VCORE_INACTIVE</span><span class="p">;</span>
	<span class="n">vc</span><span class="o">-&gt;</span><span class="n">preempt_tb</span> <span class="o">=</span> <span class="n">mftb</span><span class="p">();</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vnext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runnable_threads</span><span class="p">,</span>
				 <span class="n">arch</span><span class="p">.</span><span class="n">run_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">RESUME_GUEST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kvmppc_remove_runnable</span><span class="p">(</span><span class="n">vc</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cpu_run</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for some other vcpu thread to execute us, and</span>
<span class="cm"> * wake us up when we need to handle something in the host.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvmppc_wait_for_exec</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cpu_run</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">wait_state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">KVMPPC_VCPU_RUNNABLE</span><span class="p">)</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cpu_run</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * All the vcpus in this vcore are idle, so wait for a decrementer</span>
<span class="cm"> * or external interrupt to one of the vcpus.  vc-&gt;lock is held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvmppc_vcore_blocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvmppc_vcore</span> <span class="o">*</span><span class="n">vc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">all_idle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">vc</span><span class="o">-&gt;</span><span class="n">vcore_state</span> <span class="o">=</span> <span class="n">VCORE_SLEEPING</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runnable_threads</span><span class="p">,</span> <span class="n">arch</span><span class="p">.</span><span class="n">run_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ceded</span> <span class="o">||</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pending_exceptions</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">all_idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">all_idle</span><span class="p">)</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">vc</span><span class="o">-&gt;</span><span class="n">vcore_state</span> <span class="o">=</span> <span class="n">VCORE_INACTIVE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvmppc_run_vcpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n_ceded</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prev_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvmppc_vcore</span> <span class="o">*</span><span class="n">vc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">vn</span><span class="p">;</span>

	<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ret</span> <span class="o">=</span> <span class="n">RESUME_GUEST</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">trap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Synchronize with other threads in this virtual core</span>
<span class="cm">	 */</span>
	<span class="n">vc</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vcore</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ceded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">run_task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">kvm_run</span> <span class="o">=</span> <span class="n">kvm_run</span><span class="p">;</span>
	<span class="n">prev_state</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">state</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">KVMPPC_VCPU_RUNNABLE</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">run_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runnable_threads</span><span class="p">);</span>
	<span class="o">++</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">n_runnable</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This happens the first time this is called for a vcpu.</span>
<span class="cm">	 * If the vcore is already running, we may be able to start</span>
<span class="cm">	 * this thread straight away and have it join in.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev_state</span> <span class="o">==</span> <span class="n">KVMPPC_VCPU_STOPPED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">vcore_state</span> <span class="o">==</span> <span class="n">VCORE_RUNNING</span> <span class="o">&amp;&amp;</span>
		    <span class="n">VCORE_EXIT_COUNT</span><span class="p">(</span><span class="n">vc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptid</span> <span class="o">=</span> <span class="n">vc</span><span class="o">-&gt;</span><span class="n">n_runnable</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">kvmppc_start_thread</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">prev_state</span> <span class="o">==</span> <span class="n">KVMPPC_VCPU_BUSY_IN_HOST</span><span class="p">)</span>
		<span class="o">--</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">n_busy</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">KVMPPC_VCPU_RUNNABLE</span> <span class="o">&amp;&amp;</span>
	       <span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">n_busy</span> <span class="o">||</span> <span class="n">vc</span><span class="o">-&gt;</span><span class="n">vcore_state</span> <span class="o">!=</span> <span class="n">VCORE_INACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">kvmppc_wait_for_exec</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vc</span><span class="o">-&gt;</span><span class="n">runner</span> <span class="o">=</span> <span class="n">vcpu</span><span class="p">;</span>
		<span class="n">n_ceded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runnable_threads</span><span class="p">,</span> <span class="n">arch</span><span class="p">.</span><span class="n">run_list</span><span class="p">)</span>
			<span class="n">n_ceded</span> <span class="o">+=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ceded</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n_ceded</span> <span class="o">==</span> <span class="n">vc</span><span class="o">-&gt;</span><span class="n">n_runnable</span><span class="p">)</span>
			<span class="n">kvmppc_vcore_blocked</span><span class="p">(</span><span class="n">vc</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">kvmppc_run_core</span><span class="p">(</span><span class="n">vc</span><span class="p">);</span>

		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">vn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">runnable_threads</span><span class="p">,</span>
					 <span class="n">arch</span><span class="p">.</span><span class="n">run_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kvmppc_core_prepare_to_enter</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">run_task</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">kvmppc_remove_runnable</span><span class="p">(</span><span class="n">vc</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
				<span class="n">v</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">signal_exits</span><span class="o">++</span><span class="p">;</span>
				<span class="n">v</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_INTR</span><span class="p">;</span>
				<span class="n">v</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
				<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">cpu_run</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">vc</span><span class="o">-&gt;</span><span class="n">runner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">vcore_state</span> <span class="o">==</span> <span class="n">VCORE_RUNNING</span> <span class="o">||</span>
		    <span class="n">vc</span><span class="o">-&gt;</span><span class="n">vcore_state</span> <span class="o">==</span> <span class="n">VCORE_EXITING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">kvmppc_wait_for_exec</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">KVMPPC_VCPU_RUNNABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kvmppc_remove_runnable</span><span class="p">(</span><span class="n">vc</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">signal_exits</span><span class="o">++</span><span class="p">;</span>
			<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_INTR</span><span class="p">;</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvmppc_vcpu_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">run</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">sane</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_INTERNAL_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kvmppc_core_prepare_to_enter</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="cm">/* No need to go into the guest when all we&#39;ll do is come back out */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_INTR</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* On the first time here, set up VRMA or RMA */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">rma_setup_done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvmppc_hv_setup_rma</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flush_fp_to_thread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">flush_altivec_to_thread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">flush_vsx_to_thread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">wqp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vcore</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">pgdir</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvmppc_run_vcpu</span><span class="p">(</span><span class="n">run</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">==</span> <span class="n">KVM_EXIT_PAPR_HCALL</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">shregs</span><span class="p">.</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">MSR_PR</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">kvmppc_pseries_do_hcall</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="n">kvmppc_core_prepare_to_enter</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">RESUME_GUEST</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Work out RMLS (real mode limit selector) field value for a given RMA size.</span>
<span class="cm">   Assumes POWER7 or PPC970. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">lpcr_rmls</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rma_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">rma_size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">32ul</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span>:	<span class="cm">/* 32 MB */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_ARCH_206</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">8</span><span class="p">;</span>	<span class="cm">/* only supported on POWER7 */</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">64ul</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span>:	<span class="cm">/* 64 MB */</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">128ul</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span>:	<span class="cm">/* 128 MB */</span>
		<span class="k">return</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">256ul</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span>:	<span class="cm">/* 256 MB */</span>
		<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1ul</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span>:		<span class="cm">/* 1 GB */</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">16ul</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span>:	<span class="cm">/* 16 GB */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">256ul</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span>:	<span class="cm">/* 256 GB */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_rma_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvmppc_linear_info</span> <span class="o">*</span><span class="n">ri</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span> <span class="o">&gt;=</span> <span class="n">ri</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">base_pfn</span> <span class="o">+</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span><span class="p">);</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">kvm_rma_vm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span> <span class="o">=</span> <span class="n">kvm_rma_fault</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_rma_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_RESERVED</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kvm_rma_vm_ops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_rma_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvmppc_linear_info</span> <span class="o">*</span><span class="n">ri</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">kvm_release_rma</span><span class="p">(</span><span class="n">ri</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">kvm_rma_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">mmap</span>           <span class="o">=</span> <span class="n">kvm_rma_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">kvm_rma_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">long</span> <span class="nf">kvm_vm_ioctl_allocate_rma</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_allocate_rma</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvmppc_linear_info</span> <span class="o">*</span><span class="n">ri</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">fd</span><span class="p">;</span>

	<span class="n">ri</span> <span class="o">=</span> <span class="n">kvm_alloc_rma</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ri</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">anon_inode_getfd</span><span class="p">(</span><span class="s">&quot;kvm-rma&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm_rma_fops</span><span class="p">,</span> <span class="n">ri</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kvm_release_rma</span><span class="p">(</span><span class="n">ri</span><span class="p">);</span>

	<span class="n">ret</span><span class="o">-&gt;</span><span class="n">rma_size</span> <span class="o">=</span> <span class="n">ri</span><span class="o">-&gt;</span><span class="n">npages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvmppc_add_seg_page_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_ppc_one_seg_page_size</span> <span class="o">**</span><span class="n">sps</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">linux_psize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_psize_def</span> <span class="o">*</span><span class="n">def</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mmu_psize_defs</span><span class="p">[</span><span class="n">linux_psize</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">def</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">sps</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">page_shift</span> <span class="o">=</span> <span class="n">def</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">sps</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">slb_enc</span> <span class="o">=</span> <span class="n">def</span><span class="o">-&gt;</span><span class="n">sllp</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">sps</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">enc</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">page_shift</span> <span class="o">=</span> <span class="n">def</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">sps</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">enc</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pte_enc</span> <span class="o">=</span> <span class="n">def</span><span class="o">-&gt;</span><span class="n">penc</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">sps</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_vm_ioctl_get_smmu_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_ppc_smmu_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_ppc_one_seg_page_size</span> <span class="o">*</span><span class="n">sps</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">KVM_PPC_PAGE_SIZES_REAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_has_feature</span><span class="p">(</span><span class="n">MMU_FTR_1T_SEGMENT</span><span class="p">))</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">KVM_PPC_1T_SEGMENTS</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">slb_size</span> <span class="o">=</span> <span class="n">mmu_slb_size</span><span class="p">;</span>

	<span class="cm">/* We only support these sizes for now, and no muti-size segments */</span>
	<span class="n">sps</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">sps</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">kvmppc_add_seg_page_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sps</span><span class="p">,</span> <span class="n">MMU_PAGE_4K</span><span class="p">);</span>
	<span class="n">kvmppc_add_seg_page_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sps</span><span class="p">,</span> <span class="n">MMU_PAGE_64K</span><span class="p">);</span>
	<span class="n">kvmppc_add_seg_page_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sps</span><span class="p">,</span> <span class="n">MMU_PAGE_16M</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get (and clear) the dirty memory log for a memory slot.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kvm_vm_ioctl_get_dirty_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">KVM_MEMORY_SLOTS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">memslot</span> <span class="o">=</span> <span class="n">id_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">kvm_dirty_bitmap_bytes</span><span class="p">(</span><span class="n">memslot</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvmppc_hv_get_dirty_log</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">memslot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">,</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">slb_pgsize_encoding</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">psize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">senc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">psize</span> <span class="o">&gt;</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">senc</span> <span class="o">=</span> <span class="n">SLB_VSID_L</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">psize</span> <span class="o">==</span> <span class="mh">0x10000</span><span class="p">)</span>
			<span class="n">senc</span> <span class="o">|=</span> <span class="n">SLB_VSID_LP_01</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">senc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvmppc_core_prepare_memory_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">phys</span><span class="p">;</span>

	<span class="cm">/* Allocate a slot_phys array */</span>
	<span class="n">phys</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slot_phys</span><span class="p">[</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">using_mmu_notifiers</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">phys</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">npages</span> <span class="o">=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">memory_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">phys</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">npages</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phys</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slot_phys</span><span class="p">[</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">phys</span><span class="p">;</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slot_npages</span><span class="p">[</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">npages</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unpin_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">physp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">,</span> <span class="n">npages</span><span class="p">,</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">physp</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slot_phys</span><span class="p">[</span><span class="n">slot_id</span><span class="p">];</span>
	<span class="n">npages</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slot_npages</span><span class="p">[</span><span class="n">slot_id</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">physp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slot_phys_lock</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">physp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">KVMPPC_GOT_PAGE</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">pfn</span> <span class="o">=</span> <span class="n">physp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
			<span class="n">SetPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slot_phys</span><span class="p">[</span><span class="n">slot_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slot_phys_lock</span><span class="p">);</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">physp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvmppc_core_commit_memory_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvmppc_hv_setup_rma</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvmppc_linear_info</span> <span class="o">*</span><span class="n">ri</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hva</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lpcr</span><span class="p">,</span> <span class="n">senc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">psize</span><span class="p">,</span> <span class="n">porder</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rma_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rmls</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">physp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">npages</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">rma_setup_done</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>	<span class="cm">/* another vcpu beat us to it */</span>

	<span class="cm">/* Look up the memslot for guest physical address 0 */</span>
	<span class="n">memslot</span> <span class="o">=</span> <span class="n">gfn_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* We must have some memory at 0 by now */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memslot</span> <span class="o">||</span> <span class="p">(</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KVM_MEMSLOT_INVALID</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Look up the VMA for the start of this memory slot */</span>
	<span class="n">hva</span> <span class="o">=</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">userspace_addr</span><span class="p">;</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">hva</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;</span> <span class="n">hva</span> <span class="o">||</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_IO</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">up_out</span><span class="p">;</span>

	<span class="n">psize</span> <span class="o">=</span> <span class="n">vma_kernel_pagesize</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="n">porder</span> <span class="o">=</span> <span class="n">__ilog2</span><span class="p">(</span><span class="n">psize</span><span class="p">);</span>

	<span class="cm">/* Is this one of our preallocated RMAs? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">kvm_rma_fops</span> <span class="o">&amp;&amp;</span>
	    <span class="n">hva</span> <span class="o">==</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
		<span class="n">ri</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ri</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* On POWER7, use VRMA; on PPC970, give up */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_ARCH_201</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;KVM: CPU requires an RMO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* We can handle 4k, 64k or 16M pages in the VRMA */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">psize</span> <span class="o">==</span> <span class="mh">0x1000</span> <span class="o">||</span> <span class="n">psize</span> <span class="o">==</span> <span class="mh">0x10000</span> <span class="o">||</span>
		      <span class="n">psize</span> <span class="o">==</span> <span class="mh">0x1000000</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* Update VRMASD field in the LPCR */</span>
		<span class="n">senc</span> <span class="o">=</span> <span class="n">slb_pgsize_encoding</span><span class="p">(</span><span class="n">psize</span><span class="p">);</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vrma_slb_v</span> <span class="o">=</span> <span class="n">senc</span> <span class="o">|</span> <span class="n">SLB_VSID_B_1T</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">VRMA_VSID</span> <span class="o">&lt;&lt;</span> <span class="n">SLB_VSID_SHIFT_1T</span><span class="p">);</span>
		<span class="n">lpcr</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpcr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">LPCR_VRMASD</span><span class="p">;</span>
		<span class="n">lpcr</span> <span class="o">|=</span> <span class="n">senc</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">LPCR_VRMASD_SH</span> <span class="o">-</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpcr</span> <span class="o">=</span> <span class="n">lpcr</span><span class="p">;</span>

		<span class="cm">/* Create HPTEs in the hash page table for the VRMA */</span>
		<span class="n">kvmppc_map_vrma</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">memslot</span><span class="p">,</span> <span class="n">porder</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Set up to use an RMO region */</span>
		<span class="n">rma_size</span> <span class="o">=</span> <span class="n">ri</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rma_size</span> <span class="o">&gt;</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">)</span>
			<span class="n">rma_size</span> <span class="o">=</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">;</span>
		<span class="n">rma_size</span> <span class="o">&lt;&lt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">rmls</span> <span class="o">=</span> <span class="n">lpcr_rmls</span><span class="p">(</span><span class="n">rma_size</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rmls</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;KVM: Can&#39;t use RMA of 0x%lx bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rma_size</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">);</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">rma</span> <span class="o">=</span> <span class="n">ri</span><span class="p">;</span>

		<span class="cm">/* Update LPCR and RMOR */</span>
		<span class="n">lpcr</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpcr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_ARCH_201</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* PPC970; insert RMLS value (split field) in HID4 */</span>
			<span class="n">lpcr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1ul</span> <span class="o">&lt;&lt;</span> <span class="n">HID4_RMLS0_SH</span><span class="p">)</span> <span class="o">|</span>
				  <span class="p">(</span><span class="mi">3ul</span> <span class="o">&lt;&lt;</span> <span class="n">HID4_RMLS2_SH</span><span class="p">));</span>
			<span class="n">lpcr</span> <span class="o">|=</span> <span class="p">((</span><span class="n">rmls</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">HID4_RMLS0_SH</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">((</span><span class="n">rmls</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">HID4_RMLS2_SH</span><span class="p">);</span>
			<span class="cm">/* RMOR is also in HID4 */</span>
			<span class="n">lpcr</span> <span class="o">|=</span> <span class="p">((</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">base_pfn</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">26</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span>
				<span class="o">&lt;&lt;</span> <span class="n">HID4_RMOR_SH</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* POWER7 */</span>
			<span class="n">lpcr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">LPCR_VPM0</span> <span class="o">|</span> <span class="n">LPCR_VRMA_L</span><span class="p">);</span>
			<span class="n">lpcr</span> <span class="o">|=</span> <span class="n">rmls</span> <span class="o">&lt;&lt;</span> <span class="n">LPCR_RMLS_SH</span><span class="p">;</span>
			<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">rmor</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">rma</span><span class="o">-&gt;</span><span class="n">base_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpcr</span> <span class="o">=</span> <span class="n">lpcr</span><span class="p">;</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;KVM: Using RMO at %lx size %lx (LPCR = %lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ri</span><span class="o">-&gt;</span><span class="n">base_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">rma_size</span><span class="p">,</span> <span class="n">lpcr</span><span class="p">);</span>

		<span class="cm">/* Initialize phys addrs of pages in RMO */</span>
		<span class="n">npages</span> <span class="o">=</span> <span class="n">ri</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">;</span>
		<span class="n">porder</span> <span class="o">=</span> <span class="n">__ilog2</span><span class="p">(</span><span class="n">npages</span><span class="p">);</span>
		<span class="n">physp</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slot_phys</span><span class="p">[</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slot_phys_lock</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">physp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">base_pfn</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">porder</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slot_phys_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Order updates to kvm-&gt;arch.lpcr etc. vs. rma_setup_done */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">rma_setup_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

 <span class="nl">up_out:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvmppc_core_init_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lpcr</span><span class="p">;</span>

	<span class="cm">/* Allocate hashed page table */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvmppc_alloc_hpt</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">spapr_tce_tables</span><span class="p">);</span>

	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">rma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">host_sdr1</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_SDR1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_ARCH_201</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* PPC970; HID4 is effectively the LPCR */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lpid</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpid</span><span class="p">;</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">host_lpid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">host_lpcr</span> <span class="o">=</span> <span class="n">lpcr</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_HID4</span><span class="p">);</span>
		<span class="n">lpcr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">HID4_LPID1_SH</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xful</span> <span class="o">&lt;&lt;</span> <span class="n">HID4_LPID5_SH</span><span class="p">));</span>
		<span class="n">lpcr</span> <span class="o">|=</span> <span class="p">((</span><span class="n">lpid</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">HID4_LPID1_SH</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">((</span><span class="n">lpid</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">HID4_LPID5_SH</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* POWER7; init LPCR for virtual RMA mode */</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">host_lpid</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_LPID</span><span class="p">);</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">host_lpcr</span> <span class="o">=</span> <span class="n">lpcr</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_LPCR</span><span class="p">);</span>
		<span class="n">lpcr</span> <span class="o">&amp;=</span> <span class="n">LPCR_PECE</span> <span class="o">|</span> <span class="n">LPCR_LPES</span><span class="p">;</span>
		<span class="n">lpcr</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">4UL</span> <span class="o">&lt;&lt;</span> <span class="n">LPCR_DPFD_SH</span><span class="p">)</span> <span class="o">|</span> <span class="n">LPCR_HDICE</span> <span class="o">|</span>
			<span class="n">LPCR_VPM0</span> <span class="o">|</span> <span class="n">LPCR_VPM1</span><span class="p">;</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vrma_slb_v</span> <span class="o">=</span> <span class="n">SLB_VSID_B_1T</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">VRMA_VSID</span> <span class="o">&lt;&lt;</span> <span class="n">SLB_VSID_SHIFT_1T</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpcr</span> <span class="o">=</span> <span class="n">lpcr</span><span class="p">;</span>

	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">using_mmu_notifiers</span> <span class="o">=</span> <span class="o">!!</span><span class="n">cpu_has_feature</span><span class="p">(</span><span class="n">CPU_FTR_ARCH_206</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">slot_phys_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvmppc_core_destroy_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">using_mmu_notifiers</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_MEM_SLOTS_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">unpin_slot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">rma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_release_rma</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">rma</span><span class="p">);</span>
		<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">rma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kvmppc_free_hpt</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">spapr_tce_tables</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* These are stubs for now */</span>
<span class="kt">void</span> <span class="nf">kvmppc_mmu_pte_pflush</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ulong</span> <span class="n">pa_start</span><span class="p">,</span> <span class="n">ulong</span> <span class="n">pa_end</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/* We don&#39;t need to emulate any privileged instructions or dcbz */</span>
<span class="kt">int</span> <span class="nf">kvmppc_core_emulate_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">run</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
                           <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inst</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">advance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">EMULATE_FAIL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvmppc_core_emulate_mtspr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sprn</span><span class="p">,</span> <span class="n">ulong</span> <span class="n">spr_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">EMULATE_FAIL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvmppc_core_emulate_mfspr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sprn</span><span class="p">,</span> <span class="n">ulong</span> <span class="o">*</span><span class="n">spr_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">EMULATE_FAIL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvmppc_book3s_hv_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_init</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">THIS_MODULE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvmppc_mmu_hv_init</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvmppc_book3s_hv_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">kvmppc_book3s_hv_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">kvmppc_book3s_hv_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
