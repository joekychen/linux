<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › net › bpf_jit_comp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>bpf_jit_comp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* bpf_jit_comp.c: BPF JIT compiler for PPC64</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2011 Matt Evans &lt;matt@ozlabs.org&gt;, IBM Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Based on the x86 BPF compiler, by Eric Dumazet (eric.dumazet@gmail.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; version 2</span>
<span class="cm"> * of the License.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/moduleloader.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/filter.h&gt;</span>
<span class="cp">#include &quot;bpf_jit.h&quot;</span>

<span class="cp">#ifndef __BIG_ENDIAN</span>
<span class="cm">/* There are endianness assumptions herein. */</span>
<span class="cp">#error &quot;Little-endian PPC not supported in BPF compiler&quot;</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">bpf_jit_enable</span> <span class="n">__read_mostly</span><span class="p">;</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bpf_flush_icache</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bpf_jit_build_prologue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_filter</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">codegen_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sock_filter</span> <span class="o">*</span><span class="n">filter</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SEEN_MEM</span> <span class="o">|</span> <span class="n">SEEN_DATAREF</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Make stackframe */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">&amp;</span> <span class="n">SEEN_DATAREF</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If we call any helpers (for loads), save LR */</span>
			<span class="n">EMIT</span><span class="p">(</span><span class="n">PPC_INST_MFLR</span> <span class="o">|</span> <span class="n">__PPC_RT</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
			<span class="n">PPC_STD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

			<span class="cm">/* Back up non-volatile regs. */</span>
			<span class="n">PPC_STD</span><span class="p">(</span><span class="n">r_D</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">r_D</span><span class="p">)));</span>
			<span class="n">PPC_STD</span><span class="p">(</span><span class="n">r_HL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">r_HL</span><span class="p">)));</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">&amp;</span> <span class="n">SEEN_MEM</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Conditionally save regs r15-r31 as some will be used</span>
<span class="cm">			 * for M[] data.</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">r_M</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">r_M</span><span class="o">+</span><span class="mi">16</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">r_M</span><span class="p">)))</span>
					<span class="n">PPC_STD</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">i</span><span class="p">)));</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">EMIT</span><span class="p">(</span><span class="n">PPC_INST_STDU</span> <span class="o">|</span> <span class="n">__PPC_RS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">__PPC_RA</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
		     <span class="p">(</span><span class="o">-</span><span class="n">BPF_PPC_STACKFRAME</span> <span class="o">&amp;</span> <span class="mh">0xfffc</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">&amp;</span> <span class="n">SEEN_DATAREF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this filter needs to access skb data,</span>
<span class="cm">		 * prepare r_D and r_HL:</span>
<span class="cm">		 *  r_HL = skb-&gt;len - skb-&gt;data_len</span>
<span class="cm">		 *  r_D	 = skb-&gt;data</span>
<span class="cm">		 */</span>
		<span class="n">PPC_LWZ_OFFS</span><span class="p">(</span><span class="n">r_scratch1</span><span class="p">,</span> <span class="n">r_skb</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span>
							 <span class="n">data_len</span><span class="p">));</span>
		<span class="n">PPC_LWZ_OFFS</span><span class="p">(</span><span class="n">r_HL</span><span class="p">,</span> <span class="n">r_skb</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">len</span><span class="p">));</span>
		<span class="n">PPC_SUB</span><span class="p">(</span><span class="n">r_HL</span><span class="p">,</span> <span class="n">r_HL</span><span class="p">,</span> <span class="n">r_scratch1</span><span class="p">);</span>
		<span class="n">PPC_LD_OFFS</span><span class="p">(</span><span class="n">r_D</span><span class="p">,</span> <span class="n">r_skb</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">data</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">&amp;</span> <span class="n">SEEN_XREG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * TODO: Could also detect whether first instr. sets X and</span>
<span class="cm">		 * avoid this (as below, with A).</span>
<span class="cm">		 */</span>
		<span class="n">PPC_LI</span><span class="p">(</span><span class="n">r_X</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BPF_S_RET_K</span>:
	<span class="k">case</span> <span class="n">BPF_S_LD_W_LEN</span>:
	<span class="k">case</span> <span class="n">BPF_S_ANC_PROTOCOL</span>:
	<span class="k">case</span> <span class="n">BPF_S_ANC_IFINDEX</span>:
	<span class="k">case</span> <span class="n">BPF_S_ANC_MARK</span>:
	<span class="k">case</span> <span class="n">BPF_S_ANC_RXHASH</span>:
	<span class="k">case</span> <span class="n">BPF_S_ANC_CPU</span>:
	<span class="k">case</span> <span class="n">BPF_S_ANC_QUEUE</span>:
	<span class="k">case</span> <span class="n">BPF_S_LD_W_ABS</span>:
	<span class="k">case</span> <span class="n">BPF_S_LD_H_ABS</span>:
	<span class="k">case</span> <span class="n">BPF_S_LD_B_ABS</span>:
		<span class="cm">/* first instruction sets A register (or is RET &#39;constant&#39;) */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* make sure we dont leak kernel information to user */</span>
		<span class="n">PPC_LI</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bpf_jit_build_epilogue</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="k">struct</span> <span class="n">codegen_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SEEN_MEM</span> <span class="o">|</span> <span class="n">SEEN_DATAREF</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PPC_ADDI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">BPF_PPC_STACKFRAME</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">&amp;</span> <span class="n">SEEN_DATAREF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PPC_LD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">PPC_MTLR</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">PPC_LD</span><span class="p">(</span><span class="n">r_D</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">r_D</span><span class="p">)));</span>
			<span class="n">PPC_LD</span><span class="p">(</span><span class="n">r_HL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">r_HL</span><span class="p">)));</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">&amp;</span> <span class="n">SEEN_MEM</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Restore any saved non-vol registers */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">r_M</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">r_M</span><span class="o">+</span><span class="mi">16</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">r_M</span><span class="p">)))</span>
					<span class="n">PPC_LD</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">i</span><span class="p">)));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* The RETs have left a return value in R3. */</span>

	<span class="n">PPC_BLR</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#define CHOOSE_LOAD_FUNC(K, func) \</span>
<span class="cp">	((int)K &lt; 0 ? ((int)K &gt;= SKF_LL_OFF ? func##_negative_offset : func) : func##_positive_offset)</span>

<span class="cm">/* Assemble the body code between the prologue &amp; epilogue. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bpf_jit_build_body</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_filter</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">codegen_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">addrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sock_filter</span> <span class="o">*</span><span class="n">filter</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flen</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">func</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">true_cond</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Start of epilogue code */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">exit_addr</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">[</span><span class="n">flen</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">flen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">k</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * addrs[] maps a BPF bytecode address into a real offset from</span>
<span class="cm">		 * the start of the body code.</span>
<span class="cm">		 */</span>
		<span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*** ALU ops ***/</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_ADD_X</span>: <span class="cm">/* A += X; */</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
			<span class="n">PPC_ADD</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_ADD_K</span>: <span class="cm">/* A += K; */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">K</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">PPC_ADDI</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">IMM_L</span><span class="p">(</span><span class="n">K</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">K</span> <span class="o">&gt;=</span> <span class="mi">32768</span><span class="p">)</span>
				<span class="n">PPC_ADDIS</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">IMM_HA</span><span class="p">(</span><span class="n">K</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_SUB_X</span>: <span class="cm">/* A -= X; */</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
			<span class="n">PPC_SUB</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_SUB_K</span>: <span class="cm">/* A -= K */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">K</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">PPC_ADDI</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">IMM_L</span><span class="p">(</span><span class="o">-</span><span class="n">K</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">K</span> <span class="o">&gt;=</span> <span class="mi">32768</span><span class="p">)</span>
				<span class="n">PPC_ADDIS</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">IMM_HA</span><span class="p">(</span><span class="o">-</span><span class="n">K</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_MUL_X</span>: <span class="cm">/* A *= X; */</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
			<span class="n">PPC_MUL</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_MUL_K</span>: <span class="cm">/* A *= K */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">K</span> <span class="o">&lt;</span> <span class="mi">32768</span><span class="p">)</span>
				<span class="n">PPC_MULI</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">PPC_LI32</span><span class="p">(</span><span class="n">r_scratch1</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
				<span class="n">PPC_MUL</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">r_scratch1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_DIV_X</span>: <span class="cm">/* A /= X; */</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
			<span class="n">PPC_CMPWI</span><span class="p">(</span><span class="n">r_X</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pc_ret0</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">PPC_BCC</span><span class="p">(</span><span class="n">COND_EQ</span><span class="p">,</span> <span class="n">addrs</span><span class="p">[</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pc_ret0</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Exit, returning 0; first pass hits here</span>
<span class="cm">				 * (longer worst-case code size).</span>
<span class="cm">				 */</span>
				<span class="n">PPC_BCC_SHORT</span><span class="p">(</span><span class="n">COND_NE</span><span class="p">,</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">12</span><span class="p">);</span>
				<span class="n">PPC_LI</span><span class="p">(</span><span class="n">r_ret</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">PPC_JMP</span><span class="p">(</span><span class="n">exit_addr</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">PPC_DIVWU</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_DIV_K</span>: <span class="cm">/* A = reciprocal_divide(A, K); */</span>
			<span class="n">PPC_LI32</span><span class="p">(</span><span class="n">r_scratch1</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
			<span class="cm">/* Top 32 bits of 64bit result -&gt; A */</span>
			<span class="n">PPC_MULHWU</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">r_scratch1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_AND_X</span>:
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
			<span class="n">PPC_AND</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_AND_K</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IMM_H</span><span class="p">(</span><span class="n">K</span><span class="p">))</span>
				<span class="n">PPC_ANDI</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">PPC_LI32</span><span class="p">(</span><span class="n">r_scratch1</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
				<span class="n">PPC_AND</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">r_scratch1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_OR_X</span>:
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
			<span class="n">PPC_OR</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_OR_K</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">IMM_L</span><span class="p">(</span><span class="n">K</span><span class="p">))</span>
				<span class="n">PPC_ORI</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">IMM_L</span><span class="p">(</span><span class="n">K</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">K</span> <span class="o">&gt;=</span> <span class="mi">65536</span><span class="p">)</span>
				<span class="n">PPC_ORIS</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">IMM_H</span><span class="p">(</span><span class="n">K</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_LSH_X</span>: <span class="cm">/* A &lt;&lt;= X; */</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
			<span class="n">PPC_SLW</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_LSH_K</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">K</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">PPC_SLWI</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_RSH_X</span>: <span class="cm">/* A &gt;&gt;= X; */</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
			<span class="n">PPC_SRW</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_RSH_K</span>: <span class="cm">/* A &gt;&gt;= K; */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">K</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">PPC_SRWI</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ALU_NEG</span>:
			<span class="n">PPC_NEG</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_RET_K</span>:
			<span class="n">PPC_LI32</span><span class="p">(</span><span class="n">r_ret</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">K</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pc_ret0</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
					<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pc_ret0</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * If this isn&#39;t the very last instruction, branch to</span>
<span class="cm">			 * the epilogue if we&#39;ve stuff to clean up.  Otherwise,</span>
<span class="cm">			 * if there&#39;s nothing to tidy, just return.  If we /are/</span>
<span class="cm">			 * the last instruction, we&#39;re about to fall through to</span>
<span class="cm">			 * the epilogue to return.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">flen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Note: &#39;seen&#39; is properly valid only on pass</span>
<span class="cm">				 * #2.	Both parts of this conditional are the</span>
<span class="cm">				 * same instruction size though, meaning the</span>
<span class="cm">				 * first pass will still correctly determine the</span>
<span class="cm">				 * code size/addresses.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span><span class="p">)</span>
					<span class="n">PPC_JMP</span><span class="p">(</span><span class="n">exit_addr</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">PPC_BLR</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_RET_A</span>:
			<span class="n">PPC_MR</span><span class="p">(</span><span class="n">r_ret</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">flen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span><span class="p">)</span>
					<span class="n">PPC_JMP</span><span class="p">(</span><span class="n">exit_addr</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">PPC_BLR</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_MISC_TAX</span>: <span class="cm">/* X = A */</span>
			<span class="n">PPC_MR</span><span class="p">(</span><span class="n">r_X</span><span class="p">,</span> <span class="n">r_A</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_MISC_TXA</span>: <span class="cm">/* A = X */</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
			<span class="n">PPC_MR</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

			<span class="cm">/*** Constant loads/M[] access ***/</span>
		<span class="k">case</span> <span class="n">BPF_S_LD_IMM</span>: <span class="cm">/* A = K */</span>
			<span class="n">PPC_LI32</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_LDX_IMM</span>: <span class="cm">/* X = K */</span>
			<span class="n">PPC_LI32</span><span class="p">(</span><span class="n">r_X</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_LD_MEM</span>: <span class="cm">/* A = mem[K] */</span>
			<span class="n">PPC_MR</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_M</span> <span class="o">+</span> <span class="p">(</span><span class="n">K</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_MEM</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">K</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_LDX_MEM</span>: <span class="cm">/* X = mem[K] */</span>
			<span class="n">PPC_MR</span><span class="p">(</span><span class="n">r_X</span><span class="p">,</span> <span class="n">r_M</span> <span class="o">+</span> <span class="p">(</span><span class="n">K</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_MEM</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">K</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ST</span>: <span class="cm">/* mem[K] = A */</span>
			<span class="n">PPC_MR</span><span class="p">(</span><span class="n">r_M</span> <span class="o">+</span> <span class="p">(</span><span class="n">K</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">),</span> <span class="n">r_A</span><span class="p">);</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_MEM</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">K</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_STX</span>: <span class="cm">/* mem[K] = X */</span>
			<span class="n">PPC_MR</span><span class="p">(</span><span class="n">r_M</span> <span class="o">+</span> <span class="p">(</span><span class="n">K</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">),</span> <span class="n">r_X</span><span class="p">);</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span> <span class="o">|</span> <span class="n">SEEN_MEM</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">K</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_LD_W_LEN</span>: <span class="cm">/*	A = skb-&gt;len; */</span>
			<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">FIELD_SIZEOF</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">);</span>
			<span class="n">PPC_LWZ_OFFS</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_skb</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">len</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_LDX_W_LEN</span>: <span class="cm">/* X = skb-&gt;len; */</span>
			<span class="n">PPC_LWZ_OFFS</span><span class="p">(</span><span class="n">r_X</span><span class="p">,</span> <span class="n">r_skb</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">len</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>

			<span class="cm">/*** Ancillary info loads ***/</span>

			<span class="cm">/* None of the BPF_S_ANC* codes appear to be passed by</span>
<span class="cm">			 * sk_chk_filter().  The interpreter and the x86 BPF</span>
<span class="cm">			 * compiler implement them so we do too -- they may be</span>
<span class="cm">			 * planted in future.</span>
<span class="cm">			 */</span>
		<span class="k">case</span> <span class="n">BPF_S_ANC_PROTOCOL</span>: <span class="cm">/* A = ntohs(skb-&gt;protocol); */</span>
			<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">FIELD_SIZEOF</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span>
						  <span class="n">protocol</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">PPC_LHZ_OFFS</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_skb</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span>
							  <span class="n">protocol</span><span class="p">));</span>
			<span class="cm">/* ntohs is a NOP with BE loads. */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ANC_IFINDEX</span>:
			<span class="n">PPC_LD_OFFS</span><span class="p">(</span><span class="n">r_scratch1</span><span class="p">,</span> <span class="n">r_skb</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span>
								<span class="n">dev</span><span class="p">));</span>
			<span class="n">PPC_CMPDI</span><span class="p">(</span><span class="n">r_scratch1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pc_ret0</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">PPC_BCC</span><span class="p">(</span><span class="n">COND_EQ</span><span class="p">,</span> <span class="n">addrs</span><span class="p">[</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pc_ret0</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Exit, returning 0; first pass hits here. */</span>
				<span class="n">PPC_BCC_SHORT</span><span class="p">(</span><span class="n">COND_NE</span><span class="p">,</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">12</span><span class="p">);</span>
				<span class="n">PPC_LI</span><span class="p">(</span><span class="n">r_ret</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">PPC_JMP</span><span class="p">(</span><span class="n">exit_addr</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">FIELD_SIZEOF</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="p">,</span>
						  <span class="n">ifindex</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">);</span>
			<span class="n">PPC_LWZ_OFFS</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_scratch1</span><span class="p">,</span>
				     <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ANC_MARK</span>:
			<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">FIELD_SIZEOF</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">mark</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">);</span>
			<span class="n">PPC_LWZ_OFFS</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_skb</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span>
							  <span class="n">mark</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ANC_RXHASH</span>:
			<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">FIELD_SIZEOF</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">rxhash</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">);</span>
			<span class="n">PPC_LWZ_OFFS</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_skb</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span>
							  <span class="n">rxhash</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ANC_QUEUE</span>:
			<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">FIELD_SIZEOF</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span>
						  <span class="n">queue_mapping</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">PPC_LHZ_OFFS</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_skb</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span>
							  <span class="n">queue_mapping</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_ANC_CPU</span>:
<span class="cp">#ifdef CONFIG_SMP</span>
			<span class="cm">/*</span>
<span class="cm">			 * PACA ptr is r13:</span>
<span class="cm">			 * raw_smp_processor_id() = local_paca-&gt;paca_index</span>
<span class="cm">			 */</span>
			<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">FIELD_SIZEOF</span><span class="p">(</span><span class="k">struct</span> <span class="n">paca_struct</span><span class="p">,</span>
						  <span class="n">paca_index</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">PPC_LHZ_OFFS</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span>
				     <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">paca_struct</span><span class="p">,</span> <span class="n">paca_index</span><span class="p">));</span>
<span class="cp">#else</span>
			<span class="n">PPC_LI</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="k">break</span><span class="p">;</span>

			<span class="cm">/*** Absolute loads from packet header/data ***/</span>
		<span class="k">case</span> <span class="n">BPF_S_LD_W_ABS</span>:
			<span class="n">func</span> <span class="o">=</span> <span class="n">CHOOSE_LOAD_FUNC</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">sk_load_word</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">common_load</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_LD_H_ABS</span>:
			<span class="n">func</span> <span class="o">=</span> <span class="n">CHOOSE_LOAD_FUNC</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">sk_load_half</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">common_load</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_LD_B_ABS</span>:
			<span class="n">func</span> <span class="o">=</span> <span class="n">CHOOSE_LOAD_FUNC</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">sk_load_byte</span><span class="p">);</span>
		<span class="nl">common_load:</span>
			<span class="cm">/* Load from [K]. */</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_DATAREF</span><span class="p">;</span>
			<span class="n">PPC_LI64</span><span class="p">(</span><span class="n">r_scratch1</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
			<span class="n">PPC_MTLR</span><span class="p">(</span><span class="n">r_scratch1</span><span class="p">);</span>
			<span class="n">PPC_LI32</span><span class="p">(</span><span class="n">r_addr</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
			<span class="n">PPC_BLRL</span><span class="p">();</span>
			<span class="cm">/*</span>
<span class="cm">			 * Helper returns &#39;lt&#39; condition on error, and an</span>
<span class="cm">			 * appropriate return value in r3</span>
<span class="cm">			 */</span>
			<span class="n">PPC_BCC</span><span class="p">(</span><span class="n">COND_LT</span><span class="p">,</span> <span class="n">exit_addr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

			<span class="cm">/*** Indirect loads from packet header/data ***/</span>
		<span class="k">case</span> <span class="n">BPF_S_LD_W_IND</span>:
			<span class="n">func</span> <span class="o">=</span> <span class="n">sk_load_word</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">common_load_ind</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_LD_H_IND</span>:
			<span class="n">func</span> <span class="o">=</span> <span class="n">sk_load_half</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">common_load_ind</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_LD_B_IND</span>:
			<span class="n">func</span> <span class="o">=</span> <span class="n">sk_load_byte</span><span class="p">;</span>
		<span class="nl">common_load_ind:</span>
			<span class="cm">/*</span>
<span class="cm">			 * Load from [X + K].  Negative offsets are tested for</span>
<span class="cm">			 * in the helper functions.</span>
<span class="cm">			 */</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_DATAREF</span> <span class="o">|</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
			<span class="n">PPC_LI64</span><span class="p">(</span><span class="n">r_scratch1</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
			<span class="n">PPC_MTLR</span><span class="p">(</span><span class="n">r_scratch1</span><span class="p">);</span>
			<span class="n">PPC_ADDI</span><span class="p">(</span><span class="n">r_addr</span><span class="p">,</span> <span class="n">r_X</span><span class="p">,</span> <span class="n">IMM_L</span><span class="p">(</span><span class="n">K</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">K</span> <span class="o">&gt;=</span> <span class="mi">32768</span><span class="p">)</span>
				<span class="n">PPC_ADDIS</span><span class="p">(</span><span class="n">r_addr</span><span class="p">,</span> <span class="n">r_addr</span><span class="p">,</span> <span class="n">IMM_HA</span><span class="p">(</span><span class="n">K</span><span class="p">));</span>
			<span class="n">PPC_BLRL</span><span class="p">();</span>
			<span class="cm">/* If error, cr0.LT set */</span>
			<span class="n">PPC_BCC</span><span class="p">(</span><span class="n">COND_LT</span><span class="p">,</span> <span class="n">exit_addr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_S_LDX_B_MSH</span>:
			<span class="n">func</span> <span class="o">=</span> <span class="n">CHOOSE_LOAD_FUNC</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">sk_load_byte_msh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">common_load</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

			<span class="cm">/*** Jump and branches ***/</span>
		<span class="k">case</span> <span class="n">BPF_S_JMP_JA</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">K</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">PPC_JMP</span><span class="p">(</span><span class="n">addrs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">K</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_S_JMP_JGT_K</span>:
		<span class="k">case</span> <span class="n">BPF_S_JMP_JGT_X</span>:
			<span class="n">true_cond</span> <span class="o">=</span> <span class="n">COND_GT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cond_branch</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_JMP_JGE_K</span>:
		<span class="k">case</span> <span class="n">BPF_S_JMP_JGE_X</span>:
			<span class="n">true_cond</span> <span class="o">=</span> <span class="n">COND_GE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cond_branch</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_JMP_JEQ_K</span>:
		<span class="k">case</span> <span class="n">BPF_S_JMP_JEQ_X</span>:
			<span class="n">true_cond</span> <span class="o">=</span> <span class="n">COND_EQ</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cond_branch</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BPF_S_JMP_JSET_K</span>:
		<span class="k">case</span> <span class="n">BPF_S_JMP_JSET_X</span>:
			<span class="n">true_cond</span> <span class="o">=</span> <span class="n">COND_NE</span><span class="p">;</span>
			<span class="cm">/* Fall through */</span>
		<span class="nl">cond_branch:</span>
			<span class="cm">/* same targets, can avoid doing the test :) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jt</span> <span class="o">==</span> <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">PPC_JMP</span><span class="p">(</span><span class="n">addrs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jt</span><span class="p">]);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">BPF_S_JMP_JGT_X</span>:
			<span class="k">case</span> <span class="n">BPF_S_JMP_JGE_X</span>:
			<span class="k">case</span> <span class="n">BPF_S_JMP_JEQ_X</span>:
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
				<span class="n">PPC_CMPLW</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_JMP_JSET_X</span>:
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
				<span class="n">PPC_AND_DOT</span><span class="p">(</span><span class="n">r_scratch1</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">r_X</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_JMP_JEQ_K</span>:
			<span class="k">case</span> <span class="n">BPF_S_JMP_JGT_K</span>:
			<span class="k">case</span> <span class="n">BPF_S_JMP_JGE_K</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">K</span> <span class="o">&lt;</span> <span class="mi">32768</span><span class="p">)</span>
					<span class="n">PPC_CMPLWI</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">PPC_LI32</span><span class="p">(</span><span class="n">r_scratch1</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
					<span class="n">PPC_CMPLW</span><span class="p">(</span><span class="n">r_A</span><span class="p">,</span> <span class="n">r_scratch1</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">BPF_S_JMP_JSET_K</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">K</span> <span class="o">&lt;</span> <span class="mi">32768</span><span class="p">)</span>
					<span class="cm">/* PPC_ANDI is /only/ dot-form */</span>
					<span class="n">PPC_ANDI</span><span class="p">(</span><span class="n">r_scratch1</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">PPC_LI32</span><span class="p">(</span><span class="n">r_scratch1</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>
					<span class="n">PPC_AND_DOT</span><span class="p">(</span><span class="n">r_scratch1</span><span class="p">,</span> <span class="n">r_A</span><span class="p">,</span>
						    <span class="n">r_scratch1</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Sometimes branches are constructed &quot;backward&quot;, with</span>
<span class="cm">			 * the false path being the branch and true path being</span>
<span class="cm">			 * a fallthrough to the next instruction.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="cm">/* Swap the sense of the branch */</span>
				<span class="n">PPC_BCC</span><span class="p">(</span><span class="n">true_cond</span> <span class="o">^</span> <span class="n">COND_CMP_TRUE</span><span class="p">,</span>
					<span class="n">addrs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span><span class="p">]);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">PPC_BCC</span><span class="p">(</span><span class="n">true_cond</span><span class="p">,</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jt</span><span class="p">]);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">PPC_JMP</span><span class="p">(</span><span class="n">addrs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="cm">/* The filter contains something cruel &amp; unusual.</span>
<span class="cm">			 * We don&#39;t handle it, but also there shouldn&#39;t be</span>
<span class="cm">			 * anything missing from our list.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;BPF filter opcode %04x (@%d) unsupported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">code</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="cm">/* Set end-of-body-code address for exit. */</span>
	<span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bpf_jit_compile</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_filter</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">proglen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloclen</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">code_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">addrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">codegen_context</span> <span class="n">cgctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pass</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flen</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bpf_jit_enable</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">addrs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="n">flen</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addrs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addrs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There are multiple assembly passes as the generated code will change</span>
<span class="cm">	 * size as it settles down, figuring out the max branch offsets/exit</span>
<span class="cm">	 * paths required.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The range of standard conditional branches is +/- 32Kbytes.	Since</span>
<span class="cm">	 * BPF_MAXINSNS = 4096, we can only jump from (worst case) start to</span>
<span class="cm">	 * finish with 8 bytes/instruction.  Not feasible, so long jumps are</span>
<span class="cm">	 * used, distinct from short branches.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Current:</span>
<span class="cm">	 *</span>
<span class="cm">	 * For now, both branch types assemble to 2 words (short branches padded</span>
<span class="cm">	 * with a NOP); this is less efficient, but assembly will always complete</span>
<span class="cm">	 * after exactly 3 passes:</span>
<span class="cm">	 *</span>
<span class="cm">	 * First pass: No code buffer; Program is &quot;faux-generated&quot; -- no code</span>
<span class="cm">	 * emitted but maximum size of output determined (and addrs[] filled</span>
<span class="cm">	 * in).	 Also, we note whether we use M[], whether we use skb data, etc.</span>
<span class="cm">	 * All generation choices assumed to be &#39;worst-case&#39;, e.g. branches all</span>
<span class="cm">	 * far (2 instructions), return path code reduction not available, etc.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Second pass: Code buffer allocated with size determined previously.</span>
<span class="cm">	 * Prologue generated to support features we have seen used.  Exit paths</span>
<span class="cm">	 * determined and addrs[] is filled in again, as code may be slightly</span>
<span class="cm">	 * smaller as a result.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Third pass: Code generated &#39;for real&#39;, and branch destinations</span>
<span class="cm">	 * determined from now-accurate addrs[] map.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Ideal:</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we optimise this, near branches will be shorter.	On the</span>
<span class="cm">	 * first assembly pass, we should err on the side of caution and</span>
<span class="cm">	 * generate the biggest code.  On subsequent passes, branches will be</span>
<span class="cm">	 * generated short or long and code size will reduce.  With smaller</span>
<span class="cm">	 * code, more branches may fall into the short category, and code will</span>
<span class="cm">	 * reduce more.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Finally, if we see one pass generate code the same size as the</span>
<span class="cm">	 * previous pass we have converged and should now generate code for</span>
<span class="cm">	 * real.  Allocating at the end will also save the memory that would</span>
<span class="cm">	 * otherwise be wasted by the (small) current code shrinkage.</span>
<span class="cm">	 * Preferably, we should do a small number of passes (e.g. 5) and if we</span>
<span class="cm">	 * haven&#39;t converged by then, get impatient and force code to generate</span>
<span class="cm">	 * as-is, even if the odd branch would be left long.  The chances of a</span>
<span class="cm">	 * long jump are tiny with all but the most enormous of BPF filter</span>
<span class="cm">	 * inputs, so we should usually converge on the third pass.</span>
<span class="cm">	 */</span>

	<span class="n">cgctx</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cgctx</span><span class="p">.</span><span class="n">seen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cgctx</span><span class="p">.</span><span class="n">pc_ret0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Scouting faux-generate pass 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bpf_jit_build_body</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgctx</span><span class="p">,</span> <span class="n">addrs</span><span class="p">))</span>
		<span class="cm">/* We hit something illegal or unsupported. */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pretend to build prologue, given the features we&#39;ve seen.  This will</span>
<span class="cm">	 * update ctgtx.idx as it pretends to output instructions, then we can</span>
<span class="cm">	 * calculate total size from idx.</span>
<span class="cm">	 */</span>
	<span class="n">bpf_jit_build_prologue</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgctx</span><span class="p">);</span>
	<span class="n">bpf_jit_build_epilogue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgctx</span><span class="p">);</span>

	<span class="n">proglen</span> <span class="o">=</span> <span class="n">cgctx</span><span class="p">.</span><span class="n">idx</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">alloclen</span> <span class="o">=</span> <span class="n">proglen</span> <span class="o">+</span> <span class="n">FUNCTION_DESCR_SIZE</span><span class="p">;</span>
	<span class="n">image</span> <span class="o">=</span> <span class="n">module_alloc</span><span class="p">(</span><span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">alloclen</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span><span class="p">)));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">code_base</span> <span class="o">=</span> <span class="n">image</span> <span class="o">+</span> <span class="p">(</span><span class="n">FUNCTION_DESCR_SIZE</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* Code generation passes 1-2 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pass</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">pass</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">pass</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Now build the prologue, body code &amp; epilogue for real. */</span>
		<span class="n">cgctx</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bpf_jit_build_prologue</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">code_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgctx</span><span class="p">);</span>
		<span class="n">bpf_jit_build_body</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">code_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgctx</span><span class="p">,</span> <span class="n">addrs</span><span class="p">);</span>
		<span class="n">bpf_jit_build_epilogue</span><span class="p">(</span><span class="n">code_base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgctx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bpf_jit_enable</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Pass %d: shrink = %d, seen = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pass</span><span class="p">,</span>
				<span class="n">proglen</span> <span class="o">-</span> <span class="p">(</span><span class="n">cgctx</span><span class="p">.</span><span class="n">idx</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span> <span class="n">cgctx</span><span class="p">.</span><span class="n">seen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bpf_jit_enable</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;flen=%d proglen=%u pass=%d image=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">flen</span><span class="p">,</span> <span class="n">proglen</span><span class="p">,</span> <span class="n">pass</span><span class="p">,</span> <span class="n">image</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bpf_jit_enable</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;JIT code: &quot;</span><span class="p">,</span>
				       <span class="n">DUMP_PREFIX_ADDRESS</span><span class="p">,</span>
				       <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">code_base</span><span class="p">,</span>
				       <span class="n">proglen</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

		<span class="n">bpf_flush_icache</span><span class="p">(</span><span class="n">code_base</span><span class="p">,</span> <span class="n">code_base</span> <span class="o">+</span> <span class="p">(</span><span class="n">proglen</span><span class="o">/</span><span class="mi">4</span><span class="p">));</span>
		<span class="cm">/* Function descriptor nastiness: Address + TOC */</span>
		<span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">image</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">code_base</span><span class="p">;</span>
		<span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">image</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_paca</span><span class="o">-&gt;</span><span class="n">kernel_toc</span><span class="p">;</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">bpf_func</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">image</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">addrs</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jit_free_defer</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">module_free</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* run from softirq, we must use a work_struct to call</span>
<span class="cm"> * module_free() from process context</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bpf_jit_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_filter</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">bpf_func</span> <span class="o">!=</span> <span class="n">sk_run_filter</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">)</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">bpf_func</span><span class="p">;</span>

		<span class="n">INIT_WORK</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">jit_free_defer</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
