<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › net › bpf_jit.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>bpf_jit.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* bpf_jit.h: BPF JIT compiler for PPC64</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2011 Matt Evans &lt;matt@ozlabs.org&gt;, IBM Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; version 2</span>
<span class="cm"> * of the License.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _BPF_JIT_H</span>
<span class="cp">#define _BPF_JIT_H</span>

<span class="cp">#define BPF_PPC_STACK_LOCALS	32</span>
<span class="cp">#define BPF_PPC_STACK_BASIC	(48+64)</span>
<span class="cp">#define BPF_PPC_STACK_SAVE	(18*8)</span>
<span class="cp">#define BPF_PPC_STACKFRAME	(BPF_PPC_STACK_BASIC+BPF_PPC_STACK_LOCALS+ \</span>
<span class="cp">				 BPF_PPC_STACK_SAVE)</span>
<span class="cp">#define BPF_PPC_SLOWPATH_FRAME	(48+64)</span>

<span class="cm">/*</span>
<span class="cm"> * Generated code register usage:</span>
<span class="cm"> *</span>
<span class="cm"> * As normal PPC C ABI (e.g. r1=sp, r2=TOC), with:</span>
<span class="cm"> *</span>
<span class="cm"> * skb		r3	(Entry parameter)</span>
<span class="cm"> * A register	r4</span>
<span class="cm"> * X register	r5</span>
<span class="cm"> * addr param	r6</span>
<span class="cm"> * r7-r10	scratch</span>
<span class="cm"> * skb-&gt;data	r14</span>
<span class="cm"> * skb headlen	r15	(skb-&gt;len - skb-&gt;data_len)</span>
<span class="cm"> * m[0]		r16</span>
<span class="cm"> * m[...]	...</span>
<span class="cm"> * m[15]	r31</span>
<span class="cm"> */</span>
<span class="cp">#define r_skb		3</span>
<span class="cp">#define r_ret		3</span>
<span class="cp">#define r_A		4</span>
<span class="cp">#define r_X		5</span>
<span class="cp">#define r_addr		6</span>
<span class="cp">#define r_scratch1	7</span>
<span class="cp">#define r_D		14</span>
<span class="cp">#define r_HL		15</span>
<span class="cp">#define r_M		16</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cm">/*</span>
<span class="cm"> * Assembly helpers from arch/powerpc/net/bpf_jit.S:</span>
<span class="cm"> */</span>
<span class="cp">#define DECLARE_LOAD_FUNC(func)	\</span>
<span class="cp">	extern u8 func[], func##_negative_offset[], func##_positive_offset[]</span>

<span class="n">DECLARE_LOAD_FUNC</span><span class="p">(</span><span class="n">sk_load_word</span><span class="p">);</span>
<span class="n">DECLARE_LOAD_FUNC</span><span class="p">(</span><span class="n">sk_load_half</span><span class="p">);</span>
<span class="n">DECLARE_LOAD_FUNC</span><span class="p">(</span><span class="n">sk_load_byte</span><span class="p">);</span>
<span class="n">DECLARE_LOAD_FUNC</span><span class="p">(</span><span class="n">sk_load_byte_msh</span><span class="p">);</span>

<span class="cp">#define FUNCTION_DESCR_SIZE	24</span>

<span class="cm">/*</span>
<span class="cm"> * 16-bit immediate helper macros: HA() is for use with sign-extending instrs</span>
<span class="cm"> * (e.g. LD, ADDI).  If the bottom 16 bits is &quot;-ve&quot;, add another bit into the</span>
<span class="cm"> * top half to negate the effect (i.e. 0xffff + 1 = 0x(1)0000).</span>
<span class="cm"> */</span>
<span class="cp">#define IMM_H(i)		((uintptr_t)(i)&gt;&gt;16)</span>
<span class="cp">#define IMM_HA(i)		(((uintptr_t)(i)&gt;&gt;16) +			      \</span>
<span class="cp">				 (((uintptr_t)(i) &amp; 0x8000) &gt;&gt; 15))</span>
<span class="cp">#define IMM_L(i)		((uintptr_t)(i) &amp; 0xffff)</span>

<span class="cp">#define PLANT_INSTR(d, idx, instr)					      \</span>
<span class="cp">	do { if (d) { (d)[idx] = instr; } idx++; } while (0)</span>
<span class="cp">#define EMIT(instr)		PLANT_INSTR(image, ctx-&gt;idx, instr)</span>

<span class="cp">#define PPC_NOP()		EMIT(PPC_INST_NOP)</span>
<span class="cp">#define PPC_BLR()		EMIT(PPC_INST_BLR)</span>
<span class="cp">#define PPC_BLRL()		EMIT(PPC_INST_BLRL)</span>
<span class="cp">#define PPC_MTLR(r)		EMIT(PPC_INST_MTLR | __PPC_RT(r))</span>
<span class="cp">#define PPC_ADDI(d, a, i)	EMIT(PPC_INST_ADDI | __PPC_RT(d) |	      \</span>
<span class="cp">				     __PPC_RA(a) | IMM_L(i))</span>
<span class="cp">#define PPC_MR(d, a)		PPC_OR(d, a, a)</span>
<span class="cp">#define PPC_LI(r, i)		PPC_ADDI(r, 0, i)</span>
<span class="cp">#define PPC_ADDIS(d, a, i)	EMIT(PPC_INST_ADDIS |			      \</span>
<span class="cp">				     __PPC_RS(d) | __PPC_RA(a) | IMM_L(i))</span>
<span class="cp">#define PPC_LIS(r, i)		PPC_ADDIS(r, 0, i)</span>
<span class="cp">#define PPC_STD(r, base, i)	EMIT(PPC_INST_STD | __PPC_RS(r) |	      \</span>
<span class="cp">				     __PPC_RA(base) | ((i) &amp; 0xfffc))</span>

<span class="cp">#define PPC_LD(r, base, i)	EMIT(PPC_INST_LD | __PPC_RT(r) |	      \</span>
<span class="cp">				     __PPC_RA(base) | IMM_L(i))</span>
<span class="cp">#define PPC_LWZ(r, base, i)	EMIT(PPC_INST_LWZ | __PPC_RT(r) |	      \</span>
<span class="cp">				     __PPC_RA(base) | IMM_L(i))</span>
<span class="cp">#define PPC_LHZ(r, base, i)	EMIT(PPC_INST_LHZ | __PPC_RT(r) |	      \</span>
<span class="cp">				     __PPC_RA(base) | IMM_L(i))</span>
<span class="cm">/* Convenience helpers for the above with &#39;far&#39; offsets: */</span>
<span class="cp">#define PPC_LD_OFFS(r, base, i) do { if ((i) &lt; 32768) PPC_LD(r, base, i);     \</span>
<span class="cp">		else {	PPC_ADDIS(r, base, IMM_HA(i));			      \</span>
<span class="cp">			PPC_LD(r, r, IMM_L(i)); } } while(0)</span>

<span class="cp">#define PPC_LWZ_OFFS(r, base, i) do { if ((i) &lt; 32768) PPC_LWZ(r, base, i);   \</span>
<span class="cp">		else {	PPC_ADDIS(r, base, IMM_HA(i));			      \</span>
<span class="cp">			PPC_LWZ(r, r, IMM_L(i)); } } while(0)</span>

<span class="cp">#define PPC_LHZ_OFFS(r, base, i) do { if ((i) &lt; 32768) PPC_LHZ(r, base, i);   \</span>
<span class="cp">		else {	PPC_ADDIS(r, base, IMM_HA(i));			      \</span>
<span class="cp">			PPC_LHZ(r, r, IMM_L(i)); } } while(0)</span>

<span class="cp">#define PPC_CMPWI(a, i)		EMIT(PPC_INST_CMPWI | __PPC_RA(a) | IMM_L(i))</span>
<span class="cp">#define PPC_CMPDI(a, i)		EMIT(PPC_INST_CMPDI | __PPC_RA(a) | IMM_L(i))</span>
<span class="cp">#define PPC_CMPLWI(a, i)	EMIT(PPC_INST_CMPLWI | __PPC_RA(a) | IMM_L(i))</span>
<span class="cp">#define PPC_CMPLW(a, b)		EMIT(PPC_INST_CMPLW | __PPC_RA(a) | __PPC_RB(b))</span>

<span class="cp">#define PPC_SUB(d, a, b)	EMIT(PPC_INST_SUB | __PPC_RT(d) |	      \</span>
<span class="cp">				     __PPC_RB(a) | __PPC_RA(b))</span>
<span class="cp">#define PPC_ADD(d, a, b)	EMIT(PPC_INST_ADD | __PPC_RT(d) |	      \</span>
<span class="cp">				     __PPC_RA(a) | __PPC_RB(b))</span>
<span class="cp">#define PPC_MUL(d, a, b)	EMIT(PPC_INST_MULLW | __PPC_RT(d) |	      \</span>
<span class="cp">				     __PPC_RA(a) | __PPC_RB(b))</span>
<span class="cp">#define PPC_MULHWU(d, a, b)	EMIT(PPC_INST_MULHWU | __PPC_RT(d) |	      \</span>
<span class="cp">				     __PPC_RA(a) | __PPC_RB(b))</span>
<span class="cp">#define PPC_MULI(d, a, i)	EMIT(PPC_INST_MULLI | __PPC_RT(d) |	      \</span>
<span class="cp">				     __PPC_RA(a) | IMM_L(i))</span>
<span class="cp">#define PPC_DIVWU(d, a, b)	EMIT(PPC_INST_DIVWU | __PPC_RT(d) |	      \</span>
<span class="cp">				     __PPC_RA(a) | __PPC_RB(b))</span>
<span class="cp">#define PPC_AND(d, a, b)	EMIT(PPC_INST_AND | __PPC_RA(d) |	      \</span>
<span class="cp">				     __PPC_RS(a) | __PPC_RB(b))</span>
<span class="cp">#define PPC_ANDI(d, a, i)	EMIT(PPC_INST_ANDI | __PPC_RA(d) |	      \</span>
<span class="cp">				     __PPC_RS(a) | IMM_L(i))</span>
<span class="cp">#define PPC_AND_DOT(d, a, b)	EMIT(PPC_INST_ANDDOT | __PPC_RA(d) |	      \</span>
<span class="cp">				     __PPC_RS(a) | __PPC_RB(b))</span>
<span class="cp">#define PPC_OR(d, a, b)		EMIT(PPC_INST_OR | __PPC_RA(d) |	      \</span>
<span class="cp">				     __PPC_RS(a) | __PPC_RB(b))</span>
<span class="cp">#define PPC_ORI(d, a, i)	EMIT(PPC_INST_ORI | __PPC_RA(d) |	      \</span>
<span class="cp">				     __PPC_RS(a) | IMM_L(i))</span>
<span class="cp">#define PPC_ORIS(d, a, i)	EMIT(PPC_INST_ORIS | __PPC_RA(d) |	      \</span>
<span class="cp">				     __PPC_RS(a) | IMM_L(i))</span>
<span class="cp">#define PPC_SLW(d, a, s)	EMIT(PPC_INST_SLW | __PPC_RA(d) |	      \</span>
<span class="cp">				     __PPC_RS(a) | __PPC_RB(s))</span>
<span class="cp">#define PPC_SRW(d, a, s)	EMIT(PPC_INST_SRW | __PPC_RA(d) |	      \</span>
<span class="cp">				     __PPC_RS(a) | __PPC_RB(s))</span>
<span class="cm">/* slwi = rlwinm Rx, Ry, n, 0, 31-n */</span>
<span class="cp">#define PPC_SLWI(d, a, i)	EMIT(PPC_INST_RLWINM | __PPC_RA(d) |	      \</span>
<span class="cp">				     __PPC_RS(a) | __PPC_SH(i) |	      \</span>
<span class="cp">				     __PPC_MB(0) | __PPC_ME(31-(i)))</span>
<span class="cm">/* srwi = rlwinm Rx, Ry, 32-n, n, 31 */</span>
<span class="cp">#define PPC_SRWI(d, a, i)	EMIT(PPC_INST_RLWINM | __PPC_RA(d) |	      \</span>
<span class="cp">				     __PPC_RS(a) | __PPC_SH(32-(i)) |	      \</span>
<span class="cp">				     __PPC_MB(i) | __PPC_ME(31))</span>
<span class="cm">/* sldi = rldicr Rx, Ry, n, 63-n */</span>
<span class="cp">#define PPC_SLDI(d, a, i)	EMIT(PPC_INST_RLDICR | __PPC_RA(d) |	      \</span>
<span class="cp">				     __PPC_RS(a) | __PPC_SH(i) |	      \</span>
<span class="cp">				     __PPC_MB(63-(i)) | (((i) &amp; 0x20) &gt;&gt; 4))</span>
<span class="cp">#define PPC_NEG(d, a)		EMIT(PPC_INST_NEG | __PPC_RT(d) | __PPC_RA(a))</span>

<span class="cm">/* Long jump; (unconditional &#39;branch&#39;) */</span>
<span class="cp">#define PPC_JMP(dest)		EMIT(PPC_INST_BRANCH |			      \</span>
<span class="cp">				     (((dest) - (ctx-&gt;idx * 4)) &amp; 0x03fffffc))</span>
<span class="cm">/* &quot;cond&quot; here covers BO:BI fields. */</span>
<span class="cp">#define PPC_BCC_SHORT(cond, dest)	EMIT(PPC_INST_BRANCH_COND |	      \</span>
<span class="cp">					     (((cond) &amp; 0x3ff) &lt;&lt; 16) |	      \</span>
<span class="cp">					     (((dest) - (ctx-&gt;idx * 4)) &amp;     \</span>
<span class="cp">					      0xfffc))</span>
<span class="cp">#define PPC_LI32(d, i)		do { PPC_LI(d, IMM_L(i));		      \</span>
<span class="cp">		if ((u32)(uintptr_t)(i) &gt;= 32768) {			      \</span>
<span class="cp">			PPC_ADDIS(d, d, IMM_HA(i));			      \</span>
<span class="cp">		} } while(0)</span>
<span class="cp">#define PPC_LI64(d, i)		do {					      \</span>
<span class="cp">		if (!((uintptr_t)(i) &amp; 0xffffffff00000000ULL))		      \</span>
<span class="cp">			PPC_LI32(d, i);					      \</span>
<span class="cp">		else {							      \</span>
<span class="cp">			PPC_LIS(d, ((uintptr_t)(i) &gt;&gt; 48));		      \</span>
<span class="cp">			if ((uintptr_t)(i) &amp; 0x0000ffff00000000ULL)	      \</span>
<span class="cp">				PPC_ORI(d, d,				      \</span>
<span class="cp">					((uintptr_t)(i) &gt;&gt; 32) &amp; 0xffff);     \</span>
<span class="cp">			PPC_SLDI(d, d, 32);				      \</span>
<span class="cp">			if ((uintptr_t)(i) &amp; 0x00000000ffff0000ULL)	      \</span>
<span class="cp">				PPC_ORIS(d, d,				      \</span>
<span class="cp">					 ((uintptr_t)(i) &gt;&gt; 16) &amp; 0xffff);    \</span>
<span class="cp">			if ((uintptr_t)(i) &amp; 0x000000000000ffffULL)	      \</span>
<span class="cp">				PPC_ORI(d, d, (uintptr_t)(i) &amp; 0xffff);	      \</span>
<span class="cp">		} } while (0);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_nearbranch</span><span class="p">(</span><span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">32768</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">32768</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The fly in the ointment of code size changing from pass to pass is</span>
<span class="cm"> * avoided by padding the short branch case with a NOP.	 If code size differs</span>
<span class="cm"> * with different branch reaches we will have the issue of code moving from</span>
<span class="cm"> * one pass to the next and will need a few passes to converge on a stable</span>
<span class="cm"> * state.</span>
<span class="cm"> */</span>
<span class="cp">#define PPC_BCC(cond, dest)	do {					      \</span>
<span class="cp">		if (is_nearbranch((dest) - (ctx-&gt;idx * 4))) {		      \</span>
<span class="cp">			PPC_BCC_SHORT(cond, dest);			      \</span>
<span class="cp">			PPC_NOP();					      \</span>
<span class="cp">		} else {						      \</span>
<span class="cp">			</span><span class="cm">/* Flip the &#39;T or F&#39; bit to invert comparison */</span><span class="cp">      \</span>
<span class="cp">			PPC_BCC_SHORT(cond ^ COND_CMP_TRUE, (ctx-&gt;idx+2)*4);  \</span>
<span class="cp">			PPC_JMP(dest);					      \</span>
<span class="cp">		} } while(0)</span>

<span class="cm">/* To create a branch condition, select a bit of cr0... */</span>
<span class="cp">#define CR0_LT		0</span>
<span class="cp">#define CR0_GT		1</span>
<span class="cp">#define CR0_EQ		2</span>
<span class="cm">/* ...and modify BO[3] */</span>
<span class="cp">#define COND_CMP_TRUE	0x100</span>
<span class="cp">#define COND_CMP_FALSE	0x000</span>
<span class="cm">/* Together, they make all required comparisons: */</span>
<span class="cp">#define COND_GT		(CR0_GT | COND_CMP_TRUE)</span>
<span class="cp">#define COND_GE		(CR0_LT | COND_CMP_FALSE)</span>
<span class="cp">#define COND_EQ		(CR0_EQ | COND_CMP_TRUE)</span>
<span class="cp">#define COND_NE		(CR0_EQ | COND_CMP_FALSE)</span>
<span class="cp">#define COND_LT		(CR0_LT | COND_CMP_TRUE)</span>

<span class="cp">#define SEEN_DATAREF 0x10000 </span><span class="cm">/* might call external helpers */</span><span class="cp"></span>
<span class="cp">#define SEEN_XREG    0x20000 </span><span class="cm">/* X reg is used */</span><span class="cp"></span>
<span class="cp">#define SEEN_MEM     0x40000 </span><span class="cm">/* SEEN_MEM+(1&lt;&lt;n) = use mem[n] for temporary</span>
<span class="cm">			      * storage */</span><span class="cp"></span>
<span class="cp">#define SEEN_MEM_MSK 0x0ffff</span>

<span class="k">struct</span> <span class="n">codegen_context</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pc_ret0</span><span class="p">;</span> <span class="cm">/* bpf index of first RET #0 instruction (if any) */</span>
<span class="p">};</span>

<span class="cp">#endif</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
