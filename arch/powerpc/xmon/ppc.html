<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › powerpc › xmon › ppc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ppc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* ppc.h -- Header file for PowerPC opcode table</span>
<span class="cm">   Copyright 1994, 1995, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006</span>
<span class="cm">   Free Software Foundation, Inc.</span>
<span class="cm">   Written by Ian Lance Taylor, Cygnus Support</span>

<span class="cm">This file is part of GDB, GAS, and the GNU binutils.</span>

<span class="cm">GDB, GAS, and the GNU binutils are free software; you can redistribute</span>
<span class="cm">them and/or modify them under the terms of the GNU General Public</span>
<span class="cm">License as published by the Free Software Foundation; either version</span>
<span class="cm">1, or (at your option) any later version.</span>

<span class="cm">GDB, GAS, and the GNU binutils are distributed in the hope that they</span>
<span class="cm">will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm">warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm">the GNU General Public License for more details.</span>

<span class="cm">You should have received a copy of the GNU General Public License</span>
<span class="cm">along with this file; see the file COPYING.  If not, write to the Free</span>
<span class="cm">Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */</span>

<span class="cp">#ifndef PPC_H</span>
<span class="cp">#define PPC_H</span>

<span class="cm">/* The opcode table is an array of struct powerpc_opcode.  */</span>

<span class="k">struct</span> <span class="n">powerpc_opcode</span>
<span class="p">{</span>
  <span class="cm">/* The opcode name.  */</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

  <span class="cm">/* The opcode itself.  Those bits which will be filled in with</span>
<span class="cm">     operands are zeroes.  */</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">opcode</span><span class="p">;</span>

  <span class="cm">/* The opcode mask.  This is used by the disassembler.  This is a</span>
<span class="cm">     mask containing ones indicating those bits which must match the</span>
<span class="cm">     opcode field, and zeroes indicating those bits which need not</span>
<span class="cm">     match (and are presumably filled in by operands).  */</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>

  <span class="cm">/* One bit flags for the opcode.  These are used to indicate which</span>
<span class="cm">     specific processors support the instructions.  The defined values</span>
<span class="cm">     are listed below.  */</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

  <span class="cm">/* An array of operand codes.  Each code is an index into the</span>
<span class="cm">     operand table.  They appear in the order which the operands must</span>
<span class="cm">     appear in assembly code, and are terminated by a zero.  */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">operands</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* The table itself is sorted by major opcode number, and is otherwise</span>
<span class="cm">   in the order in which the disassembler should consider</span>
<span class="cm">   instructions.  */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">powerpc_opcode</span> <span class="n">powerpc_opcodes</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">powerpc_num_opcodes</span><span class="p">;</span>

<span class="cm">/* Values defined for the flags field of a struct powerpc_opcode.  */</span>

<span class="cm">/* Opcode is defined for the PowerPC architecture.  */</span>
<span class="cp">#define PPC_OPCODE_PPC			 1</span>

<span class="cm">/* Opcode is defined for the POWER (RS/6000) architecture.  */</span>
<span class="cp">#define PPC_OPCODE_POWER		 2</span>

<span class="cm">/* Opcode is defined for the POWER2 (Rios 2) architecture.  */</span>
<span class="cp">#define PPC_OPCODE_POWER2		 4</span>

<span class="cm">/* Opcode is only defined on 32 bit architectures.  */</span>
<span class="cp">#define PPC_OPCODE_32			 8</span>

<span class="cm">/* Opcode is only defined on 64 bit architectures.  */</span>
<span class="cp">#define PPC_OPCODE_64		      0x10</span>

<span class="cm">/* Opcode is supported by the Motorola PowerPC 601 processor.  The 601</span>
<span class="cm">   is assumed to support all PowerPC (PPC_OPCODE_PPC) instructions,</span>
<span class="cm">   but it also supports many additional POWER instructions.  */</span>
<span class="cp">#define PPC_OPCODE_601		      0x20</span>

<span class="cm">/* Opcode is supported in both the Power and PowerPC architectures</span>
<span class="cm">   (ie, compiler&#39;s -mcpu=common or assembler&#39;s -mcom).  */</span>
<span class="cp">#define PPC_OPCODE_COMMON	      0x40</span>

<span class="cm">/* Opcode is supported for any Power or PowerPC platform (this is</span>
<span class="cm">   for the assembler&#39;s -many option, and it eliminates duplicates).  */</span>
<span class="cp">#define PPC_OPCODE_ANY		      0x80</span>

<span class="cm">/* Opcode is supported as part of the 64-bit bridge.  */</span>
<span class="cp">#define PPC_OPCODE_64_BRIDGE	     0x100</span>

<span class="cm">/* Opcode is supported by Altivec Vector Unit */</span>
<span class="cp">#define PPC_OPCODE_ALTIVEC	     0x200</span>

<span class="cm">/* Opcode is supported by PowerPC 403 processor.  */</span>
<span class="cp">#define PPC_OPCODE_403		     0x400</span>

<span class="cm">/* Opcode is supported by PowerPC BookE processor.  */</span>
<span class="cp">#define PPC_OPCODE_BOOKE	     0x800</span>

<span class="cm">/* Opcode is only supported by 64-bit PowerPC BookE processor.  */</span>
<span class="cp">#define PPC_OPCODE_BOOKE64	    0x1000</span>

<span class="cm">/* Opcode is supported by PowerPC 440 processor.  */</span>
<span class="cp">#define PPC_OPCODE_440		    0x2000</span>

<span class="cm">/* Opcode is only supported by Power4 architecture.  */</span>
<span class="cp">#define PPC_OPCODE_POWER4	    0x4000</span>

<span class="cm">/* Opcode isn&#39;t supported by Power4 architecture.  */</span>
<span class="cp">#define PPC_OPCODE_NOPOWER4	    0x8000</span>

<span class="cm">/* Opcode is only supported by POWERPC Classic architecture.  */</span>
<span class="cp">#define PPC_OPCODE_CLASSIC	   0x10000</span>

<span class="cm">/* Opcode is only supported by e500x2 Core.  */</span>
<span class="cp">#define PPC_OPCODE_SPE		   0x20000</span>

<span class="cm">/* Opcode is supported by e500x2 Integer select APU.  */</span>
<span class="cp">#define PPC_OPCODE_ISEL		   0x40000</span>

<span class="cm">/* Opcode is an e500 SPE floating point instruction.  */</span>
<span class="cp">#define PPC_OPCODE_EFS		   0x80000</span>

<span class="cm">/* Opcode is supported by branch locking APU.  */</span>
<span class="cp">#define PPC_OPCODE_BRLOCK	  0x100000</span>

<span class="cm">/* Opcode is supported by performance monitor APU.  */</span>
<span class="cp">#define PPC_OPCODE_PMR		  0x200000</span>

<span class="cm">/* Opcode is supported by cache locking APU.  */</span>
<span class="cp">#define PPC_OPCODE_CACHELCK	  0x400000</span>

<span class="cm">/* Opcode is supported by machine check APU.  */</span>
<span class="cp">#define PPC_OPCODE_RFMCI	  0x800000</span>

<span class="cm">/* Opcode is only supported by Power5 architecture.  */</span>
<span class="cp">#define PPC_OPCODE_POWER5	 0x1000000</span>

<span class="cm">/* Opcode is supported by PowerPC e300 family.  */</span>
<span class="cp">#define PPC_OPCODE_E300          0x2000000</span>

<span class="cm">/* Opcode is only supported by Power6 architecture.  */</span>
<span class="cp">#define PPC_OPCODE_POWER6	 0x4000000</span>

<span class="cm">/* Opcode is only supported by PowerPC Cell family.  */</span>
<span class="cp">#define PPC_OPCODE_CELL		 0x8000000</span>

<span class="cm">/* A macro to extract the major opcode from an instruction.  */</span>
<span class="cp">#define PPC_OP(i) (((i) &gt;&gt; 26) &amp; 0x3f)</span>

<span class="cm">/* The operands table is an array of struct powerpc_operand.  */</span>

<span class="k">struct</span> <span class="n">powerpc_operand</span>
<span class="p">{</span>
  <span class="cm">/* The number of bits in the operand.  */</span>
  <span class="kt">int</span> <span class="n">bits</span><span class="p">;</span>

  <span class="cm">/* How far the operand is left shifted in the instruction.  */</span>
  <span class="kt">int</span> <span class="n">shift</span><span class="p">;</span>

  <span class="cm">/* Insertion function.  This is used by the assembler.  To insert an</span>
<span class="cm">     operand value into an instruction, check this field.</span>

<span class="cm">     If it is NULL, execute</span>
<span class="cm">         i |= (op &amp; ((1 &lt;&lt; o-&gt;bits) - 1)) &lt;&lt; o-&gt;shift;</span>
<span class="cm">     (i is the instruction which we are filling in, o is a pointer to</span>
<span class="cm">     this structure, and op is the opcode value; this assumes twos</span>
<span class="cm">     complement arithmetic).</span>

<span class="cm">     If this field is not NULL, then simply call it with the</span>
<span class="cm">     instruction and the operand value.  It will return the new value</span>
<span class="cm">     of the instruction.  If the ERRMSG argument is not NULL, then if</span>
<span class="cm">     the operand value is illegal, *ERRMSG will be set to a warning</span>
<span class="cm">     string (the operand will be inserted in any case).  If the</span>
<span class="cm">     operand value is legal, *ERRMSG will be unchanged (most operands</span>
<span class="cm">     can accept any value).  */</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">insert</span><span class="p">)</span>
    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instruction</span><span class="p">,</span> <span class="kt">long</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dialect</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">errmsg</span><span class="p">);</span>

  <span class="cm">/* Extraction function.  This is used by the disassembler.  To</span>
<span class="cm">     extract this operand type from an instruction, check this field.</span>

<span class="cm">     If it is NULL, compute</span>
<span class="cm">         op = ((i) &gt;&gt; o-&gt;shift) &amp; ((1 &lt;&lt; o-&gt;bits) - 1);</span>
<span class="cm">	 if ((o-&gt;flags &amp; PPC_OPERAND_SIGNED) != 0</span>
<span class="cm">	     &amp;&amp; (op &amp; (1 &lt;&lt; (o-&gt;bits - 1))) != 0)</span>
<span class="cm">	   op -= 1 &lt;&lt; o-&gt;bits;</span>
<span class="cm">     (i is the instruction, o is a pointer to this structure, and op</span>
<span class="cm">     is the result; this assumes twos complement arithmetic).</span>

<span class="cm">     If this field is not NULL, then simply call it with the</span>
<span class="cm">     instruction value.  It will return the value of the operand.  If</span>
<span class="cm">     the INVALID argument is not NULL, *INVALID will be set to</span>
<span class="cm">     non-zero if this operand type can not actually be extracted from</span>
<span class="cm">     this operand (i.e., the instruction does not match).  If the</span>
<span class="cm">     operand is valid, *INVALID will not be changed.  */</span>
  <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">extract</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instruction</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dialect</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">invalid</span><span class="p">);</span>

  <span class="cm">/* One bit syntax flags.  */</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Elements in the table are retrieved by indexing with values from</span>
<span class="cm">   the operands field of the powerpc_opcodes table.  */</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">powerpc_operand</span> <span class="n">powerpc_operands</span><span class="p">[];</span>

<span class="cm">/* Values defined for the flags field of a struct powerpc_operand.  */</span>

<span class="cm">/* This operand takes signed values.  */</span>
<span class="cp">#define PPC_OPERAND_SIGNED (01)</span>

<span class="cm">/* This operand takes signed values, but also accepts a full positive</span>
<span class="cm">   range of values when running in 32 bit mode.  That is, if bits is</span>
<span class="cm">   16, it takes any value from -0x8000 to 0xffff.  In 64 bit mode,</span>
<span class="cm">   this flag is ignored.  */</span>
<span class="cp">#define PPC_OPERAND_SIGNOPT (02)</span>

<span class="cm">/* This operand does not actually exist in the assembler input.  This</span>
<span class="cm">   is used to support extended mnemonics such as mr, for which two</span>
<span class="cm">   operands fields are identical.  The assembler should call the</span>
<span class="cm">   insert function with any op value.  The disassembler should call</span>
<span class="cm">   the extract function, ignore the return value, and check the value</span>
<span class="cm">   placed in the valid argument.  */</span>
<span class="cp">#define PPC_OPERAND_FAKE (04)</span>

<span class="cm">/* The next operand should be wrapped in parentheses rather than</span>
<span class="cm">   separated from this one by a comma.  This is used for the load and</span>
<span class="cm">   store instructions which want their operands to look like</span>
<span class="cm">       reg,displacement(reg)</span>
<span class="cm">   */</span>
<span class="cp">#define PPC_OPERAND_PARENS (010)</span>

<span class="cm">/* This operand may use the symbolic names for the CR fields, which</span>
<span class="cm">   are</span>
<span class="cm">       lt  0	gt  1	eq  2	so  3	un  3</span>
<span class="cm">       cr0 0	cr1 1	cr2 2	cr3 3</span>
<span class="cm">       cr4 4	cr5 5	cr6 6	cr7 7</span>
<span class="cm">   These may be combined arithmetically, as in cr2*4+gt.  These are</span>
<span class="cm">   only supported on the PowerPC, not the POWER.  */</span>
<span class="cp">#define PPC_OPERAND_CR (020)</span>

<span class="cm">/* This operand names a register.  The disassembler uses this to print</span>
<span class="cm">   register names with a leading &#39;r&#39;.  */</span>
<span class="cp">#define PPC_OPERAND_GPR (040)</span>

<span class="cm">/* Like PPC_OPERAND_GPR, but don&#39;t print a leading &#39;r&#39; for r0.  */</span>
<span class="cp">#define PPC_OPERAND_GPR_0 (0100)</span>

<span class="cm">/* This operand names a floating point register.  The disassembler</span>
<span class="cm">   prints these with a leading &#39;f&#39;.  */</span>
<span class="cp">#define PPC_OPERAND_FPR (0200)</span>

<span class="cm">/* This operand is a relative branch displacement.  The disassembler</span>
<span class="cm">   prints these symbolically if possible.  */</span>
<span class="cp">#define PPC_OPERAND_RELATIVE (0400)</span>

<span class="cm">/* This operand is an absolute branch address.  The disassembler</span>
<span class="cm">   prints these symbolically if possible.  */</span>
<span class="cp">#define PPC_OPERAND_ABSOLUTE (01000)</span>

<span class="cm">/* This operand is optional, and is zero if omitted.  This is used for</span>
<span class="cm">   example, in the optional BF field in the comparison instructions.  The</span>
<span class="cm">   assembler must count the number of operands remaining on the line,</span>
<span class="cm">   and the number of operands remaining for the opcode, and decide</span>
<span class="cm">   whether this operand is present or not.  The disassembler should</span>
<span class="cm">   print this operand out only if it is not zero.  */</span>
<span class="cp">#define PPC_OPERAND_OPTIONAL (02000)</span>

<span class="cm">/* This flag is only used with PPC_OPERAND_OPTIONAL.  If this operand</span>
<span class="cm">   is omitted, then for the next operand use this operand value plus</span>
<span class="cm">   1, ignoring the next operand field for the opcode.  This wretched</span>
<span class="cm">   hack is needed because the Power rotate instructions can take</span>
<span class="cm">   either 4 or 5 operands.  The disassembler should print this operand</span>
<span class="cm">   out regardless of the PPC_OPERAND_OPTIONAL field.  */</span>
<span class="cp">#define PPC_OPERAND_NEXT (04000)</span>

<span class="cm">/* This operand should be regarded as a negative number for the</span>
<span class="cm">   purposes of overflow checking (i.e., the normal most negative</span>
<span class="cm">   number is disallowed and one more than the normal most positive</span>
<span class="cm">   number is allowed).  This flag will only be set for a signed</span>
<span class="cm">   operand.  */</span>
<span class="cp">#define PPC_OPERAND_NEGATIVE (010000)</span>

<span class="cm">/* This operand names a vector unit register.  The disassembler</span>
<span class="cm">   prints these with a leading &#39;v&#39;.  */</span>
<span class="cp">#define PPC_OPERAND_VR (020000)</span>

<span class="cm">/* This operand is for the DS field in a DS form instruction.  */</span>
<span class="cp">#define PPC_OPERAND_DS (040000)</span>

<span class="cm">/* This operand is for the DQ field in a DQ form instruction.  */</span>
<span class="cp">#define PPC_OPERAND_DQ (0100000)</span>

<span class="cm">/* The POWER and PowerPC assemblers use a few macros.  We keep them</span>
<span class="cm">   with the operands table for simplicity.  The macro table is an</span>
<span class="cm">   array of struct powerpc_macro.  */</span>

<span class="k">struct</span> <span class="n">powerpc_macro</span>
<span class="p">{</span>
  <span class="cm">/* The macro name.  */</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

  <span class="cm">/* The number of operands the macro takes.  */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">operands</span><span class="p">;</span>

  <span class="cm">/* One bit flags for the opcode.  These are used to indicate which</span>
<span class="cm">     specific processors support the instructions.  The values are the</span>
<span class="cm">     same as those for the struct powerpc_opcode flags field.  */</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

  <span class="cm">/* A format string to turn the macro into a normal instruction.</span>
<span class="cm">     Each %N in the string is replaced with operand number N (zero</span>
<span class="cm">     based).  */</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">powerpc_macro</span> <span class="n">powerpc_macros</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">powerpc_num_macros</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* PPC_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
