<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › hexagon › include › asm › pgtable.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pgtable.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Page table support for the Hexagon architecture</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 and</span>
<span class="cm"> * only version 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_PGTABLE_H</span>
<span class="cp">#define _ASM_PGTABLE_H</span>

<span class="cm">/*</span>
<span class="cm"> * Page table definitions for Qualcomm Hexagon processor.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm-generic/pgtable-nopmd.h&gt;</span>

<span class="cm">/* A handy thing to have if one has the RAM. Declared in head.S */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">empty_zero_page</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zero_page_mask</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The PTE model described here is that of the Hexagon Virtual Machine,</span>
<span class="cm"> * which autonomously walks 2-level page tables.  At a lower level, we</span>
<span class="cm"> * also describe the RISCish software-loaded TLB entry structure of</span>
<span class="cm"> * the underlying Hexagon processor. A kernel built to run on the</span>
<span class="cm"> * virtual machine has no need to know about the underlying hardware.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;asm/vm_mmu.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * To maximize the comfort level for the PTE manipulation macros,</span>
<span class="cm"> * define the &quot;well known&quot; architecture-specific bits.</span>
<span class="cm"> */</span>
<span class="cp">#define _PAGE_READ	__HVM_PTE_R</span>
<span class="cp">#define _PAGE_WRITE	__HVM_PTE_W</span>
<span class="cp">#define _PAGE_EXECUTE	__HVM_PTE_X</span>
<span class="cp">#define _PAGE_USER	__HVM_PTE_U</span>

<span class="cm">/*</span>
<span class="cm"> * We have a total of 4 &quot;soft&quot; bits available in the abstract PTE.</span>
<span class="cm"> * The two mandatory software bits are Dirty and Accessed.</span>
<span class="cm"> * To make nonlinear swap work according to the more recent</span>
<span class="cm"> * model, we want a low order &quot;Present&quot; bit to indicate whether</span>
<span class="cm"> * the PTE describes MMU programming or swap space.</span>
<span class="cm"> */</span>
<span class="cp">#define _PAGE_PRESENT	(1&lt;&lt;0)</span>
<span class="cp">#define _PAGE_DIRTY	(1&lt;&lt;1)</span>
<span class="cp">#define _PAGE_ACCESSED	(1&lt;&lt;2)</span>

<span class="cm">/*</span>
<span class="cm"> * _PAGE_FILE is only meaningful if _PAGE_PRESENT is false, while</span>
<span class="cm"> * _PAGE_DIRTY is only meaningful if _PAGE_PRESENT is true.</span>
<span class="cm"> * So we can overload the bit...</span>
<span class="cm"> */</span>
<span class="cp">#define _PAGE_FILE	_PAGE_DIRTY </span><span class="cm">/* set:  pagecache, unset = swap */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * For now, let&#39;s say that Valid and Present are the same thing.</span>
<span class="cm"> * Alternatively, we could say that it&#39;s the &quot;or&quot; of R, W, and X</span>
<span class="cm"> * permissions.</span>
<span class="cm"> */</span>
<span class="cp">#define _PAGE_VALID	_PAGE_PRESENT</span>

<span class="cm">/*</span>
<span class="cm"> * We&#39;re not defining _PAGE_GLOBAL here, since there&#39;s no concept</span>
<span class="cm"> * of global pages or ASIDs exposed to the Hexagon Virtual Machine,</span>
<span class="cm"> * and we want to use the same page table structures and macros in</span>
<span class="cm"> * the native kernel as we do in the virtual machine kernel.</span>
<span class="cm"> * So we&#39;ll put up with a bit of inefficiency for now...</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Top &quot;FOURTH&quot; level (pgd), which for the Hexagon VM is really</span>
<span class="cm"> * only the second from the bottom, pgd and pud both being collapsed.</span>
<span class="cm"> * Each entry represents 4MB of virtual address space, 4K of table</span>
<span class="cm"> * thus maps the full 4GB.</span>
<span class="cm"> */</span>
<span class="cp">#define PGDIR_SHIFT 22</span>
<span class="cp">#define PTRS_PER_PGD 1024</span>

<span class="cp">#define PGDIR_SIZE (1UL &lt;&lt; PGDIR_SHIFT)</span>
<span class="cp">#define PGDIR_MASK (~(PGDIR_SIZE-1))</span>

<span class="cp">#ifdef CONFIG_PAGE_SIZE_4KB</span>
<span class="cp">#define PTRS_PER_PTE 1024</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PAGE_SIZE_16KB</span>
<span class="cp">#define PTRS_PER_PTE 256</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PAGE_SIZE_64KB</span>
<span class="cp">#define PTRS_PER_PTE 64</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PAGE_SIZE_256KB</span>
<span class="cp">#define PTRS_PER_PTE 16</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PAGE_SIZE_1MB</span>
<span class="cp">#define PTRS_PER_PTE 4</span>
<span class="cp">#endif</span>

<span class="cm">/*  Any bigger and the PTE disappears.  */</span>
<span class="cp">#define pgd_ERROR(e) \</span>
<span class="cp">	printk(KERN_ERR &quot;%s:%d: bad pgd %08lx.\n&quot;, __FILE__, __LINE__,\</span>
<span class="cp">		pgd_val(e))</span>

<span class="cm">/*</span>
<span class="cm"> * Page Protection Constants. Includes (in this variant) cache attributes.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_dflt_cache_att</span><span class="p">;</span>

<span class="cp">#define PAGE_NONE	__pgprot(_PAGE_PRESENT | _PAGE_USER | \</span>
<span class="cp">				_dflt_cache_att)</span>
<span class="cp">#define PAGE_READONLY	__pgprot(_PAGE_PRESENT | _PAGE_USER | \</span>
<span class="cp">				_PAGE_READ | _PAGE_EXECUTE | _dflt_cache_att)</span>
<span class="cp">#define PAGE_COPY	PAGE_READONLY</span>
<span class="cp">#define PAGE_EXEC	__pgprot(_PAGE_PRESENT | _PAGE_USER | \</span>
<span class="cp">				_PAGE_READ | _PAGE_EXECUTE | _dflt_cache_att)</span>
<span class="cp">#define PAGE_COPY_EXEC	PAGE_EXEC</span>
<span class="cp">#define PAGE_SHARED	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | \</span>
<span class="cp">				_PAGE_EXECUTE | _PAGE_WRITE | _dflt_cache_att)</span>
<span class="cp">#define PAGE_KERNEL	__pgprot(_PAGE_PRESENT | _PAGE_READ | \</span>
<span class="cp">				_PAGE_WRITE | _PAGE_EXECUTE | _dflt_cache_att)</span>


<span class="cm">/*</span>
<span class="cm"> * Aliases for mapping mmap() protection bits to page protections.</span>
<span class="cm"> * These get used for static initialization, so using the _dflt_cache_att</span>
<span class="cm"> * variable for the default cache attribute isn&#39;t workable. If the</span>
<span class="cm"> * default gets changed at boot time, the boot option code has to</span>
<span class="cm"> * update data structures like the protaction_map[] array.</span>
<span class="cm"> */</span>
<span class="cp">#define CACHEDEF	(CACHE_DEFAULT &lt;&lt; 6)</span>

<span class="cm">/* Private (copy-on-write) page protections. */</span>
<span class="cp">#define __P000 __pgprot(_PAGE_PRESENT | _PAGE_USER | CACHEDEF)</span>
<span class="cp">#define __P001 __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | CACHEDEF)</span>
<span class="cp">#define __P010 __P000	</span><span class="cm">/* Write-only copy-on-write */</span><span class="cp"></span>
<span class="cp">#define __P011 __P001	</span><span class="cm">/* Read/Write copy-on-write */</span><span class="cp"></span>
<span class="cp">#define __P100 __pgprot(_PAGE_PRESENT | _PAGE_USER | \</span>
<span class="cp">			_PAGE_EXECUTE | CACHEDEF)</span>
<span class="cp">#define __P101 __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_EXECUTE | \</span>
<span class="cp">			_PAGE_READ | CACHEDEF)</span>
<span class="cp">#define __P110 __P100	</span><span class="cm">/* Write/execute copy-on-write */</span><span class="cp"></span>
<span class="cp">#define __P111 __P101	</span><span class="cm">/* Read/Write/Execute, copy-on-write */</span><span class="cp"></span>

<span class="cm">/* Shared page protections. */</span>
<span class="cp">#define __S000 __P000</span>
<span class="cp">#define __S001 __P001</span>
<span class="cp">#define __S010 __pgprot(_PAGE_PRESENT | _PAGE_USER | \</span>
<span class="cp">			_PAGE_WRITE | CACHEDEF)</span>
<span class="cp">#define __S011 __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | \</span>
<span class="cp">			_PAGE_WRITE | CACHEDEF)</span>
<span class="cp">#define __S100 __pgprot(_PAGE_PRESENT | _PAGE_USER | \</span>
<span class="cp">			_PAGE_EXECUTE | CACHEDEF)</span>
<span class="cp">#define __S101 __P101</span>
<span class="cp">#define __S110 __pgprot(_PAGE_PRESENT | _PAGE_USER | \</span>
<span class="cp">			_PAGE_EXECUTE | _PAGE_WRITE | CACHEDEF)</span>
<span class="cp">#define __S111 __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_READ | \</span>
<span class="cp">			_PAGE_EXECUTE | _PAGE_WRITE | CACHEDEF)</span>

<span class="k">extern</span> <span class="n">pgd_t</span> <span class="n">swapper_pg_dir</span><span class="p">[</span><span class="n">PTRS_PER_PGD</span><span class="p">];</span>  <span class="cm">/* located in head.S */</span>

<span class="cm">/* Seems to be zero even in architectures where the zero page is firewalled? */</span>
<span class="cp">#define FIRST_USER_ADDRESS 0</span>
<span class="cp">#define pte_special(pte)	0</span>
<span class="cp">#define pte_mkspecial(pte)	(pte)</span>

<span class="cm">/*  HUGETLB not working currently  */</span>
<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
<span class="cp">#define pte_mkhuge(pte) __pte((pte_val(pte) &amp; ~0x3) | HVM_HUGEPAGE_SIZE)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * For now, assume that higher-level code will do TLB/MMU invalidations</span>
<span class="cm"> * and don&#39;t insert that overhead into this low-level function.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sync_icache_dcache</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">);</span>

<span class="cp">#define pte_present_exec_user(pte) \</span>
<span class="cp">	((pte_val(pte) &amp; (_PAGE_EXECUTE | _PAGE_USER)) == \</span>
<span class="cp">	(_PAGE_EXECUTE | _PAGE_USER))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*  should really be using pte_exec, if it weren&#39;t declared later. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_present_exec_user</span><span class="p">(</span><span class="n">pteval</span><span class="p">))</span>
		<span class="n">sync_icache_dcache</span><span class="p">(</span><span class="n">pteval</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">pteval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For the Hexagon Virtual Machine MMU (or its emulation), a null/invalid</span>
<span class="cm"> * L1 PTE (PMD/PGD) has 7 in the least significant bits. For the L2 PTE</span>
<span class="cm"> * (Linux PTE), the key is to have bits 11..9 all zero.  We&#39;d use 0x7</span>
<span class="cm"> * as a universal null entry, but some of those least significant bits</span>
<span class="cm"> * are interpreted by software.</span>
<span class="cm"> */</span>
<span class="cp">#define _NULL_PMD	0x7</span>
<span class="cp">#define _NULL_PTE	0x0</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pmd_clear</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd_entry_ptr</span><span class="p">)</span>
<span class="p">{</span>
	 <span class="n">pmd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pmd_entry_ptr</span><span class="p">)</span> <span class="o">=</span> <span class="n">_NULL_PMD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Conveniently, a null PTE value is invalid.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pte_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">=</span> <span class="n">_NULL_PTE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef NEED_PMD_INDEX_DESPITE_BEING_2_LEVEL</span>
<span class="cm">/**</span>
<span class="cm"> * pmd_index - returns the index of the entry in the PMD page</span>
<span class="cm"> * which would control the given virtual address</span>
<span class="cm"> */</span>
<span class="cp">#define pmd_index(address) (((address) &gt;&gt; PMD_SHIFT) &amp; (PTRS_PER_PMD-1))</span>

<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * pgd_index - returns the index of the entry in the PGD page</span>
<span class="cm"> * which would control the given virtual address</span>
<span class="cm"> *</span>
<span class="cm"> * This returns the *index* for the address in the pgd_t</span>
<span class="cm"> */</span>
<span class="cp">#define pgd_index(address) (((address) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD-1))</span>

<span class="cm">/*</span>
<span class="cm"> * pgd_offset - find an offset in a page-table-directory</span>
<span class="cm"> */</span>
<span class="cp">#define pgd_offset(mm, addr) ((mm)-&gt;pgd + pgd_index(addr))</span>

<span class="cm">/*</span>
<span class="cm"> * pgd_offset_k - get kernel (init_mm) pgd entry pointer for addr</span>
<span class="cm"> */</span>
<span class="cp">#define pgd_offset_k(address) pgd_offset(&amp;init_mm, address)</span>

<span class="cm">/**</span>
<span class="cm"> * pmd_none - check if pmd_entry is mapped</span>
<span class="cm"> * @pmd_entry:  pmd entry</span>
<span class="cm"> *</span>
<span class="cm"> * MIPS checks it against that &quot;invalid pte table&quot; thing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_none</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">==</span> <span class="n">_NULL_PMD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmd_present - is there a page table behind this?</span>
<span class="cm"> * Essentially the inverse of pmd_none.  We maybe</span>
<span class="cm"> * save an inline instruction by defining it this</span>
<span class="cm"> * way, instead of simply &quot;!pmd_none&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_present</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pmd_val</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_NULL_PMD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmd_bad - check if a PMD entry is &quot;bad&quot;. That might mean swapped out.</span>
<span class="cm"> * As we have no known cause of badness, it&#39;s null, as it is for many</span>
<span class="cm"> * architectures.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pmd_bad</span><span class="p">(</span><span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pmd_page - converts a PMD entry to a page pointer</span>
<span class="cm"> */</span>
<span class="cp">#define pmd_page(pmd)  (pfn_to_page(pmd_val(pmd) &gt;&gt; PAGE_SHIFT))</span>
<span class="cp">#define pmd_pgtable(pmd) pmd_page(pmd)</span>

<span class="cm">/**</span>
<span class="cm"> * pte_none - check if pte is mapped</span>
<span class="cm"> * @pte: pte_t entry</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_none</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">==</span> <span class="n">_NULL_PTE</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * pte_present - check if page is present</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_present</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_PRESENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* mk_pte - make a PTE out of a page pointer and protection bits */</span>
<span class="cp">#define mk_pte(page, pgprot) pfn_pte(page_to_pfn(page), (pgprot))</span>

<span class="cm">/* pte_page - returns a page (frame pointer/descriptor?) based on a PTE */</span>
<span class="cp">#define pte_page(x) pfn_to_page(pte_pfn(x))</span>

<span class="cm">/* pte_mkold - mark PTE as not recently accessed */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkold</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_PAGE_ACCESSED</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* pte_mkyoung - mark PTE as recently accessed */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkyoung</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_ACCESSED</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* pte_mkclean - mark page as in sync with backing store */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkclean</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_PAGE_DIRTY</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* pte_mkdirty - mark page as modified */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkdirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_DIRTY</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* pte_young - &quot;is PTE marked as accessed&quot;? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_young</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_ACCESSED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* pte_dirty - &quot;is PTE dirty?&quot; */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_dirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_DIRTY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* pte_modify - set protection bits on PTE */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_modify</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">prot</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* pte_wrprotect - mark page as not writable */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_wrprotect</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_PAGE_WRITE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* pte_mkwrite - mark page as writable */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkwrite</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_WRITE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* pte_mkexec - mark PTE as executable */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkexec</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_EXECUTE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* pte_read - &quot;is PTE marked as readable?&quot; */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_read</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_READ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* pte_write - &quot;is PTE marked as writable?&quot; */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_write</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_WRITE</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* pte_exec - &quot;is PTE marked as executable?&quot; */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_exec</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_EXECUTE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* __pte_to_swp_entry - extract swap entry from PTE */</span>
<span class="cp">#define __pte_to_swp_entry(pte) ((swp_entry_t) { pte_val(pte) })</span>

<span class="cm">/* __swp_entry_to_pte - extract PTE from swap entry */</span>
<span class="cp">#define __swp_entry_to_pte(x) ((pte_t) { (x).val })</span>

<span class="cm">/* pfn_pte - convert page number and protection value to page table entry */</span>
<span class="cp">#define pfn_pte(pfn, pgprot) __pte((pfn &lt;&lt; PAGE_SHIFT) | pgprot_val(pgprot))</span>

<span class="cm">/* pte_pfn - convert pte to page frame number */</span>
<span class="cp">#define pte_pfn(pte) (pte_val(pte) &gt;&gt; PAGE_SHIFT)</span>
<span class="cp">#define set_pmd(pmdptr, pmdval) (*(pmdptr) = (pmdval))</span>

<span class="cm">/*</span>
<span class="cm"> * set_pte_at - update page table and do whatever magic may be</span>
<span class="cm"> * necessary to make the underlying hardware/firmware take note.</span>
<span class="cm"> *</span>
<span class="cm"> * VM may require a virtual instruction to alert the MMU.</span>
<span class="cm"> */</span>
<span class="cp">#define set_pte_at(mm, addr, ptep, pte) set_pte(ptep, pte)</span>

<span class="cm">/*</span>
<span class="cm"> * May need to invoke the virtual machine as well...</span>
<span class="cm"> */</span>
<span class="cp">#define pte_unmap(pte)		do { } while (0)</span>
<span class="cp">#define pte_unmap_nested(pte)	do { } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * pte_offset_map - returns the linear address of the page table entry</span>
<span class="cm"> * corresponding to an address</span>
<span class="cm"> */</span>
<span class="cp">#define pte_offset_map(dir, address)                                    \</span>
<span class="cp">	((pte_t *)page_address(pmd_page(*(dir))) + __pte_offset(address))</span>

<span class="cp">#define pte_offset_map_nested(pmd, addr) pte_offset_map(pmd, addr)</span>

<span class="cm">/* pte_offset_kernel - kernel version of pte_offset */</span>
<span class="cp">#define pte_offset_kernel(dir, address) \</span>
<span class="cp">	((pte_t *) (unsigned long) __va(pmd_val(*dir) &amp; PAGE_MASK) \</span>
<span class="cp">				+  __pte_offset(address))</span>

<span class="cm">/* ZERO_PAGE - returns the globally shared zero page */</span>
<span class="cp">#define ZERO_PAGE(vaddr) (virt_to_page(&amp;empty_zero_page))</span>

<span class="cp">#define __pte_offset(address) (((address) &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1))</span>

<span class="cm">/* Nothing special about IO remapping at this point */</span>
<span class="cp">#define io_remap_pfn_range(vma, vaddr, pfn, size, prot) \</span>
<span class="cp">	remap_pfn_range(vma, vaddr, pfn, size, prot)</span>

<span class="cm">/*  I think this is in case we have page table caches; needed by init/main.c  */</span>
<span class="cp">#define pgtable_cache_init()    do { } while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Swap/file PTE definitions.  If _PAGE_PRESENT is zero, the rest of the</span>
<span class="cm"> * PTE is interpreted as swap information.  Depending on the _PAGE_FILE</span>
<span class="cm"> * bit, the remaining free bits are eitehr interpreted as a file offset</span>
<span class="cm"> * or a swap type/offset tuple.  Rather than have the TLB fill handler</span>
<span class="cm"> * test _PAGE_PRESENT, we&#39;re going to reserve the permissions bits</span>
<span class="cm"> * and set them to all zeros for swap entries, which speeds up the</span>
<span class="cm"> * miss handler at the cost of 3 bits of offset.  That trade-off can</span>
<span class="cm"> * be revisited if necessary, but Hexagon processor architecture and</span>
<span class="cm"> * target applications suggest a lot of TLB misses and not much swap space.</span>
<span class="cm"> *</span>
<span class="cm"> * Format of swap PTE:</span>
<span class="cm"> *	bit	0:	Present (zero)</span>
<span class="cm"> *	bit	1:	_PAGE_FILE (zero)</span>
<span class="cm"> *	bits	2-6:	swap type (arch independent layer uses 5 bits max)</span>
<span class="cm"> *	bits	7-9:	bits 2:0 of offset</span>
<span class="cm"> *	bits 10-12:	effectively _PAGE_PROTNONE (all zero)</span>
<span class="cm"> *	bits 13-31:  bits 21:3 of swap offset</span>
<span class="cm"> *</span>
<span class="cm"> * Format of file PTE:</span>
<span class="cm"> *	bit	0:	Present (zero)</span>
<span class="cm"> *	bit	1:	_PAGE_FILE (zero)</span>
<span class="cm"> *	bits	2-9:	bits 7:0 of offset</span>
<span class="cm"> *	bits 10-12:	effectively _PAGE_PROTNONE (all zero)</span>
<span class="cm"> *	bits 13-31:  bits 26:8 of swap offset</span>
<span class="cm"> *</span>
<span class="cm"> * The split offset makes some of the following macros a little gnarly,</span>
<span class="cm"> * but there&#39;s plenty of precedent for this sort of thing.</span>
<span class="cm"> */</span>
<span class="cp">#define PTE_FILE_MAX_BITS     27</span>

<span class="cm">/* Used for swap PTEs */</span>
<span class="cp">#define __swp_type(swp_pte)		(((swp_pte).val &gt;&gt; 2) &amp; 0x1f)</span>

<span class="cp">#define __swp_offset(swp_pte) \</span>
<span class="cp">	((((swp_pte).val &gt;&gt; 7) &amp; 0x7) | (((swp_pte).val &gt;&gt; 10) &amp; 0x003ffff8))</span>

<span class="cp">#define __swp_entry(type, offset) \</span>
<span class="cp">	((swp_entry_t)	{ \</span>
<span class="cp">		((type &lt;&lt; 2) | \</span>
<span class="cp">		 ((offset &amp; 0x3ffff8) &lt;&lt; 10) | ((offset &amp; 0x7) &lt;&lt; 7)) })</span>

<span class="cm">/* Used for file PTEs */</span>
<span class="cp">#define pte_file(pte) \</span>
<span class="cp">	((pte_val(pte) &amp; (_PAGE_FILE | _PAGE_PRESENT)) == _PAGE_FILE)</span>

<span class="cp">#define pte_to_pgoff(pte) \</span>
<span class="cp">	(((pte_val(pte) &gt;&gt; 2) &amp; 0xff) | ((pte_val(pte) &gt;&gt; 5) &amp; 0x07ffff00))</span>

<span class="cp">#define pgoff_to_pte(off) \</span>
<span class="cp">	((pte_t) { ((((off) &amp; 0x7ffff00) &lt;&lt; 5) | (((off) &amp; 0xff) &lt;&lt; 2)\</span>
<span class="cp">	| _PAGE_FILE) })</span>

<span class="cm">/*  Oh boy.  There are a lot of possible arch overrides found in this file.  */</span>
<span class="cp">#include &lt;asm-generic/pgtable.h&gt;</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
