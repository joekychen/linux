<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › hexagon › kernel › traps.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>traps.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Kernel traps/events for Hexagon processor</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 and</span>
<span class="cm"> * only version 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/tracehook.h&gt;</span>
<span class="cp">#include &lt;asm/traps.h&gt;</span>
<span class="cp">#include &lt;asm/vm_fault.h&gt;</span>
<span class="cp">#include &lt;asm/syscall.h&gt;</span>
<span class="cp">#include &lt;asm/registers.h&gt;</span>
<span class="cp">#include &lt;asm/unistd.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#ifdef CONFIG_KGDB</span>
<span class="cp"># include &lt;linux/kgdb.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#define TRAP_SYSCALL	1</span>
<span class="cp">#define TRAP_DEBUG	0xdb</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">trap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_GENERIC_BUG</span>
<span class="cm">/* Maybe should resemble arch/sh/kernel/traps.c ?? */</span>
<span class="kt">int</span> <span class="nf">is_valid_bugaddr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_GENERIC_BUG */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ex_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_XPROT</span>:
	<span class="k">case</span> <span class="n">HVM_GE_C_XUSER</span>:
		<span class="k">return</span> <span class="s">&quot;Execute protection fault&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_RPROT</span>:
	<span class="k">case</span> <span class="n">HVM_GE_C_RUSER</span>:
		<span class="k">return</span> <span class="s">&quot;Read protection fault&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_WPROT</span>:
	<span class="k">case</span> <span class="n">HVM_GE_C_WUSER</span>:
		<span class="k">return</span> <span class="s">&quot;Write protection fault&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_XMAL</span>:
		<span class="k">return</span> <span class="s">&quot;Misaligned instruction&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_RMAL</span>:
		<span class="k">return</span> <span class="s">&quot;Misaligned data load&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_WMAL</span>:
		<span class="k">return</span> <span class="s">&quot;Misaligned data store&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_INVI</span>:
	<span class="k">case</span> <span class="n">HVM_GE_C_PRIVI</span>:
		<span class="k">return</span> <span class="s">&quot;Illegal instruction&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_BUS</span>:
		<span class="k">return</span> <span class="s">&quot;Precise bus error&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_CACHE</span>:
		<span class="k">return</span> <span class="s">&quot;Cache error&quot;</span><span class="p">;</span>

	<span class="k">case</span> <span class="mh">0xdb</span>:
		<span class="k">return</span> <span class="s">&quot;Debugger trap&quot;</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;Unrecognized exception&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_show_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">kstack_depth_to_print</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">newfp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tmpstr</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CPU#%d, %s/%d, Call Trace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">raw_smp_processor_id</span><span class="p">(),</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span>
	       <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asm</span><span class="p">(</span><span class="s">&quot;%0 = r30&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">fp</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span>
			     <span class="p">((</span><span class="k">struct</span> <span class="n">hexagon_switch_stack</span> <span class="o">*</span><span class="p">)</span>
			     <span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">switch_sp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">fp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">fp</span> <span class="o">&lt;</span> <span class="mh">0x1000</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;-- Corrupt frame pointer %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Saved link reg is one word above FP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ip</span><span class="p">)</span>
		<span class="n">ip</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">fp</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Expect kernel stack to be in-bounds */</span>
	<span class="n">low</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">task_stack_page</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">high</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="n">THREAD_SIZE</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">low</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_info</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kstack_depth_to_print</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">name</span> <span class="o">=</span> <span class="n">kallsyms_lookup</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modname</span><span class="p">,</span> <span class="n">tmpstr</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;[%p] 0x%lx: %s + 0x%lx&quot;</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
			<span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">fp</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">high</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">fp</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot; (FP out of bounds!)&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">modname</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot; [%s] &quot;</span><span class="p">,</span> <span class="n">modname</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">newfp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">newfp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;-- Corrupt frame pointer %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">newfp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Attempt to continue past exception. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">newfp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">fp</span><span class="p">)</span>
						<span class="o">+</span> <span class="mi">8</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">syscall_nr</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;-- trap0 -- syscall_nr: %ld&quot;</span><span class="p">,</span>
					<span class="n">regs</span><span class="o">-&gt;</span><span class="n">syscall_nr</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;  psp: %lx  elr: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">pt_psp</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">pt_elr</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* really want to see more ... */</span>
				<span class="n">kstack_depth_to_print</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;-- %s (0x%lx)  badva: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ex_name</span><span class="p">(</span><span class="n">pt_cause</span><span class="p">(</span><span class="n">regs</span><span class="p">)),</span> <span class="n">pt_cause</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span>
					<span class="n">pt_badva</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>
			<span class="p">}</span>

			<span class="n">newfp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r30</span><span class="p">;</span>
			<span class="n">ip</span> <span class="o">=</span> <span class="n">pt_elr</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ip</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">newfp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* If link reg is null, we are done. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* If newfp isn&#39;t larger, we&#39;re tracing garbage. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newfp</span> <span class="o">&gt;</span> <span class="n">fp</span><span class="p">)</span>
			<span class="n">fp</span> <span class="o">=</span> <span class="n">newfp</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">show_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Saved link reg is one word above FP */</span>
	<span class="n">do_show_stack</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dump_stack</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;%0 = r30&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">fp</span><span class="p">));</span>
	<span class="n">show_stack</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dump_stack</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">die</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
		<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">die</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">__SPIN_LOCK_UNLOCKED</span><span class="p">(</span><span class="n">die</span><span class="p">.</span><span class="n">lock</span><span class="p">),</span>
		<span class="p">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="p">};</span>

	<span class="n">console_verbose</span><span class="p">();</span>
	<span class="n">oops_enter</span><span class="p">();</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">die</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">bust_spinlocks</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;Oops: %s[#%d]:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="o">++</span><span class="n">die</span><span class="p">.</span><span class="n">counter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_OOPS</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">pt_cause</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">SIGSEGV</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">print_modules</span><span class="p">();</span>
	<span class="n">show_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">do_show_stack</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r30</span><span class="p">,</span> <span class="n">pt_elr</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>

	<span class="n">bust_spinlocks</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">add_taint</span><span class="p">(</span><span class="n">TAINT_DIE</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">die</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_interrupt</span><span class="p">())</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Fatal exception in interrupt&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">panic_on_oops</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Fatal exception&quot;</span><span class="p">);</span>

	<span class="n">oops_exit</span><span class="p">();</span>
	<span class="n">do_exit</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">die_if_kernel</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">die</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * It&#39;s not clear that misaligned fetches are ever recoverable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">misaligned_instruction</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;Misaligned Instruction&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGBUS</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Misaligned loads and stores, on the other hand, can be</span>
<span class="cm"> * emulated, and probably should be, some day.  But for now</span>
<span class="cm"> * they will be considered fatal.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">misaligned_data_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;Misaligned Data Load&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGBUS</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">misaligned_data_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;Misaligned Data Store&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGBUS</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">illegal_instruction</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;Illegal Instruction&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGILL</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Precise bus errors may be recoverable with a a retry,</span>
<span class="cm"> * but for now, treat them as irrecoverable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">precise_bus_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;Precise Bus Error&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGBUS</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If anything is to be done here other than panic,</span>
<span class="cm"> * it will probably be complex and migrate to another</span>
<span class="cm"> * source module.  For now, just die.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cache_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">die</span><span class="p">(</span><span class="s">&quot;Cache Error&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * General exception handler</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">do_genex</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Decode Cause and Dispatch</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pt_cause</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_XPROT</span>:
	<span class="k">case</span> <span class="n">HVM_GE_C_XUSER</span>:
		<span class="n">execute_protection_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_RPROT</span>:
	<span class="k">case</span> <span class="n">HVM_GE_C_RUSER</span>:
		<span class="n">read_protection_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_WPROT</span>:
	<span class="k">case</span> <span class="n">HVM_GE_C_WUSER</span>:
		<span class="n">write_protection_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_XMAL</span>:
		<span class="n">misaligned_instruction</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_RMAL</span>:
		<span class="n">misaligned_data_load</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_WMAL</span>:
		<span class="n">misaligned_data_store</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_INVI</span>:
	<span class="k">case</span> <span class="n">HVM_GE_C_PRIVI</span>:
		<span class="n">illegal_instruction</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_BUS</span>:
		<span class="n">precise_bus_error</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HVM_GE_C_CACHE</span>:
		<span class="n">cache_error</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Halt and catch fire */</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Unrecognized exception 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pt_cause</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Indirect system call dispatch */</span>
<span class="kt">long</span> <span class="nf">sys_syscall</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;sys_syscall invoked!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">do_trap0</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">syscallret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">syscall_fn</span> <span class="n">syscall</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">pt_cause</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TRAP_SYSCALL</span>:
		<span class="cm">/* System call is trap0 #1 */</span>

		<span class="cm">/* allow strace to catch syscall args  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_SYSCALL_TRACE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">tracehook_report_syscall_entry</span><span class="p">(</span><span class="n">regs</span><span class="p">)))</span>
			<span class="k">return</span><span class="p">;</span>  <span class="cm">/*  return -ENOSYS somewhere?  */</span>

		<span class="cm">/* Interrupts should be re-enabled for syscall processing */</span>
		<span class="n">__vmsetie</span><span class="p">(</span><span class="n">VM_INT_ENABLE</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * System call number is in r6, arguments in r0..r5.</span>
<span class="cm">		 * Fortunately, no Linux syscall has more than 6 arguments,</span>
<span class="cm">		 * and Hexagon ABI passes first 6 arguments in registers.</span>
<span class="cm">		 * 64-bit arguments are passed in odd/even register pairs.</span>
<span class="cm">		 * Fortunately, we have no system calls that take more</span>
<span class="cm">		 * than three arguments with more than one 64-bit value.</span>
<span class="cm">		 * Should that change, we&#39;d need to redesign to copy</span>
<span class="cm">		 * between user and kernel stacks.</span>
<span class="cm">		 */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">syscall_nr</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r06</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * GPR R0 carries the first parameter, and is also used</span>
<span class="cm">		 * to report the return value.  We need a backup of</span>
<span class="cm">		 * the user&#39;s value in case we need to do a late restart</span>
<span class="cm">		 * of the system call.</span>
<span class="cm">		 */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">restart_r0</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r00</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">syscall_nr</span> <span class="o">&gt;=</span> <span class="n">__NR_syscalls</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r00</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">syscall</span> <span class="o">=</span> <span class="p">(</span><span class="n">syscall_fn</span><span class="p">)</span>
				  <span class="p">(</span><span class="n">sys_call_table</span><span class="p">[</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">syscall_nr</span><span class="p">]);</span>
			<span class="n">syscallret</span> <span class="o">=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r00</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r01</span><span class="p">,</span>
				   <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r02</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r03</span><span class="p">,</span>
				   <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r04</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r05</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If it was a sigreturn system call, don&#39;t overwrite</span>
<span class="cm">		 * r0 value in stack frame with return value.</span>
<span class="cm">		 *</span>
<span class="cm">		 * __NR_sigreturn doesn&#39;t seem to exist in new unistd.h</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">syscall_nr</span> <span class="o">!=</span> <span class="n">__NR_rt_sigreturn</span><span class="p">)</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r00</span> <span class="o">=</span> <span class="n">syscallret</span><span class="p">;</span>

		<span class="cm">/* allow strace to get the syscall return state  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_SYSCALL_TRACE</span><span class="p">)))</span>
			<span class="n">tracehook_report_syscall_exit</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TRAP_DEBUG</span>:
		<span class="cm">/* Trap0 0xdb is debug breakpoint */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">info</span><span class="p">;</span>

			<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGTRAP</span><span class="p">;</span>
			<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Some architecures add some per-thread state</span>
<span class="cm">			 * to distinguish between breakpoint traps and</span>
<span class="cm">			 * trace traps.  We may want to do that, and</span>
<span class="cm">			 * set the si_code value appropriately, or we</span>
<span class="cm">			 * may want to use a different trap0 flavor.</span>
<span class="cm">			 */</span>
			<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">TRAP_BRKPT</span><span class="p">;</span>
			<span class="n">info</span><span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">pt_elr</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
			<span class="n">send_sig_info</span><span class="p">(</span><span class="n">SIGTRAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_KGDB</span>
			<span class="n">kgdb_handle_exception</span><span class="p">(</span><span class="n">pt_cause</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">SIGTRAP</span><span class="p">,</span>
					      <span class="n">TRAP_BRKPT</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Ignore other trap0 codes for now, especially 0 (Angel calls) */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Machine check exception handler</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">do_machcheck</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Halt and catch fire */</span>
	<span class="n">__vmstop</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
